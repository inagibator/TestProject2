unit K_CM0;
// CMS MAIN Code - Common Data Types, Global Varaibles, Constants and Routines
interface

// !!! don't change order in uses -> GDIPAPI, Graphics
uses Forms, Menus, Classes, ADODB, DB, Math, Dialogs, ActnList, Controls, Windows,
  GDIPAPI, Graphics, ExtCtrls, IniFiles, Types, ComCtrls,// AnsiStrings,
  N_Lib0, N_Lib2, N_Types, N_Comp1, N_CompBase, N_BaseF,
  N_Gra2, N_Rast1Fr, N_Comp2, N_SGComp,
  K_RImage, K_CLib0, K_UDT1, K_Script1, K_SBuf0, K_SBuf, K_STBuf, K_CLib,
  K_Gra0, K_Types, K_CMWEBBase, Datasnap.DBClient;

var
//  K_CMEDDBVersion     : Integer = 41;    // Current DB Data Structure Version
//  K_CMEDDBVersion     : Integer = 42;    // Current DB Data Structure Version
//  K_CMEDDBVersion     : Integer = 43;    // Current DB Data Structure Version
//  K_CMEDDBVersion     : Integer = 44;    // Current DB Data Structure Version
//  K_CMEDDBVersion     : Integer = 45;    // Current DB Data Structure Version
  K_CMEDDBVersion     : Integer = 46;    // Current DB Data Structure Version
  K_CMS_LogsCtrlAll   : Boolean = TRUE;

const
//  K_CMEDDBUseSQLProcs : Boolean = FALSE; // Use new Stored SQL Procedures instead Functions (additional control for K_CMEDDBVersion less 39)
//  K_CMEDDBUseSQLProcs : Boolean = TRUE; // Use new Stored SQL Procedures instead Functions (additional control for K_CMEDDBVersion less 39)
//  K_CMSComLibVer : Integer = 24;
  K_CMSComLibVer : Integer = 25;
  CentaurSoftwareUID = '1.2.36.18057620390';
  K_WEBCMSAPIVer : Integer = 1;
  CMS_LogsCtrlAll: Boolean = FALSE;

//**************************************************** TK_CMUserAccessRights ***
// CMS User Access Rights
//
type TK_CMUserAccessRights = set of (
  K_uarStart,      // Start MediaSuite
  K_uarCapture,    // Capture Media Objects
  K_uarImport,     // Import Media Objects
  K_uarDuplicate,  // Duplicate Media Objects
  K_uarModify,     // Modify Media Objects
  K_uarDelete,     // Delete Media Objects
  K_uarExport,     // Export Media Objects
  K_uarPrint,      // Print Media Objects
  K_uarEmail,      // Email Media Objects
  K_uarPreferences,// Preferences
  K_uarReports     // Reports
);
var K_CMCurUserAccessRights : TK_CMUserAccessRights = [
  K_uarStart,      // Start MediaSuite
  K_uarCapture,    // Capture Media Objects
  K_uarImport,     // Import Media Objects
  K_uarDuplicate,  // Duplicate Media Objects
  K_uarModify,     // Modify Media Objects
  K_uarDelete,     // Delete Media Objects
  K_uarExport,     // Export Media Objects
  K_uarPrint,      // Print Media Objects
  K_uarEmail,      // Email Media Objects
  K_uarPreferences,// Preferences
  K_uarReports     // Reports
];

type TK_FreeBuffer = procedure( APBuf : Pointer ) of object;

//************************************************
// Slide Thumbnail Texts Set
//************************************************
type TK_CMSThumbTextFlagsSet = set of ( // Set of Slide Thumbnail Text Flags
  ttsObjDateTaken, // Object Date Taken
  ttsObjTimeTaken, // Object Time Taken
  ttsObjTeethChart,// Object Teeth Chart
  ttsObjSource     // Object Source Description
);

//************************************************
// Slide ImageX View Conversion Attributes Runtime Data
//************************************************
type TK_CMSImgViewConvSet = set of ( // Set of View conversion Image Attributes
  vcifFlipRotate, // FLip/Rotate Attributes
  vcifBriCoGam,   // Brightness/Contrast/Gammma correction Attributes
  vcifColorize,   // Colorize Attributes
  vcifIsodensity, // Isodensity Attributes
  vcifEmboss      // Emboss Attributes
);
type TK_CMSImgViewConvData = record // Slide Image View Attributes Runtime Data
// Slide Flip/Rotate Attrs
  VCFlipRotateAttrs : Integer;

// Image BriCoGam Attributes
  VCNegateFlag: Boolean; // Image Negate Flag
  VCCoFactor  : Float; // Image Contrast Correction Factor
  VCGamFactor : Float; // Image Gamma Correction Factor
  VCBriFactor : Float; // Image Brightness Correction Factor
  VCBriMinFactor: Float; // Image Brightness Convertion Minimal Value
  VCBriMaxFactor: Float; // Image Brightness Convertion Maximal Value

// Image Emboss Attributes
  VCShowEmboss : Boolean; // Show Image Emboss Effect
  VCEmbDepth   : Integer; // Image Emboss Depth 1 - 20
  VCEmbDirAngle:   Float; // Image Emboss Direction Angle in degrees
  VCEmbRFactor :   Float; // Image Emboss Correction Factor
  VCEmbBase    : Integer; // Image Emboss Base Gray Intensity

// Slide Image Colorize Attributes
  VCShowColorize : Boolean; // Show Image Pseudocolors
  VCColPalInd    : Integer; // Pseudocolors Palette Index

// Slide Image Isodensity Attributes
  VCShowIsodensity : Boolean; // Show Image Isodensity
  VCIsoBaseColInt  : Integer; // Image Base Color Intensity
  VCIsoRangeFactor :   Float; // Image Colors Intensity Range Factor (0-100)
  VCIsoColor       : Integer; // Isodensity Draw Color
  VCIsoTranspFactor:   Float; // Isodensity Draw Transparency Factor (0-100)
end;
type TK_PCMSImgViewConvData = ^TK_CMSImgViewConvData;

//************************************************
// Slide Map Root Image Attributes (View, ... )
//************************************************
type TK_CMSMapRootImgFlags = set of ( // Slide Image MapRoot Flags
  K_smriRestoreSrcImg, // Original Image Restoring enabled flag
  K_smriNegateImg      // Negate Image Pixels Color
);

type TK_CMSMRImgAttrs = packed record // Slide Image Attributes Stored in MapRoot
// Slide Attributes Stored in MapRoot
//  IMRFlags : TK_CMSMapRootImgFlags;
  MRImgFlags : TK_CMSMapRootImgFlags;

// Slide Flip/Rotate Attrs
//  FlipRotateAttrs : Integer;
  MRFlipRotateAttrs : Integer;

// Image BriCoGam Attributes
//  ContrFactor : Float; // Image Contrast Correction Factor
  MRCoFactor : Float;    // Image Contrast Correction Factor
//  GammaFactor : Float; // Image Gamma Correction Factor
  MRGamFactor : Float;   // Image Gamma Correction Factor
//  BrightFactor: Float; // Image Brightness Correction Factor
  MRBriFactor: Float;    // Image Brightness Correction Factor
//  BrightFactor: Float; // Image Brightness Correction Factor
  MRBriMinFactor: Float; // Image Brightness Convertion Minimal Factor
  MRBriMaxFactor: Float; // Image Brightness Convertion Maximal Factor
end;
type TK_PCMSMRImgAttrs = ^TK_CMSMRImgAttrs;

//************************************************
// Slide Data Types
//************************************************
type TN_CMSlideDUnits = ( // Slide Measure Units
  cmsduMM,   // milimeters
  cmsduInch  // inches
);

type TN_CMSlideRFlags = Set Of ( // Slide runtime flags
  cmsfIsNew,            // Slide was just created
  cmsfCurImgChanged,    // Slide Current Image was changed - is used to Control Study User Defined Properties Saving
  cmsfMapRootChanged,   // Slide MapRoot SubTree was changed
  cmsfAttribsChanged,   // Slide Root Object Attributes were changed
  cmsfThumbChanged,     // Slide Thumbnail was changed
  cmsfHideDrawings,     // Hide Drawing Flag
  cmsfIsOpened,         // Slide is opened in studio area
  cmsfIsPrinting,       // Slide is shown in printing page
  cmsfIsLocked,         // Slide is locked by current user
  cmsfSkipUnlock,       // Skip Slide unlock - is needed while opened slides are reoder in EditFrames
  cmsfIsUsed,           // Slide is Used (is locked by Other User)
  cmsfSkipNewFile,      // Skip new Slide Image and Video file creation - is needed for copy SLides to another Patient
  cmsfSkipSlideEdit,    // Skip Slide Edit
  cmsfSkipChangesSave,  // Skip Slide Changes Saving to ECache and DB
  cmsfInitUndoBuf,      // Initialize Slide Undo Buffer
  cmsfCloseOpened       // Close Opend Slide by refresh
);


type TN_CMSlideSFlags = Set Of (
  cmsfIsMediaObj,    // Slide is associated with Media File (Video later Audio)
  cmsfHasSrcImg,     // Slide has stored in DB Original Image
  cmsfSaveSrcImg,    // Slide Original Image should be stored in DB when Current Image would be changed
  cmsfGreyScale,     // Slide Image is GreyScale
  cmsfShowColorize,  // Show Pseudocolors flag
  cmsfShowIsodensity,// Show Isodensity flag
  cmsfShowEmboss,    // Show Emboss flag
  cmsfUserCalibrated,// Slide is calibrated by user
  cmsfAutoCalibrated,// Slide is auto calibrated just after capturing
  cmsfProbablyCalibrated, // Slide is probably calibrated just after capturing
  cmsfIsImg3DObj,     // Slide is associated with 3D Image object (2D slices "array")
  cmsfDICOMStudy  //CMSuite DICOM study
 );
const
// Default values, are not used now
//  K_CMSlideDefDCMKVP     = 70.0; // DICOM KVP - Peak kilo voltage output of the x-ray generator used
//  K_CMSlideDefDCMExpTime = 160; // DICOM ExposureTime - Time of x-ray exposure in msec
//  K_CMSlideDefDCMTubeCur =  7; // DICOM TubeCurrent - X-Ray Tube Current in mA

  K_CMSlideDefDCMModColorXC = 'XC'; // DICOM Modality for color XC
  K_CMSlideDefDCMModColorES = 'ES'; // DICOM Modality for color ES
  K_CMSlideDefDCMModColorGM = 'GM'; // DICOM Modality for color GM
//  K_CMSlideDefDCMModXRay    = 'CR'; // obsolete DICOM Modality for X-Ray Computer Radiographi
  K_CMSlideDefDCMModXRayCR  = 'CR'; // DICOM Modality for X-Ray Computer Radiographi
  K_CMSlideDefDCMModXRayPan = 'PX'; // DICOM Modality for X-Ray Panoramic
  K_CMSlideDefDCMModXRayIO  = 'IO'; // DICOM Modality for X-Ray Intra Oral
//  K_CMSlideDefDCMModIO      = 'IO'; // DICOM Modality for X-Ray instead of CR - Computer Radiographi
  K_CMSlideDefDCMModXRayCT  = 'CT'; // DICOM Modality for X-Ray Computer Tomographi
  K_CMSlideDefDCMModXRayDX  = 'DX'; // DICOM Modality for Digital X-Ray
  K_CMSlideDefDCMModXRayOT  = 'OT'; // DICOM Modality for X-Ray Other

type TK_CMDCMAttrs = packed record // Common for Slides and All (TWAIN, Other, Video) Profiles Image DICOM attributes
  CMDCMModality :  string; // DICOM Modality
  CMDCMKVP      : Double; // DICOM KVP - Peak kilo voltage output of the x-ray generator used
  CMDCMExpTime  : Integer; // DICOM ExposureTime - Time of x-ray exposure in msec
  CMDCMTubeCur  : Integer; // DICOM Integer TubeCurrent - X-Ray Tube Current in mA
//  CMDCMTubeCurF : single;  // DICOM Float TubeCurrent - X-Ray Tube Current in mA
//  CMDCMRDoseF   : single;  // DICOM RadiationDose     - X-Ray Radiation Dose in mGy
end; // type TK_CMDCMAttrs = packed record
type TK_PCMDCMAttrs = ^TK_CMDCMAttrs;

type TN_CMSViewAttrs = packed record //*** Slide View Attributes (use in runtime)
///////////////////////////
// Slide View Attributes
//
// Image Colorize Attributes
  ColPalInd : Integer; // Colorized Palette Index

// Image Isodensity Attributes
  IsoBaseColInt   : Integer; // Image Base Color intensity
  IsoRangeFactor  :   Float; // Image Colors Intensity Range Factor (0-100)
  IsoColor        : Integer; // Isodensity Draw Color
  IsoTranspFactor :   Float; // Isodensity Draw Transparency Factor (0-100)

// Image Emboss Attributes
  EmbDepth   : Integer; // Image Emboss Depth 1 - 20
  EmbDirAngle:   Float; // Image Emboss Direction Angle in degrees
  EmbRFactor :   Float; // Image Emboss Resulting Correction Factor
  EmbBase    : Integer; // Image Emboss Base Gray Intensity
//
// end of Slide View Attributes
///////////////////////////

end; // type TN_CMSlideView = packed record

type TN_CMSlideSDBF = packed record //*** Slide Fields Stored in as single DB field
  SFlags: TN_CMSlideSFlags; // Slide State Saved Flags
  DUnits: TN_CMSlideDUnits; // Show Distance Units
  PixPermm   :   float; // Pixel per millimeter (=0 is Slide was NOT calibrated)
  PixWidth   : Integer; // Image width in pixels
  PixHeight  : Integer; // Image height in pixels
  PixBits    : Integer; // Image bits per pixel
  BytesSize  :   Int64; // Image size in bytes
  MDuration  :   Float; // Media Object Duration in seconds
  MediaFExt  :  string; // MediaFile Extension
// TK_CMDCMAttrs
  DCMModality:  string; // DICOM Modality
  DCMKVP     :  Double; // DICOM KVP - Peak kilo voltage output of the x-ray generator used (0018,0060)
  DCMExpTime : Integer; // DICOM ExposureTime - Time of x-ray exposure in msec   (0018,1150)
  DCMTubeCur : Integer; // DICOM Integer TubeCurrent - X-Ray Tube Current in mA  (0018,1151)
//  DCMTubeCurF: Single;  // DICOM Float TubeCurrent - X-Ray Tube Current in mA
  DCMRDose   :   Double; // DICOM RadiationDose      - X-Ray Radiation Dose in dGy*cm*cm  (0018,115E)
  DCMECMode  :  Integer; // DICOM ExposureControlMode - 0 - undefibed, 1 - MANUAL, 2 - AUTOMATIC (0018,7060)
  DCMMnf     :   string; // DICOM Manufacturer (0008,0070)
  DCMMnfMN   :   string; // DICOM Manufacturer’s Model Name (0008,1090)
//
  IniDTTaken : Integer; // Initial Date Taken
  PixDepth   : Integer; // for Image 3D only
  Capt3DDevObjName : string; // Name of capture device object
//
  DCMSerID   : Integer; // DICOM  series ID
//!!! in SPL type TN_CMSViewAttrs is not used and it's fields are directly inside TN_CMSlideSDBF
  ViewAttrs  : TN_CMSViewAttrs;
// new View Attributes should be inserted both:
// - in TN_CMSViewAttrs in Pascal
// - in TN_CMSlideSDBF  in SPL
{
//!!! Insert New Fields here - View Attributes should occupy end of record
///////////////////////////
// Slide View Attributes
//
// Size of this part of TN_CMSlideSDBF is in const K_SlideViewAttsSize
//
// Image Colorize Attributes
  ColPalInd : Integer; // Colorized Palette Index

// Image Isodensity Attributes
  IsoBaseColInt   : Integer; // Image Base Color intensity
  IsoRangeFactor  :   Float; // Image Colors Intensity Range Factor (0-100)
  IsoColor        : Integer; // Isodensity Draw Color
  IsoTranspFactor :   Float; // Isodensity Draw Transparency Factor (0-100)

// Image Emboss Attributes
  EmbDepth   : Integer; // Image Emboss Depth 1 - 20
  EmbDirAngle:   Float; // Image Emboss Direction Angle in degrees
  EmbRFactor :   Float; // Image Emboss Resulting Correction Factor
  EmbBase    : Integer; // Image Emboss Base Gray Intensity
//
// end of Slide View Attributes
///////////////////////////
}
end; // type TN_CMSlideSDBF = packed record
type TN_PCMSlideSDBF = ^TN_CMSlideSDBF;
{
const
  K_SlideViewAttsSize = SizeOf(TN_CMSlideSDBF)
     - SizeOf(TN_CMSlideSFlags) // SFlags
     - SizeOf(TN_CMSlideDUnits) // DUnits
     - SizeOf(Float)            // PixPermm
     - SizeOf(Integer)          // PixWidth
     - SizeOf(Integer)          // PixHeight
     - SizeOf(Integer)          // PixBits
     - SizeOf(Int64)            // BytesSize
     - SizeOf(Float)            // MDuration
     - SizeOf(string)           // MediaFExt
     - SizeOf(string)           // DCMModality
     - SizeOf(Double)           // DCMKVP
     - SizeOf(Integer)          // DCMExpTime
     - SizeOf(Integer)          // DCMTubeCur
     - SizeOf(Integer)          // IniDTTaken
     - SizeOf(Integer);         // PixDepth
}
const
  K_shATFSkipSaveChangesFlag = $40000000; // Skip Save Changes Flag

//**********************************
//      Histiry Events texts
//**********************************

type TK_CMSlideHistActType = ( // Slide History Action Type
  K_shATNotChange, // Events not changing Slide
  K_shATChange,    // Events changing Slide
  K_shATUndoChange,// Events Undo Slide changes
  K_shATRedoChange // Events Redo Slide changes
);

type TK_CMSlideHistNCAct = ( // Slide History (not change Slide) Events
  K_shNCAPrint,            // Print
  K_shNCAExportFile,       // Export to File
  K_shNCAExportWClipboard, // Export to Clipboard
  K_shNCAEmail,            // Send by Email
  K_shNCADuplicate,        // Duplicate
  K_shNCAStartSession,     // Start Session Context
  K_shNCACMSStart,         // CMS Start
  K_shNCACMSClose,         // CMS Close
  K_shNCAAltShiftM,        // Alt+Shift+M service menu was opended
  K_shNCACapDevSetup,      // Capture device setup dialog was opended
  K_shNCAFinishSession,    // Finish Session Context
  K_shNCADuplicateCrop,    // Duplicate for Crop
  K_shNCAOther1,           // other Events 1-st group
  K_shNCAArchive,          // Archiving and Restoring from Archive Events
  K_shNCADICOM             // DICOM Events
);
var K_CMSHistNCActTexts : array [0..Ord(K_shNCADICOM)] of string;
{
var K_CMSHistNCActTexts : array [0..Ord(K_shNCAArchive)] of string =
  ( 'Printed',
    'Exported to file format',
    'Exported to clipboard',
    'Emailed',
    'Duplicated',
    'Session Started',
    'CMS Started',
    'CMS Closed',
    'Alt+Shift+M',
    'Capture Setup',
    'Session Finished',
    'Cropped',
    '',
    '',
    '' );
}
type TK_CMSlideHistExpFormat = ( // Slide History Export Type
  K_shExpImgJPG, // JPG
  K_shExpImgTIF, // TIF
  K_shExpImgBMP, // BMP
  K_shExpImgPNG, // PNG
  K_shExpImgDCM, // DICOM
  K_shExpVideo   // Video
);

var K_CMSHistExpFormatTexts : array [0..Ord(K_shExpVideo)] of string =
  ( 'JPG',
    'TIF',
    'BMP',
    'PNG',
    'DICOM',
    'Video' );

type TK_CMSlideHistNCAOther1 = ( // Slide History (not change Slide) Events 1-st Group
  K_shNCA1UAFilterChange,  // Change User Advanced Filter Attributes
  K_shNCA1GAFilterChange   // Change Global Advanced Filter Attributes
);

var K_CMSHistNCAOther1Texts : array [0..Ord(K_shNCA1GAFilterChange)] of string =
  ( 'Advanced Filter changed User',
    'Advanced Filter changed GLobal' );

type TK_CMSlideHistNCAArch = ( // Slide History (not change Slide) Events 2-nd Group - Archiving and Restoring from Archive events
  K_shNCAArchMoveTo,      // Slide is archived
  K_shNCAArchRestFrom,    // Slide is restored from archive
  K_shNCAArchQAdd,        // Slide is added to Restoring Queue
  K_shNCAArchQDel         // Slide is deleted from Restoring Queue
);

var K_CMSHistNCAArchTexts : array [0..Ord(K_shNCAArchQDel)] of string =
  ( 'Archived',
    'Restored from Archive',
    'Added to Restoring Queue',
    'Deleted from Restoring Queue' );

type TK_CMSlideHistNCADCM = ( // Slide History (not change Slide) Events 3-d Group - DICOM events
  K_shNCADCMStore,    // Slide is send to DCMStorage OK
  K_shNCADCMStoreErr, // Slide is send to DCMStorage Error
  K_shNCADCMComm,     // Slide DCM send to PACS commitment
  K_shNCADCMCommErr,  // Slide DCM send to PACS commitment error
  K_shNCADCMExists,   // Slide DCM exists in PACS
  K_shNCADCMAbsent,   // Slide DCM is absent in PACS
  K_shNCADCMImport    // Slide DCM is import from PACS
);

  var K_CMSHistNCADCMTexts : array [0..Ord(K_shNCADCMImport)] of string =
  ( 'Send to DCM Storage',
    'Send to DCM Storage Error',
    'Send Commitment Request',
    'Send Commitment Request Error',
    'Recieve Exist Commitment',
    'Recieve Absent Commitment',
    'Import by retrieve'
     );

type TK_CMSlideHistCAct = ( // Slide History Events changing Slide
  K_shCACreate,   // Create Slide Virtual Code Put to Result History Programatically
  K_shCAProps,    // Change Slide Properties/Diagnoses
  K_shCAImage,    // Change Image
  K_shCAVOObject, // Change Vector Objects
  K_shCAHLoc,     // Change Slide HostLocation
  K_shCAPat,      // Change Slide Patient
  K_shCADelMark,  // Mark Slide as Deleted
  K_shCADelUnMark,// UnMark Slide as Deleted
  K_shCADelete,   // Delete Slide from DB
  K_shCACreateIAC,// Create SlDde during import after convertion
  K_shCADeleteIAC,// Delete Slide during undo import after convertion
  K_shCADBRecovery// Change Slide by DB Recovery or Integrity check utility
);

var K_CMSHistCActTexts : array [0..Ord(K_shCADBRecovery)] of string =
  ( 'Created',
    '',
    'Image',
    'Annotation',
    'Host location changed',
    'Patient changed',
    'Deleted',
    'Restored deleted',
    'Deleted forever',
    'Imported after convertion',
    'Undo Imported after convertion',
    '' );

type TK_CMSlideHistPropAct = ( // Slide History Change Properties/Diadnoses Event
  K_shPropDiagn,    // Change slide diagnoses or media category
  K_shPropDTChange, // Change slide Date Taken
  K_shPropDTReset   // Reset slide Date Taken to original
);

var K_CMHistPropActTexts : array [0..Ord(K_shPropDTReset)] of string =
  ( 'Properties/diagnoses changed',
    'Date Taken changed',
    'Date Taken reset' );


type TK_CMSlideHistImgAct = ( // Slide History Chage Image Event
  K_shImgActRestoreSrc, // Restore Original Image
  K_shImgActRotateLeft, // Rotate Left
  K_shImgActRotateRight,// Rotate Right
  K_shImgActRotate180,  // Rotate 180
  K_shImgActRotateByAngle,// Rotate By Degree
  K_shImgActFlipHor, // Flip Horizontaly
  K_shImgActFlipVert,// Flip Verticaly
  K_shImgActBriCoGam,// Change Bri/Co/Gam
  K_shImgActNegate,  // Negate
  K_shImgActSharpen, // Sharpen/Smoothen
  K_shImgActNoise,   // Self Noise Reduction
  K_shImgActAutoEqualize, // Auto Equalize
  K_shImgActCrop,       // Crop
  K_shImgActConvToGrey, // Convert to Grey
  K_shImgActUFilter,    // Process Image by User Filter
  K_shImgActResolution, // Change Image Resolution
  K_shImgActGFilter,    // Process Image by Global Filter
  K_shImgActSmoothen,   // Smoothen
  K_shImgActMedian,     // Median Noise Reduction
  K_shImgActDespeckle,  // Despeckle
  K_shImgActConvTo8,    // Convert to 8 bit
  K_shImgActAutoContrast,// Auto Contrast
  K_shImgActResample     // Auto Resample
);

var K_CMSHistImgActTexts : array [0..Ord(K_shImgActResample)] of string =
  ( 'Restored original',
    'Rotated to left',
    'Rotated to right',
    'Rotated to 180',
    'Rotated by degree',
    'Flipped horizontaly',
    'Flipped verticaly',
    'Brightness/Contrast/Gamma changed',
    'Negated',
    'Sharped',
    'Noise reduced',
    'Equalized',
    'Cropped',
    'Converted to grey',
    'Processed by custom filter',
    'Resolution changed',
    'Processed by global filter',
    'Smoothed',
    'Noise reduced by Median',
    'Noise reduced by Despeckle',
    'Converted to 8 bit',
    'Contrast adjusted',
    'Resampled'
     );

type TK_CMSlideHistVObjAct = ( // Slide History VObject Acton Enum
  K_shVOActAdd,        // Add New
  K_shVOActDel,        // Delete Existing
  K_shVOActMove,       // Move Object
  K_shVOActMoveVertex, // Move Obj Vertex
  K_shVOActResize,     // Obj Resize
  K_shVOActEdAttrs,    // Edit Annotation Attributes
  K_shVOActCalibrate   // Change Measure Line Length
);

var K_CMSHistVObjActTexts : array [0..Ord(K_shVOActCalibrate)] of string =
  ( 'Added',
    'Deleted',
    'Moved',
    'Vertex moved',
    'Resized',
    'Attributes changed',
    'Image Calibrated' );

type TK_CMSlideHistRDBAct = ( // Slide History Recovery DB Acton Enum
  K_shRDBCreate,        // Create while DB normal Recovering
  K_shRDBCreateWOCur,   // Create while DB Recovering without Current (from Original) Image (Original -> Current, Current missing or corrupted)
  K_shRDBCreateWOOrig,  // Create while DB Recovering without Original Image (Current -> Original, Original corrupted)
  K_shRDBSrcImgChng,    // Replace Original Image by Current (Current -> Original, Original missing or corrupted)
  K_shRDBCurImgChng,    // Replace Current  Image by Original (Original -> Current, Current missing or corrupted)
  K_shRDBDelete,        // Delete object Current and Original Images are missing or corrupted
  K_shRDBCurImgFromThumb// Restore Current Image be DB Thumbnail
);

var K_CMSHistRDBActTexts : array [0..Ord(K_shRDBCurImgFromThumb)] of string =
  ( 'Restored by Database recovery',
    'Restored by Database recovery (current image is missing or corrupted)',
    'Restored by Database recovery (original image is corrupted)',
    'Recovered original from ñurrent by Integrity check',
    'Recovered current from original by Integrity check',
    'Deleted by Integrity check (unrecoverable)',
    'Recovered current from thumbnail by Integrity check' );

type TK_CMSlideHistVObjType = ( // Slide History VObject Types Enum
  K_shVOTypeMeasureLine, // Measure Line
  K_shVOTypeMeasureText, // Measure Text
  K_shVOTypeAngle,       // Angle
  K_shVOTypeFreeAngle,   // Free Angle
  K_shVOTypePolyLine,    // Polyline
  K_shVOTypeFreeHand,    // Freehand
  K_shVOTypeText,        // Text
  K_shVOTypeFlashlight,  // Flashlight
  K_shVOTypeRect,        // Retangle
  K_shVOTypeEllipse,     // Ellipse
  K_shVOTypeArrow,       // Arrow
  K_shVOTypeDot          // Dot
);

var K_CMSHistVObjTypeTexts : array [0..Ord(K_shVOTypeDot)] of string =
  ( 'Measure line',
    'Measure text',
    'Angle',
    'Free angle',
    'Polyline',
    'Freehand',
    'Text',
    'Magnify region',
    'Rectangle',
    'Ellipse',
    'Arrow',
    'Dot' );
//**********************************
//    end of Histiry Events texts
//**********************************


type TN_CMSlideHist = packed record //*** Slide History
  SHistProvID  : Integer;   // Provider ID
  SHistLocID  : Integer;    // Location ID
  SHistSessionID: Integer;  // Session ID
  SHistActCode : Integer;   // History Action Code
  SHistActTS   : TDateTime; // History Action Timestamp
  end;
type TN_PCMSlideHist = ^TN_CMSlideHist;

type TK_CMHistRepFlags = set of ( // History Report Flags
  K_srfAllSlideActs, // All Slide Actions
  K_srfSlideCreate,  // Slide Create
  K_srfSlideModify,  // Slide Modify
  K_srfSlideDelete,  // Slide Delete
  K_srfSlideExport,  // Slide Export
  K_srfSlidePrint,   // Slide Print
  K_srfSlideEmail,   // Slide Email
  K_srfSlideArchRest,// Slide Archive/Restore
  K_srfSAImportAC,    // Spec Actions Import after convertion
  K_srfSAUndoImportAC,// Spec Actions Undo Import after convertion
  K_srfSACMSSetup,    // Spec Actions CMS setup (Alt+Shift+M)
  K_srfSACaptDevSetup,// Spec Actions Capture device setup
  K_srfSASaveResCurSession, // Save Cur Session Start if Selected SLide
  K_srfSADBRecovery,   // Database Recovery Events generated During Integrity Check or DB Recovery utility
  K_srfSAAFilterSetup,  // Spec Actions Advanced Image Filter setup
  A_srfRadiologyLog //radiology log
);

type TK_CMHistRepAtttrs = packed record //*** History Report Attributes
  HRFlags   : TK_CMHistRepFlags;
  HRStartTS : TDateTime;
  HRFinTS   : TDateTime;
  HRSlideID : string;
  HRPatID   : string;
  HRProvID  : string;
  HRLocID   : string;
end;
type TK_PCMHistRepAtttrs = ^TK_CMHistRepAtttrs;

{
type TN_CMSlideShowHist = packed record //*** Slide Show History
  EDHSlideID : Integer;   // Slide ID
  EDHProvID  : Integer;   // Provider ID
  EDHLocID  : Integer;    // Location ID
  EDHActCode : Integer;   // History Action Code
  EDHActTS   : TDateTime; // History Action Timestamp
end;
type TN_PCMSlideShowHist = ^TN_CMSlideShowHist;
type TN_CMSlideShowHistArray = array of TN_CMSlideShowHist;
}
type TN_CMSlideDBFlags = Set Of ( // Slide DB State Flags
  cmsdbfMarkedAsDel, // Slide is marked as deleted
  cmsdbfInDelState   // Slide is deleting from DB (is needed only in Enterprise mode,
                     // is used while slide files are deleted from distributed data warehouse
);

type TN_CMSlide = packed record //*** Slide Attributes (TN_UDCMSlide record type)
  CMSRFlags: TN_CMSlideRFlags; // Slide State Runtime Flags

  CMSDTTaken:      TDateTime; // Slide DateTime Taken
  CMSDTCreated:    TDateTime; // Slide DateTime Created
  CMSDTImgMod:     TDateTime; // Slide DateTime Image Modified
//  CMSDTModified:   TDateTime; // Slide DateTime Modified
  CMSDTMapRootMod: TDateTime; // Slide DateTime MapRoot Modified
  CMSDTPropMod:    TDateTime; // Slide DateTime Properties/Diagnoses Modified

  CMSProvIDCreated:  integer; // Provider ID that Creates Slide
  CMSProvIDModified: integer; // Provider ID that (last) Modifies Slide

  CMSLocIDCreated:   integer; // Location ID where Slide was Created
  CMSLocIDModified:  integer; // Location ID where Slide was Modified

  CMSCompIDCreated:   string; // Computer Name where Slide was Created
  CMSCompIDModified:  string; // Computer Name where Slide was Modified

  CMSMediaType:      integer; // Slide Media Type (Media Category) (global to all Patients)
  CMSTeethFlags:     Int64;   // Slide Teeth Flags

  CMSDiagn:          string;  // Slide Diagnoses
  CMSSourceDescr:    string;  // Slide Source

  CMSLocIDHost:     integer;  // Slide Host Location ID (is needed only in Enterprise mode)
//  CMSSelfId:      integer;   // Unique Self Id (to be used to retrieve from external DB)
  CMSPatID:       integer;    // Patient ID (to be used to retrieve from external DB)

//  CMSStudyID:      integer;   // Slide Study ID if Slide is included to some Study
//  CMSStudyPos:     integer;   // Slide Exam ID if slide is included to Exam
  CMDCMSerID   : Integer; // DICOM  series ID

  CMSDB   : TN_CMSlideSDBF;   // Slide Fields stored as single DB field
  CMSHist : TK_RArray;        // Slide Edit History (Array of TN_CMSlideHist). In DB mode Temporary History - is cleared after saving to DB
end; // type TN_CMSlide = packed record
type TN_PCMSlide = ^TN_CMSlide;

type TN_CMSlideResUnits = ( // Slide Resolition Units
  cmiPSMN,  // pix size in microns
  cmiPPMM,  // pix per milimetre
  cmiDPI    // dot per inche
);

var
//  K_CMSNewDistUnits : TN_CMSlideDUnits; // Current Distance Unite for New Slides
  K_CMSDistUnitsFormat : array [0..Ord(cmsduInch)] of string = ( '%.*f mm', '%.*f inch' );
  K_CMSDistRoundFactor : array [0..Ord(cmsduInch)] of Integer = ( 1, 2 );
  K_CMSDistUnitsAliase : array [0..Ord(cmsduInch)] of string = ( 'millimetres', 'inches' );
  K_CMSResolutionUnitsAliase : array [0..Ord(cmiDPI)] of string = ( 'Pixel size, microns', 'Pixels per mm', 'DPI' );

var
  K_CMSDistResAliase   : array [0..Ord(cmiDPI)] of string = ( 'pixel size in microns', 'pixels per millimetre', 'dots per inche (DPI)' );

///////////////////////////////////////////////////////////
//  Flashlight Ini Data Type
//
type TK_CMFlashlightIniData = packed record
  CMFLPixSize          : Integer; // Flashlight Initial Pixel Size
  CMFLScaleFactor      : Float;   // Flashlight Scale Factor
  CMFLBriFactor        : Float;   // Flashlight Brightness Factor
  CMFLCoFactor         : Float;   // Flashlight Contrast Factor
  CMFLSkipScaleFlag    : Integer; // Flashlight Skip Scale Mode Flag
  CMFLAutoEqualizeFlag : Integer; // Flashlight Use Auto Equalize Mode Flag
  CMFLRectFlag         : Integer; // Flashlight Rectangle Shape Flag
  CMFLNewAttrsFlag     : Integer; // Flashlight New Attrs Flag
  CMFLGamFactor        : Float;   // Flashlight Gamma Factor
  CMFLMode             : TN_UDDIBRectMode;  // Mode (effect)
  CMFLEmbAngle:    float;   // Emboss Angle    (see CalcEmbossDIB)
  CMFLEmbCoef:     float;   // Emboss Coef     (see CalcEmbossDIB)
  CMFLEmbDepth:    integer; // Emboss Depth    (see CalcEmbossDIB)
  CMFLEmbBaseGrey: integer; // Emboss BaseGrey (see CalcEmbossDIB)
end;
type TK_PCMFlashlightIniData = ^TK_CMFlashlightIniData;

type TK_CMSShowWaitState = (swsNotDef, swsShowWaitState, swsSkipWaitState);
type TK_CMSSlideROIPrepFlags = Set of (
  K_roiDoneAll,       // do not break Prepare ROI reference loop if slide 1-st ROI is OK
  K_roiClearRefs,     // Clear ROI reference
  K_roiRestoreIfImage // Restore ROI reference only if MapImage exists
);
type TK_CMSlideSaveStateFlags = Set Of (
  cmssfAttribsChanged, // Slide attributes were changed
  cmssfMapRootChanged, // Slide MapRoot Tree was changed
  cmssfCurImgChanged,  // Slide Current Image was changed
  cmssfIsNew );        // New Slide was created - is needed only for Emergency Cache Saving
type TK_PCMSlideSaveStateFlags  = ^TK_CMSlideSaveStateFlags;

type TK_CMSlideEdState = ( // Slide Edit State Enumeration for Enterprise Edition
  K_edsFullAccess,  // Slide Data Full Access (Always in not Enterprise Mode )
                    // In Enterprise Mode Slide is opened on self Host Location
  K_edsSkipChanges, // In Enterprise Mode Only Slide Data can be changed but no changes are saved
                    // Slide is opened on foreign (not Host) Location and Image is synchronized
  K_edsSkipOpen     // In Enterprise Mode Only Slide Image couldn't be open
                    // Slide is opened on foreign (not Host) Location and Image is not synchronized
);

type TK_CMSlideLocFlags = Set Of (
  K_slfSrcImgFileExists // File with Original Image is accessible in Location
);

type TN_CMRFEdFreeFlags = set of (
  cmrfefSkipUnlock, // Skip Unlock while Slide Objects are Free during deletion
  cmrfefSkipSave    // Skip Save while Slide Objects are Free during deletion
);

type TK_UDCMSlideGetMapRootFlagsSet = set of (
  K_gmrfSkipMapRootLoad, // Skip MapRoot Load
  K_gmrfSkipMapImgBuild, // Skip Map Image Build
  K_gmrfSkipCurImgLoad   // Skip Current Image Load
);

var K_UDCMSlideGetMapRootFlags : TK_UDCMSlideGetMapRootFlagsSet = [];

type TK_CMBSlideExportToDIBFlags = set of (
  K_bsedExportOriginal,      // export Original Image
  K_bsedSkipConvColorToGrey, // skip conversion TrueColor Image to Grey if its pixels are realy Grey
  K_bsedSkipConvGrey16To8,   // skip Grey 16bit Image conversion to 8bit
  K_bsedSkipAnnotations      // skip Annotations
); // type TK_CMBSlideExportToDIBFlags
// bit0 (0001) - export Original Image
// bit1 (0002) - skip conversion TrueColor Image to Grey if its pixels are realy Grey
// bit2 (0004) - skip Grey 16bit Image conversion to 8bit

type TK_CMBSlideDCMState = set of (
  K_bsdcmsStore,
  K_bsdcmsStoreErr,
  K_bsdcmsComm,
  K_bsdcmsCommErr,
  K_bsdcmsCommExists,
  K_bsdcmsCommAbsent,
  K_bsdcmsImport
); // type TK_CMBSlideDCMState

type TK_CMSUndoBuf = class;
{type}TN_UDCMStudy = class;
//************************************************************ TN_UDCMSlide ***
// Slide object
//
{type} TN_UDCMBSlide = class( TK_UDRArray ) //*** UDCMSlide Base Obj
  CMSUndoBuf  : TK_CMSUndoBuf;   // Slide Image UNDO buffer

  CMSlideMarker: boolean;        // Slide Image Runtime marker

  // Emergency Cache Attributes
  CMSlideECSFlags: TK_CMSlideSaveStateFlags;// Slide Emergency Cache Current Flags - controls saving to Cache
  CMSlideECFName: string;                   // Slide Emergency Cache File Name
  CMSlideECFStream : TFileStream;           // Slide Emergency Cache File Stream

  // Edit Slide State
  CMSlideEdState : TK_CMSlideEdState;
  CMSlideLocFlags : TK_CMSlideLocFlags;
  CMSDBStateFlags : TN_CMSlideDBFlags; // Slide DB Flags

  CMSScaleFontFactor : Double;   // Slide Texts Font scale Factor
  CMSRFrame : TN_Rast1Frame; // RFrame with open slide

  CMSViewUpdateFlag  : Boolean; // Object View was updated
  CMSViewRefreshFlag : Boolean; // Object View Refresh is neede because it is opened

  CMSArchDate : TDateTime; // for control slide UI visibility
  CMSArchived : Boolean;   // for control slide UI visibility

  CMSDCMFSet : TK_CMBSlideDCMState;   // for control slide DICOM state

  constructor Create;      override;
  destructor  Destroy;     override;

  function  P(): TN_PCMSlide;

  function  CheckConsistency( APObj : Pointer; ACheckPar : Integer ) : string; virtual;

  function  GetThumbnail     (): TN_UDDIB;
  procedure GetThumbnailBMP  ( var ABuf: TN_BArray; out AThumbSize: integer );
  function  SetThumbnailByBMP( AMemPtrBMP: pointer     ): TN_UDDIB;
  function  SetThumbnailByDIB( AThumbDIBObj: TN_DIBObj ): TN_UDDIB;

  function  GetFilesPatientPathSegm() : string;
  function  GetFilesPathSegm() : string;
  function  GetIDForFileName( ) : string;

  procedure CheckSlideInsideGetMapRoot;
  function  CreateThumbnail(): TN_UDDIB; virtual; abstract;
  function  ExportToDIB( AExportFlags : TK_CMBSlideExportToDIBFlags = [];
                         AMaxWidth : Integer = 0;
                         AMaxHeight : Integer = 0 ): TN_DIBObj;  virtual; abstract;
  function  GetMapRoot       ( ): TN_UDCompVis; virtual;
  procedure CMSlideAddCurState(AStrings: TStrings; AIndent: Integer); virtual;
  function  GetFileTypeCounts( APImgCount : PInteger = nil; APMediaCount : PInteger = nil;
                               APImg3DCount : PInteger = nil ) : Integer; virtual; abstract;
  procedure ECacheSave( ADumpRTID : Integer; ASaveMode : Integer ); virtual; abstract;
  procedure ECacheClear( ADumpRTID : Integer ); virtual;
end; // type TN_UDCMBSlide = class( TK_UDRArray )
{type} TN_UDCMBSArray = array of TN_UDCMBSlide;

//************************************************************ TN_UDCMSlide ***
// Image or Media representation Slide object
//
{type} TN_UDCMSlide = class( TN_UDCMBSlide ) //*** UDCMSlide Obj

  CMSShowWaitStateFlag : Boolean;// Slide Show Wait State mode during image processing

  // Slide Files Info
  CMSCurImgFSize:   integer;  // Slide Current Image Size is needed for Enterprise Mode to control Files Synchronization process
  CMSSrcImgFSize:   integer;  // Slide Original Image Size is needed for Enterprise Mode to control Files Synchronization process

  CMSSkipNotCalibratedWarning : Boolean;

  // Fields order should not be changed
  CMSIsoMin : Integer; // Isodensity minimal intensity value
  CMSIsoMax : Integer; // Isodensity maximal intensity value
  CMSXLatBCGHist  : TN_IArray; // Used Current Image XLat for Draw Correct Histogram
  CMSXLatBCGColor : TN_IArray; // Used Current Image XLat for get Real Image color

  // Study Link Info
  CMSStudyID : Integer;
  CMSStudyItemID : Integer;
  CMSStudyItemPos : Integer; // Pos = 0  - linked Slide is current visible,
                             // Pos <> 0 - linked Slide is invisible,
                             //            Pos controls the order in "list" of linked to Item Slides

  // Slide Mem Check Results
  CMSSkipMemFree4CurImage : Boolean;
  CMSSkipMemFree4MapImage : Boolean;

  CMSAutoOpen : Boolean; // Auto Open just after Processing Dialog

  CMSSkipDCMAutoStore : Boolean; // Skip sending new object to DICOM Store

  constructor Create;      override;
  destructor  Destroy;     override;

  function  CheckConsistency( APObj : Pointer; ACheckPar : Integer ) : string; override;

  procedure PascalInit (); override;

  procedure InitViewAutoScale();
  procedure PrepROIView( APrepFlags : TK_CMSSlideROIPrepFlags );

  procedure SetAttrsByCurImgParams   ( ASkipGreyInit : Boolean );

  function  GetImgFilesNamePat( const APath : string ) : string;
  function  GetCurImgFileName( const APath : string ) : string;
  function  GetSrcImgFileName( const APath : string ) : string;
  function  GetMediaFileNamePref( const APath : string ) : string;
  function  GetAttrsFileName(const APath: string): string;
  function  GetMediaFileName( const APath : string ) : string;
  function  GetMediaFileClientName() : string;
  procedure SetMediaFileTMPName( const AMediaFExt: string );
  function  AddMediaFile( const ASrcMediaFName: string ) : Integer;
  function  GetImg3DFolderName( const APath: string ): string;
  function  GetDCMFileName(const APath: string): string;

  function  CreateThumbnail  (): TN_UDDIB; override;

  function  CreateMapRoot( AWidth, AHeight : Integer ): TN_UDCompVis;
{
  function  GetMapRoot       ( ASkipLoad : Boolean = false;
                               ASkipMapImgBuild : Boolean = false;
                               ASkipCurImgLoad : Boolean = false ): TN_UDCompVis;
}
  function  GetMapRoot       (): TN_UDCompVis; override;
  function  GetPMapRootAttrs (): TK_PCMSMRImgAttrs;

  function  GetCurrentImage       ( ASkipLoad : Boolean = FALSE;
                                    ASkipLoadDIB : Boolean = FALSE ): TN_UDDIB;
  procedure GetCurrentImageSData  ( out AMemPtr: pointer; out AImgSize: Integer );
  function  SetCurrentImageBySData( AMemPtr: pointer; AImgSize: Integer;
                                    AFreeBufProc : TK_FreeBuffer = nil ) : Boolean;

  procedure GetImgViewConvData( APImgViewConvData : TK_PCMSImgViewConvData;
                                AImgVCSet : TK_CMSImgViewConvSet =
           [vcifFlipRotate,vcifBriCoGam,vcifColorize,vcifIsodensity,vcifEmboss] );
  procedure RebuildMapImageByDIB( ASDIBObj: TN_DIBObj = nil;
                                  APImgViewConvData : TK_PCMSImgViewConvData = nil;
                                  APEmbDIB1: TN_PDIBObj = nil );

  function  GetMapImage      ( ASkipLoadFlag : Boolean = false ): TN_UDDIB;
  procedure ClearMapImage    ();
  procedure SwitchMapRootSize();

//  function  GetMediaObj      ( ASkipLoadFlag : Boolean = false ): TN_UDCompBase;

  function  GetSourceImage   ( ASkipLoad : Boolean = FALSE;
                               ASkipLoadDIB : Boolean = FALSE ): TN_UDDIB;
  procedure GetSourceImageSData( out AMemPtr: pointer; out AImgSize: Integer );
  function  SetSourceImageBySData( AMemPtr: pointer; AImgSize: Integer;
                                   AFreeBufProc : TK_FreeBuffer = nil ) : Boolean;
  function  SetSourceImageByDIBSData( AMemPtr: pointer ): TN_UDDIB;

  function  GetMeasureRoot   (): TN_UDCompVis;
  function  GetPMeasureRootSkipSelf(): PByte;
  function  AddNewMeasurement( const APatName : string; AInsBeforeAll : Boolean = FALSE ): TN_UDCompVis;
  function  DistMM2Units     ( AMMDistance : Double; AUnitsIndex : Integer = -1 ): Double;
  function  DistMM2UnitsText ( AMMDistance : Double; AUnitsIndex : Integer = -1 ): string;
  function  CalcMMDistance   ( const AFP1, AFP2: TFPoint ): Double;
  function  CalcMMLineLength ( AUDLine : TN_UDPolyline ): Double;
  function  RebuildMLineTexts( AUDMLineRoot : TN_UDBase;
                               AUnitsIndex : Integer = -1;
                               APRSum : PDouble = nil ) : Double;
  procedure RebuildAllMLineTexts( ASkipedMLine : TN_UDBase = nil );
  procedure SetMLineInterimTextsDisplayMode( AUDMLineRoot: TN_UDBase;
                               ADisplayMode: Boolean );
  function  GetMLineInterimTextsDisplayMode( AUDMLineRoot: TN_UDBase ) : Integer;
  procedure CalibrateByLine( AUDLine : TN_UDPolyline; ALength : Double;
                             AUnits : TN_CMSlideDUnits );

  function  PrepOneVObj( AUDRObj : TN_UDBase ) : Integer;
  procedure PrepVObjs( );
  function  ExportToDIB  ( AExportFlags : TK_CMBSlideExportToDIBFlags = [];
                           AMaxWidth : Integer = 0;
                           AMaxHeight : Integer = 0 ): TN_DIBObj; override;
  function  GetCMSUndoBuf(): TK_CMSUndoBuf;
  procedure SetTextFontAttrs ( AUDText : TN_UDParaBox; ADecreaseFont : Boolean = false  );
  procedure CMSlideAddCurState ( AStrings: TStrings; AIndent: integer ); override;
  procedure AffConvVObjects6( APixAffCoefs6: TN_AffCoefs6; AAngle : Double; ARFVectorScale : Float );
  procedure AffConvVObjects( AFlipRotateFlags : Integer; ARFVectorScale : Float );
  procedure SetAutoCalibrated();
  function  GetCurImgPixColorByMapImgCursorPos( AMapImgCursorPos : TPoint; APMapImgPixPos : PPoint ) : Integer;
  function  GetStudyItem(): TN_UDBase;
  function  GetStudy(): TN_UDCMStudy;
  function  GetFileTypeCounts( APImgCount : PInteger = nil; APMediaCount : PInteger = nil;
                               APImg3DCount : PInteger = nil ) : Integer; override;
  procedure SetInitDCMAttrs( APDCMAttrs : TK_PCMDCMAttrs );
  procedure InitSelfName();
  procedure ECacheInitName();
  procedure ECacheSave( ADumpRTID : Integer; ASaveMode : Integer = 0 ); override;
  procedure ECacheClear( ADumpRTID : Integer ); override;
  function  ECacheToFile( const AFName : string; AFNamePar : char ) : Integer;
  function  ECacheToCurImageFile( const APath : string; var AFileName : string ) : Integer;
  function  ECacheToSrcImageFile( const APath : string; var AFileName : string ) : Integer;
  function  ECacheToDCMAttrsFile( const APath : string; var AFileName : string ) : Integer;
  procedure SaveAttrsToFile( const AFName : string; ASaveToArchiveFlag : Boolean );
//  property

  //***** TN_UDBase overloaded Methods
//##!!  procedure SetMapRoot       ( ANewMapRoot : TN_UDBase );
//##!!  procedure SetCurImg        ( ANewCurImg : TN_UDBase );
//##!!  function  GetCurImg        (): TN_UDDIB;
//##!!  procedure GetCurrentImageBMP    ( var ABuf: TN_BArray; out AImgSize: integer );
//##!!  function  SetCurrentImageByDIB  ( ACurImgDIBObj: TN_DIBObj ): TN_UDDIB;
//##!!  function  SetCurrentImageByBMP  ( AMemPtrBMP: pointer ): TN_UDDIB;
//##!!  procedure SetSourceImage     ( ANewSrcImg: TN_UDDIB );
//##!!  procedure CreateSourceImage();
//##!!  procedure GetSourceImageBMP  ( var ABuf: TN_BArray; out AOriginImgSize: integer );
//##!!  function  SetSourceImageByDIB( AOriginImgDIBObj: TN_DIBObj ): TN_UDDIB;
//##!!  function  SetSourceImageByBMP( AMemPtrBMP: pointer      ): TN_UDDIB;
//##!!  procedure GetSlideAttribs  ( AAttribs: TStrings );
//##!!  procedure SetSlideAttribs  ( AAttribs: TStrings );
//##!!  procedure GetFieldsFromSBuf ( SBuf: TN_SerialBuf ); override;
//##!!  function  GetFieldsFromText ( SBuf: TK_SerialTextBuf ): Integer; override;
//##!!  procedure CopyFields        ( SrcObj: TN_UDBase ); override;

//##!! function  GetPatient       (): TN_UDCMPatient;
//##!!  function  GetMapRoot       (): TN_UDCompVis;
//##!!  procedure SaveSlideContent ( ADstName: string );
//##!!  function  SaveSlideInfo    ( AFlags: TN_CMSlidesInfoFlags ): integer;
//##!!  function  PrepareMapRoot   (): boolean;
//##!!  procedure SetUniqueId      ();
//##!!  procedure SetSkipSaveFlags ( AFlags: integer );
end; // type TN_UDCMSlide = class( TN_UDCMBSlide )

{type} TN_PUDCMSlide = ^TN_UDCMSlide;
{type} TN_UDCMSArray = array of TN_UDCMSlide;
{type} TN_PUDCMSArray = ^TN_UDCMSArray;

  TN_UDCMSArrayHelper = record helper for TN_UDCMSArray
    procedure Delete(const AIndex: integer);
  end;

//************************************************************ TN_UDCMSlide ***
// Study representation Slide object
//
{type} TN_UDCMStudy = class( TN_UDCMBSlide ) //*** UDCMStudy Obj
  // Study Graphics Info
  CMSStudySampleID   : Integer; // Study Sample ID
  CMSStudyItemsCount : Integer; // Study Sample count = for control study Sample
  CMSStudyCaptStartPos : Integer; // Study Capture Start position number
  CMSSelectedItems : TN_UDCompVisArray; // Array of Sample Item Components
  CMSSelectedCount : Integer;
  constructor Create; override;
  function  GetMapRoot       () : TN_UDCompVis; override;
  procedure InitByMapRoot    ();
  procedure InitBySample     ();
  function  CreateMapRoot    () : TN_UDCompVis;
  function  CreateThumbnail  () : TN_UDDIB; override;
  procedure SetChangeState   ();

  function  GetFileName( const APath: string ): string;
  function  ExportToDIB( AExportFlags : TK_CMBSlideExportToDIBFlags = [];
                         AMaxWidth : Integer = 0;
                         AMaxHeight : Integer = 0 ): TN_DIBObj; override;
  procedure GetSlidesPixRects( var ASlides : TN_UDCMSArray; var APixRects : TN_IRArray );
  function  GetCurSlidesToArray( var ASlides : TN_UDCMSArray; AStartInd : Integer = 0 ): Integer;
  function  GetSelectedSlidesToArray( var ASlides : TN_UDCMSArray; AStartInd : Integer = 0 ): Integer;
  procedure GetAllSlidesToArray( out ASlides : TN_UDCMSArray );

  function  IfItemSelected( AItem : TN_UDBase ) : Integer;
  function  GetItemIndex( AItem: TN_UDBase ) : Integer;
  function  SelectItemByIndex( AItemInd: Integer ) : Integer;
  function  SelectItem( AItem : TN_UDBase ) : Integer;
  function  UnSelectItem( AItem : TN_UDBase ) : Integer;
  procedure ToggleSlide( AItem: TN_UDBase );
  function  SelectAll( ) : Integer;
  function  UnSelectAll( ) : Integer;
  function  InvertSelection( ) : Integer;
  function  GetFileTypeCounts( APImgCount : PInteger = nil; APMediaCount : PInteger = nil;
                               APImg3DCount : PInteger = nil ) : Integer; override;
  procedure RebuildItemsSearchList( ASearchGroup : TN_SGComp; AIncUsedItems : Boolean );
  function  GetItemThumbnailByIndex( AItemInd: Integer ): TN_UDDIB;

  procedure ECacheSave( ADumpRTID : Integer; ASaveMode : Integer = 0 ); override;
end; // type TN_UDCMStudy = class( TN_UDCMBSlide )
{type} TN_PUDCMStudy = ^TN_UDCMStudy;

{type} TN_CMSUndoSlideAttrs = packed record // UNDO Slide Attrs
  USADTImgMod   : TDateTime;
  USADTMapRootMod: TDateTime;
  USADTPropMod  : TDateTime;
  USADTTaken    : TDateTime;
  USATeethFlags : Int64;
  USAMediaType  : Integer;
  USADiagn      : string;
  USAPixpermm   : Float;
  USAPixBits    : Integer;
  USAPixWidth   : Integer; // Image width in pixels
  USAPixHeight  : Integer; // Image height in pixels
  USADUnits     : TN_CMSlideDUnits;
  USASFlags     : TN_CMSlideSFlags;
  USAProvIDModified : Integer;
  USALocIDModified  : Integer;
  USACompModified   : string;
  USAIniDTTaken     : Integer;
end;
{type} TN_PCMSUndoSlideAttrs = ^TN_CMSUndoSlideAttrs;

//************************************************************ TK_CMSUndoBuf ***
// Slide Undo buffer
//
{type} TK_CMSUndoBuf = class(TK_UNDOBuf1)
//type TK_CMSUndoBuf = class(TK_UNDOBuf)
  UDCMSlide: TN_UDCMSlide;
  constructor Create( );
  constructor CreateByUNDOBuf( AUNDOBuf: TK_CMSUndoBuf );
  destructor Destroy; override;
  procedure UBInitBySlide( ASlide: TN_UDCMSlide );
  procedure UBPushSlideState( AEditCapt : string;
                              ASaveStateFlags : TK_CMSlideSaveStateFlags;
                              AHistActionCode : Integer );
  function  UBGetSlideHistActionCode( AInd : Integer ) : Integer;
  procedure UBGetSlideCurImgUDData( ACurUDImg : TN_UDDIB );
  function  UBGetSlideState( AInd : Integer ) : TK_CMSlideSaveStateFlags;
  function  UBPopSlideState( ) : TK_CMSlideSaveStateFlags;
  function  UBPrevPopedSlideState( ) : TK_CMSlideSaveStateFlags;
  function  UBGetSrcImgCreationIsNeeded( ASavedCurImgID : Integer = -1 ) : Boolean;
  procedure UBMarkSlideBufState();
  function  UBMarkSaveStateFlags( ) : TK_CMSlideSaveStateFlags;
  procedure UBSlidePrepForSaving();
  procedure UBSlideRestoreSavingContext;
  procedure UBSetSlideChangeDataFlags();
  function  UBRebuildCurImageGreyState( APrevGreyState : Boolean; APrevPixBits : Integer ) : Boolean;
  function  UBGetSrcImageDIB( APUData : TN_PBArray = nil ) : TN_DIBObj;
  function  UBPrepRestSrcImageState( ARestoreCapt: string;
                      out ASaveUndoFlags : TK_CMSlideSaveStateFlags ) : Boolean;
  procedure UBRestoreSrcState( ARestoreCapt: string );
  procedure UBRestoreSrcImage ( ARestoreCapt: string );
  function  UBRestoreSrcStateIsEnabled() : Boolean;
  function  UBRestoreSrcImageIsEnabled() : Boolean;
    private
  FPrevCurInd   : Integer; // UNDO Record Index when slide was saved to DB
  FPrevAttribsID: Integer; // UNDO Attribs Saved Index - Index when Attribs were saved to DB
  FPrevMapRootID: Integer; // UNDO MapRoot Saved Index - Index when MapRoot was saved to DB
  FPrevCurImgID : Integer; // UNDO Current Image Saved Index - Index when Current Image was saved to DB

  FSavedCurInd   : Integer; // UNDO Record Index when slide was saved to DB
  FSavedAttribsID: Integer; // UNDO Attribs Saved Index - Index when Attribs were saved to DB
  FSavedMapRootID: Integer; // UNDO MapRoot Saved Index - Index when MapRoot was saved to DB
  FSavedCurImgID : Integer; // UNDO Current Image Saved Index - Index when Current Image was saved to DB

  FMarkedCurInd    : Integer; // UNDO Record Index when slide was Marked
  FMarkedAttribsID : Integer; // Attribs Marked Index - for control if Attribs restoring is needed during UNDO/REDO
  FMarkedMapRootID : Integer; // MapRoot Marked Index - for control if MapRoot restoring is needed during UNDO/REDO
  FMarkedCurImgID  : Integer; // Current Image Marked Index - for control if Current Image restoring is needed during UNDO/REDO

    public

  FAttribsID     : Integer; // Attribs Saved Index - for control if Attribs restoring is needed during UNDO/REDO
  FMapRootID     : Integer; // MapRoot Saved Index - for control if MapRoot restoring is needed during UNDO/REDO
  FCurImgID      : Integer; // Current Image Saved Index - for control if Current Image restoring is needed during UNDO/REDO

  FSkipSetRestoreSrcImgFlag : Boolean; // Skip Set Restore SrcImg Flag in Slide Attrs while Push New CurImg
  property UBCurImgID : Integer read FCurImgID;
//  property UBSkipSetRestoreSrcImgFlag : Boolean read FSkipSetRestoreSrcImgFlag write FSkipSetRestoreSrcImgFlag;
end;
//*** end of CMS Slide Image Undo

type TK_CMStudyRemountOneSlideContext = record
  CMRItem       : TN_UDBase;    // Target Item
  CMRItemStudy  : TN_UDCMStudy; // Target Item Study
  CMRItemSlide  : TN_UDCMSlide; // Target Item Slide
  CMRItemFRFlags: Integer;      // Target Item FlipRotate Flags
  CMRItemTeethFlags: Int64;     // Target Item Teeth Flags
  CMRSlide      : TN_UDCMSlide; // Source Slide
  CMRSlideItem  : TN_UDBase;    // Source Slide Item
  CMRSlideStudy : TN_UDCMStudy; // Source Slide Item Study
  CMRSlideItemFRFlags: Integer; // Source Slide Item FlipRotate Flags
  CMRSlideItemTeethFlags: Int64;// Source Slide Item Teeth Flags
end;
type TK_PCMStudyRemountOneSlideContext = ^TK_CMStudyRemountOneSlideContext;

type TK_CMStudyRemountUpdateFlags = set of (
  K_srufRebuildVisSlides, // Rebuild Visible Slides Thumbnails List
  K_srufRedrawItemStudy,  // Redraw Remount Item Study
  K_srufRedrawSlideStudy  // Redraw Slide previouse Open Study
);


var K_CMSUndoSlideAttrsType : TK_ExprExtType;

//*** Slide Tree Indexes
const
  K_CMSlideIndThumbnail     = 0; // Slide Thumbnail Child Index
  K_CMSlideIndMapRoot       = 1; // Slide MapRoot Child Index
  K_CMSlideIndCurImg        = 2; // Slide Current Image Child Index
  K_CMSlideIndSrcImg        = 3; // Slide Original Image Child Index
  K_CMSlideIndStudyItem     = 4; // Slide Study Item Reference Child Index

  K_CMStudyIndSrcSample     = 2; // Study Source Sample Reference Child Index
//  K_CMStudyItemIndInvisRoot = 2; // Study Item Invisible slides root Child Index

  K_CMSlideMRIndAttrs     = 0; // Slide MapRoot Attributes Child Index
  K_CMSlideMRIndMapImg    = 1; // Slide MapRoot Temporary Image Child Index
  K_CMSlideMRIndMeasures  = 2; // Slide MapRoot Measurements Child Index

{
//*************************************************** TK_CMEIsodensityRFA ***
// Create New Line Measurement Raster Frame Action
//
type TK_CMEGetRFA = class( TN_RFrameAction )
  SkipNextMouseDown : Boolean;
  procedure Execute (); override;
end; // type TK_CMEIsodensityRFA = class( TN_RFrameAction )
}

//************************************************
// Tooth Numbering Scheme Consts, Types, Routines
//************************************************
const
  K_CMTNumUSANames : array [0..61] of string = (
   '8', '7', '6', '5', '4', '3', '2', '1',
        'E', 'D', 'C', 'B', 'A','UR',
  '25','26','27','28','29','30','31','32',
        'P', 'Q', 'R', 'S', 'T','LR',
        'R.BW1', 'R.BW2', {reserved} '', '',
   '9','10','11','12','13','14','15','16',
        'F', 'G', 'H', 'I', 'J','UL',
  '24','23','22','21','20','19','18','17',
        'O', 'N', 'M', 'L', 'K','LL',
        'L.BW1', 'L.BW2' );
  K_CMTNumFDINames : array [0..61] of string = (
  '11','12','13','14','15','16','17','18',
       '51','52','53','54','55','UR',
  '41','42','43','44','45','46','47','48',
       '81','82','83','84','85','LR',
       'R.BW1', 'R.BW2', {reserved} '', '',
  '21','22','23','24','25','26','27','28',
       '61','62','63','64','65','UL',
  '31','32','33','34','35','36','37','38',
       '71','72','73','74','75','LL',
       'L.BW1', 'L.BW2' );
  K_CMTNumTextInds : array [0..59] of Integer = (
  13, 45, 27, 59, 28, 29, 60, 61,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
  14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
  46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58 );

  K_CMTNumUSAScheme = false;  // Use USA Tooth Numbering Scheme
  K_CMTNumFDIScheme = true;   // Use F.D.I. Tooth Numbering Scheme

var
  K_CMToothNumSchemeFlag : Boolean = true; //  Use F.D.I. Tooth Numbering Scheme Default
  K_CMToothNumSchemeList : TStringList;    //  Strings List used to convert Slide Tooth string to Tooth slide Set
  K_CMToothNumSchemeListFlag : Boolean;    //  if TRUE then F.D.I. Tooth Numbering Scheme was used to create K_CMToothNumSchemeList

//////////////////////////////////////////////
//  Teeth DICOM Info
//
const
  K_CMTeethUpperMask = $00003FFF00003FFF;
  K_CMTeethLowMask   = $0FFFC0000FFFC000;
  K_CMTeethBWMask    = $3000000030000000;
  K_CMTeethBWMaskR   = $0000000030000000;
  K_CMTeethBWMaskL   = $3000000000000000;

type TK_CMTDICOMInfo = record
  c : string; // Tooth DICOM Code
  n : string; // Tooth DICOM Name
end;

var
  K_CMTeethRegDICOMInfo : array [0..1] of TK_CMTDicomInfo = (
  (c :'T-11170'; n :'Maxilla';),
  (c :'T-54270'; n :'Mandible';)
);
  K_CMTeethDICOMInfo : array [0..61] of TK_CMTDicomInfo = (
// Upper Right Permanent Dentition
  (c :'T-54280'; n :'Maxillary right central incisor tooth';),
  (c :'T-54270'; n :'Maxillary right lateral incisor tooth';),
  (c :'T-54260'; n :'Maxillary right canine tooth';),
  (c :'T-54250'; n :'Maxillary right first premolar tooth';),
  (c :'T-54240'; n :'Maxillary right second premolar tooth';),
  (c :'T-54230'; n :'Maxillary right first molar tooth';),
  (c :'T-54220'; n :'Maxillary right second molar tooth';),
  (c :'T-54210'; n :'Maxillary right third molar tooth';),
// Upper Right Deciduous Dentition
  (c :'T-54610'; n :'Deciduous maxillary right central incisor tooth';),
  (c :'T-54620'; n :'Deciduous maxillary right lateral incisor tooth';),
  (c :'T-54630'; n :'Deciduous maxillary right canine tooth';),
  (c :'T-54640'; n :'Deciduous maxillary right first molar tooth';),
  (c :'T-54650'; n :'Deciduous maxillary right second molar tooth';),
// UR
  (c :''; n :'';),
// Low Right Permanent Dentition
  (c :'T-54450'; n :'Mandibular right central incisor tooth';),
  (c :'T-54460'; n :'Mandibular right lateral incisor tooth';),
  (c :'T-54470'; n :'Mandibular right canine tooth';),
  (c :'T-54480'; n :'Mandibular right first premolar tooth';),
  (c :'T-54490'; n :'Mandibular right second premolar tooth';),
  (c :'T-54500'; n :'Mandibular right first molar tooth';),
  (c :'T-54510'; n :'Mandibular right second molar tooth';),
  (c :'T-54520'; n :'Mandibular right third molar tooth';),
// Low Right Deciduous Dentition
  (c :'T-54710'; n :'Deciduous mandibular right central incisor tooth';),
  (c :'T-54720'; n :'Deciduous mandibular right lateral incisor tooth';),
  (c :'T-54730'; n :'Deciduous mandibular right canine tooth';),
  (c :'T-54740'; n :'Deciduous mandibular right first molar tooth';),
  (c :'T-54750'; n :'Deciduous mandibular right second molar tooth';),
// LR Low Right
  (c :''; n :'';),

// Right BW1,BW2
  (c :''; n :'';),
  (c :''; n :'';),
// Reserved
  (c :''; n :'';),
  (c :''; n :'';),

// Upper Left Permanent Dentition
  (c :'T-54290'; n :'Maxillary left central incisor tooth';),
  (c :'T-54300'; n :'Maxillary left lateral incisor tooth';),
  (c :'T-54310'; n :'Maxillary left canine tooth';),
  (c :'T-54320'; n :'Maxillary left first premolar tooth';),
  (c :'T-54330'; n :'Maxillary left second premolar tooth';),
  (c :'T-54340'; n :'Maxillary left first molar tooth';),
  (c :'T-54350'; n :'Maxillary left second molar tooth';),
  (c :'T-54360'; n :'Maxillary left third molar tooth';),
// Upper Left Deciduous Dentition
  (c :'T-54660'; n :'Deciduous maxillary left central incisor tooth';),
  (c :'T-54670'; n :'Deciduous maxillary left lateral incisor tooth';),
  (c :'T-54680'; n :'Deciduous maxillary left canine tooth';),
  (c :'T-54690'; n :'Deciduous maxillary left first molar tooth';),
  (c :'T-54700'; n :'Deciduous maxillary left second molar tooth';),
// UL Upper Left
  (c :''; n :'';),
// Low Left Permanent Dentition
  (c :'T-54440'; n :'Mandibular left central incisor tooth';),
  (c :'T-54430'; n :'Mandibular left lateral tooth';),
  (c :'T-54420'; n :'Mandibular left canine tooth';),
  (c :'T-54410'; n :'Mandibular left first premolar tooth';),
  (c :'T-54400'; n :'Mandibular left second premolar tooth';),
  (c :'T-54390'; n :'Mandibular left first molar tooth';),
  (c :'T-54380'; n :'Mandibular left second molar tooth';),
  (c :'T-54370'; n :'Mandibular left third molar tooth';),
// Low Left Deciduous Dentition
  (c :'T-54760'; n :'Deciduous mandibular left central incisor tooth';),
  (c :'T-54770'; n :'Deciduous mandibular left lateral incisor tooth';),
  (c :'T-54780'; n :'Deciduous mandibular left canine tooth';),
  (c :'T-54790'; n :'Deciduous mandibular left first molar tooth';),
  (c :'T-54800'; n :'Deciduous mandibular left second molar tooth';),
// LL Low Left
  (c :''; n :'';),
// Left BW1,BW2
  (c :''; n :'';),
  (c :''; n :'';)
);

//
//  Teeth DICOM Info
//////////////////////////////////////////////

function K_CMSTeethChartStateToText( ATeethChartState : Int64 ) : string;
function K_CMSTeethChartTextToState( const ATeethChartText : string; ADelim : Char = ',' ) : Int64;

// *** end of Tooth Numbering Scheme Consts, Types, Routines

//************************************************
// Slides Filtering Consts, Types, Routines
//************************************************
//type TK_CMSlideFilterDateSelectMode = (K_sfdsmDatesAll, K_sfdsmDatesRange, K_sfdsmDatesExact);

type TK_CMSlideFilterDateSelectMode = (
  K_sfdsmDatesAll,    // Any Slide Date is OK
  K_sfdsmDatesRange,  // Slide Date is inside given interval
  K_sfdsmToday,       // Slide Date is inside Today interval
  K_sfdsmPrevWeek,    // Slide Date is inside Week ago till Today interval
  K_sfdsmPrevMonth,   // Slide Date is inside Month ago till Today interval
  K_sfdsmPrevQuarter, // Slide Date is inside Quarter ago till Today interval
  K_sfdsmPrev1Year,   // Slide Date is inside Year ago till Today interval
  K_sfdsmPrev2Years,  // Slide Date is inside 2 Years ago till Today interval
  K_sfdsmPrev3Years   // Slide Date is inside 3 Years ago till Today interval
  );

type TK_CMSlideFilterAttrs = packed record
  FATeethFlags  : Int64;  // Slide Teeth Flags
  FAMediaType   : Integer; // Slide Media Types
  FAOpenCount   : Integer; // Slide to Open after filter apply Counter
  FADate1       : TDateTime; // Slide DTTaken Range Start
  FADate2       : TDateTime; // Slide DTTaken Range Fin
  FADateMode    : TK_CMSlideFilterDateSelectMode; // Slide DTTaken Select Mode
end;
type TK_PCMSlideFilterAttrs = ^TK_CMSlideFilterAttrs;

const K_CMFilterAllMTypesVal = -2;
const K_CMFilterUDViewFilter = -100;

procedure K_CMFilterDatesPrepEInterval( AFADateMode    : TK_CMSlideFilterDateSelectMode;
                         var AFADate1, AFADate2 : TDateTime );
procedure K_CMFilterDatesInit( APFilterAttrs: TK_PCMSlideFilterAttrs );
procedure K_CMFilterAttrsClear( APFilterAttrs : TK_PCMSlideFilterAttrs );
function  K_CMSlideCheckByFilter( ASlide: TN_UDCMSlide; APFilterAttrs : TK_PCMSlideFilterAttrs ) : Boolean;
function  K_CMSlideFilterText( ASlide: TN_UDCMSlide ) : string;
function  K_CMSlideViewCaption( ASlide: TN_UDCMSlide ) : string;

//*** end of Slides Filtering Consts, Types, Routines
{
//************************************************
// Providers Locations Patients Extenal data buffering
//************************************************
type TK_CMGetExtDataProc = function ( ADataID : Integer; AFieldNames : TN_SArray ) : TN_SArray of object;

//************************************************************ TK_CMExtDBuf ***
// External Data Buffer class
//
// Used for buffering auxiliary data (Provider, Location, etc.) retrieved
// from some external data source (D4W or CMS DB)
//
type TK_CMExtDBuf = class

  OnGetExtData : TK_CMGetExtDataProc;
//##/*
  constructor Create();
  destructor Destoy();
//##*/
  procedure DBAddExtFields( AFieldNames : array of string );
  procedure DBAddExtField( AFieldName : string );
  function  DBAddValuesArrayByID( ADataID: Integer;
                                  AFieldValues: TN_SArray ) : Integer;
  function  DBAddValuesListByID( ADataID: Integer;
                                 AFieldNValues: TStrings ) : Integer;
  function  DBGetFieldValueByID( ADataID : Integer; AFieldName : string ) : string;
  procedure DBGetAllValuesByID( ADataID : Integer; AFieldValues : TStrings;
                                AAddToValues : Boolean = false );
     private
  ExtFieldsValues : TN_ASArray;
  ExtFieldNames : TN_SArray;
  ExtFieldsList : TStringList;
  ExtDataIDs : TList;
  function  DBPrepDataIndByID( ADataID: Integer ) : Integer;
  procedure DBAddValuesArrayByInd( ADataInd: Integer;
                                  AFieldValues: TN_SArray );
end;

//************************************************************ TK_CMExtDSource ***
// External Data Source Base class
//
// Base class for auxiliary data (Provider, Location, etc.) access
//
type TK_CMExtDSource = class

  function DSGetData( ADataID : Integer; AFieldNames : TN_SArray ) : TN_SArray; virtual; abstract;
end;

//************************************************************ TK_CMExtDSourceEmulator ***
// External Data Source Emulator class
//
// Class for auxiliary data (Provider, Location, etc.) access Emulation
//
type TK_CMExtDSourceEmulator = class (TK_CMExtDSource)
  DataPrefix : string;
  function DSGetData( ADataID : Integer; AFieldNames : TN_SArray ) : TN_SArray; override;
end;

//************************************************************ TK_CMDBSource ***
// CMS DB Data Source class
//
// DB access to auxiliary data (Provider, Location, etc.)
//
type TK_CMDBSource = class (TK_CMExtDSource)
  DBTableName   : string; // Souce table name
  DBIDFieldName : string; // Primary Key Field Name
  DBDataSet   : TADOQuery;
  DBConnection : TADOConnection;
//##/*
  destructor Destroy(); override;
//##*/
  function DSGetData( ADataID : Integer; AFieldNames : TN_SArray ) : TN_SArray; override;
end;


var
  K_CMEProviderDBuf : TK_CMExtDBuf; // External Provider Data Buffer
  K_CMELocationDBuf : TK_CMExtDBuf; // External Location Data Buffer

//*** end of Providers Locations Patients Extenal data buffering
}

//**********************************************
// CMS External data Names (CMEN) Varaibles
//**********************************************
var
//*** TmpTable for Blob Data
  K_CMENDBTmpTable  : string = 'TmpBlobTable';// Temporary Blob Table Name
    K_CMENDBTTFID      : string = 'ID';      // TmpBlobTable Field Name for record ID
    K_CMENDBTTFBlobBuf : string = 'BlobBuf'; // TmpBlobTable Field Name for Blob Buffer for Image Files exchange

//*** Slides Table Info
  K_CMENDBSlidesTable       : string = 'AllSlides';    // Slides Table Name

    K_CMENDBSTFSlideID        : string = 'SlideID';    // SlidesTable Field Name for Slide ID
    K_CMENDBSTFSlideIDInd     : Integer;               // SlidesTable Slide ID select field index
    K_CMENDBSTFPatID          : string = 'PatID';      // SlidesTable Field Name for Patient ID
    K_CMENDBSTFPatIDInd       : Integer;               // SlidesTable Patient ID select field index
    K_CMENDBSTFSlideDTTaken   : string = 'DTTaken';    // SlidesTable Field Name for Slide Taken DateTime
    K_CMENDBSTFSlideDTTakenInd: Integer;               // SlidesTable Taken DateTime select field index
    K_CMENDBSTFSlideDTCr      : string = 'DTCr';       // SlidesTable Field Name for Slide Created DateTime
    K_CMENDBSTFSlideDTCrInd   : Integer;               // SlidesTable Created DateTime select field index
    K_CMENDBSTFSlideDTImg     : string = 'DTImg';      // SlidesTable Field Name for Slide Image Modified DateTime
    K_CMENDBSTFSlideDTImgInd  : Integer;               // SlidesTable Image Modified DateTime select field index
    K_CMENDBSTFSlideDTMapRoot : string = 'DTMapRoot';  // SlidesTable Field Name for Slide MapRoot Modified DateTime
    K_CMENDBSTFSlideDTMapRootInd  : Integer;           // SlidesTable MapRoot Modified DateTime select field index
    K_CMENDBSTFSlideDTProp    : string = 'DTProp';     // SlidesTable Field Name for Slide Properties/Diagnoses Modified DateTime
    K_CMENDBSTFSlideDTPropInd : Integer;               // SlidesTable Properties/Diagnoses Modified DateTime select field index
    K_CMENDBSTFSlideMTypeID   : string = 'MTID';       // SlidesTable Field Name for Slide Media Type ID
    K_CMENDBSTFSlideMTypeIDInd: Integer;               // SlidesTable Media Type ID select field index
    K_CMENDBSTFSlideProvIDCr  : string = 'ProvIDCr';   // SlidesTable Field Name for Slide Created Provider ID
    K_CMENDBSTFSlideProvIDCrInd: Integer;              // SlidesTable Created Provider ID select field index
    K_CMENDBSTFSlideProvIDMod : string = 'ProvIDMod';  // SlidesTable Field Name for Slide Modified Provider ID
    K_CMENDBSTFSlideProvIDModInd: Integer;             // SlidesTable Modified Provider ID select field index
    K_CMENDBSTFSlideLocIDCr   : string = 'LocIDCr';    // SlidesTable Field Name for Slide Created Location ID
    K_CMENDBSTFSlideLocIDCrInd: Integer;               // SlidesTable Created Location ID select field index
    K_CMENDBSTFSlideLocIDMod  : string = 'LocIDMod';   // SlidesTable Field Name for Slide Modified Location ID
    K_CMENDBSTFSlideLocIDModInd: Integer;              // SlidesTable Modified Location ID select field index
    K_CMENDBSTFSlideCompCr    : string = 'CompCr';     // SlidesTable Field Name for Slide Created Computer Name
    K_CMENDBSTFSlideCompCrInd : Integer;               // SlidesTable Created Computer Name select field index
    K_CMENDBSTFSlideCompMod   : string = 'CompMod';    // SlidesTable Field Name for Slide Modified Computer Name
    K_CMENDBSTFSlideCompModInd : Integer;              // SlidesTable Modified Computer Name select field index
    K_CMENDBSTFSlideTeethRight: string = 'RTeethFlags';// SlidesTable Field Name for Slide Right Teeth Flags
    K_CMENDBSTFSlideTeethRightInd : Integer;           // SlidesTable Right Teeth Flags select field index
    K_CMENDBSTFSlideTeethLeft : string = 'LTeethFlags';// SlidesTable Field Name for Slide Left Teeth Flags
    K_CMENDBSTFSlideTeethLeftInd : Integer;            // SlidesTable Left Teeth Flags select field index
    K_CMENDBSTFSlideSrcDescr  : string = 'Source';     // SlidesTable Field Name for Slide Source Description
    K_CMENDBSTFSlideSrcDescrInd  : Integer;            // SlidesTable Source Description select field index
    K_CMENDBSTFSlideDiagnoses : string = 'Diagn';      // SlidesTable Field Name for Slide Diagnoses
    K_CMENDBSTFSlideDiagnosesInd  : Integer;           // SlidesTable Diagnoses select field index
    K_CMENDBSTFSlideSysInfo   : string = 'SysInfo';    // SlidesTable Field Name for Slide System Info (Special CMS Fields)
    K_CMENDBSTFSlideSysInfoInd    : Integer;           // SlidesTable System Info select field index
    K_CMENDBSTFSlideThumbnail : string = 'Thumbnail';  // SlidesTable Field Name for Slide Image Thumbnail
    K_CMENDBSTFSlideMapRoot   : string = 'MapRoot';    // SlidesTable Field Name for Slide CMS IDB Fragment with Slide ViewAttrs and Vector Objects
    K_CMENDBSTFSlideLocIDHost : string = 'LocIDHost';  // SlidesTable Field Name for Slide Host Location ID
    K_CMENDBSTFSlideLocIDHostInd    : Integer;         // SlidesTable Host Location ID select field index
    K_CMENDBSTFSlideDTArch    : string = 'DTArch';     // SlidesTable Field Name for Slide archived routinues Date field
    K_CMENDBSTFSlideDTArchInd : Integer;               // SlidesTable Slide archived routinues Date select field index
    K_CMENDBSTFSlideFlags     : string = 'Flags';      // SlidesTable Field Name for Slide Flags Set
                                                       // Bit0 (001) - Slide is marked as deleted
                                                       // Bit1 (002) - Slide is deleting
    K_CMENDBSTFSlideFlagsInd  : Integer;               // SlidesTable Flags Set select field index
    K_CMENDBSTFSlideCurFSize  : string = 'CurFSize';   // SlidesTable Field Name for Slide Current Image File Size
    K_CMENDBSTFSlideCurFSizeInd: Integer;              // SlidesTable Current Image File Size select field index
    K_CMENDBSTFSlideSrcFSize  : string = 'SrcFSize';   // SlidesTable Field Name for Slide Original Image File Size
    K_CMENDBSTFSlideSrcFSizeInd: Integer;              // SlidesTable Original Image File Size select field index
    K_CMENDBSTFSlideVideoFSize: string = 'VideoFSize'; // SlidesTable Field Name for Slide Video File Size
    K_CMENDBSTFSlideVideoFSizeInd: Integer;            // SlidesTable Video Image File Size select field index
    K_CMENDBSTFSlideSFlags    : string = 'SFlags';     // SlidesTable Field Name for Slide Service Flags Set
                                                       // Bit0 (001) - Slide is processed by Integrity check or Creation Study Files Routine
                                                       // Bit1 (002) - Slide is marked as unrecovered (for process unrecovered only)
                                                       // Bit2 (004) - Slide is processed by Resampling large
                                                       // Bit3 (008) - Slide is marked as large (to be resampled)
                                                       // Bit4 (016) - Slide is archived but not all files are deleted from file storage marked (while archiving)
    K_CMENDBSTFSlideSFlagsInd : Integer;               // SlidesTable Service Flags Set select field index
    K_CMENDBSTFSlideStudyID   : string = 'StudyID';    // SlidesTable Field Name for Slide Study ID (DBVer >= 24)
                                                       // StudyID=0 - Object is Slide not linked to any Study
                                                       // StudyID>0 - Object is Slide linked to Study with ID=StudyID
                                                       // StudyID<0 - Object is Study, StudyID=-StudySampleID in Study Samples Lib
    K_CMENDBSTFSlideStudyIDInd: Integer;               // SlidesTable Study ID select field index
    K_CMENDBSTFSlideStudyItem : string = 'StudyItem';  // SlidesTable Field Name for Slide Study Item ID (DBVer >= 24)
    K_CMENDBSTFSlideStudyItemInd: Integer;             // SlidesTable Study Item ID select field index
    K_CMENDBSTFSlideStudyItemPos : string = 'StudyItemPos';// SlidesTable Field Name for Slide Study Item Pos for Study Capture Start position (DBVer >= 39)
    K_CMENDBSTFSlideStudyItemPosInd: Integer;              // SlidesTable Study Item Pos select field index
    K_CMENDBSTFSlideDFlags         : string = 'DFlags';    // SlidesTable Field Name for Slide DICOM Flags Set (DBVer >= 44)
    K_CMENDBSTFSlideDFlagsInd      : Integer;              // SlidesTable Slide DICOM Flags Set field index
    K_CMENDBSTFSlideDCMSerID       : string = 'DCMSerID';  // SlidesTable Field Name for Slide DICOM Series (DBVer >= 46)
    K_CMENDBSTFSlideDCMSerIDInd    : Integer;              // SlidesTable Slide DICOM Series Set field index

{*}    K_CMENDBSTFSlideCurImg    : string = 'CurImg';     // SlidesTable Field Name for Slide Current Image
{*}    K_CMENDBSTFSlideSrcImg    : string = 'SrcImg';     // SlidesTable Field Name for Slide Original Image

//  Have to be deleted
    K_CMENDBSTFSlideAttrs     : string = ''; // Have to be deleted

//*** Media Types Table Info
  K_CMENDBMTypesTable    : string = 'AllMTypes';// Media Types Table Name
    K_CMENDBMTFMTypeID   : string = 'MTID';     // MTypesTable and SlidesTable Field Name for Media Type ID
    K_CMENDBMTFMTypeTitle: string = 'MTTitle';  // MTypesTable Field Name for Media Type Title

//*** Providers Contexts Table Info
  K_CMENDBContextsTable  : string = 'AppContexts';// Apllication Contexts Table Name
    K_CMENDBCTFContTypeID: string = 'ContType';   // ContextsTable Field Name for Context Type
    K_CMENDBCTFContID    : string = 'ContID';     // ContextsTable Field Name for Context ID
    K_CMENDBCTFBinData   : string = 'BData';      // ContextsTable Field Name for Context Binary Data
    K_CMENDBCTFContID1   : string = 'ContID1';    // ContextsTable Field Name for additional Context ID (DB >= 22)

//*** Global Attributes Table Info (1 record table)
  K_CMENDBGlobAttrsTable  : string = 'GlobAttrs';  // Table with single Row for Global attributes values
    K_CMENDBGTFDBVersion  : string = 'DBVersion';  // GlobAttrsTable Field Name for DB Data Structure version
    K_CMENDBGTFImgFPath   : string = 'ImgFPath';   // GlobAttrsTable Field Name for Image Files Base Path
    K_CMENDBGTFMediaFPath : string = 'MediaFPath'; // GlobAttrsTable Field Name for Media Files Base Path
    K_CMENDBGTFNewFPath   : string = 'NewFPath';   // GlobAttrsTable Field Name for Moving Files New Base Path
    K_CMENDBGTFCopiedFNum : string = 'CopiedFNum'; // GlobAttrsTable Field Name for Moving Files Copied to New Location Number
    K_CMENDBGTFCopiedFSize: string = 'CopiedFSize';// GlobAttrsTable Field Name for Moving Files Copied to New Location Size
    K_CMENDBGTFNewFProvID : string = 'NewFProvID'; // GlobAttrsTable Field Name for Moving Files Provider ID
    K_CMENDBGTFSSStartTS  : string = 'SyncSessionStartTS'; // GlobAttrsTable Field Name for Sync Session Start Timestamp
    K_CMENDBGTFSSFinTS    : string = 'SyncSessionFinTS';   // GlobAttrsTable Field Name for Sync Session Finish Timestamp
    K_CMENDBGTFSSState    : string = 'SyncSessionState';   // GlobAttrsTable Field Name for Sync Session State (=0 - wait, =1 - copy File)
    K_CMENDBGTFSSFlags    : string = 'SyncSessionFlags';   // GlobAttrsTable Field Name for Sync Session Flags Set
    K_CMENDBGTFDBFlags    : string = 'DBFlags';            // GlobAttrsTable Field Name for DB Flags Set
                                                           // Bit0 (001) - Enterpise Mode Flag
                                                           // Bit1 (002) - Client Computer Virtual Name is build by IP Address Flag (DB >= 19) !!! not used now
                                                           // Bit2 (004) - Use Client Online Registration !!! for future
                                                           // Bit3 (008) - DB recovery mode flags
    K_CMENDBGTFCodePage      : string = 'CodePage';        // GlobAttrsTable Field Name for Code Page
    K_CMENDBGTFMaintenanceTS : string = 'MaintenanceTS';   // GlobAttrsTable Field Name for Maintenance Last TimeStamp
    K_CMENDBGTFMaintenanceErr: string = 'MaintenanceErr';  // GlobAttrsTable Field Name for Maintenance Errors Count:
                                                           //    =0    - means Maintenance was finished
                                                           //   <> 0  - means Maintenance was not finished: -1 - no errors were detected, or number of detected errors
//-    K_CMENDBGTFStatInfo   : string = 'StatInfo';   // GlobAttrsTable Field Name for Running Statistics Info
//-    K_CMENDBGTFRegInfo    : string = 'RegInfo';    // GlobAttrsTable Field Name for Licensing Key Info after Registration
//-    K_CMENDBGTFBlobBuf    : string = 'BlobBuf';    // GlobAttrsTable Field Name for Blob Buffer for Image Files exchange
    K_CMENDBGTFSAFlags        : string = 'SAFlags';       // GlobAttrsTable Field Name for Stand Alone Flags  (DB >= 19)
                                                          // Bit0-1 (003) - CMS Stand alone Mode:
                                                          //  0 - Independed mode
                                                          //  1 - Hybrid mode
                                                          //  2 - Link mode
                                                          // Bit2   (004) - CMS Stand alone should use individual Provider Authorities Flag
    K_CMENDBGTFSACAuthorities : string = 'SACAuthorities';// GlobAttrsTable Field Name for Stand alone Common Authorities (DB >= 19)
    K_CMENDBGTFDPContType     : string = 'DPContType';    // GlobAttrsTable Field Name for Devide Profiles Context storing type (DB >= 19)
                                                          //  =0 - old context type - computer (server) specific
                                                          //  =1 - specific for each Server
                                                          //  =2 - specific for each Location
                                                          //  =3 - specific for each Client Name
                                                          //  =4 - specific for each Client IP Address
                                                          //  =5 - specific for each Provider
                                                          //  =6 - ñîmmîn for all clients (??)
                                                          //
    K_CMENDBGTFLogFilesPath   : string = 'LogFilesPath';  // GlobAttrsTable Field Name for Log Files special path (DB >= 19)
//    K_CMENDBGTFLastExportCount: string = 'LastExportCount';// GlobAttrsTable Field Name for Last Export Counter (DB >= 21)
    K_CMENDBGTFLinkCLMode     : string = 'LinkCLMode';    // GlobAttrsTable Field Name for Link Command Line Format Mode  (DB >= 21)
                                                          //  =0 - None format is defined
                                                          //  =1 - VW
                                                          //  =2 - Ini
                                                          //  =3 - User Defined
                                                          //  =4 - CL2000
    K_CMENDBGTFLinkCLUDFormat : string = 'LinkCLUDFormat';// GlobAttrsTable Field Name for Link Command User Defined Format  (DB >= 21)
    K_CMENDBGTFFixStudyDate   : string = 'FixStudyDate';  // GlobAttrsTable Field Name for Fixing Study Data Remind Date  (DB >= 27)
//    K_CMENDBGTFDBUID          : string = 'DBUID';         // GlobAttrsTable Field Name for DICOM UIDs creation (DB >= 29)
    K_CMENDBGTFImg3DFPath     : string = 'Img3DFPath';    // GlobAttrsTable Field Name for 3D Image Files Base Path (DB >= 34)
    K_CMENDBGTFInitInfo       : string = 'InitInfo';      // GlobAttrsTable Field Name for Initial Info Base Path (DB >= 37)
//    K_CMENDBGTFDBAPSW         : string = 'DBAPSW';        // GlobAttrsTable Field Name for DBAPSW(DB >= 47)

//*** Active Application Instances Table
  K_CMENDBAAInstsTable: string = 'ActAppInstances';// Active Application Instances Data Table
    K_CMENDBAAInstsTFActRTID  : string = 'ActRTID';  // Active Application Instances Table Field Name for Instance runtime ID
    K_CMENDBAAInstsTFActTS    : string = 'ActTS';    // Active Application Instances Table Field Name for Activity Timestamp
    K_CMENDBAAInstsTFActTSUID : string = 'ActTSUID'; // Active Application Instances Table Field Name for Instance TimeStamp Uniq ID
    K_CMENDBAAInstsTFGlobID   : string = 'AppGlobID';// Active Application Instances Table Field Name for Instance Global ID
    K_CMENDBAAInstsTFPatID    : string = 'PatID';    // Active Application Instances Table Field Name for Patient ID
    K_CMENDBAAInstsTFProvID   : string = 'ProvID';   // Active Application Instances Table Field Name for Provider ID
    K_CMENDBAAInstsTFLocID    : string = 'LocID';    // Active Application Instances Table Field Name for Location ID
    K_CMENDBAAInstsTFActFlags : string = 'ActFlags'; // Active Application Instances Table Field Name for Instance Flags
                                                     // Field is used in cms_LockActMode stored procedure
                                                     //   Bit0 (001) - Session Global Administrator Mode (single session should be in this mode)
                                                     //   Bit1 (002) - Session DB Maintenance Mode       (single session should be in this mode)
                                                     //   Bit2 (004) - Session DB Resample Large Images Mode (single session should be in this mode)
                                                     //   Bit6 (064) - Session Stand alone mode          (many sessions may be in this mode) (!!! may be not needed)
                                                     //   Bit7 (128) - Session in not active mode, it resources should not be free by active control (many sessions may be in this mode)
    K_CMENDBAAInstsTFServID   : string = 'ServID';   // Active Sessions Data Table Field Name for Session Server ID (DB >= 19)

//*** Active Patients CopyMove Table (DB >= 28)
  K_CMENDBACMPDataTable: string = 'ActCopyMovePatData'; // Active Patients Copy/Move Data Table
    K_CMENDBACMPDataTFCMPActID   : string = 'CMPActID'; // Active Patients Copy/Move Table Field Name for process ID
    K_CMENDBACMPDataTFCMPatSID   : string = 'CMPatSID'; // Active Patients Copy/Move Table Field Name for Src  Patient ID
    K_CMENDBACMPDataTFCMPatDID   : string = 'CMPatDID'; // Active Patients Copy/Move Table Field Name for Dest Patient ID
    K_CMENDBACMPDataTFCMPState   : string = 'CMPState'; // Active Patients Copy/Move Table Field Name for Process State (phase)
                                                        // 0 - copy is started
                                                        // 1 - move is started
                                                        // 2 - DB records are copied
                                                        // 3 - DB records are moved
                                                        // 4 - File are copied to destination for move (delete source files phase is not done)
    K_CMENDBACMPDataTFCMPActRTID : string = 'CMPActRTID';// Active Patients Copy/Move Table Field Name for Active Instance runtime ID
                                                        //  = 0 - process is waiting for resume
                                                        // <> 0 - process is doing by some Active Instance

//*** Application Global Instances Table
  K_CMENDBGAInstsTable: string = 'GlobAppInstances';// Application Instances Global Data Table
    K_CMENDBGAInstsTFGlobID : string = 'AppGlobID';  // Application Instances Table Field Name for Instance Global ID
    K_CMENDBGAInstsTFLocalID: string = 'AppLocalID'; // Application Instances Table Field Name for Instance Local ID
    K_CMENDBGAInstsTFCName  : string = 'CompName';   // Application Instances Table Field Name for Instance ComputerName
//-    K_CMENDBGAInstsTFStat   : string = 'StatInfo';   // Application Instances Table Field Name for Running Statistics Info

//*** Lock Slides Table
  K_CMENDBLockSlidesTable: string = 'LockedSlides'; // Application Locked Slides Data Table
    K_CMENDBLSlidesTFSlideID   : string = 'SlideID';  // Application Locked Slides Table Field Name for Slide ID
                                                      // Should be equal to K_CMENDBSTFSlideID
    K_CMENDBLSlidesTFActRTID   : string = 'ActRTID';  // Application Locked Slides Table Field Name for Instance runtime ID
    K_CMENDBLSlidesTFLockFlag  : string = 'LockFlag'; // Application Locked Slides Table Field Name for Lock Flag = Ord(TK_CMEDLockState)
    K_CMENDBLSlidesTFFLockFlag : string = 'LockFileFlag'; // Application Locked Slides Table Field Name for File Lock Flag = Ord(TK_CMEDLockFileState)

//*** Media File Uniq ID Table   !!! not used now
  K_CMENDBMediaUniqIDTable: string = 'MediaUniqID'; // Media File Uniq ID Table
    K_CMENDBMUIDTFID    : string = 'ID';   // Media File Uniq ID Table Field Name for Media ID
    K_CMENDBMUIDTFDData : string = 'DData';// Media File Uniq ID Table Field Name for Dummy Data

//*** Slides History Table
  K_CMENDBSlidesHistTable: string = 'AllSlidesHistory'; // Slides History Table
    K_CMENDBSlidesHTFSlideID : string = 'SlideID';// Slides History Table Field Name for Slide ID
                                                  // Should be equal to K_CMENDBSTFSlideID
    K_CMENDBSlidesHTFProvID  : string = 'ProvID'; // Slides History Table Field Name for Provider ID
    K_CMENDBSlidesHTFActID   : string = 'ActID';  // Slides History Table Field Name for Action ID
    K_CMENDBSlidesHTFActTS   : string = 'ActTS';  // Slides History Table Field Name for Action Timestamp

//*** Slides New History Table
  K_CMENDBSlidesNewHistTable: string = 'AllSlidesHistory1'; // Slides New History Table
    K_CMENDBSlidesNHTFSlideID  : string = 'AHSlideID';  // Slides New History Table Field Name for Slide ID
    K_CMENDBSlidesNHTFSessionID: string = 'AHSessionID';// Slides New History Table Field Name for Session ID
    K_CMENDBSlidesNHTFActCode  : string = 'AHActCode';  // Slides New History Table Field Name for Action Code
    K_CMENDBSlidesNHTFActTS    : string = 'AHActTS';    // Slides New History Table Field Name for Action Timestamp

//*** Sesions History Table
  K_CMENDBSessionsHistTable: string = 'AllSessionsHistory'; // Sessions History Table
    K_CMENDBSessionsHTFSessionID: string = 'AHSessionID';// Sessions  History Table Field Name for Session ID
    K_CMENDBSessionsHTFPatID    : string = 'AHPatID';    // Sessions  History Table Field Name for Patient ID
    K_CMENDBSessionsHTFProvID   : string = 'AHProvID';   // Sessions  History Table Field Name for Provider ID
    K_CMENDBSessionsHTFLocID    : string = 'AHLocID';    // Sessions  History Table Field Name for Location ID
    K_CMENDBSessionsHTFCompID   : string = 'AHCompID';   // Sessions  History Table Field Name for Computer ID (Application Global ID)
    K_CMENDBSessionsHTFServID   : string = 'AHServID';   // Sessions  History Table Field Name for Server ID
    K_CMENDBSessionsHTFFlags    : string = 'AHFlags';    // Sessions  History Table Field Name for Flags DB >= 19
                                                         //   Bit0 (001) - Session Stand alone mode
    K_CMENDBSessionsHTFDCMSTUID : string = 'AHDCMSTUID'; // Sessions  History Table Field Name for D4W DICOM Study UID DB >= 44


//*** Import History Table
  K_CMENDBImportHistTable: string = 'ImportHistory'; // Slides History Table
    K_CMENDBImportHTFID   : string = 'ImpId';   // Import History Table Field Name for Import ID
    K_CMENDBImportHTFDate : string = 'ImpDate'; // Import History Table Field Name for Import Date
    K_CMENDBImportHTFInfo : string = 'ImpInfo'; // Import History Table Field Name for Import Slides Info

//*** Locations File Access Contexts Table
  K_CMENDBLocsFAccessTable: string = 'AllLocsFileAccess'; // Locations File Access Table
    K_CMENDBLFALocID            : string = 'LocID';            // Locations File Access Table Field Name for Loction ID
    K_CMENDBLFALocFlags         : string = 'LocFlags';         // Locations File Access Table Field Name for Loction Flags Set
    K_CMENDBLFALocImgFPath      : string = 'LocImgFPath';      // Locations File Access Table Field Name for Loction Image Files Internal Base Path
    K_CMENDBLFALocImgExtFPath   : string = 'LocImgExtFPath';   // Locations File Access Table Field Name for Loction Image Files External Base Path
    K_CMENDBLFALocVideoFPath    : string = 'LocVideoFPath';    // Locations File Access Table Field Name for Loction Video Files Internal Base Path
    K_CMENDBLFALocVideoExtFPath : string = 'LocVideoExtFPath'; // Locations File Access Table Field Name for Loction Video Files External Base Path
    K_CMENDBLFALocNewFPath      : string = 'LocNewFPath';      // Locations File Access Table Field Name for for Moving Files New Base Path
    K_CMENDBLFALocNewFCopiedNum : string = 'LocNewFCopiedNum'; // Locations File Access Table Field Name for for Moving Files Copied to New Location Number
    K_CMENDBLFALocNewFCopiedSize: string = 'LocNewFCopiedSize';// Locations File Access Table Field Name for for Moving Files Copied to New Location Size
    K_CMENDBLFALocNewFProvID    : string = 'LocNewFProvID';    // Locations File Access Table Field Name for for Moving Files Provider ID

//*** Locations Slides Files State Table
  K_CMENDBLocFilesInfoTable: string = 'AllLocFilesInfo'; // Locations Slides Files State Table
    K_CMENDBLFILocID         : string = 'LocID';     // Locations Slides Files State Table Field Name for Loction ID
    K_CMENDBLFILocSlideID    : string = 'SlideID';   // Locations Slides Files State Table Field Name for Loction Slide ID
                                                     // Should be equal to K_CMENDBSTFSlideID
    K_CMENDBLFILocSlideTS    : string = 'FileTS';    // Locations Slides Files State Table Field Name for Loction Slide Current File Time Stamp
    K_CMENDBLFILocSlideFlags : string = 'FileFlags'; // Locations Slides Files State Table Field Name for Loction Slide Files Flags Set

//*** Slides Files Synchronization Query Table
  K_CMENDBSyncFilesQueryTable: string = 'SyncFilesQuery'; // Files Synchronization Query Table
    K_CMENDBSFQElemID    : string = 'SFQElemID';    // Files Synchronization Query Table Field Name for Query Element ID
    K_CMENDBSFQFlags     : string = 'SFQFlags';     // Files Synchronization Query Table Field Name for Query Element Flags Set
    K_CMENDBSFQPatID     : string = 'SFQPatID';     // Files Synchronization Query Table Field Name for Patient ID
    K_CMENDBSFQSlideID   : string = 'SFQSlideID';   // Files Synchronization Query Table Field Name for Slide ID
    K_CMENDBSFQDstLocID  : string = 'SFQDstLocID';  // Files Synchronization Query Table Field Name for Destination Location ID
    K_CMENDBSFQTS        : string = 'SFQTS';        // Files Synchronization Query Table Field Name for Synchronization Resulting Timestamp
    K_CMENDBSFQPriority  : string = 'SFQPriority';  // Files Synchronization Query Table Field Name for Query Element Priority
    K_CMENDBSFQSTS       : string = 'SFQSTS';       // Files Synchronization Query Table Field Name for Synchronization add to Query Timestamp
    K_CMENDBSFQAppGID    : string = 'SFQAppGID';    // Files Synchronization Query Table Field Name for Source Application ID
    K_CMENDBSFQProvID    : string = 'SFQProvID';    // Files Synchronization Query Table Field Name for Source Provider ID

//*** Slides Files Synchronization History Table
  K_CMENDBSyncFilesHistTable: string = 'SyncFilesHistory'; // Files Synchronization History Table
    K_CMENDBSFHQElemID : string = 'SFHQElemID'; // Files Synchronization Histiry Table Field Name for Query Element ID
    K_CMENDBSFHSlideID : string = 'SFHSlideID'; // Files Synchronization Histiry Table Field Name for Slide ID
    K_CMENDBSFHDstLocID: string = 'SFHDstLocID';// Files Synchronization Histiry Table Field Name for Destination Location ID
    K_CMENDBSFHSrcLocID: string = 'SFHSrcLocID';// Files Synchronization Histiry Table Field Name for Source Location ID
    K_CMENDBSFHFlags   : string = 'SFHFlags';   // Files Synchronization Histiry Table Field Name for Record Flags Set
    K_CMENDBSFHFSize   : string = 'SFHFSize';   // Files Synchronization Histiry Table Field Name for Transfered File Size in bytes
    K_CMENDBSFHSTS     : string = 'SFHSTS';     // Files Synchronization Histiry Table Field Name for Start File Transfer Timestamp
    K_CMENDBSFHFTMSec  : string = 'SFHFTMSec';  // Files Synchronization Histiry Table Field Name for File Transfer Time in milliseconds

//*** Slides Files Synchronization Query History Table
  K_CMENDBSyncFilesQueryHistTable: string = 'SyncFilesQueryHistory'; // Files Synchronization Query History Table
    K_CMENDBSFQHElemID    : string = 'SFQHElemID';    // Files Synchronization Query Histiry Table Field Name for Query Element ID
    K_CMENDBSFQHFlags     : string = 'SFQHFlags';     // Files Synchronization Query Histiry Table Field Name for Query Element Flags Set
    K_CMENDBSFQHPatID     : string = 'SFQHPatID';     // Files Synchronization Query Histiry Table Field Name for Patient ID
    K_CMENDBSFQHSlideID   : string = 'SFQHSlideID';   // Files Synchronization Query Histiry Table Field Name for Slide ID
    K_CMENDBSFQHDstLocID  : string = 'SFQHDstLocID';  // Files Synchronization Query Histiry Table Field Name for Destination Location ID
    K_CMENDBSFQHTS        : string = 'SFQHTS';        // Files Synchronization Query Histiry Table Field Name for Synchronization Resulting Timestamp
    K_CMENDBSFQHPriority  : string = 'SFQHPriority';  // Files Synchronization Query Histiry Table Field Name for Query Element Priority
    K_CMENDBSFQHSTS       : string = 'SFQHSTS';       // Files Synchronization Query Histiry Table Field Name for Synchronization add to Query Timestamp
    K_CMENDBSFQHAppGID    : string = 'SFQHAppGID';    // Files Synchronization Query Histiry Table Field Name for Source Application ID
    K_CMENDBSFQHProvID    : string = 'SFQHProvID';    // Files Synchronization Query Histiry Table Field Name for Source Provider ID

//*** History Patient Captions Table
  K_CMENDBAllHistPatientsTable: string = 'AllHistPatients'; // History Patient Captions Table
    K_CMENDAHPatID   : string = 'AHPatID';   // History Patient Captions Table Field Name for Patient ID
    K_CMENDAHPatCN   : string = 'AHPatCN';   // History Patient Captions Table Field Name for Patient Card Number
    K_CMENDAHPatCapt : string = 'AHPatCapt'; // History Patient Captions Table Field Name for Patient Caption

//*** History Provider Captions Table
  K_CMENDBAllHistProvidersTable: string = 'AllHistProviders'; // History Provider Captions Table
    K_CMENDAHProvID   : string = 'AHProvID';   // History Provider Captions Table Field Name for Provider ID
    K_CMENDAHProvCapt : string = 'AHProvCapt'; // History Provider Captions Table Field Name for Provider Caption

//*** History Location Captions Table
  K_CMENDBAllHistLocationsTable: string = 'AllHistLocations'; // History Location Captions Table
    K_CMENDAHLocID   : string = 'AHLocID';   // History Location Captions Table Field Name for Location ID
    K_CMENDAHLocCapt : string = 'AHLocCapt'; // History Location Captions Table Field Name for Location Caption

//*** Mark as Deleted Slides Table Table
  K_CMENDBDelMarkedSlidesTable: string = 'DelMarkedSlides'; // Marked as Deleted Slides Table
    K_CMENDMSlideID : string = 'SlideID'; // Marked as Deleted Slides Table Field Name for Slide ID
                                          // should be equal to K_CMENDBSTFSlideID
    K_CMENDMTS      : string = 'DMTS';    // Marked as Deleted Slides Table Field Name for Mark Timestamp

//*** Customer Info Table Info (DB >= 16)
  K_CMENDBCustomerInfoTable    : string = 'CustomerInfo';// Customer Info Table Name
    K_CMENDBCITitle   : string = 'CIVIPUserName'; // CustomerInfo Table Field Name for Customer Title

//*** All Servers Table (DB >= 19)
  K_CMENDBAllServersTable: string = 'AllServers'; // All Servers Table
    K_CMENDASServID   : string = 'AServID';   // All Servers Table Field Name for Server ID
    K_CMENDASServName : string = 'AServName'; // All Servers Table Field Name for Server Name

//*** All CMS stand alone Patients Table
  K_CMENDBAllPatientsTable: string = 'AllPatients'; // All Patients Table
    K_CMENDAPID        : string = 'APID';       // All Patients Table Field Name for Patient ID
    K_CMENDAPBridgeID  : string = 'APBridgeID'; // All Patients Table Field Name for Patient Bridge ID
    K_CMENDAPTitle     : string = 'APTitle';    // All Patients Table Field Name for Patient Title
    K_CMENDAPGender    : string = 'APGender';   // All Patients Table Field Name for Patient Gender
    K_CMENDAPCardNum   : string = 'APCardNum';  // All Patients Table Field Name for Patient Card Number
    K_CMENDAPSurname   : string = 'APSurname';  // All Patients Table Field Name for Patient Surname
    K_CMENDAPFirstname : string = 'APFirstname';// All Patients Table Field Name for Patient First Name
    K_CMENDAPMiddle    : string = 'APMiddle';   // All Patients Table Field Name for Patient Middle Name
    K_CMENDAPDOB       : string = 'APDOB';      // All Patients Table Field Name for Patient DOB
    K_CMENDAPProvID    : string = 'APProvID';   // All Patients Table Field Name for Patient Personal Provider ID
    K_CMENDAPAddr1     : string = 'APAddr1';    // All Patients Table Field Name for Patient Address 1
    K_CMENDAPAddr2     : string = 'APAddr2';    // All Patients Table Field Name for Patient Address 2
    K_CMENDAPSuburb    : string = 'APSuburb';   // All Patients Table Field Name for Patient Suburb
    K_CMENDAPPostCode  : string = 'APPostCode'; // All Patients Table Field Name for Patient Post Code
    K_CMENDAPState     : string = 'APState';    // All Patients Table Field Name for Patient State
    K_CMENDAPPhone1    : string = 'APPhone1';   // All Patients Table Field Name for Patient Phone 1
    K_CMENDAPPhone2    : string = 'APPhone2';   // All Patients Table Field Name for Patient Phone 2
    K_CMENDAPFlags     : string = 'APFlags';    // All Patients Table Field Name for Patient Contol Flags
                                                //  Bit0 (001) - Patient is marked as deleted
                                                //  Bit1 (002) - Patient is deleting
    K_CMENDAPActRTID   : string = 'APActRTID';  // All Patients Table Field Name for Instance runtime ID
    K_CMENDAPExpFlags  : string = 'APExpFlags'; // All Patients Table Field Name for Export Control Flags ID (DB >= 22)
                                                //   Bit0 (001) - Patient is marked as exported

//*** All CMS stand alone Providers/Users Table
  K_CMENDBAllProvidersTable: string = 'AllProviders'; // All Providers/Users Table
    K_CMENDAUID         : string = 'AUID';         // All Providers Table Field Name for Provider ID
    K_CMENDAUBridgeID   : string = 'AUBridgeID';   // All Providers Table Field Name for Provider Bridge ID
    K_CMENDAUTitle      : string = 'AUTitle';      // All Providers Table Field Name for Provider Title
    K_CMENDAUSurname    : string = 'AUSurname';    // All Providers Table Field Name for Provider Surname
    K_CMENDAUFirstname  : string = 'AUFirstname';  // All Providers Table Field Name for Provider First Name
    K_CMENDAUMiddle     : string = 'AUMiddle';     // All Providers Table Field Name for Provider Middle Name
    K_CMENDAUAuthorities: string = 'AUAuthorities';// All Providers Table Field Name for Provider DOB
    K_CMENDAUFlags      : string = 'AUFlags';      // All Providers Table Field Name for Provider Contol Flags
                                                   //   Bit0 (001) - Provider is marked as deleted
    K_CMENDAUActRTID    : string = 'AUActRTID';    // All Providers Table Field Name for Instance runtime ID
    K_CMENDAUExpFlags   : string = 'AUExpFlags';   // All Providers Table Field Name for Export Control Flags ID (DB >= 22)
                                                   //   Bit0 (001) - Provider is marked as exported
    K_CMENDAUEncLP      : string = 'AUEncLP';      // All Providers Table Field Name for Encoded Login/Password (DB >= 31)

//*** All CMS stand alone Locations Table
  K_CMENDBAllLocationsTable: string = 'AllLocations'; // All Location Table
    K_CMENDALID       : string = 'ALID';         // All Locations Table Field Name for Location ID
    K_CMENDALBridgeID : string = 'ALBridgeID';   // All Locations Table Field Name for Location Bridge ID
    K_CMENDALName     : string = 'ALName';       // All Locations Table Field Name for Location Name
    K_CMENDALFlags    : string = 'ALFlags';      // All Locations Table Field Name for Location Contol Flags
                                                 //   Bit0 (001) - Location is marked as deleted
    K_CMENDALActRTID  : string = 'ALActRTID';    // All Locations Table Field Name for Instance runtime ID
    K_CMENDALExpFlags : string = 'ALExpFlags';   // All Locations Table Field Name for Export Control Flags ID (DB >= 22)
                                                 //   Bit0 (001) - Location is marked as exported
    K_CMENDALCustRefN : string = 'ALCustRefN';   // All Locations Table Field Name for Custom Reference #(DB >= 33)

///// DB >= 20
//*** Deleted Patients Card Numbers
  K_CMENDBDelPatCardNumsTable: string = 'DelPatCardNums'; // Deleted Patients Card Numbers Table
    K_CMENDDPCardNum : string = 'APCardNum';   // Deleted Patients Card Numbers Table Field Name for Card Number

///// DB >= 21
//*** CMS stand alone Patients Import Table
  K_CMENDBImportPatientsTable: string = 'ImportPatients'; // All Patients Table
    K_CMENDIPID        : string = 'IPID';       // Import Patients Table Field Name for Patient ID
    K_CMENDIPTitle     : string = 'IPTitle';    // Import Patients Table Field Name for Patient Title
    K_CMENDIPGender    : string = 'IPGender';   // Import Patients Table Field Name for Patient Gender
    K_CMENDIPCardNum   : string = 'IPCardNum';  // Import Patients Table Field Name for Patient Card Number
    K_CMENDIPSurname   : string = 'IPSurname';  // Import Patients Table Field Name for Patient Surname
    K_CMENDIPFirstname : string = 'IPFirstname';// Import Patients Table Field Name for Patient First Name
    K_CMENDIPMiddle    : string = 'IPMiddle';   // Import Patients Table Field Name for Patient Middle Name
    K_CMENDIPDOB       : string = 'IPDOB';      // Import Patients Table Field Name for Patient DOB
    K_CMENDIPProvID    : string = 'IPProvID';   // Import Patients Table Field Name for Patient Personal Provider ID
    K_CMENDIPAddr1     : string = 'IPAddr1';    // Import Patients Table Field Name for Patient Address 1
    K_CMENDIPAddr2     : string = 'IPAddr2';    // Import Patients Table Field Name for Patient Address 2
    K_CMENDIPSuburb    : string = 'IPSuburb';   // Import Patients Table Field Name for Patient Suburb
    K_CMENDIPPostCode  : string = 'IPPostCode'; // Import Patients Table Field Name for Patient Post Code
    K_CMENDIPState     : string = 'IPState';    // Import Patients Table Field Name for Patient State
    K_CMENDIPPhone1    : string = 'IPPhone1';   // Import Patients Table Field Name for Patient Phone 1
    K_CMENDIPPhone2    : string = 'IPPhone2';   // Import Patients Table Field Name for Patient Phone 2
    K_CMENDIPMarker    : string = 'IPMarker';   // Import Patients Table Field Name for Patient Import Marker

//*** CMS stand alone Providers/Users Import Table
  K_CMENDBImportProvidersTable: string = 'ImportProviders'; // Import Providers/Users Table
    K_CMENDIUID         : string = 'IUID';         // Import  Providers Table Field Name for Provider ID
    K_CMENDIUTitle      : string = 'IUTitle';      // Import  Providers Table Field Name for Provider Title
    K_CMENDIUSurname    : string = 'IUSurname';    // Import  Providers Table Field Name for Provider Surname
    K_CMENDIUFirstname  : string = 'IUFirstname';  // Import  Providers Table Field Name for Provider First Name
    K_CMENDIUMiddle     : string = 'IUMiddle';     // Import  Providers Table Field Name for Provider Middle Name
    K_CMENDIUAuthorities: string = 'IUAuthorities';// Import  Providers Table Field Name for Provider DOB
    K_CMENDIUMarker     : string = 'IUMarker';      // Import Providers Table Field Name for Provider Import Marker

//*** CMS stand alone Locations Import Table
  K_CMENDBImportLocationsTable: string = 'ImportLocations'; // Import Location Table
    K_CMENDILID       : string = 'ILID';         // Import Locations Table Field Name for Location ID
    K_CMENDILName     : string = 'ILName';       // Import Locations Table Field Name for Location Name
    K_CMENDILMarker   : string = 'ILMarker';     // Import Providers Table Field Name for Provider Import Marker
    K_CMENDILCustRefN : string = 'ILCustRefN';   // Import Locations Table Field Name for Custom Reference #(DB >= 33)

//*** CMS stand alone Link IDs Import Table
  K_CMENDBImportLinkIDsTable: string = 'ImportLinkIDs'; // Import Link IDs Table
    K_CMENDILIOldID     : string = 'IOldID';       // Import Link IDs Table Field Name for Old ID
    K_CMENDILINewID     : string = 'INewID';       // Import Link IDs Table Field Name for New ID

//*** CMS auto upgrade support Table (DB >= 29)
  K_CMENDBUpgradeSupportTable: string = 'support_upgrade'; // auto upgrade support Table
    K_CMENDUpgradeTypeID   : string = 'type_upgrade';   // upgrade support Table Field Name for upgrade type
    K_CMENDUpgradeBridgeID : string = 'upgrade_bridge'; // upgrade support Table Field Name for upgrade bridge

//*** CMS All Device Profiles Type Table (DB >= 32)
  K_CMENDBAllDevProfileTypesTable: string = 'AllDevProfileTypes'; // All Device Profile Types Table
    K_CMENDADPTDI   : string = 'ADPTID';   // All Device Profiles Type Table Field Name for Type ID
    K_CMENDADPTName : string = 'ADPTName'; // All Device Profiles Type Table Field Name for Type Name

//*** CMS All Device Profiles Use Table (DB >= 32)
  K_CMENDBActInstDevProfilesTable: string = 'ActInstDevProfiles'; // Active Appication Instances Device Profiles Table
    K_CMENDAInstRTID     : string = 'AInstRTID';     // Active Appication Instances Device Profiles Table Field Name for Instance Runtime ID
    K_CMENDAInstDevTID   : string = 'AInstDevTID';   // Active Appication Instances Device Profiles Table Field Name for Device Type ID
    K_CMENDAInstDevCount : string = 'AInstDevCount'; // Active Appication Instances Device Profiles Table Field Name for Device Count

//*** CMS All Study Templates Table (DB >= 40)
  K_CMENDBAllStudyTemplatesTable: string = 'AllStudyTemplates'; //  All Study Templates Table
    K_CMENDASTempID     : string = 'ASTID';    // All Study Templates Table Field Name for Study Template ID
    K_CMENDASTempDescr  : string = 'ASTDescr'; // All Study Templates Table Field Name for Study Template Description

//*** CMS Device Plates Total Use Table (DB >= 42)
  K_CMENDBDevicePlatesTotalUseTable: string = 'DevicePlatesTotalUse'; //  Device Plates Total Use Table
    K_CMENDDPTID    : string = 'DPTID';   // Device Plates Total Use Table Field Name for Plate ID
    K_CMENDDPTName  : string = 'DPTName'; // Device Plates Total Use Table Field Name for Plate Name
    K_CMENDDPTCount : string = 'DPTCount';// Device Plates Total Use Table Field Name for Plate Use Counter

//*** CMS Device Plates Client Use Table (DB >= 42)
  K_CMENDBDevicePlatesClientUseTable: string = 'DevicePlatesClientUse'; //  Device Plates Client Use Table
    K_CMENDDPCID    : string = 'DPCID';   // Device Plates Client Use Table Field Name for Plate ID
    K_CMENDDPCClientID : string = 'DPCClientID'; // Device Plates Client Use Table Field Name for Client ID
    K_CMENDDPCUpdateDT : string = 'DPCUpdateDT';// Device Plates Client Use Table Field Name for Plate Update TimeStamp

//*** CMS Device Plates Client Use Table (DB >= 44)
  K_CMENDBDCMSeriesTable: string = 'AllDCMSeries'; //  Device Plates Client Use Table
    K_CMENDDCMSRID : string = 'DCMSRID';   // Device Plates Client Use Table Field Name for Plate ID
    K_CMENDDCMSRDT : string = 'DCMSRDT'; // Device Plates Client Use Table Field Name for Client ID

//*** CMS DCM Commitment Queue Table (DB >= 45)
  K_CMENDBDCMComQueueTable: string = 'DCMComQueue'; //  DCM Commitment Queue Table
    K_CMENDDCMCQID   : string = 'DCMCQID';  // DCM Commitment Queue Table Field Name for Queue ID
    K_CMENDDCMCQDT   : string = 'DCMCQDT';  // DCM Commitment Queue Table Field Name for Send Time Stamp
    K_CMENDDCMCQSID  : string = 'DCMCQSID'; // DCM Commitment Queue Table Field Name for Slide ID
    K_CMENDDCMCQIUID : string = 'DCMCQIUID';// DCM Commitment Queue Table Field Name for SOPInstance UID
    K_CMENDDCMCQCUID : string = 'DCMCQCUID';// DCM Commitment Queue Table Field Name for SOPClass UID
    K_CMENDDCMCQTUID : string = 'DCMCQTUID';// DCM Commitment Queue Table Field Name for Transaction UID
    K_CMENDDCMCQW    : string = 'DCMCQW';   // DCM Commitment Queue Table Field Name for Wait Flag

//*** CMS DCM Retrieve Queue Table (DB >= 46)
  K_CMENDBDCMRQueueTable: string = 'DCMRQueue';// DCM Retrive Queue Table
    K_CMENDDCMRQID    : string = 'DCMRQID';     // DCM Retrive Queue Table Field Name for Queue ID
    K_CMENDDCMRQSPID  : string = 'DCMRQCMSPID'; // DCM Retrive Queue Table Field Name for CMSuite Patient ID
    K_CMENDDCMRQDPID  : string = 'DCMRQDCMPID'; // DCM Retrive Queue Table Field Name for DICOM Patient ID
    K_CMENDDCMRQSTUID : string = 'DCMRQSTUID';  // DCM Retrive Queue Table Field Name for Study UID
    K_CMENDDCMRQSEUID : string = 'DCMRQSEUID';  // DCM Retrive Queue Table Field Name for Series UID
{
}

// Auxiliary Data Texts Patterns
//LLL!!!  K_CMENPTAppTaskBar : string = 'Centaur Media Suite - (#PatientFirstName#) (#PatientSurname#)';
//LLL!!!  K_CMENPTAppTitleBar: string = 'Centaur Media Suite - Px:[(#PatientCardNumber#)] (#PatientFirstName#) (#PatientSurname#)     Prv: (#ProviderTitle#) (#ProviderFirstName#) (#ProviderSurname#)     Location: (#LocationID#) - (#LocationTitle#)';
//LLL!!!  K_CMENPTVIPCAppTitleBar: string = 'Centaur Media Suite Enterprise       (#VIPCTitle#) (#LocationTitle#)    Px:[(#PatientCardNumber#)] (#PatientFirstName#) (#PatientSurname#)    Prv: (#ProviderTitle#) (#ProviderFirstName#) (#ProviderSurname#)';
//LLL!!!  K_CMENPTLockPatAppTitleBar: string = 'Centaur Media Suite - Patient is locked';
//LLL!!!  K_CMENPTLockPatAppMessage: string = 'Px: (#PatientFirstName#) (#PatientSurname#)  is locked by     Prv: (#ProviderTitle#) (#ProviderFirstName#) (#ProviderSurname#)     Location: (#LocationTitle#)  Client: (#CLientCompVirtualID#)';

  K_CMENPTProviderProp: string = '(#ProviderFirstName#) (#ProviderSurname#)';
  K_CMENPTLocationProp: string = '(#LocationTitle#)';

//LLL!!!  K_CMENPTEmailSubject: string = 'Images/Media from (#ProviderTitle#) (#ProviderFirstName#) (#ProviderSurname#) (Px: (#PatientFirstName#) (#PatientSurname#))';
  K_CMENPTEmailAttachmentFName: string = '(#PatientSurname#)-(#PatientFirstName#)_(#DateTaken#)_(#Number#)';

  K_CMENPTExportFName: string = '(#PatientSurname#)-(#PatientFirstName#)-(#PatientCardNumber#)_(#DateTaken#)_(#SlideID#)';
//  K_CMENPTNExportAllPName: string = '(#PatientCardNumber#) (#PatientFirstName#) (#PatientSurname#)\';
  K_CMENPTNExportAllPName: string = '(#PatientFirstName#) (#PatientSurname#)\';
  K_CMENPTNExportPName: string = '(#PatientSurname#), (#PatientTitle#) (#PatientFirstName#) [(#PatientCardNumber#)]';
  K_CMENPTNExportFName: string = '(#DateTaken#)_(#SlideID#)';

{
 Export/Email file name pattern
(#PatientSurname#),  (#PatientTitle#) (#PatientFirstName#) [(#PatientCardNumber#)] DOB:(#Patient DOB#) Chart:(#TeethChartNums#) Taken:(#ObjDateTaken#)_(#ObjID#)
}
//LLL!!!    K_CMENPTPrintPatientDetails1: string = '(#PatientFirstName#) (#PatientSurname#) (ID: (#PatientCardNumber#))';
//LLL!!!    K_CMENPTPrintPatientDetails2: string = 'Gender:   (#PatientGender#)   DOB:  (#PatientDOB#)';

  K_CMENPTPrintProviderDetails : string = '(#ProviderTitle#)  (#ProviderFirstName#) (#ProviderSurname#) ((#LocationTitle#))';

//LLL!!!    K_CMENPTDelMTypePatientDetails: string = '(#PatientFirstName#) (#PatientSurname#) (ID: (#PatientCardNumber#))';

  K_CMENPTCommonLocationDetails : string = '(#LocationTitle#)';
  K_CMENPTCommonProviderDetails : string = '(#ProviderTitle#) (#ProviderFirstName#) (#ProviderSurname#)';
  K_CMENPTCommonPatientDetails  : string = '(#PatientFirstName#) (#PatientSurname#)';
  K_CMENPTCommonPatientDetails1 : string = '(#PatientFirstName#) (#PatientSurname#) [(#PatientCardNumber#)]';

  K_CMENPTDICOMPatientDetails1: string = '(#PatientFirstName#)^(#PatientSurname#)';
  K_CMENPTDICOMPatientDetails2: string = '(#PatientCardNumber#)';
  K_CMENPTDICOMPatientDetails3: string = '(#PatientDOB#)';

  K_CMENPTSAProviderDetails : string = '(#ProviderTitle#) (#ProviderFirstName#) (#ProviderSurname#)';

//*** end of CMS External data Names (CMEN) Varaibles

  K_CMEDSlideInitID : Integer = 10; // Slides start maximal ID
  K_CMEDMTypeInitID : Integer =  1; // MediaTypes start maximal ID
  K_CMEDMFileInitID : Integer = 10; // MediaFiles start maximal ID

type TK_CMSlidesSelectAttrs = record
  SSPatID : Integer; // Slides Patient ID
end;
type TK_PCMSlidesSelectAttrs = ^TK_CMSlidesSelectAttrs;

//**********************************************
// CM Archive Maximal IDs Array Indexes
//**********************************************
const
  K_CMAMIDSlideInd = 0; // Index of Slides Maximal ID in Archive GlobInfo Table
  K_CMAMIDMTypeInd = 1; // Index of MediaTypes Maximal ID in Archive GlobInfo Table
  K_CMAMIDMFileInd = 2; // Index of MediaFiles Maximal ID in Archive GlobInfo Table

//**********************************************
// CMS External Data Access Base Class
//**********************************************
type TK_CMEDResult = ( K_edOK, K_edFails, K_edImageFilesMoving, K_edExDataError,
                       K_edAbsentData, K_edExistedMediaType, K_edUsedMediaType,
                       K_edAbsentMediaType, K_edEFSyncProcStarted );
type TK_CMEDError = ( K_eeDBConnection, K_eeDBSelect, K_eeDBLock, K_eeDBUpdate,
                      K_eeDBDel, K_eeDBIns, K_eeDBFilter, K_eeDBEdit,
                      K_eeDBSetField, K_eeDBBlobWrite, K_eeDBBlobRead,
                      K_eeDBBatchUpdate, K_eeDBSetOption, K_eeDBBlobCompress,
                      K_eeDBBlobDecompress, K_eeFilesPocessing, K_eePathExists,
                      K_eePathCreate, K_eeFileExists, K_eeFileCorrupted );
type TK_CMEDSlidesSaveMode = ( K_cmesImmediately, K_cmesFinEdit, K_cmesTimer, K_cmesSetRebuild );
// only K_cmesImmediately, K_cmesFinEdit modes are realized

type TK_CMEDStateSaveMode  = ( K_cmetImmediately, K_cmetContextChange );
type TK_CMEDSaveStateFlags = set of (
// Skip Save Contexts Flags
          K_cmssSkipSlides, K_cmssSkipAllContexts, K_cmssSkipInstanceBinInfo,
          K_cmssSkipGlobalInfo,
          K_cmssSkipInstanceInfo, K_cmssSkipPatientInfo,
          K_cmssSkipProviderInfo, K_cmssSkipLocationInfo, K_cmssSkipExtIniInfo,
// Use Save Contexts Flags (needed to minimize code change while GlobalContext error correction)
          K_cmssSaveGlobal2Info );

type TK_CMEDLockResultMode = (
  K_cmlrmOpenLock,      // Lock for View
  K_cmlrmEditImgLock,   // Lock for ViewEdit object in Viewport
  K_cmlrmEditPropLock,  // Lock for ViewEdit object Properties
  K_cmlrmEditAllLock,   // Lock for ECache procesing
  K_cmlrmMarkAsDelLock, // Lock for Mark as Deleted procesing
  K_cmlrmUnDelLock,     // Lock for Undelete processing
  //  K_cmlrmExclusive,     // Lock for Patient All Slides Processing
  K_cmlrmDeleteLock,    // Lock for Slides Deletion
  K_cmlrmCheckFilesLock,// Lock for DB Files Integrity Check
  K_cmlrmDBRecoveryLock,// Lock for DB Recovery during Integrity Check
  K_cmlrmSaveOpenLock,  // Save Lock for View
  K_cmlrmEditStudyLock  // Lock Opened Study For Chaging
 );

type TK_CMEDLockState = ( K_cmlsUsed, K_cmlsLocked, K_cmlsLockedExclusive );
type TK_CMEDLockFileMode = ( K_cmlfFree, K_cmlfRead, K_cmlfWrite );


type TK_ChangeRootFolderContext = record
  RootFolder     : string;  // New Root Folder
  CopiedFNum     : Integer; // Copied Files Number
  CopiedFSize    : Int64;   // Copied Files Size
  RootFDA        : Boolean; // Direct Access to Files at New Root Folder from Client Computer
  SameFolder     : Boolean; // Source Folder is same as Destination Folder
  Img3DFCopy     : Boolean; // 3D Images Files Move to New Root Folder Flag
  MediaFCopy     : Boolean; // Media Files Move to New Root Folder Flag
  MediaFSplit    : Boolean; // Media Files Split at New Root Folder Flag
  MovingFSDDescr : Integer; // Moving Files Source and Destination description
                            // 0 - Server to Server
                            // 1 - Local  to Server
                            // 2 - Server to Local
                            // 3 - Local  to Local
  OpProvID       : Integer; // Operating Provider ID
  ChangePathStage: Integer; // Change files path Stage if Server Migration Mode
                            // 0 - not server migration mode
                            // 1 - Image files migration
                            // 2 - Video files migration
                            // 3 - 3D Image files migration mode
end;
type TK_PChangeRootFolderContext = ^TK_ChangeRootFolderContext;

type TK_Int64TeethFlags = packed record
  case Integer of
  0: ( IRight : Integer;   // Right Flags
       ILeft  : Integer;   // Left Flags
     );
  1: ( All : Int64; ); // Right + Left Flags
end;

type TK_CMEDBUStateFlags = set of ( // slide update state flags set
  K_dbusOldProps,   // DB User Properties Date is Older than current
  K_dbusOldMapRoot, // DB User MapRoot Date is Older than current
  K_dbusOldCurImg,  // DB User CurImg Date is Older than current
  K_dbusNewProps,   // DB User Properties Date is Newer than current
  K_dbusNewMapRoot, // DB User MapRoot Date is Newer than current
  K_dbusNewCurImg,  // DB User CurImg Date is Newer than current
  K_dbusECacheNew,  // ECahe Element is New Slide
  K_dbusECacheDel   // ECahe Element is Deleted Slide
);
type TK_CMEDBUSFArray = array of TK_CMEDBUStateFlags;

type TK_CMEDBLockState = packed record // Slide DB Locking Result State
  LSSrcInd    : Integer;             // Locked Slide Source Array Index
  LSUpdate    : TK_CMEDBUStateFlags; // Locked Slide Update State
  LSDTMod     : TDateTime;           // Locked Slide Modified Date (Maximal Date)
  LSProvIDMod : Integer;             // Locked Slide Provider ID that (last) Modifies Slide
  LSLocIDMod  : Integer;             // Locked Slide Location ID where Slide was Modified
  LSCompIDMod : string;              // Locked Slide Computer Name where Slide was Modified
  LSProvIDLock: Integer;             // Locked Slide Provider ID that Locked Slide
  LSLocIDLock : Integer;             // Locked Slide Location ID where Slide was Locked
  LSCompIDLock: string;              // Locked Slide Computer Name where Slide was Locked
  LSCMSRFlags : TN_CMSlideRFlags;    // Locked Slide Initial Runtime Flags Value
end;
type TK_CMEDBLockStateArray = array of TK_CMEDBLockState;

///////////////////////////////////////////////
// Import after conversion state and routines
//
type TK_CMImportState = record
  CMIXMLSlidesFName :  string; // Path to XML Slides file
  CMIAllCount       : Integer; // All importing slides counter
  CMIProcCount      : Integer; // Processed slides counter
  CMIImpCount       : Integer; // Imported slides counter
  CMIErrCount       : Integer; // Import Errors counter
  CMILastSlideID    : Integer; // Last Imported Slide ID
  CMILastSlideSID   :  string; // Last Imported Slide String ID
  CMILastSlidesInfo :  string; // Last Imported Slides DB Info
  CMILastSlidesInfoM1 :  string; // Last Imported Slides DB Info  without Last Slide ID
  CMIDBID           : Integer; // Last Import DB ID
  CMIDate           : TDateTime; // Last Import Date
//  TN_IArray
end;
type TK_PCMImportState = ^TK_CMImportState;

function  K_CMImportBuildInfo( APCMIState : TK_PCMImportState ) : string;
procedure K_CMImportClear( APCMIState : TK_PCMImportState; ASaveDBInfo : Boolean = FALSE );
procedure K_CMImportParseInfo( const AImportInfo : string;
                               APCMIState : TK_PCMImportState;
                               APSlidesIDArr : TN_PIArray );

type TK_CMEDDevProfilesSaveMode  = ( K_cmdpServer, K_cmdpGAServer, K_cmdpGALocation, K_cmdpClientName, K_cmdpClientIP, K_cmdpProvider, K_cmdpGAGlobal );

////////////////////////////////////////////
// CMS Stand alone runtime interface types
//
type TK_CMSALocationDBData = record // CMS Stand Alone Location Data get from Add/Modify Dialog
  ALName      : string;
  ALIsLocked  : Boolean;
  ALDBFlags   : Integer;
  ALIsPMSSync : Boolean; // =TRUE if DATA is syncronized with PMS
  ALCustRefN  : string;
end;
type TK_PCMSALocationDBData = ^TK_CMSALocationDBData;

type TK_CMSAProviderDBData = record // CMS Stand Alone Provider Data get from Add/Modify Dialog
  AUTitle       : string;
  AUSurname     : string;
  AUFirstname   : string;
  AUMiddle      : string;
  AUAuthorities : string;
  AUEncodeLP    : string;
  AUIsLocked    : Boolean;
  AUDBFlags     : Integer;
  AUPatCount    : Integer;
  AUIsPMSSync   : Boolean; // =TRUE if DATA is syncronized with PMS
end;
type TK_PCMSAProviderDBData = ^TK_CMSAProviderDBData;

type TK_CMSAPatientDBData = record // CMS Stand Alone Patient Data get from Add/Modify Dialog
  APTitle       : string;
  APGender      : string;
  APCardNum     : string;
  APSurname     : string;
  APFirstname   : string;
  APMiddle      : string;
  APDOB         : TDateTime;
  APProvID      : Integer;
  APAddr1       : string;
  APAddr2       : string;
  APSuburb      : string;
  APPostCode    : string;
  APState       : string;
  APPhone1      : string;
  APPhone2      : string;
  APIsLocked    : Boolean;
  APDBFlags     : Integer;
  APIsPMSSync: Boolean; // =TRUE if DATA is not syncronized with PMS
end;
type TK_PCMSAPatientDBData = ^TK_CMSAPatientDBData;

//
// end of CMS Stand alone runtime interface types
////////////////////////////////////////////

type TK_CMPatientHistDBData = record // CMS Patient DB History Data
  HPCardNum : string;
  HPName    : string;
end;
type TK_PCMPatientHistDBData = ^TK_CMPatientHistDBData;


////////////////////////////////////////////
// CMS Stand alone DEMO archive types
//

// Location attributes table record
type TK_CMSALocationAttrs = packed record
  SALID   : Integer; // Location ID
  SALName : string;  // Location Name
  SALFlags: Integer; // Location Flags
  SALCustRefN: string; // Location Custom Reference Number
end;
type TK_PCMSALocationAttrs = ^TK_CMSALocationAttrs;

// Provider attributes table record
type TK_CMSAProviderAttrs = packed record
  SAUID          : Integer; // Provider ID
  SAUTitle       : string;  // Provider Title
  SAUSurname     : string;  // Provider Surname
  SAUFirstname   : string;  // Provider Firstname
  SAUMiddle      : string;  // Provider Middle
  SAUAuthorities : Integer; // Provider Authorities
  SAUFlags       : Integer; // Provider Flags
  SAUEncodeLP    : string;  // Provider Encoded Login Password
end;
type TK_PCMSAProviderAttrs = ^TK_CMSAProviderAttrs;

// Patient attributes table record
type TK_CMSAPatientAttrs = packed record
  SAPID          : Integer;  // Patient ID
  SAPCardNum     : string;   // Patient Card Number
  SAPGender      : string;   // Patient Gender
  SAPTitle       : string;   // Patient Title
  SAPSurname     : string;   // Patient Surname
  SAPFirstname   : string;   // Patient Firstname
  SAPMiddle      : string;   // Patient Middle
  SAPDOB         : TDateTime;// Patient DOB
  SAPProvID      : Integer;  // Patient Provider ID
  SAPAddr1       : string;   // Patient Addr1
  SAPAddr2       : string;   // Patient Addr2
  SAPSuburb      : string;   // Patient Suburb
  SAPPostCode    : string;   // Patient PostCode
  SAPState       : string;   // Patient State
  SAPPhone1      : string;   // Patient Phone1
  SAPPhone2      : string;   // Patient Phone2
  SAPFlags       : Integer;  // Patient Flags
end;
type TK_PCMSAPatientAttrs = ^TK_CMSAPatientAttrs;
//
// end of CMS Stand alone DEMO archive types
////////////////////////////////////////////

type TK_CMSUpdateLinkInfoSet = set of (
  K_uliLocations,
  K_uliProviders,
  K_uliPatients
);

////////////////////////////////////////////
// CMS Command Line Link Info types
//

// Location attributes table record
type TK_CMSCLLLocationAttrs = packed record
  CLLLID   : Integer; // Location ID
  CLLLName : string;  // Location Name
  CLLLCustRefN : string; // Location Custom References
//  CMSID    : Integer; // CMS Location ID
end;
type TK_PCMSCLLLocationAttrs = ^TK_CMSCLLLocationAttrs;

// Provider attributes table record
type TK_CMSCLLProviderAttrs = packed record
  CLLUID          : Integer; // Provider ID
  CLLUTitle       : string;  // Provider Title
  CLLUSurname     : string;  // Provider Surname
  CLLUFirstname   : string;  // Provider Firstname
  CLLUAuthorities : Integer; // Provider Authorities
  CLLUMiddle      : string;  // Provider Middle
//  CMSUID   : Integer; // CMS Provider ID
end;
type TK_PCMSCLLProviderAttrs = ^TK_CMSCLLProviderAttrs;

// Patient attributes table record
type TK_CMSCLLPatientAttrs = packed record
  CLLPID          : Integer;  // Patient ID
  CLLPCardNum     : string;   // Patient Card Number
  CLLPTitle       : string;   // Patient Title
  CLLPSurname     : string;   // Patient Surname
  CLLPFirstname   : string;   // Patient Firstname
  CLLPAddr1       : string;   // Patient Addr1
  CLLPAddr2       : string;   // Patient Addr2
  CLLPPostCode    : string;   // Patient PostCode
  CLLPSuburb      : string;   // Patient Suburb
  CLLPPhone1      : string;   // Patient Phone1
  CLLPPhone2      : string;   // Patient Phone2
  CLLPDOB         : TDateTime;// Patient DOB
  CLLPState       : string;   // Patient State
  CLLPGender      : string;   // Patient Gender
//  CLLPMiddle      : string;   // Patient Middle
//  CLLPProvID      : Integer;  // Patient Provider ID
  CMSPProvID      : Integer;  // CMS Patient Provider ID
end;
type TK_PCMSCLLPatientAttrs = ^TK_CMSCLLPatientAttrs;

type TK_CMSCLLAttrs = packed record
  PatientAttrs  : TK_CMSCLLPatientAttrs;
  ProviderAttrs : TK_CMSCLLProviderAttrs;
  LocationAttrs : TK_CMSCLLLocationAttrs;
  CodePage  : Integer;
end;
type TK_PCMSCLLAttrs = ^TK_CMSCLLPatientAttrs;
//
// end CMS Command Line Link Info types
////////////////////////////////////////////

type TK_CMSAGetInfoFlags = set of (
  K_cmsagiLockOnly, // Lock Patient|Provider|Location record only
  K_cmsagiSkipLock  // Skip Patient|Provider|Location record Locking
);

//***************************************************************
//         Capture Devices Profiles
//***************************************************************

type TK_CMAutoImgProcFlags  = set of (
  K_aipfNoiseReduction,// Noise Reduction 1
  K_aipfEqualize,      // Equalize        3
  K_aipfNegate,        // Negate          4
  K_aipfConvToGrey,    // Convert to Grey 2
// 0000000F
  K_aipfFlipHor,       // Flip Horizontally
  K_aipfFlipVert,      // Flip Vertically
  K_aipfSSConv,        // Sharp/Smooth
  K_aipfBri,           // Use Brightness Factor
// 000000F0
  K_aipfCo,            // Use Contrast Factor
  K_aipfGam,           // Use Gamma Factor
  K_aipfLLUL,          // Use Brightness Window
  K_aipfAutoLLUL,      // Use Brightness Window Auto
// 00000F00
  K_aipfModified,      // Filter was modified by user
//
// New Flags
//
  K_aipfNRSelf,        // Noise Reduction with Threshold
  K_aipfMedian,        // Median
  K_aipfDespeckle,     // Despeckle
// 0000F000
  K_aipfSmooth,        // Smooth
  K_aipfSharp,         // Sharp
  K_aipfConvTo8,       // Convert Grey 16 to Grey 8
  K_aipfAutoContrast,  // Auto Contrast
// 000F0000
  K_aipfAutoLLULPower  // Use Auto LL/UL Power
// 00F00000
// 0F000000
// F0000000
);
const K_CMAIEqualizeMax  = 1.0; // Maximal Value
const K_CMAIEqualizeMin  = 0.0001; // Minimal Value
const K_CMAIEqualizeSpec = 0; // Special Value
type TK_CMAutoImgProcAttrs = packed record // Auto Image Processing Attributes
  CMAIPFlags:  TK_CMAutoImgProcFlags; // Operation Flags
  CMAIPAngl :   Byte;                 // Rotate Angle 0 - 3 -> 0 - 270
  CMAIPCoFactor   : Float; // Image Contrast Correction Factor
  CMAIPGamFactor  : Float; // Image Gamma Correction Factor
  CMAIPBriFactor  : Float; // Image Brightness Correction Factor
  CMAIPResolution : Float; // Image Resolution in DPI (not used for filters)
  CMAIPSSFactor   : Float; // Image Sharpen/Smoothen Factor (-1 <> 1)
  CMAIBriLLFactor : Float; // Image Brightness Window Low Level Factor
  CMAIBriULFactor : Float; // Image Brightness Window Upper Level Factor
//
// New Attributes
//
  CMAINRThreshold1: Float;   // Noise Reduction Threshold1
  CMAIMedianDepth : Integer; // Median Filter Aperture width
  CMAIDespeckleDepth : Integer; // Despeckle Filter Aperture width
  CMAISmoothPower : Float;   // Smooth Filter Power Factor
  CMAISmoothDepth : Integer; // Smooth Filter Aperture width
  CMAISharpPower  : Float;   // Sharp Filter Power Factor
  CMAISharpDepth  : Integer; // Sharp Filter Aperture width
//
// New Attributes
//
  CMAIAutoLLULPower : Float; // AutoLLUL Filter Power Factor 0 and continued range from 1 to 11
  CMAIEqualizePower : Float; // Equalize Filter Power Factor 0 and continued range from 1 to 11
end; // type TK_CMAutoImgProcAttrs = packed record
type TK_PCMAutoImgProcAttrs = ^TK_CMAutoImgProcAttrs;

type TK_CMDevProfListElem = packed record // Device Profiles List element
  CMDPLEARef: TN_UDBase; // Profile Devices UDRArray
  CMDPLEAInd:   integer; // Profile Element Index in Devices UDRArray
end; // type TK_CMDevProfListElem = packed record
type TK_PCMDevProfListElem = ^TK_CMDevProfListElem;

type TK_CMDeviceProfile = packed record // First fields, common to all (TWAIN, Other, Video) Profiles
//   Interface attributes
  CMDPCaption:     string; // Profile Name and Capture Menu Item Caption
  CMDPHint:        string; // Capture Menu Item and Device ToolButton Hint
  CMDPShortCut:    string; // Capture Menu Item and Device ToolButton ShortCut
  CMDPImageIndex: integer; // Capture Menu Item and Device ToolButton Image Index (for static ImageList)
  CMDPDynSIcon: TN_UDDIB;  // Saved (Dynamic) Small Image Object
  CMDPDynBIcon: TN_UDDIB;  // Saved (Dynamic)  Big  Image Object

//   Runtime attributes
  CMDPDelphiAction: TAction; // TAction for Capture MenuItem and Device ToolButton

//   Device attributes
  CMDPProductName: string; // Device Product Name (TWAIN or DirectShow Driver Name, N_ExtCuptDevices.ECDName)
  CMDPDLLInd:     integer; // Index in N_ExtCuptDevices Array for Other Devices, for Video and TWAIN Devices not used
  CMAutoImgProcAttrs : TK_CMAutoImgProcAttrs; // Auto Image Processing Attributes
  CMDPMTypeID:    integer; // Profile Media Type default ID
  CMDPGroupName:   string; // Profile Group Name
  CMDPStrPar1  :   string; // Profile Additional 1-st String Parameter
  CMDPStrPar2  :   string; // Profile Additional 2-nd String Parameter

//  TK_CMDCMAttrs
  CMDPDModality:  string; // DICOM Modality
  CMDPDKVP     :  Double; // DICOM KVP - Peak kilo voltage output of the x-ray generator used
  CMDPDExpTime : Integer; // DICOM ExposureTime - Time of x-ray exposure in msec
  CMDPDTubeCur : Integer; // DICOM TubeCurrent - X-Ray Tube Current in mA
//  CMDPDTubeCurF: Single;  // DICOM Float TubeCurrent - X-Ray Tube Current in mA
//  CMDPDRDoseF  : Single;  // DICOM RadiationDose     - X-Ray Radiation Dose in mGy
end; // type TK_CMDeviceProfile = packed record
type TK_PCMDeviceProfile = ^TK_CMDeviceProfile;

type TK_CMTwainProfile = packed record // Profile for TWAIN devices (now same as TK_CMDeviceProfile)
//*** first fields should be the same as in TK_CMDeviceProfile
//   Interface attributes
  CMDPCaption:     string; // Profile Name and Capture Menu Item Caption
  CMDPHint:        string; // Capture Menu Item and Device ToolButton Hint
  CMDPShortCut:    string; // Capture Menu Item and Device ToolButton ShortCut
  CMDPImageIndex: integer; // Capture Menu Item and Device ToolButton Image Index (for static ImageList)
  CMDPDynSIcon: TN_UDBase; // Saved (Dynamic) Small Image Object
  CMDPDynBIcon: TN_UDBase; // Saved (Dynamic)  Big  Image Object

//   Runtime attributes
  CMDPDelphiAction: TObject;// TAction for Capture MenuItem and Device ToolButton

//   Device attributes
  CMDPProductName: string; // Driver Name
  CMDPDLLInd:     integer; // not used for TWAIN Devices
  CMAutoImgProcAttrs : TK_CMAutoImgProcAttrs; // Auto Image Processing Attributes
  CMDPMTypeID:    integer; // Profile Media Type default ID
  CMDPGroupName:   string; // Profile Group Name
  CMDPStrPar1  :   string; // Profile Additional 1-st String Parameter
  CMDPStrPar2  :   string; // Profile Additional 2-nd String Parameter
//*** end of TK_CMDeviceProfile

//  TK_CMDCMAttrs
  CMDPDModality:  string; // DICOM Modality
  CMDPDKVP     :  Double; // DICOM KVP - Peak kilo voltage output of the x-ray generator used
  CMDPDExpTime : Integer; // DICOM ExposureTime - Time of x-ray exposure in msec
  CMDPDTubeCur : Integer; // DICOM TubeCurrent - X-Ray Tube Current in mA
//  CMDPDTubeCurF: Single;  // DICOM Float TubeCurrent - X-Ray Tube Current in mA
//  CMDPDRDoseF  : Single;  // DICOM RadiationDose     - X-Ray Radiation Dose in mGy
end; // type TK_CMTwainProfile = packed record
type TK_PCMTwainProfile = ^TK_CMTwainProfile;

type TK_CMOtherProfile = packed record // Profile for Other devices (with Ext DLLs)
//*** first fields should be the same as in TK_CMDeviceProfile
//   Interface attributes
  CMDPCaption:     string; // Profile Name and Capture Menu Item Caption
  CMDPHint:        string; // Capture Menu Item and Device ToolButton Hint
  CMDPShortCut:    string; // Capture Menu Item and Device ToolButton ShortCut
  CMDPImageIndex: integer; // Capture Menu Item and Device ToolButton Image Index (for static ImageList)
  CMDPDynSIcon: TN_UDBase; // Saved (Dynamic) Small Image Object
  CMDPDynBIcon: TN_UDBase; // Saved (Dynamic)  Big  Image Object

//   Runtime attributes
  CMDPDelphiAction: TAction; // TAction for Capture MenuItem and Device ToolButton

//   Device attributes
  CMDPProductName: string; // N_ExtCuptDevices.ECDName
  CMDPDLLInd:     integer; // Index in N_ExtCuptDevices Array for Other Devices
  CMAutoImgProcAttrs : TK_CMAutoImgProcAttrs; // Auto Image Processing Attributes
  CMDPMTypeID:    integer; // Profile Media Type default ID
  CMDPGroupName:   string; // Profile Group Name
  CMDPStrPar1  :   string; // Profile Additional 1-st String Parameter
  CMDPStrPar2  :   string; // Profile Additional 2-nd String Parameter
//*** end of TK_CMDeviceProfile

//  TK_CMDCMAttrs
  CMDPDModality:  string; // DICOM Modality
  CMDPDKVP     :  Double; // DICOM KVP - Peak kilo voltage output of the x-ray generator used
  CMDPDExpTime : Integer; // DICOM ExposureTime - Time of x-ray exposure in msec
  CMDPDTubeCur : Integer; // DICOM TubeCurrent - X-Ray Tube Current in mA
//  CMDPDTubeCurF: Single;  // DICOM Float TubeCurrent - X-Ray Tube Current in mA
//  CMDPDRDoseF  : Single;  // DICOM RadiationDose     - X-Ray Radiation Dose in mGy
end; // type TK_CMOtherProfile = packed record
type TK_PCMOtherProfile = ^TK_CMOtherProfile;

type TK_CMOtherProfile3D = packed record // Profile for Other 3D devices (with Ext DLLs)
//*** first fields should be the same as in TK_CMDeviceProfile
//   Interface attributes
  CMDPCaption:     string; // Profile Name and Capture Menu Item Caption
  CMDPHint:        string; // Capture Menu Item and Device ToolButton Hint
  CMDPShortCut:    string; // Capture Menu Item and Device ToolButton ShortCut
  CMDPImageIndex: integer; // Capture Menu Item and Device ToolButton Image Index (for static ImageList)
  CMDPDynSIcon: TN_UDBase; // Saved (Dynamic) Small Image Object
  CMDPDynBIcon: TN_UDBase; // Saved (Dynamic)  Big  Image Object

//   Runtime attributes
  CMDPDelphiAction: TAction; // TAction for Capture MenuItem and Device ToolButton

//   Device attributes
  CMDPProductName: string; // N_ExtCuptDevices.ECDName
  CMDPDLLInd:     integer; // Index in N_ExtCuptDevices Array for Other Devices
  CMAutoImgProcAttrs : TK_CMAutoImgProcAttrs; // Auto Image Processing Attributes
  CMDPMTypeID:    integer; // Profile Media Type default ID
  CMDPGroupName:   string; // Profile Group Name
  CMDPStrPar1  :   string; // Profile Additional 1-st String Parameter
  CMDPStrPar2  :   string; // Profile Additional 2-nd String Parameter
//*** end of TK_CMDeviceProfile

end; // type TK_CMOtherProfile3D = packed record
type TK_PCMOtherProfile3D = ^TK_CMOtherProfile3D;

type TK_CMVCMode = ( K_cvcmStillImage, K_cvcmVideo );

type TK_CMVideoProfile = packed record // Profile for VIDEO devices
//*** first fields should be the same as in TK_CMDeviceProfile
//   Interface attributes
  CMDPCaption:     string; // Profile Name and Capture Menu Item Caption
  CMDPHint:        string; // Capture Menu Item and Device ToolButton Hint
  CMDPShortCut:    string; // Capture Menu Item and Device ToolButton ShortCut
  CMDPImageIndex: integer; // Capture Menu Item and Device ToolButton Image Index (for static ImageList)
  CMDPDynSIcon: TN_UDBase; // Saved (Dynamic) Small Image Object
  CMDPDynBIcon: TN_UDBase; // Saved (Dynamic)  Big  Image Object

//   Runtime attributes
  CMDPDelphiAction: TObject; // TAction for Capture MenuItem and Device ToolButton

//   Device attributes
  CMDPProductName: string; // DirectShow Driver Name
  CMDPDLLInd:     integer; // Not used for DirectShow Video Devices
  CMAutoImgProcAttrs : TK_CMAutoImgProcAttrs; // Auto Image Processing Attributes
  CMDPMTypeID :   integer; // Profile Media Type default ID
  CMDPGroupName:   string; // Profile Group Name
  CMDPStrPar1  :   string; // Profile Additional 1-st String Parameter
  CMDPStrPar2  :   string; // Profile Additional 2-nd String Parameter
//*** end of TK_CMDeviceProfile

    // additional fields for DirectShow Video devices:
  CMVResolution  : string;  // Video Resolution
  CMVCMode  : TK_CMVCMode;  // Video Capturing Mode
  CMPreviewMode :  integer; // Still Images Preview Mode: 0-not init, 1-1Win, 2-2WinsVer, 3-2WinsHor, 4-4Wins
  CMNumClicksInd:  integer; // NumClicks Groupbox Item Index (0-twoClicks, 1-SingleClick)
  CMCaptButDLLInd: integer; // Camera Buttons DLL Index in TN_CMCameraButDevDLLs (=0 means no buttons)
  CMFreezeUnfreezeKey:  integer; // FreezeUnfreeze Key for "Keystrokes" Camera Button Device
  CMSaveAndUnfreezeKey: integer; // SaveAndUnfreeze Key for "Keystrokes" Camera Button Device
  CMVFormatGUIDString : string;  // Video Format GUID string
end; // type TK_CMVideoProfile = packed record
type TK_PCMVideoProfile = ^TK_CMVideoProfile;

type TK_CMScanCaptureFlags = set of (  // CMScan Capture Flags
  K_scfSlideUploadWOGap,         // start slides upload without one slide gap
  K_scfSkipProfileDICOMDefaults, // skip apply profile DICOM attributes default values
  K_scfUseFullStayOnTopMode      // Use full stay on top for CMS Device Windows
);

//************************************************************ TK_CMEDAccess ***
// External Data Access Base Class
//
type TK_CMEDAccess = class
  ATimer : TTimer;            // Activity Timer
  DumpSavingContext : Boolean;
//  DumpSavingBinContext : Boolean;
//  DumpSavingIniContext : Boolean;
  constructor Create;
  destructor Destroy; override;
    private
  PatientsFIOIndex  : TStringList; // Special field for DICOMDIR import patients
    protected
//  MemTextFragms : TN_MemTextFragms;

  BlobEncParams   : TK_DFCreateParams; // File and Blob Encoding Params


  //PCMSlide : TN_PCMSlide;

//*********************************************************************
// Wait User Event Utility
  WaitEventForm : TForm;
  WaitDlgResult : Integer;

//*********************************************************************
// Activity Timer Control
  ATimerCount : Integer;

  function  EDAGetSlidesFPathContext( ALocID : Integer = -1 ): TK_CMEDResult; virtual;
  procedure EDAPrepStateAfterException; virtual;
  function  EDAGetArchUDTabRowStrings( AUDTab : TK_UDRArray; ARow : Integer;
                                       ASList : TStrings ) : TK_CMEDResult;
  function  EDAArchUDTabIndexOf( ASStr : string; AUDTab : TK_UDRArray;
                                 AFInd : Integer = 0 ) : Integer;
  function  EDAGetArchUDTab( const APath : string; var AUDTab : TK_UDRArray ) : TK_CMEDResult;
  function  EDAFixIDsRangeArch( AIDInd, ARangeSize : Integer ) : Integer;
  function  EDAGetAnyDataInfo( AUDTab : TK_UDRArray; ADataID: Integer;
                               AInfo: TStrings = nil;
                               AAddToValues : Boolean = false ): TStrings;
  function  EDAAddCurSlideSection( ASlideChildInd : Integer ) : TN_UDBase;
//  procedure EDALogChanAddFullStr( AStr: string );
//  procedure EDALogChanAddAllStr( AStr: string );
  function  EDACompressData( var APData: Pointer; var ADataSize: integer;
                             ACurCompressPower: integer = -1 ) : TK_CMEDResult;
  function  EDAPutDataToStream( AStream: TStream;
                               APData: Pointer; ADataSize: integer ) : TK_CMEDResult;

    public
  AllMediaTypes   : TStrings;    // All MediaTypes Buffered List
//  CurSlidesRoot : TN_UDBase;
  SlideECRoot : TN_UDCMSlide; // Slide Emergency cache root
  CurSlide   : TN_UDCMSlide;

  TmpStrings : TStringList;   // tmp TStrings needed public to set Application Properties via MemIni

  StrTextBuf      : string;      // Text Buffer
  AnsiTextBuf     : AnsiString;  // Ansi Text Buffer
  Int64Data       : Int64;

  BlobBuf         : TN_BArray;   // File and Blob Fields Buffer
  BlobComprBuf    : TN_BArray;   // File and Blob Fields Buffer for Data Compression
  ImgFileCompressPower   : Integer; // Directly Stored File CompressPower;
  CurDataCompressPower   : Integer; // Current Data compress power

{ // previouse version
  ContMemIni   : TMemIniFile;   // tmp MemIni Object for contexts processing, needed public to set Application Properties via MemIni
  DFPLExec     : TK_DFPLScriptExec; // DFPL Script Processor

  DefaultMemIni: TMemIniFile; // MemIni Object for saving Some Default IniFile Fields for futute restore
}

//  SkipProcessMessages : Boolean; // Skip Application.ProcessMessages while Image Files are Saving when Application is Finalized
  AccessReady : Boolean; // External Data Access Ready Flag for D4W Client
  ExecCommandsFlag : Boolean; // Execute Commands List in not D4W Client Mode

  SlidesSaveMode : TK_CMEDSlidesSaveMode; // Slides Save Mode - defines Slides Saving Moment
  StateSaveMode  : TK_CMEDStateSaveMode;  // State Save Mode - defines Application Modes Saving Moment
//  SaveSlideImmedeately : Boolean; // Save Slide After just after change

  GUISilentFlag : Boolean;

//*********************************************************************
// CMS DB Emulation Context Data
//
  ArchSlidesRoot : TN_UDBase;    // Archive SLides Root
  ArchMTypesInfo : TK_UDRArray;  // Archive MediaTypes Table
  ArchGlobInfo   : TK_UDRArray;  // Archive Global Info Table

//*********************************************************************
// CMS Components Library Context
//
  ArchMLibRoot  : TN_UDBase; // Archive Measurements Library Root
  ArchMLibMRMPat: TN_UDBase; // Archive MapRoot Measurements Pattern

  ArchPrnPageRoot       : TN_UDBase; // Archive Printing Page Root Component
  ArchPrnPageSlidesRoot : TN_UDBase; // Archive Printing Page Slides Root Component
  ArchPrnPageParams     : TN_UDBase; // Archive Printing Page Parameters Component
  ArchPrnSlidePatRoot   : TN_UDBase; // Archive Printing Slide Pattern Root Component

  ArchStudySamplesInitLibRoot: TN_UDBase; // Archive Study Samples Library Initial Root Component
  ArchStudySamplesLibRoot: TN_UDBase; // Archive Study Samples Library Root Component
//*********************************************************************
// CMS Current Context Data
//
  UDRootInstanceInfo  : TN_UDBase;    // Current Instance(Application) Root

  CurSlidesList : TList;
  SaveSlidesList: TList;
  DelSlidesList : TList;

  // Devices Profiles
  ProfilesSaveMode : TK_CMEDDevProfilesSaveMode;
  SavedIcons    : TN_UDBase;   // Saved Icons Root
  ProfilesList  : TK_UDRArray; // Profiles List Object
  TwainProfiles : TK_UDRArray; // Scanner Profiles Table Archive Object
  OtherProfiles : TK_UDRArray; // Other Device Profiles Table Archive Object
  OtherProfiles3D : TK_UDRArray; // Other Device 3D Profiles Table Archive Object
  VideoProfiles : TK_UDRArray; // Video Profiles Table Archive Object

  // Current User Binary Info
  UDRootProviderInfo : TN_UDBase;    // Current User Data UDRoot
  UFiltersProfiles   : TK_UDRArray;  // User Filter Profiles Container Object

  // CMS Global Binary Info
  UDRootGlobalInfo       : TN_UDBase;     // Global Data UDRoot
  GFiltersProfiles : TK_UDRArray;  // Global Filters Profiles Container Object
  GFiltersImgProcAttrs : TK_UDRArray;  // Global Filters Ini ImgProcAttrs Container Object

  CurSessionHistID: Integer;  // Current Session History ID
  CurSessionHistStartTS: TDateTime; // Timestamp of CMS Session Start event
  PrevSessionHistID: Integer; // Needed for Correct Seesion ID for CMSClose Event
  CurPatID  : Integer; // Current Patient ID
  CurProvID : Integer; // Current Provider ID
  CurLocID  : Integer; // Current Location ID
  CurLocEFlags : Integer;  // Current Location Enterprise Flags


  UpdatePPLFlagsSet : TK_CMSUpdateLinkInfoSet;

  PatientsInfo  : TK_UDRArray;
  ProvidersInfo : TK_UDRArray;
  LocationsInfo : TK_UDRArray;

  UndeletedFileNames : TK_UDStringList;

  CurSlidesSelectAttrs  : TK_CMSlidesSelectAttrs;
  ExtResultCode      : TK_CMEDResult;
  ExtDataErrorCode   : TK_CMEDError;
  ExtDataErrorString : string;
  ExtDFile: TK_DFile;

  PatSlidesAutoRefreshFName : string;
  PatSlidesAutoRefreshTS : TDateTime;

//*********************************************************************
// CMS Slides Locking Result Data
//
//  LockResultUpdateState : TK_CMEDBUSFArray;  // Update Slide States Array (Sinchronized with LockResultSlides)
//  LockResultSrcInds : TN_IArray;   // Lock Slides Result Array of Indexes to Source Array (Sinchronized with LockResultSlides)
  LockResSlides : TN_UDCMSArray;          // Lock Slides Result Array
  LockResState  : TK_CMEDBLockStateArray; // Lock Slides Results array
  LockResCount  : Integer;                // Lock Slides Result Counter

  LockResDelCount  : Integer;       // Deleted and Deleting Slides Result Counter
  LockResDelSlides : TN_UDCMSArray; // Deleted and Deleting Slides Result Array

  LockResMarkAsDelCount  : Integer;       // Marked as Deleted Slides Result Counter
  LockResMarkAsDelSlides : TN_UDCMSArray; // Marked as Deleted Slides Result Array

  LockResSkipOpenCount: Integer;         // SkipOpen Slides Result Counter
  LockResSkipOpenSlides : TN_UDCMSArray; // SkipOpen Slides Result Array

  LockResUpdateThumbCount   : Integer;// Slides to Update Thumbnails
  LockResUpdateOpenImgCount : Integer;// Slides to Update Image Counter
  LockResUpdateCount : Integer;   // Slides to Update Counter
  LockResUpdateStudyCount : Integer;   // Studies to Update Counter

  LockResMediaCreatedOnOtherCount : Integer; // Slides which were created on other computers Counter
  LockResDelUsedByOtherCount : Integer; // Slides which are used by other user during deletion
  LockResDelNotHostLoc : Integer; // Slides which are from another Host Location

//*********************************************************************
// CMS Lock Error Context Data - needed for Patient Locking Errors Dump
// (Is needed only in DB mode. Is placed to base class in order to skip type cast)
//
  LEProvID : Integer; // Provider ID
  LELocID  : Integer; // Location ID
  LEClientAppGlobID : Integer; // Application Instance Global ID
  LEClientCompVID : string;// Client Computer Virtual ID

//*********************************************************************
// CMS Slides Files Path context
//
  SlidesClientMediaRootFolder : string; // Slides Client MediaFiles Base Path

  SlidesCRFC : TK_ChangeRootFolderContext;    // Slides Change Root Folder Current Context
//  SlidesIniCRFC : TK_ChangeRootFolderContext; // Slides Change Root Folder Context from Ini-file
  SlidesCRFCopiedFilesPaths : THashedStringList; // List of Paths to delete after moving

//*********************************************************************
// CMS Data Consistency Check
//
  SkipEDADataCheckInDelProc : Boolean; // Skip check during Deletion Process

//*********************************************************************
// CMS Image Files DIB format
//
  SlidesDIBFormat : TN_UDDIBDataFormat;

//*********************************************************************
// CMS Data Access Aditional Results
//
  AResStr1 : string;
  AResInt1 : Integer;

//*********************************************************************
// EDASelectDataFiles parameters
//
  SkipDataFolder : string;  // Folder to Skip while selecting Image and Video Files
  RelPathStartInd : Integer;// Relative Path Start Index

//*********************************************************************
// EDAStartCapture|EDAFinCapture context
//
  PCurDevProfile: TK_PCMDeviceProfile;
  CurDevProfilePar1, CurDevProfilePar2 : string;

//*********************************************************************
// EDASaveSlidesList context
//
  RemovedFromCurSlidesSetCount : Integer;

//*********************************************************************
// CMS Slide Data Access
//
  function  EDAArchUDTabFieldIndex( AFieldName: string; AUDTab: TK_UDRArray;
                                    AddFieldFlag : Boolean = TRUE ): Integer;
  function  EDAUncompressData( var APData: Pointer; var ADataSize: integer ) : TK_CMEDResult;
  function  EDASlideDataToFile( APData: Pointer; var ADataSize: integer; const AImgFName : string ): TK_CMEDResult; virtual;
  function  EDASlideDataFromFile( out APData : Pointer; out ADSize : Integer;
                                  const AImgFName : string; out AFSize : Integer ): TK_CMEDResult; virtual;
  function  EDASlideDIBToFile( AUDSect: TN_UDBase; ASkipFreeDIBMemFlag : Boolean = FALSE ): TK_CMEDResult;
  function  EDASlideDIBFromFile( AUDSect: TN_UDBase ): TK_CMEDResult;

  procedure EDAFreeBuffer( APBuf : Pointer );
  procedure EDAShowErrMessage( AShowMessage : Boolean );

  function  EDAAnsiTextToString( var APData : Pointer; ADSize : Integer ) : Integer;
  function  EDAStringToAnsiText( APStrChar: PChar; AStrLeng : Integer; out APData: Pointer ): Integer;
  function  EDAStringsToAnsiText( AStrings : TStrings; out APData : Pointer ) : Integer;

  function  EDACheckFSSettings(  ) : Integer; virtual;
  procedure EDAMemIniFilesMovingInfoToCurState( APCRFC : TK_PChangeRootFolderContext );
  procedure EDAFilesMovingInfoToMemIni( );
  procedure EDASaveFilesMovingInfo( );
  function  EDAGetSlideCurImage0  ( ASlide: TN_UDCMSlide ): TK_CMEDResult; virtual;

//*********************************************************************
// CMS Current Context Interface
//
  function  EDAGetSyncTimestamp( ATime : TDateTime = 0 ) : TDateTime; virtual;
//  function  EDAExtIniFileToMemIni( AIniFName : string; const AIniDFPLName : string = '' ) : TK_CMEDResult;
//  function  EDAExtIniFilesToMemIni( ) : Integer;
//  function  EDAMemIniToExtIniFile( AIniFName : string; const AIniDFPLName : string = '' ) : TK_CMEDResult;
//  function  EDAMemIniToExtIniFiles( ) : Integer;
  procedure EDAAssign( ACMEDA : TK_CMEDAccess );
  function  EDAArchUDCompsInit() : TK_CMEDResult;
  function  EDAAppUDTreeInit() : TK_CMEDResult;
  function  EDADevProfilesUDTreeInit(): TK_CMEDResult;
  function  EDAProviderUDTreeInit(): TK_CMEDResult;
  procedure EDAUDFiltersInit();
  function  EDAGlobUDTreeInit(): TK_CMEDResult;
  function  EDASaveContextsData( ASaveFlags : TK_CMEDSaveStateFlags = [] ) : TK_CMEDResult; virtual;
  function  EDAAppContextToCurState( ANPatId, ANProvID, ANLocID : Integer ) : TK_CMEDResult; virtual;
  function  EDAInit() : TK_CMEDResult; virtual;
  procedure EDATimerAction( Sender : TObject );
//  function  EDAArchInit() : TK_CMEDResult;
  function  EDASetInstanceState( ASetActive : Boolean; AStateFlag : Integer ) : TK_CMEDResult; virtual;
  procedure EDADelUnusedImgFiles( );

//*********************************************************************
// Auxiliary Data Access
// Resulting Info is list of <Name>=<Value>
//
  function  EDAGetLocationMacroInfo( ADataID : Integer = -1; AInfo : TStrings = nil;
                                AAddToValues : Boolean = false ) : TStrings;
  function  EDAGetPatientMacroInfo ( ADataID : Integer = -1; AInfo : TStrings = nil;
                                AAddToValues : Boolean = false ) : TStrings; virtual;
  function  EDAGetProviderMacroInfo( ADataID : Integer = -1; AInfo : TStrings = nil;
                                AAddToValues : Boolean = false ) : TStrings;
  function  EDAGetProviderAccessRights( ADataID: Integer = -1 ): TK_CMUserAccessRights;
  procedure EDAGetUserDefineMediaFilter( const AFilterName: string; APUDFilterAttrs : TK_PCMSlideFilterAttrs );
  procedure EDAPutUserDefineMediaFilter( const AFilterName: string; APUDFilterAttrs : TK_PCMSlideFilterAttrs );

//*********************************************************************
// Slides Access
//
  function  EDACheckSlideMedia( ASlide : TN_UDCMSlide; ASkipShowDlg : Boolean = FALSE ): TK_CMEDResult; virtual;
  procedure EDARemovePathFolders0( AFName : string; const ABasePath : string );
  function  EDADelSlideMediaFiles( ASlide: TN_UDCMSlide ) : TK_CMEDResult; virtual;
  procedure EDAInitSlideViewAttrs( ASlide: TN_UDCMSlide );
//  function  EDALockActiveContext( ): TK_CMEDResult; virtual;
  function  EDAAddSessionHistRecord( ANPatID : Integer = -1;
                                     ANProvID : Integer = -1;
                                     ANLocID  : Integer = -1 ) : TK_CMEDResult; virtual;
  function  EDALockActiveContext1( ANPatID, ANProvID, ANLocID : Integer ): TK_CMEDResult; virtual;
  function  EDALockSlides( APSlide: TN_PUDCMSlide; ASlidesCount : Integer;
                           ALockResultMode : TK_CMEDLockResultMode;
                           APatID : Integer = -1 ): TK_CMEDResult; virtual;

  function  EDAUnlockAllLockedSlides( ALockResultMode : TK_CMEDLockResultMode  ): TK_CMEDResult; virtual;
  function  EDAUnlockSlides( APSlide: TN_PUDCMSlide; ASlidesCount : Integer;
                             ALockResultMode : TK_CMEDLockResultMode  ): TK_CMEDResult; virtual;

  //  function  EDADelSlide( ASlide : TN_UDBase ) : Integer;
  function  EDADelSlides( APSlide : TN_PUDCMSlide; ASlidesCount : Integer;
                          ASaveInCurSlidesSet : Boolean;
                          AClearDelSlides : Boolean = FALSE  ) : Integer;
  procedure EDAAddSlide( ASlide : TN_UDBase; ASkipECahe : Boolean = FALSE;
                         ASlidesCount : Integer = 0  ); virtual;
  procedure EDARemoveSlide( ASlide : TN_UDBase );

  function  EDARenameSlideNewMediaFile( ASlide: TN_UDCMSlide;
                                        const APermFNamePref : string = '' ): TK_CMEDResult;
  function  EDAStoreSlideNewMediaData( ASlide: TN_UDCMSlide ): TK_CMEDResult; virtual;
  function  EDASetCurSlide       ( ASlide: TN_UDCMSlide; AUpdateMode : Boolean = false ) : TK_CMEDResult; virtual;
  function  EDASaveSlideFields   ( ) : TK_CMEDResult; virtual;
  function  EDASaveSlideThumbnail( ) : TK_CMEDResult; virtual;
  function  EDASaveSlideCurImage ( ) : TK_CMEDResult; virtual;
  function  EDASaveSlideSrcImage ( ) : TK_CMEDResult; virtual;
  function  EDASaveSlide         ( ASlide: TN_UDCMSlide ) : TK_CMEDResult; virtual;

  procedure EDAClearCurSlidesSet( );
  function  EDASaveSlidesList( ASLides : TList ) : TK_CMEDResult;
  function  EDASaveSlidesArray( APSlide: TN_PUDCMSlide; ASlidesCount : Integer ): TK_CMEDResult;
  function  EDAGetNewSlidesStartID( ANCount : Integer ) : Integer; virtual;
  function  EDASetNewSlidesID( ASlides : TList ) : TK_CMEDResult;
  function  EDAClearDeletedSlides( AMarkAsDelFlag : Boolean ) : TK_CMEDResult; virtual;
  function  EDAUnDeleteSlides( APSlides: TN_PUDCMSlide; ASlidesCount: Integer ) : TK_CMEDResult; virtual;

  procedure EDACurSlidesToStrings( AStrings : TStrings );
  function  EDACalcBySlidesSelectAttrs( out ASlidesCount : Integer ) : TK_CMEDResult; virtual;
  function  EDARefreshCurSlidesSet( out ANewSlidesCount, ADelSlidesCount,
                                    AUpdateSlidesCount : Integer ) : TK_CMEDResult; virtual;
  function  EDAGetCurSlidesSet( ) : TK_CMEDResult; virtual;
  function  EDAGetUDCMSlidesByID( APID : PInteger; ACount : Integer; var ASlides : TN_UDCMSArray ) : TK_CMEDResult; virtual;
  function  EDAGetSlideFields( ASlide: TN_UDCMSlide; AGetStudyLinkInfo : Boolean = FALSE; ADataSet : TObject = nil ) : TK_CMEDResult; virtual;
  function  EDAGetSlideThumbnail( ASlide: TN_UDCMBSlide ) : TK_CMEDResult; virtual;
  function  EDAGetSlideMapRoot( ASlide: TN_UDCMSlide;
                                ASkipLoadFlag : Boolean = false;
                                ASkipCurImgLoad : Boolean = false ) : TK_CMEDResult; virtual;
  function  EDAGetSlideCurImage( ASlide: TN_UDCMSlide;
                                 ASkipLoadFlag : Boolean = false ) : TK_CMEDResult; virtual;
  function  EDAGetSlideSrcImage( ASlide: TN_UDCMSlide;
                                 ASkipLoadFlag : Boolean = false ) : TK_CMEDResult; virtual;

  function  EDAGetPatSlidesDates( ASkipTime : Boolean ): TN_DArray;
  procedure EDASetSlideMediaFileTMPName( ASlide: TN_UDCMSlide; const AMediaFExt: string ); virtual;
  function  EDAGetMediaFileClientName( ASlide: TN_UDCMSlide ) : string; virtual;
  procedure EDASetPatientSlidesUpdateFlag(); virtual;
  procedure EDAGetPatientSlidesUpdateTS(); virtual;


//*********************************************************************
// Study Access
//
  function  EDAStudyGetMapRoot( AStudy: TN_UDCMStudy ) : TK_CMEDResult; virtual;

  function  EDAStudySetCur    ( AStudy: TN_UDCMStudy ) : TK_CMEDResult; virtual;
  function  EDAStudySavingStart() : TK_CMEDResult; virtual;
  function  EDAStudySavingFinish() : TK_CMEDResult; virtual;
  function  EDAStudySaveFields(): TK_CMEDResult; virtual;
  function  EDAStudySave( AStudy: TN_UDCMStudy ) : TK_CMEDResult; virtual;
  function  EDAStudyCaptStartPosGet( AStudy: TN_UDCMStudy ) : TK_CMEDResult; virtual;
  function  EDAStudyCaptStartPosSavingPrep( AStudy: TN_UDCMStudy ) : TK_CMEDResult; virtual;

  function  EDAStudyDismountOneSlideFromItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide = nil; AStudy: TN_UDCMStudy = nil; ARuntimeInfoOnly : Boolean = FALSE ) : TK_CMEDResult; virtual;
  function  EDAStudyMountOneSlideToEmptyItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE ) : TK_CMEDResult; virtual;
//  function  EDAStudyRemountOneSlideToItem( ARItem: TN_UDBase; ARSlide : TN_UDCMSlide;
//                                           APRContext : TK_PCMStudyRemountOneSlideContext;
//                                           var ARUpdateFlags : TK_CMStudyRemountUpdateFlags ) : TK_CMEDResult;

  function  EDAStudyDismountAllSlidesFromItem( AItem: TN_UDBase; out ASlides : TN_UDCMSArray; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                               ASelfItemFRFlags : Integer = 0; ASelfItemTeethFlags : Int64 = 0;
                                               AMountItemFRFlags : Integer = 0; AMountItemTeethFlags : Int64 = 0 ) : TK_CMEDResult; virtual;
  function  EDAStudyMountAllSlidesToEmptyItem( AItem: TN_UDBase; ASlides : TN_UDCMSArray; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                               ASelfItemFRFlags : Integer = 0; ASelfItemTeethFlags : Int64 = 0 ) : TK_CMEDResult; virtual;
  function  EDAStudyMountAddSlideToItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                         ASelfItemFRFlags : Integer = -1; ASelfItemTeethFlags : Int64 = -1 ) : TK_CMEDResult; virtual;
  function  EDAStudyRemoveSlideFromItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil ) : TK_CMEDResult;
  function  EDAStudyReplaceSlideInItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil ) : TK_CMEDResult;
  function  EDAStudyItemSlideSetCurrent( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE ) : TK_CMEDResult; virtual;
{
  function  EDAStudyRemountAllSlidesToItem( ARItem: TN_UDBase; ARSlide : TN_UDCMSlide;
                                        APRContext : TK_PCMStudyRemountOneSlideContext;
                                        var ARUpdateFlags : TK_CMStudyRemountUpdateFlags ) : TK_CMEDResult;
}
  function  EDAStudyTemplatesPrepare() : TK_CMEDResult; virtual;

//*********************************************************************
// Media Types Access
//
  function  EDAGetBuildInMediaTypes ( AMTypes: TStrings ) : TK_CMEDResult;
  procedure EDAPrepIniMediaTypeTexts();
  function  EDAGetAllMediaTypes0 ( ): TStrings; virtual;
  function  EDAGetAllMediaTypes ( AMTypes: TStrings ): TK_CMEDResult;
  function  EDAddNewMediaType ( out AMTypID : Integer; const AMTypeTitle : string ): TK_CMEDResult; virtual;
  function  EDARenameMediaType ( AMTypID : Integer; AMTypeTitle : string ): TK_CMEDResult; virtual;
  function  EDACheckMediaTypeInCurSlidesSet( AMTypID: Integer ) : Boolean;
  function  EDADeleteMediaTypeByID( AMTypID : Integer; out APatID: Integer ): TK_CMEDResult; virtual;

//*********************************************************************
// Utilities
//
  function  EDAddInitialMediaTypes ( APInitMTypesNum : PInteger = nil ): TK_CMEDResult; virtual;
  function  EDAClearAllEData(): TK_CMEDResult; virtual;
  function  EDAGetInfo( APInfo : Pointer ): TK_CMEDResult; virtual;
  function  EDAGetDirFreeSpace(const AFPath: string;
                        ADAFlag: Boolean; out AFreeSpace: Int64): TK_CMEDResult; virtual;
  function  EDAGetImgDiskFreeSpace( out AFreeSpace : Int64 ): TK_CMEDResult; virtual;
  function  EDAGetVideoDiskFreeSpace( out AFreeSpace : Int64 ): TK_CMEDResult; virtual;
  function  EDAGetDiskFreeSpace( out AFreeSpace : Int64 ): TK_CMEDResult;
  function  EDAVideoFolderAccessPrevCheck() : Boolean; virtual;
  function  EDACheckImgFilesFolderAccess() : Integer; virtual;
  function  EDACheckVideoFilesFolderAccess() : Integer; virtual;
//  function  EDACheckVideoFolderAccessDlg() : Boolean; virtual;
  function  EDACheckFilesAccessBySlidesSet( APUDSlide: TN_PUDCMSlide;
                                            ASlidesCount : Integer;
                                            const AddWarnStr : string;
                                            AMDButtons : TMsgDlgButtons = [];
                                            AMDResult : word = mrOk ): Integer; virtual;
  function  EDACheckAllFilesAccess( AFImgCheck: Boolean; AFVideoCheck: Boolean;
                                    AFImg3DCheck: Boolean;
                                    const AddWarnStr2 : string;
                                    const AddWarnStr1 : string = '';
                                    AMDButtons : TMsgDlgButtons = [];
                                    AMDResult : word = mrOk ): Integer; virtual;
  function  EDACheckFoldersEquality( AFPath1 : string;
                                     AFPath2 : string ) : Boolean;
  function  EDAPrepFreeSpaceWarnText( AFreeSpace : Int64; ADriveName : string ) : string;
  function  EDACheckMinDiskFreeSpace( ) : Boolean; virtual;
  procedure EDADumpSlidesToTmpStrings( APUDSlide: TN_PUDCMSlide;
                                       ASlidesCount : Integer );
  function  EDASelectDataFiles( const APathName, AFileName : string; AScanLevel : Integer ) : TK_ScanTreeResult;
  function  EDACalcFilesSize( const APathName, AFileName : string; AScanLevel : Integer ) : TK_ScanTreeResult;
//  function  EDAPasteSlideClone( UDParent : TN_UDBase; ChildInd : Integer; const SrcDE : TN_DirEntryPar ) : Boolean;
  function  EDAWaitForEventUserDlg( ACheckEventFunc : TK_FuncObjBool;
                                    const AMessage: string; AMDLT: TMsgDlgType;
                                    AMDButtons: TMsgDlgButtons = []; ACaption: string = '' ) : Integer;
  procedure EDAOnWaitDlgFormCloseQuery( Sender: TObject; var CanClose: Boolean );
  procedure EDAOnWaitDlgFormButtonClick( Sender: TObject );
  procedure EDAWaitDlgFormClear();
  function  EDAGetDBUID( ) : string;
  procedure EDAGetDCMStudiesAttrs( APSlide: TN_PUDCMSlide;
               ASlidesCount: Integer; out AStudiesSID : TN_SArray;
               out AStudiesTS : TN_DArray ); virtual;
  procedure EDAGetDCMStudiesUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
               ADCMFNames : TN_SArray;
               out AStudiesUID, AStudiesSID : TN_SArray; out AStudiesTS : TN_DArray ); virtual;
  procedure EDAGetDCMSeriesUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
               ADCMFNames : TN_SArray;
               out ASeriesUID, ASeriesSID  : TN_SArray; out ASeriesTS  : TN_DArray ); virtual;
  procedure EDAGetDCMSlideUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
               out ADCMFNames, AContentUID, AContentSID : TN_SArray; out AContentTS, AcqTS : TN_DArray ); virtual;
  procedure EDAGetDCMSlideUCAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
               out ADCMFNames, AStudiesUID, AStudiesSID : TN_SArray; out AStudiesTS : TN_DArray;
               out ASeriesUID, ASeriesSID  : TN_SArray; out ASeriesTS  : TN_DArray;
               out AContentUID, AContentSID : TN_SArray; out AContentTS, AcqTS : TN_DArray );
  function  EDAScanFilesTreeSelectFile( const APathName, AFileName : string; AScanLevel : Integer ) : TK_ScanTreeResult;
  function  EDAStartCapture( ACMScanCaptureFlags : TK_CMScanCaptureFlags;
                             APCurDevProfile: TK_PCMDeviceProfile ): Boolean; virtual;
  procedure EDAFinCapture(); virtual;
  function  EDAForceDirPath( const AFPath: string ): Boolean;
  function  EDAClearGAMode() : TK_CMEDResult; virtual;
  procedure EDAClearSlidesCRFC;

//*********************************************************************
// Save Restore Application Contexts
//
  procedure EDAVobjAttrsMemIniToCurState();
  procedure EDAGlobalMemIniToCurState();
  procedure EDAGlobalCurStateToMemIni();
  function  EDAGAGlobalToCurState : TK_CMEDResult; virtual;
  procedure EDAGlobal2MemIniToCurState();
  procedure EDAGlobal2CurStateToMemIni();
  function  EDANotGAGlobalToCurState : TK_CMEDResult; virtual;
  function  EDANotGAGlobalToMemIni : TK_CMEDResult; virtual;
  function  EDANotGAGlobalToMemIni1 : TK_CMEDResult; virtual;
  procedure EDAInstanceMemIniToCurState();
  procedure EDAInstanceCurStateToMemIni();
  procedure EDAPatientMemIniToCurState();
  procedure EDAPatientCurStateToMemIni();
  procedure EDAProviderMemIniToCurState();
  procedure EDAProviderCurStateToMemIni();
  procedure EDAProviderInstanceMemIniToCurState();
  procedure EDAProviderInstanceCurStateToMemIni();
  procedure EDALocationMemIniToCurState(); virtual;
  procedure EDALocationCurStateToMemIni(); virtual;
  function  EDALocationToCurState() : TK_CMEDResult; virtual;
  function  EDALocationToMemIni1() : TK_CMEDResult; virtual;
  procedure EDAHidePasswordForDump( AStrings : TStrings; AEncodeLogin : Boolean = FALSE );

//*********************************************************************
// Emergency Cache Routines
//
  procedure EDASaveSlideToECache( AUDSlide: TN_UDCMSlide ); virtual;
  procedure EDAClearSlideECache( AUDSlide: TN_UDCMSlide ); virtual;

//*********************************************************************
// Ordered Visible Slides Routines
//
  function EDASlidesDTakenOrder( Ptr1, Ptr2: Pointer ): Integer;

//*********************************************************************
// Slide History
//
  function  EDABuildHistActionCode( AHistActType : TK_CMSlideHistActType;
                                AHist1 : Byte = 0; AHist2 : Byte = 0;
                                AHist3 : Byte = 0; AHist4 : Byte = 0 ): Integer;
  function  EDAChangeHistActionType( AActCode : Integer;
                                        AHistActType : TK_CMSlideHistActType ): Integer;
  function  EDAGetHistActionType( AActCode : Integer ): TK_CMSlideHistActType;
  function  EDAGetHistActionInfo( AActCode : Integer;
            out AHist1, AHist2, AHist3, AHist4 :Byte ): TK_CMSlideHistActType;
  function  EDAGetVObjHistType( AUDVObj: TN_UDBase ) : TK_CMSlideHistVObjType;
  function  EDAGetHistActionText( AActCode: Integer;
                                        ASkipUndoText, AShowExpFExt : Boolean;
                                        const AExpFExt, ASrcDescr : string ): string;
  procedure EDAAddHistActionToSlideBuffer( ASlide : TN_UDCMSlide; AActCode : Integer );

//*********************************************************************
// Import History
//
  function  EDAAddImportHistory( out AImportID : Integer ): TK_CMEDResult; virtual;
  function  EDAChangeImportInfo( AImportID : Integer; const AImportInfo : string; ADumpFlag : Integer = 0 ): TK_CMEDResult; virtual;
  function  EDAGetLastImportHistory( out AImportID : Integer; out AImportDate : TDateTime;
                                     out AImportInfo : string ): TK_CMEDResult; virtual;
  function  EDADeleteImportHistory( AImportID : Integer ): TK_CMEDResult; virtual;
  function  EDAChangeImportInfo1( APCMIState : TK_PCMImportState ): TK_CMEDResult;
  function  EDAGetLastImportHistory1( APCMIState : TK_PCMImportState; APSlidesIDArr : TN_PIArray ): TK_CMEDResult;

//*********************************************************************
// Slide History
//
  function  EDASaveSlidesHistory( const ASQLStr: string;
                                               AHistActCode: Integer ) : TK_CMEDResult; virtual;
  function  EDASaveSlidesListHistory( APSlide: TN_PUDCMSlide;
                                                   ASlidesCount: Integer;
                                                   AHistActCode: Integer ) : TK_CMEDResult; virtual;

//*********************************************************************
// CMS Data Consistency Check
//
  function EDADataCheck( APObj : Pointer; ACheckPar : Integer ) : string; virtual;

//*********************************************************************
// Stand alone routines
//
  function  EDASAUDTabIndByID( ASAUDTable : TK_UDRArray; ASID : string  ) : Integer;
  function  EDASAGetLocalArchiveUDTab( const AUDTabName : string ) : TK_UDRArray;
  function  EDASAInitDBInfo( AInitFlags : Integer ) : TK_CMEDResult; virtual;
  function  EDASAGetLocationsInfo( AShowDelFlag : Boolean ) : TK_CMEDResult; virtual;
  function  EDASAGetOneLocationInfo( const ALocSID : string;
                       APCMSALocationDBData : TK_PCMSALocationDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult; virtual;
  function  EDASASetOneLocationInfo( var ALocSID : string;
                        APCMSALocationDBData : TK_PCMSALocationDBData;
                        ASkipFieldsSet : Boolean ) : TK_CMEDResult; virtual;
  function  EDASASetClearMarkLocatonAsDel( const ALocSID, AFlags : string ) : TK_CMEDResult; virtual;
  function  EDASADelLocation( const ALocSID : string  ) : TK_CMEDResult; virtual;
  function  EDASASyncLocationsInfo( ): TK_CMEDResult; virtual;
  function  EDASAGetProvidersInfo( AShowDelFlag : Boolean ) : TK_CMEDResult; virtual;
  function  EDASAGetOneProviderInfo( const AProvSID : string;
                       APCMSAProviderDBData : TK_PCMSAProviderDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult; virtual;
  function  EDASASetOneLoginPassword( const AProvSID : string;
                        AEncLoginPassword : string ) : TK_CMEDResult; virtual;
  function  EDASACheckLoginPassword( const AProvSID : string;
                        AEncLoginPassword : string ) : TK_CMEDResult; virtual;
  function  EDASASetOneProviderInfo( var AProvSID : string;
                       APCMSAProviderDBData : TK_PCMSAProviderDBData;
                       ASkipFieldsSet : Boolean ) : TK_CMEDResult; virtual;
  function  EDASASetClearMarkProviderAsDel( const AProvSID, AFlags : string  ) : TK_CMEDResult; virtual;
  function  EDASADelProvider( const AProvSID : string  ) : TK_CMEDResult; virtual;
  function  EDASASyncProvidersInfo( ): TK_CMEDResult; virtual;
  function  EDASAGetPatientsInfo( AShowDelFlag : Boolean; AGetAll : Boolean = FALSE ) : TK_CMEDResult; virtual;
  function  EDASAGetOnePatientInfo( const APatSID : string;
                       APCMSAPatientDBData : TK_PCMSAPatientDBData;
                       ALockFlags : TK_CMSAGetInfoFlags  ) : TK_CMEDResult; virtual;
  function  EDASACheckPatientCardNum( const APatSID, AParCardNum : string ) : TK_CMEDResult; virtual;
  function  EDASASetOnePatientInfo( var APatSID : string;
                       APCMSAPatientDBData : TK_PCMSAPatientDBData;
                       ASkipFieldsSet : Boolean ) : TK_CMEDResult; virtual;
  function  EDASASetClearPatientDelState( const APatSID, AFlags : string ) : TK_CMEDResult; virtual;
  function  EDASAGetPatientSlidesView( const APatSID : string; var ASlidesArray : TN_UDCMSArray ): TK_CMEDResult; virtual;
  function  EDASADelOnePatientSlides( const APatSID : string ): TK_CMEDResult; virtual;
  function  EDASADelAllDelPatientSlides( ): TK_CMEDResult; virtual;
  function  EDASASyncPatientsInfo(): TK_CMEDResult; virtual;

//*********************************************************************
// DICOM DIR Import|Export
//
  function  EDADCMCheckPatient( const APatSirname, APatFirstName, APatCardNum : string; APatDOB : TDate ) : Integer; virtual;

//*********************************************************************
// Extra Info
//
//  function  EDAAddExtraInfoStrings( AMacroStrings : TStrings ): TK_CMEDResult; virtual;

//*********************************************************************
// Print Logo Access
//
  function  EDAPrintLogoGetDIBByFile( ALogoFName : string ): TN_DIBObj;
  function  EDAPrintLogoGetDIB( ): TN_DIBObj; virtual;
  function  EDAPrintLogoSetByFile( const ALogoFName : string ): TN_DIBObj; virtual;
  function  EDAPrintLocMemIniSave : TK_CMEDResult; virtual;
  function  EDAPrintLocMemIniUnload( const APTFName : string ) : TK_CMEDResult; virtual;

//*********************************************************************
// Media Scan Device Plates Info
//
  function EDADevicePlateUseCountGet( const APlateName : string ) : Integer; virtual;
  function EDADevicePlateUseCountInc( const APlateName : string ) : Integer; virtual;


//*********************************************************************
// DICOM Series Info
//
  procedure EDADCMSeriesStart(); virtual;
  procedure EDADCMSeriesFin(); virtual;
end; // TK_CMEDAccess
//*** end of CMS External Data Access

{
type TK_CurLocSlideState = set of ( // Bufferd Slide Current State

);
}

const
// Active Delta to prevent real active control
// K_CMEDAActivateDelta  = 6000000;

// Active Timer Step Delta in msec
  K_CMEDAActivateTimerDeltaMS  = 1000;

// CMS Active Instance Delta in msec
  K_CMEDAActivateDeltaMS  = 60000;

// Active Delta in days = Active Delta in msec / Number msec in Day
  K_CMEDAActivateDeltaDD  = K_CMEDAActivateDeltaMS / (60000 * 24 * 60);

// ActiveTimeout in days = 3 * Active Delta in msec / Number msec in Day
  K_CMEDAActiveTimeout = 3 * K_CMEDAActivateDeltaDD;

// NotActiveTimeout in days
  K_CMEDANotActiveTimeout = 4 / 24;

// Time Delta in msec / Number msec in Day
//  K_CMEDATimeThreshold =  5 / (60000 * 24 * 60);
  K_CMEDATimeThreshold =  501 / (60000 * 24 * 60);

// Trial Running Period in minutes
  K_CMEDATrialRunningPeriod = 48 * 60;

// Minimal Server Free Space
  K_CMSMinServerFreeSpace = 500 * N_BytesInMB;
//  K_CMSMinServerFreeSpace = 500 * Int64(N_BytesInGB); // for debug

// Enough Server Free Space
  K_CMSLowServerFreeSpace = N_BytesInGB;
//  K_CMSLowServerFreeSpace = 500 * Int64(N_BytesInGB); // for debug

// Enough Server Free Space
  K_CMSNormServerFreeSpace = 2 * Int64(N_BytesInGB);
//  K_CMSNormServerFreeSpace = 500 * Int64(N_BytesInGB); // for debug

type TK_CMAppContextType = ( // Do not change Elements Order - it is used in actual Data Bases
  K_actGlobIni, // Global Ini Context 0 in GA mode
  K_actGInstIni,// Instance Ini Context 1
  K_actGInstUD, // Instance UDTree Context 2
  K_actPatIni,  // Patient Ini Context 3
  K_actProvIni, // Provider Ini Context 4
  K_actLocIni,   // Location Ini Context 5
  K_actProvInstIni,// Provider/Instance Ini Context 6
  K_actProvUD,   // Provider UDTree Context 7
  K_actGlobUD,   // Global UDTree Context 8
  K_actServerUD, // Server UDTree Context 9
  K_actLocUD,    // Location UDTree Context 10
  K_actGlobIni2, // Global Ini Context 1 not in GA mode 11
  K_actLocPrintIni, // Location Ini Context  not in GA mode 12
  K_actLocPrintLogo // Location Print Logo Context not in GA mode 13
  );
{
type TK_CMDBStatInfo = record
  CurSTS : TDateTime; // Current session Start Timestamp
  CurFTS : TDateTime; // Current session Final Timestamp
  FullMinutes : Integer;  // CMS full running time
  TrialMinutes : Integer; // CMS full running time when trial period start
//  TrialMode    : Boolean; // CMS trial period flag
end;
type  TK_PCMDBStatInfo = ^TK_CMDBStatInfo;
}
{
type TK_CMDBStatInfoFlags = set of (
  K_sifChangeTimestamp, // Change Final Timestamp
  K_sifStartTimeCount // Change Final Timestamp
  );
}

type TK_CMEDASelectFieldsFlags = set of (
  K_sffAddThumbField,      // Add Thumbnail Field
  K_sffAddMapRootField,    // Add MapRoot Field
  K_sffAddFieldsPrefix,    // Add Fields Prefix S.
  K_sffAddStudyOnlyFields, // Add Study only Fields
  K_sffAllFieldsForCopy    // All fields for copy in table without SlideID and PatID

);

type TK_CMEDASelectWhereFlags = (
  K_swfSkipFlagsCond,  // Skip Flags select condition
  K_swfSkipAllDel,     // Skip Marked as Deleted Slides and deleting from DB
  K_swfSkipDBDeleting, // Skip Slides in Deleting from DB State - for Enterprise only
  K_swfOnlyMarkedAsDel,// Only Marked as Deleted Slides - for Enterprise only
  K_swfOnlyDBDeleting  // Only Slides in DB Deleting State - for Enterprise only
);

type TK_CMEDAInstanceActModeFlags = set of (
  K_iafEGAMode, // Entreprise Global Administrator Mode
  K_iafDBMMode, // DB Maintenance Mode
  K_iafRLIMode, // DB Resample Large Images Mode Mode
  K_iafCSFMode  // Create Study Files Mode
);

const
  K_CMFilesSyncProcClientAppTypeID = 999; // Files Synchronization Process Application Local ID
  K_CMEDAInstanceNActiveStateFlag = 128;
  K_CMEDAInstanceStandaloneFlag   = 64;

//***************************************************************
// CMS TN_UDDIB file serialization/desrialization
//
var K_CMDIBFileFormatID : Integer = 1; // 0 - means old TN_UDDIB serialization
                                       // 1 - new DIB format without DIBNumBits
const K_CMDIBFileSignatue : AnsiString = 'DIB2';
type TK_CMDIBFileHeader1 = packed record // CMS DIB file header for Format Code = 1
  DIBFSignature   : array [0..3] of AnsiChar; // CMS DIB file data signature
  DIBFFormatID    : Integer;                  // CMS DIB file data format ID code
  DIBFFlagsN      : TN_UDDIBFlagsN;           // CMS TN_CDIBN.ÑDIBFlagsN field value
  DIBFDataFormat  : TN_UDDIBDataFormat;       // CMS TN_CDIBN.ÑDIBDataFormat field value
  DIBFByteR1      : Byte;                     // Reserved Byte
  DIBFJPEGQuality : Integer;                  // CMS TN_CDIBN.ÑDIBJPEGQuality field value
  DIBFDataSize    : Integer;                  // CMS TN_UDDIB UDData size
end;
type TK_PCMDIBFileHeader1 = ^TK_CMDIBFileHeader1;

var
  K_CMAddADOQuery : TADOQuery;     // Additional Query Data Set
  K_CMAddADOCommand : TADOCommand; // Additional SQL Command
  K_CMAddDBConnection : TADOConnection; // Additional Connection needed to get Slides Attributes before CMS Main Connection is active
  K_CMAddDBConnectionID : Integer;      // Additional Connection ID: 0 - access to AllSLides, 1 - access to AllProviders ...
//  K_CMEDAMSSQL : Boolean = TRUE; // Use MSSQL flag
  K_CMEDAMSSQL : Boolean = FALSE; // Use MSSQL flag

type TK_DBTransIsoLevel = (K_tilReadUncommitted, K_tilReadCommitted, K_tilRepeatableRead, K_tilSerializable);
//************************************************************ TK_CMEDDBAccess ***
// External Data DB Access Class
//
type TK_CMEDDBAccess = class (TK_CMEDAccess)
  constructor Create;
  destructor  Destroy; override;
  procedure EDARebuildADOObjects();
    private
  PrevConnectionErr: Boolean; // previous Connection Error Flag
  SyncTimeDelta : TDateTime;  // Time Shift for time Synchronization

  procedure EDAAppUnlockObjects( ASAppRTID: string );
    protected
//  WANDBConnection : TADOConnection;
  NextActiveTimeStamp  : Double;  // Next Active TimeStamp Action Time
  NextActiveTimeCount  : Integer; // Next Active TimeStamp Action Count
  LastFastTimeStamp    : Double;  // Last Fast TimeStamp Action Time
  TimeStampUID    : Int64;       // Last TimeStamp UID
//  ChngLockedSlide : TN_UDBase;   // SLide Locked for Changing
  ChngLockedSlideFlag : Boolean; // SLide is Locked for Changing Media File Flag
  ReconnectCounter    : Integer; // Reconnect Counter in Lost DB Connection case
  ReconnectNextActiveCount : Integer; // Next Reconnect Active Counter in Lost DB Connection case

  ArchSlideTIMG : TN_DIBObj;
  ArchSlideQTIMG : TN_DIBObj;

  function  EDAGetFilesHandlingDBContext( ): TK_CMEDResult;

  procedure EDAPrepStateAfterException; override;

//  function  EDARefreshCurSlidesSet(): TK_CMEDResult;
//  function  EDAFixIDsRangeDB( AUIDFieldName : string; ARangeSize : Integer ) : Integer;
  function  EDGetBlobFieldToDIB( ADataSet : TDataSet; AField : TField;
                                 out ADIBObj : TN_DIBObj ) : TK_CMEDResult;
  function  EDAGetSlideBlobFieldValue( const ASlideID: string;
                                  AFieldName : string;
                                  out APData : Pointer;
                                  out ADsize : Integer ): TK_CMEDResult;
  function  EDAPutSlideBlobFieldValue( const ASlideID: string; AFieldName : string;
                                   APData: Pointer; ADataSize: integer ): TK_CMEDResult;

  function  EDASplitMediaFileIsNeeded( AMediaSize : Int64 ): Boolean;
  function  EDACopyMediaFileToServer( ASlide : TN_UDCMSlide; const AFName : string ): TK_CMEDResult;
  function  EDASplitMediaStreamToFiles( AMFStream : TStream; const AMFNamePref : string;
                                        ADestRootFDA : Boolean ): TK_CMEDResult;
  function  EDAJoinFilesToMediaStream( AMFStream : TStream; const AMFNamePref : string;
                                       ASrcRootFDA : Boolean ): TK_CMEDResult;
  function  EDALocFilesInfoQuery( const ASlideID : string = '' ) : TK_CMEDResult;
  function  EDACheckSLideUpdates( APCMSlideFields: TN_PCMSlide; var ASlideChageTS : TDateTime;
                             ASlidesDSet : TADOQuery;
                             APropTSFInd, AMapRootTSFInd, AImgTSFInd : Integer ) : TK_CMEDBUStateFlags;
    public
  LANDBConnection : TADOConnection; // Main Connection
//  CurTmpTableExists : Boolean;
//  AddDBConnection : TADOConnection; // Additional Connection needed to get Slides Attributes before CMS Main Connection is active
  CurSQLCommand1  : TADOCommand; // Common SQL Command object 1
  CurDSet1        : TADOQuery;   // Common SQL Query Data Set 1
  CurDSet2        : TADOQuery;   // Common SQL Query Data Set 2
  CurDSet3        : TADOQuery;   // Common SQL Query Data Set 3
  CurSlidesDSet   : TADOQuery;   // Current Slides Data Set
  CurSlidesLocDSet: TADOQuery;   // Current Slides Data Set for request to LocFilesInfo Table
  CurBlobDSet     : TADOQuery;   // Common SQL Blobs Query Data Set
  CurStoredProc1  : TADOStoredProc; // Common Stored Procedure object1

  SlideStudyInfoUpdateStrings : TStringList;  // SlideStudyInfoUpdateStrings needed store Slide->StudyItem link info

  ImgDBFileCompressPower : Integer; // File Stored via DB Compress Power;
  ClientAppTypeID : Integer; // Client Application Instance Type ID get from D4W Client
  ClientAppGlobID : Integer; // Client Application Instance Global ID retrieved by ClientAppTypeID and Client Computer Virtual ID
  CurServID       : Integer; // Current Server ID
  AppRTID    : Integer; // Application Instance dynamic runtime ID,
                        // needed to Slides Location. Is get just after DB connection
                        // is established and Application Instance Activity is
                        // match by regular renewing activity timestamp

  UDRootServerInfo       : TN_UDBase;     // Server Data UDRoot
  UDRootLocationInfo     : TN_UDBase;     // Location Data UDRoot

//*********************************************************************
// CMS Files Server Paths context
//
  SlidesImgRootFolder  : string;  // Slides Image Files Root Folder
  SlidesImgRootFDA     : Boolean; // Direct Access to Images Files at Root Folder from CLient Computer
  SlidesImgRootEFolder : string;  // Slides Image Files Root Folder External Path

  SlidesMediaRootFolder: string;  // Slides Media Files Root Folder
  SlidesMediaRootFDA   : Boolean; // Direct Access to Media Files at Server Root Folder from CLient Computer
  SlidesMediaFSplit    : Boolean; // Split Media Files Flag
  SlidesMediaRootEFolder  : string; // Slides Media Files Root Folder External Path

  SlidesMediaImgSameDrive : Boolean;// Slides Img/Media Files same drive Flag

  SlidesImg3DRootFolder   : string; // Slides 3D Image Files Root Folder
  SlidesImg3DImgSameDrive : Boolean;// Slides Img/Media Files same drive Flag

  SyncSessionStartTS : TDateTime; // Files Sync Session Start Timesatmp
  SyncSessionFinTS   : TDateTime; // Files Sync Session Fin Timesatmp
//  SyncSessionPeriod  : Integer;   // Files Sync Session Periodicity
  SyncSessionFlags   : Integer;   // Files Sync Session Flags:
  //             bit0=1 - compulsary synchronization to Head Office

  SaveSlidesAttrsFiles : Boolean;
//  function  EDAStringsToDBText( AStrings : TStrings; out APData : Pointer ) : Integer;
//  function  EDADBTextToString( var APData : Pointer; ADSize : Integer ) : Integer;
//  Skip

//*********************************************************************
// CopyMove patient objects Context
  WaitCMPProcID : Integer; //


//*********************************************************************
// Logo File CRC
  LogoFileCRC   : LongWord; // Logo file CRC to create Logo file name in WrkFiles
  LogoFileLocID : Integer;  // Logo file CRC Location ID

//*********************************************************************
// ClearInstLostRecords
  InstLostRecordsCount : Integer;

//*********************************************************************
// CMS DB Access Syncronization and Sybase|MSSQL specific
//
  function  EDADBIsolationLevelSet( AILevel : TK_DBTransIsoLevel ) : string;
  function  EDADBIsolationLevelDefault( ) : string;
  function  EDADBDateTimeToSQL( ADT : TDateTime; const AFormatStr : string = '' ) : string;
  function  EDADBDateToSQL( ADT : TDateTime ) : string;

//*********************************************************************
// Blob Fields Access Access
//
  function  EDAGetBlobFieldValue( ADataSet : TDataSet; AField : TField;
                            out APData: Pointer; out ADataSize : Integer ) : TK_CMEDResult;
  function  EDAPutBlobFieldValue( ADataSet : TDataSet; AField : TField;
                             APData: Pointer; var ADataSize: integer;
                             ACurCompressPower: integer = -1 ) : TK_CMEDResult;
{
  function  EDPutBlobFieldFromDIB( ADataSet : TDataSet; AField : TField;
                 ADIBObj : TN_DIBObj; AMimeType : TK_GPImgMimeType;
                 AGPAttr : Integer ) : TK_CMEDResult;
}
  function  EDPutBlobFieldFromDIB( ADataSet : TDataSet; AField : TField;
                 ADIBObj : TN_DIBObj; ARIEncType : TK_RIFileEncType;
                 ARIEncAttr : Integer ) : TK_CMEDResult;

//*********************************************************************
// CMS Slide Data Access
//
  function  EDASlideDataToFile( APData: Pointer; var ADataSize: integer; const AImgFName : string ): TK_CMEDResult; override;

//*********************************************************************
// CMS DB Fields Access
//
  procedure EDAPutStringFieldValue( AField: TField; const AStr: string );
  function  EDAGetStringFieldValue( AField: TField  ): string;

//*********************************************************************
// CMS Common Routines
//
  procedure EDADumpActiveContext( ADataSet : TADOQuery; ARStrings : TStrings; ASkipSelfFlag : Boolean = FALSE );
  procedure EDASetActiveTimeStamp( Sender : TObject );
  function  EDAAppActivate( ): TK_CMEDResult;
  function  EDAAppDeactivate( ): TK_CMEDResult;
  function  EDAClearActiveContext(): TK_CMEDResult;
  function  EDAGetSlidesFPathContext( ALocID : Integer = -1 ): TK_CMEDResult; override;
//  procedure EDAGetSlideSysFieldsData( const ASysInfo : string; APCMSlideSDBF : TN_PCMSlideSDBF );
  procedure EDADBConnect( ADBConnection: TADOConnection );
  function  EDACheckDBConnection( ADBConnection : TADOConnection;
                                  AShowMessageFlag : Boolean = TRUE ) : TK_CMEDResult;
  function  EDAPathOrFileExists( const AFName : string; AFilesDA : Boolean; APathFlag : Boolean ): TK_CMEDResult;
  function  EDAGetSlideImgPath( AUDSlide: TN_UDCMBSlide ): string;
  function  EDAGetSlideImg3DPath( AUDSlide: TN_UDCMBSlide ): string;
  function  EDAGetDICOMPath(AUDSlide: TN_UDCMBSlide): string;
  function  EDACheckFSSettings(  ) : Integer; override;
  function  EDACheckActiveInstances( AFlags : Integer ) : Integer;

//*********************************************************************
// CMS File Handling Routines
//
  function  EDAFileDelete( const AFName : string; AFilesDA : Boolean ): TK_CMEDResult;
  function  EDAForceFilePath( const AFPath : string; AFilesDA : Boolean;
                              ARaiseExcept : Boolean ): TK_CMEDResult;
  function  EDARenameFileOnServer( const ASFName, ADFName: string;
                                   AFDA: Boolean ): TK_CMEDResult;
  function  EDACopyFileOnServer( const ASFName, ADFName : string;
                                 AFDA : Boolean ): TK_CMEDResult;
  function  EDACopyFilesOnServer( const ASFPath, ADFPath, AFilesPat : string;
                                  AFDA : Boolean ): TK_CMEDResult;
  function  EDACopyFileToServer( const ASFName, ADFName : string;
                                 ADestFDA : Boolean ): TK_CMEDResult;
  function  EDACopyFileFromServer( const ASFName, ADFName : string;
                                   ASrcFDA : Boolean ): TK_CMEDResult;
//*********************************************************************
// CMS Current Context Interface
//
  procedure EDAGetVersionRegInfo( );
  function  EDAGetSyncTimestamp( ATime : TDateTime = 0 ) : TDateTime; override;
  function  EDAGetDBFilePath( out ADBFilePath : string ) : TK_CMEDResult;

  function  EDAGetOneAppContextDBField( ASContType, ASContID, ASContID1: string;
                                 ADataSet: TADOQuery; out AField: TField ): TK_CMEDResult;
  function  EDAGetOneAppContext( ASContType, ASContID, ASContID1 : string;
                                 out APData: Pointer; out ADSize : Integer ) : TK_CMEDResult;
  function  EDAOneAppContextToMemIni( AContType, AContID, AContID1 : Integer;
                                      ADFPLNameCopy : string = ''; ADFPLNameClear : string = '' ) : TK_CMEDResult;
  function  EDAAppContextToCurState( ANPatId, ANProvID, ANLocID : Integer ) : TK_CMEDResult; override;
  function  EDASaveOneAppContext0( ADataSet: TADOQuery;
                                   AContType, AContID, AContID1: Integer;
                                   APData: pointer; ADSize : Integer;
                                   ACurCompressPower : Integer = -1 ): TK_CMEDResult;
  function  EDASaveOneAppContext( ADataSet : TADOQuery;
                                  AContType, AContID, AContID1 : Integer;
                                  AContObj : TObject = nil ) : TK_CMEDResult;
  function  EDAAddOneAppMemIniContext( AScriptName: string; AInitContext : Boolean ): Boolean;
  function  EDASaveOneAppMemIniContext0( AContType, AContID, AContID1: Integer): TK_CMEDResult;
  function  EDASaveOneAppMemIniContext( AContType, AContID, AContID1: Integer; AScriptName: string ): TK_CMEDResult;
  function  EDASaveContextsData( ASaveFlags : TK_CMEDSaveStateFlags = [] ) : TK_CMEDResult; override;

  function  EDAGAGlobalToCurState : TK_CMEDResult; override;
  function  EDANotGAGlobalToCurState : TK_CMEDResult; override;
  function  EDANotGAGlobalToMemIni : TK_CMEDResult; override;
  function  EDANotGAGlobalToMemIni1 : TK_CMEDResult; override;
  function  EDALocationToCurState() : TK_CMEDResult; override;
  function  EDALocationToMemIni1() : TK_CMEDResult; override;

  function  EDAInit() : TK_CMEDResult; override;
  function  EDASetInstanceState( ASetActive : Boolean; AStateFlag : Integer ) : TK_CMEDResult; override;
  function  EDAServUDTreeInit(): TK_CMEDResult;
  function  EDALocUDTreeInit(): TK_CMEDResult;

//*********************************************************************
// Slide Access
//
  function  EDAGetSlideSelectFieldsStr(
                         ACtrlFlags : TK_CMEDASelectFieldsFlags ) : string;
  function  EDAGetSlideSelectFromStr( ) : string;
//  function  EDAGetSlideSelectWhereStr( ACtrlFlags : TK_CMEDASelectWhereFlags;
//                                       AFieldPref : string = '' ) : string;
  function  EDACheckSlideMedia( ASlide : TN_UDCMSlide; ASkipShowDlg : Boolean = FALSE ): TK_CMEDResult; override;
  function  EDARemovePathFolders1( AFName : string; const APathBase : string; ADAFlag : Boolean ) : TK_CMEDResult;
  function  EDADelSlideImgFiles( ASlide: TN_UDCMBSlide ) : TK_CMEDResult;
  function  EDADelSlideMediaFiles( ASlide: TN_UDCMSlide ) : TK_CMEDResult; override;
  function  EDADelSlideImg3DFiles( ASlide: TN_UDCMSlide ) : TK_CMEDResult;
  function  EDAClearSlideImgFolders( ASlideImgFName : string ) : TK_CMEDResult;
  function  EDAAddSessionHistRecord( ANPatID : Integer = -1;
                                     ANProvID : Integer = -1;
                                     ANLocID  : Integer = -1 ) : TK_CMEDResult; override;
//  function  EDALockActiveContext(): TK_CMEDResult; override;
  function  EDALockActiveContext1( ANPatID, ANProvID, ANLocID : Integer ): TK_CMEDResult; override;
  function  EDALockSlideForRW( const ASlideID: string;
                              ALockFileMode : TK_CMEDLockFileMode ): TK_CMEDResult;
  function  EDAWaitForCurSlideRWLock( const ASlideID : string; ALockFileMode : TK_CMEDLockFileMode ): TK_CMEDResult;
  function  EDALockSlides( APSlide: TN_PUDCMSlide; ASlidesCount : Integer;
                           ALockResultMode : TK_CMEDLockResultMode;
                           APatID : Integer = -1 ): TK_CMEDResult; override;
  function  EDAUnlockSlides( APSlide: TN_PUDCMSlide; ASlidesCount : Integer;
                             ALockResultMode : TK_CMEDLockResultMode ): TK_CMEDResult; override;
//  procedure EDAAddSlide( ASlide : TN_UDBase ); override;
  function  EDAStoreSlideNewMediaData( ASlide: TN_UDCMSlide ): TK_CMEDResult; override;
  function  EDASetCurSlide         ( ASlide: TN_UDCMSlide; AUpdateMode : Boolean = false ) : TK_CMEDResult; override;

  function  EDAClearDeletedSlides  ( AMarkAsDelFlag : Boolean ) : TK_CMEDResult; override;
  function  EDAUnDeleteSlides      ( APSlides: TN_PUDCMSlide; ASlidesCount: Integer ): TK_CMEDResult; override;
  function  EDAClearLocDelSlides   ( AClearNum : Integer ) : TK_CMEDResult;
  function  EDAClearMarkAsDelSlides( AClearNum : Integer ): TK_CMEDResult;
  function  EDAGetNewSlidesStartID ( ANCount : Integer ) : Integer; override;

  function  EDASaveSlideHistBuffer( ASlide : TN_UDCMSlide; AHistCode : Integer ): TK_CMEDResult;
  function  EDASaveSlideFields     () : TK_CMEDResult; override;
  function  EDASaveSlideLocFields  (): TK_CMEDResult;
  function  EDASaveSlideThumbnail  () : TK_CMEDResult; override;
  function  EDASaveSlideMapRoot    (): TK_CMEDResult;
  function  EDASaveSlideAttrsToFile( ASaveToArchiveFlag : Boolean ): TK_CMEDResult;
  function  EDASaveSlide           ( ASlide: TN_UDCMSlide ): TK_CMEDResult; override;

  function  EDASlideDataFromFile( out APData : Pointer; out ADSize : Integer;
                                  const AImgFName : string; out AFSize : Integer ): TK_CMEDResult; override;
  function  EDAGetSlideFields      ( ASlide: TN_UDCMSlide; AGetStudyLinkInfo : Boolean = FALSE; ADataSet : TObject = nil ) : TK_CMEDResult; override;
  function  EDAGetSlideLocFields   ( ASlide: TN_UDCMSlide;
                                     ASlideDTImgMod : TDateTime = 0 ): TK_CMEDResult;
  function  EDAGetSlideThumbnail   ( ASlide: TN_UDCMBSlide ) : TK_CMEDResult; override;
  function  EDACalcBySlidesSelectAttrs( out ASlidesCount : Integer ) : TK_CMEDResult; override;

  function  EDARefreshCurSlidesSet( out ANewSlidesCount, ADelSlidesCount,
                                    AUpdateSlidesCount : Integer ) : TK_CMEDResult; override;
  function  EDAGetCurSlidesSet     ( ) : TK_CMEDResult; override;
  function  EDAGetUDCMSlidesByID0  ( APSlideIDs: PInteger; ACount: Integer;
                                     var ASLides: TN_UDCMSArray ): TK_CMEDResult;
  function  EDAGetUDCMSlidesByID   ( APSlideIDs : PInteger; ACount : Integer;
                                     var ASlides : TN_UDCMSArray ) : TK_CMEDResult; override;
  function  EDAUpdateSlide         ( ASlide: TN_UDCMSlide;
                                     ASkipCurImgLoad : Boolean = false ) : TK_CMEDResult;
  function  EDAGetSlideMapRoot0    (ASlide: TN_UDCMSlide ) : TK_CMEDResult;
  function  EDAGetSlideMapRoot     ( ASlide: TN_UDCMSlide;
                                     ASkipLoad : Boolean = false;
                                     ASkipCurImgLoad : Boolean = false ): TK_CMEDResult; override;
  function  EDACheckSlideImageData ( const AFName : string;
                                     out APData : Pointer; out ADSize : Integer;
                                     out AFSize : Integer;
                                     ACheckLevel : Integer ) : Integer;
  function  EDAGetSlideCurImage0   ( ASlide: TN_UDCMSlide ): TK_CMEDResult; override;
  function  EDAGetSlideCurImage    ( ASlide: TN_UDCMSlide;
                                     ASkipLoad : Boolean = false ): TK_CMEDResult; override;
  function  EDAGetSlideSrcImage    ( ASlide: TN_UDCMSlide;
                                     ASkipLoadFlag : Boolean = false ) : TK_CMEDResult; override;
  procedure EDASetSlideMediaFileTMPName( ASlide: TN_UDCMSlide; const AMediaFExt: string ); override;
  procedure EDASetPatientSlidesUpdateFlag(); override;
  procedure EDAGetPatientSlidesUpdateTS(); override;

  function  EDACheckSlideImg3DData ( const AFPath : string;
                                     ACheckLevel : Integer;
                                     var AErrFileRPath : string ) : Integer;
//*********************************************************************
// Study Access
  function  EDAStudySetCur    ( AStudy: TN_UDCMStudy ) : TK_CMEDResult; override;
  function  EDAStudyGetFields ( AStudy: TN_UDCMStudy; ADataSet : TADOQuery = nil ): TK_CMEDResult;
  function  EDAStudyGetMapRoot( AStudy: TN_UDCMStudy ) : TK_CMEDResult; override;
  function  EDAStudySaveFields(): TK_CMEDResult; override;
  function  EDAStudySave( AStudy: TN_UDCMStudy ) : TK_CMEDResult; override;
  function  EDAStudyCaptStartPosGet( AStudy: TN_UDCMStudy ) : TK_CMEDResult; override;
  function  EDAStudyCaptStartPosSavingPrep( AStudy: TN_UDCMStudy ) : TK_CMEDResult; override;
  function  EDARestoreAllMountedSlidesLinks( AStudiesList : TStringList ): TK_CMEDResult;
  function  EDAStudySavingStart() : TK_CMEDResult; override;
  function  EDAStudySavingFinish() : TK_CMEDResult; override;
  procedure EDAStudyAddSlideLinkInfo( const ASlideID, AlinkInfo : string );
  function  EDAStudyDismountOneSlideFromItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide = nil; AStudy: TN_UDCMStudy = nil; ARuntimeInfoOnly : Boolean = FALSE ) : TK_CMEDResult; override;
  function  EDAStudyMountOneSlideToEmptyItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE ) : TK_CMEDResult; override;
  function  EDAStudyDismountAllSlidesFromItem( AItem: TN_UDBase; out ASlides : TN_UDCMSArray; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                               ASelfItemFRFlags : Integer = 0; ASelfItemTeethFlags : Int64 = 0;
                                               AMountItemFRFlags : Integer = 0; AMountItemTeethFlags : Int64 = 0 ) : TK_CMEDResult; override;
  function  EDAStudyMountAllSlidesToEmptyItem( AItem: TN_UDBase; ASlides : TN_UDCMSArray; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                               ASelfItemFRFlags : Integer = 0; ASelfItemTeethFlags : Int64 = 0 ) : TK_CMEDResult; override;
  function  EDAStudyMountAddSlideToItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                         ASelfItemFRFlags : Integer = -1; ASelfItemTeethFlags : Int64 = -1 ) : TK_CMEDResult; override;
  function  EDAStudySaveToFile( AStudy: TN_UDCMStudy ) : TK_CMEDResult;
  function  EDAStudySaveAttrsToFile( const AStudyID, AFilesPath : string;
                                     APCMStudy : TN_PCMSlide;
                                     AStudySID, AStudySICount : Integer;
                                     AStudyLinksInfo : TStrings ) : TK_CMEDResult;
  function  EDAStudyGetAttrsFromFile( const AFileName : string;
                                      AStudyLinksInfo : TStrings;
                                      APCMStudy : TN_PCMSlide = nil;
                                      APStudySID : PInteger = nil;
                                      APStudySICount : PInteger = nil ) : TK_CMEDResult;
  function  EDAStudyGetLinksInfoFromDB( const ASStudyID : string;
                                        ADataSet : TADOQuery;
                                        AStudyLinksInfo : TStrings ) : TK_CMEDResult;
  function  EDACalcFixStudyDataModeByTime( ANumHours : Integer ): Integer;
  function  EDAGetFixStudyDataMode() : TK_CMEDResult;
  function  EDAChangeFixStudyDataMode( AClearFixMode : Boolean = FALSE ) : TK_CMEDResult;

  function  EDAStudyTemplatesPrepare() : TK_CMEDResult; override;

//*********************************************************************
// Media Types Access
  function  EDAGetAllMediaTypes0 ( ): TStrings; override;
  function  EDASearchMediaTypeTitle( ADataSet : TADOQuery; AMTypeTitle: string;
                                     out AMTypeID: Integer ): TK_CMEDResult;
  function  EDAddNewMediaType ( out AMTypeID : Integer; const AMTypeTitle : string ): TK_CMEDResult; override;
  function  EDADeleteMediaTypeByID( AMTypeID : Integer; out APatID: Integer ): TK_CMEDResult; override;
  function  EDARenameMediaType ( AMTypeID : Integer; AMTypeTitle : string ): TK_CMEDResult; override;

//*********************************************************************
// Utilities
  function  EDAddInitialMediaTypes ( APInitMTypesNum : PInteger = nil ): TK_CMEDResult; override;
  function  EDAClearAllEData(): TK_CMEDResult; override;
  function  EDAGetDirFreeSpace( const AFPath : string; ADAFlag : Boolean;
                                out AFreeSpace : Int64 ): TK_CMEDResult; override;
  function  EDAGetImg3DDiskFreeSpace( out AFreeSpace: Int64): TK_CMEDResult;
  function  EDAGetImgDiskFreeSpace( out AFreeSpace : Int64 ): TK_CMEDResult; override;
  function  EDAGetVideoDiskFreeSpace( out AFreeSpace : Int64 ): TK_CMEDResult; override;
  function  EDAVideoFolderAccessPrevCheck() : Boolean; override;
  function  EDACheckImgFilesFolderAccess() : Integer; override;
  function  EDACheckVideoFilesFolderAccess() : Integer; override;
//  function  EDACheckVideoFolderAccessDlg() : Boolean; override;
  function  EDACheckFilesFolderAccess( const AFPath: string;
                                       ADAFlag : Boolean ): Integer;
  function  EDACheckFilesAccessBySlidesSet( APUDSlide: TN_PUDCMSlide;
                                            ASlidesCount : Integer;
                                            const AddWarnStr : string;
                                            AMDButtons : TMsgDlgButtons = [];
                                            AMDResult : word = mrOk ): Integer; override;
  function  EDACheckAllFilesAccess( AFImgCheck: Boolean;
                                    AFVideoCheck: Boolean;
                                    AFImg3DCheck: Boolean;
                                    const AddWarnStr2 : string;
                                    const AddWarnStr1 : string = '';
                                    AMDButtons : TMsgDlgButtons = [];
                                    AMDResult : word = mrOk ): Integer; override;
  function  EDACheckFoldersEquality1( AFPath1 : string; AFDA1 : Boolean;
                                      AFPath2 : string; AFDA2 : Boolean ) : Boolean;
  function  EDAWarnMinFreeSpace( AFreeSpace : Int64; ADriveName : string ) : Integer;
  function  EDACheckMinDiskFreeSpace( ) : Boolean; override;
  procedure EDABuildSelectSQLBySlidesList( APSlide: TN_PUDCMSlide;
               ASlidesCount: Integer; APSQLStr, APLogStr : PString );
  procedure EDABuildXMLBySlidesList( APSlide: TN_PUDCMSlide;
               ASlidesCount: Integer; const AXMLFormat : string;
               APXMLStr, APLogStr : PString );
//  function  EDALockUnlockEGAMode( ALockGAMode: Integer ): TK_CMEDResult;
  function  EDALockUnlockActMode( AActModeFlag : TK_CMEDAInstanceActModeFlags; ALockMode: Integer ): TK_CMEDResult;
  procedure EDAGetDCMStudiesAttrs( APSlide: TN_PUDCMSlide;
               ASlidesCount: Integer; out AStudiesSID : TN_SArray;
               out AStudiesTS : TN_DArray ); override;
  procedure EDAGetDCMStudiesUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
               ADCMFNames : TN_SArray;
               out AStudiesUID, AStudiesSID : TN_SArray; out AStudiesTS : TN_DArray ); override;
  procedure EDAGetDCMSeriesUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
               ADCMFNames : TN_SArray;
               out ASeriesUID, ASeriesSID  : TN_SArray; out ASeriesTS  : TN_DArray ); override;
  procedure EDAGetDCMSlideUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
               out ADCMFNames, AContentUID, AContentSID : TN_SArray; out AContentTS, AcqTS : TN_DArray ); override;
  function  EDAClearGAMode() : TK_CMEDResult; override;
  function  EDAScanFilesToClearImg3DTmpFiles( const APathName, AFileName : string; AScanLevel : Integer ) : TK_ScanTreeResult;
  function  EDAClearInstLostRecords(): Boolean;

//*********************************************************************
// CopyMove patient objects
  function  EDAPatObjCopyMoveProcCheck( ): Boolean;
//  function  EDAPatObjCopyMoveProcCheck( ACMPProcID : Integer ): TK_CMEDResult; overload;
  function  EDAPatObjCopyMoveProcResume( ACMPProcID : Integer; AShowResDlgFlag : Boolean ): Integer;
  function  EDAPatObjCopyMoveProcGet( out ACMPProcID : Integer;
                     APatID : Integer; AMode : Integer ): TK_CMEDResult;
  function  EDAPatObjCopyMoveProcLaunch( out ACMPProcID : Integer;
                ACMPatSrc, ACMPatDst : Integer; ACMPMoveMode : Boolean ) : TK_CMEDResult;

//*********************************************************************
// Change Image Files Path
  function  EDAGetSlidesFilesInfo( out AFilesPath : string; out AFilesCount : Integer;
                                   out AFilesSize : Int64; out AFilesDA : Boolean ): TK_CMEDResult;
  function  EDAPrepSlidesFilesMoving( const ANewFPath : string; ADAFlag,
                                      ASplitFlag, ASkipMovingSlidesContext : Boolean): TK_CMEDResult;
  function  EDACopyNextSlideFiles( ): TK_CMEDResult;
  function  EDAPrepClearFilesMoving( const AFPath : string; ADAFlag, ASplitFlag : Boolean ): TK_CMEDResult;
  function  EDARestoreFilesContext( const AFPath : string; ADAFlag, ASplitFlag : Boolean ): TK_CMEDResult;
  function  EDASetFilesEnterpriseContext( ): TK_CMEDResult;
  function  EDADelNextSlideFiles( ): TK_CMEDResult;
  function  EDAPrepSetFilesPathInfo( const AFPath : string;
                   ADAFlag, ASplitFlag, AEmptyFolder : Boolean ): TK_CMEDResult;
  function  EDAPrepSetFilesPathInfo1( const AFPath : string; ASkipPrepSlidesMovingContext : Boolean ): TK_CMEDResult;
  function  EDASetFilesPathInfo( ): TK_CMEDResult;
  function  EDASaveCurFilePathsInfoToDB( ): TK_CMEDResult;
  function  EDACheckNextSlideFiles( ): TK_CMEDResult;
  function  EDAClearFilesMovingInfo( ): TK_CMEDResult;

//*********************************************************************
// Media Files Storing Config
  procedure EDAConfigGetInfo( const AInfoFName : string );
  procedure EDAConfigSetInfo( const AInfoFName : string );

//*********************************************************************
// Licensing Info
//!!SkipOldReg  function  EDASetLicenseKeyInfo( APData : Pointer; ADataSize : Integer ): TK_CMEDResult;
//!!SkipOldReg  function  EDAGetLicenseKeyInfo( ADataSet : TDataSet; AField : TField ): TK_CMEDResult;
  function  EDAAddRegInfoStrings( AMacroStrings : TStrings ): TK_CMEDResult;
//!!SkipOldReg  function  EDACheckDevicesLicensing( AStrings : TStrings ): TK_CMEDResult;


//*********************************************************************
// Save Statistic and CMS Version Trial Period Control and Global Setting
//  function  EDASaveStatInfo( AStatInfoFlags : TK_CMDBStatInfoFlags ): TK_CMEDResult;
//  function  EDASaveDBGlobalContext( ): TK_CMEDResult;

//*********************************************************************
// Emergency Cache Routines
  procedure EDASaveSlideToECache( AUDSlide: TN_UDCMSlide ); override;
  procedure EDAClearSlideECache( AUDSlide: TN_UDCMSlide ); override;

//*********************************************************************
// Import History
  function  EDAAddImportHistory( out AImportID : Integer ): TK_CMEDResult; override;
  function  EDAChangeImportInfo( AImportID : Integer; const AImportInfo : string; ADumpFlag : Integer = 0 ): TK_CMEDResult; override;
  function  EDAGetLastImportHistory( out AImportID : Integer; out AImportDate : TDateTime;
                                     out AImportInfo : string ): TK_CMEDResult; override;
  function  EDADeleteImportHistory( AImportID : Integer ): TK_CMEDResult; override;

//*********************************************************************
// Slide History
  function  EDASaveSlidesHistory( const ASQLStr: string;
                                               AHistActCode: Integer ) : TK_CMEDResult; override;
  function  EDASaveSlidesListHistory( APSlide: TN_PUDCMSlide;
                                                   ASlidesCount: Integer;
                                                   AHistActCode: Integer ) : TK_CMEDResult; override;

//*********************************************************************
// CMS Entreprise Mode Routines
//
  function  EDAEMGetLocCaptsList( ALocList : TStrings ) : TK_CMEDResult;
  function  EDAEMSetSlidesHLoc( APSlide: TN_PUDCMSlide;
                  ASlidesCount: Integer; ANewHlocID: Integer ) : TK_CMEDResult;
  procedure EDAEMDumpSFSyncSessionAttrs( const AInfo : string );
  function  EDAEMGetFSyncSessionTime( out ASSStartTS, ASSFinTS : TDateTime ) : TDateTime;
  function  EDAEMGetFSyncSessionAttrs( ): TK_CMEDResult;
  function  EDAEMSaveFSyncSessionAttrs( ): TK_CMEDResult;

//*********************************************************************
// CMS Data Consistency Check
//  function EDADataCheck( APObj : Pointer; ACheckPar : Integer ) : string; override;

//*********************************************************************
// CMS Get Patients Info Auxiliary Routines
//
  function  EDAGetPatientsOrderSQL( AOrderCode : Integer ) : string;
  function  EDAGetPatientsWhereSQL( AShowDelFlag : Integer;
                       const ACardNumLike, ASurnameLike, AFirstnameLike : string ) : string;
  function  EDAGetPatientsFilteredCount( const AWhereSQL : string;
                                         out AllPatCount : Integer ) :  TK_CMEDResult;

//*********************************************************************
// CMS WEB Access Routines
//
  function  EDAWEBGetPatientsInfo( const AWhereSQL, AOrderSQL : string;
                                   AStartInd : Integer; ACount : Integer;
                        out APatAttrsArr : TK_WCMSPatAttrsArr ) : TK_CMEDResult;

//*********************************************************************
// Stand alone routines
//
  function  EDASAInitDBInfo( AInitFlags : Integer ) : TK_CMEDResult; override;

  function  EDASAGetLocationsInfo( AShowDelFlag : Boolean ) : TK_CMEDResult; override;
  function  EDASAGetOneLocationInfo( const ALocSID : string;
                       APCMSALocationDBData : TK_PCMSALocationDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult; override;
  function  EDASASetOneLocationInfo( var ALocSID : string;
                        APCMSALocationDBData : TK_PCMSALocationDBData;
                        ASkipFieldsSet : Boolean ) : TK_CMEDResult; override;
  function  EDASASetClearMarkLocatonAsDel( const ALocSID, AFlags : string ) : TK_CMEDResult; override;
  function  EDASADelLocation( const ALocSID : string  ) : TK_CMEDResult; override;
  function  EDASAUpdateLocationsByLinkInfo( ) : TK_CMEDResult;
  function  EDASAUpdateOneLocationByLinkInfo( APCLLLocAttrs : TK_PCMSCLLLocationAttrs ) : TK_CMEDResult;

  function  EDASAGetProvidersInfo( AShowDelFlag : Boolean ) : TK_CMEDResult; override;
  function  EDASAGetOneProviderInfo( const AProvSID : string;
                       APCMSAProviderDBData : TK_PCMSAProviderDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult; override;
  function  EDASASetOneLoginPassword( const AProvSID : string;
                        AEncLoginPassword : string ) : TK_CMEDResult; override;
  function  EDASACheckLoginPassword( const AProvSID : string;
                        AEncLoginPassword : string ) : TK_CMEDResult; override;
  function  EDASASetOneProviderInfo( var AProvSID : string;
                       APCMSAProviderDBData : TK_PCMSAProviderDBData;
                       ASkipFieldsSet : Boolean ) : TK_CMEDResult; override;
  function  EDASASetClearMarkProviderAsDel( const AProvSID, AFlags : string  ) : TK_CMEDResult; override;
  function  EDASADelProvider( const AProvSID : string  ) : TK_CMEDResult; override;
  function  EDASAUpdateProvidersByLinkInfo( ) : TK_CMEDResult;
  function  EDASAUpdateOneProviderByLinkInfo( APCLLProvAttrs : TK_PCMSCLLProviderAttrs ) : TK_CMEDResult;
  function  EDAGetOneProviderHistAttrs( const AProvSID : string;
                       APCMProviderHistCapt : PString ) : TK_CMEDResult;

  function  EDASAGetPatientsInfo( AShowDelFlag : Boolean; AGetAll : Boolean = FALSE ) : TK_CMEDResult; override;
  function  EDASAGetPatientsInfo1( AShowDelFlag : Integer; AOrderCode : Integer;
                       const ACardNumLike, ASurnameLike, AFirstnameLike : string;
                       AStartInd : Integer; ACount : Integer ) : TK_CMEDResult;
  function  EDASAGetOnePatientInfo( const APatSID : string;
                       APCMSAPatientDBData : TK_PCMSAPatientDBData;
                       ALockFlags : TK_CMSAGetInfoFlags  ) : TK_CMEDResult; override;
  function  EDASACheckPatientCardNum( const APatSID, AParCardNum : string ) : TK_CMEDResult; override;
  function  EDASASetOnePatientInfo( var APatSID : string;
                       APCMSAPatientDBData : TK_PCMSAPatientDBData;
                       ASkipFieldsSet : Boolean ) : TK_CMEDResult; override;
  function  EDASASetClearPatientDelState( const APatSID, AFlags : string ) : TK_CMEDResult; override;
//  function  EDASAMarkPatientAsDel( const APatSID : string ) : TK_CMEDResult;
  function  EDASAGetPatientSlidesView( const APatSID : string; var ASlidesArray : TN_UDCMSArray ): TK_CMEDResult; override;
  function  EDASADelOnePatientSlides( const APatSID : string ): TK_CMEDResult; override;
  function  EDASADelAllDelPatientSlides( ): TK_CMEDResult; override;
//  function  EDASAUpdatePatientsByLinkInfo( ) : TK_CMEDResult;
  function  EDASAUpdateOnePatientByLinkInfo( APCLLPatAttrs : TK_PCMSCLLPatientAttrs ) : TK_CMEDResult;
  function  EDASAChangePatientBridgeID( AOldID, ANewID : Integer ): TK_CMEDResult;
  function  EDASAChangePatientBridgeIDs( const ATableName, AFOldID, AFNewID : string ): TK_CMEDResult;
  function  EDAGetOnePatientHistAttrs( const APatSID : string;
                               APCMPatientHistDBData : TK_PCMPatientHistDBData ) : TK_CMEDResult;

//*********************************************************************
// DICOM DIR Import|Export
  function  EDADCMCheckPatient( const APatSirname, APatFirstName, APatCardNum : string; APatDOB : TDate ) : Integer; override;

//*********************************************************************
// Extra Info
//  function  EDAAddExtraInfoStrings( AMacroStrings : TStrings ): TK_CMEDResult; override;

//*********************************************************************
// Print Logo Access
//
  function  EDAPrintLogoGetDIB( ): TN_DIBObj; override;
  function  EDAPrintLogoSetByFile( const ALogoFName : string ): TN_DIBObj; override;
  function  EDAPrintLocMemIniSave : TK_CMEDResult; override;

//*********************************************************************
// Media Scan Device Plates Info
//
  procedure EDADevicePlatesListAdd( ASL : TStrings; ATSInd : Integer );
  function  EDADevicePlateUseCountGet( const APlateName : string ) : Integer; override;
  function  EDADevicePlateUseCountInc( const APlateName : string ) : Integer; override;

//*********************************************************************
// DICOM Series Info
//
  procedure EDADCMSeriesStart(); override;
  procedure EDADCMSeriesFin(); override;
end; // type TK_CMEDDBAccess = class (TK_CMEDAccess)
//*** end of CMS External Data Access

//////////////////////////////////////
//  Client Scanner Common Data
//
const
  K_CMScanPathRedirectFileName = 'ScanRedirectInfo.txt';
  K_CMScanClientStateFileName  = 'ScanClientState.txt';
  K_CMScanCommonInfoFileName   = 'ScanCommonInfo.txt';
  K_CMScanCurTaskInfoFileName  = 'ScanCurTaskInfo.txt';
  K_CMScanWEBTaskFileName      = 'ScanWEBTaskInfo.txt';
  K_CMScanTaskIsStopped  = 'FSTOP';
  K_CMScanTaskIsUploaded = 'FLOAD';
  K_CMScanNetworkMaxDelay = 10;
  K_CMScanNetworkMidDelay = 5;
  K_CMScanNetworkSlowMinTest = 3;
//  K_CMScanNetworkSlowMinTest = 1; // Debug

var
  K_CMScanDataVersion  : Integer = 1; // CMScan Data transfer protocol version
  // Stored Context
  K_CMScanDataPath     : string;  // CMScan Exchange Folder
  K_CMScanDataPathOld  : string;  // Old CMScan Exchange Folder - used during Path change procedure (if Common Data Path change place on serever)
  K_CMScanDataPathOnClientPC: Boolean;     // CMScan Exchange Folder is on a Client PC Flag
  K_CMScanDataPathOnClientPCAuto: Boolean; // CMScan Auto detect Client PC Exchange Folder Flag
  K_CMScanDataForD4W   : Boolean; // D4WScan mode flag

  // Runtime Context
  K_CMScanDataLocPath  : string;  // CMScan Local Exchange Folder (for Client Based Exchange Folder)
  K_CMScanDataPathAuto : string;  // Auto detected Client PC CMScan Exchange Folder
  K_CMScanDataPathAutoSInd : Integer;  // Auto detected Client PC CMScan Exchange Folder Search Index
  K_CMScanClientName   : string;  // CMScan Client Name
  K_CMScanIsInstalled  : Boolean; // CMScan is installed Flag
  K_CMScanWasInstalled : Boolean; // CMScan was installed Flag  - used during Path change procedure
  K_CMScanDataPathLost : Boolean; // CMScan Exchange Folder is lost
  K_CMScanDataPathAutoCur : string;  // Current Auto detected Client PC CMScan Exchange Folder
  K_CMScanDataPathAutoSearchNextStartTS : Double;
  K_CMScanDataPathAutoSearchClearTS : Double;
//  K_CMScanDataPathAutoSearchStarTimeStamp : Double;
  K_CMScanProcessClientTasksFlag : Boolean;
  K_CMScanDataPathLostShowMessage : Boolean;
//
//  Client Scanner Common Data
//////////////////////////////////////

type TK_CMPatObjCMPState = (
  K_cmpsCopyIsStarted,  // Copy operation is started
  K_cmpsMoveIsStarted,  // Move operation is started
  K_cmpsDBDataIsCopied, // DB records for dest patient are created
  K_cmpsDBDataIsMoved,  // DB records are "moved" to dest patient
  K_cmpsFilesAreCopied  // Files are copied to dest patient folder
                        // (deletion from src patient is needed)
);

type TK_CMUFilterProfile = packed record
//   Interface attributes
  CMUFPCaption:     string; // User Filter Caption
  CMUFPShortCut:    string; // User Filter ShortCut
//   Filter attributes
  CMUFPAutoImgProcAttrs : TK_CMAutoImgProcAttrs; // User Filter Auto Image Processing Attributes
end; // type TK_CMFilterProfile = packed record
type TK_PCMUFilterProfile = ^TK_CMUFilterProfile;

//////////////////////////////////////
//  Internet Upgrade Data
//
var
  K_CMIURemindeInDays: Integer = 0; // Internet Upgrade Interval in days
  K_CMIURemindeTS : TDateTime; // Internet Upgrade Last Timestamp
  K_CMIUCheckUpdatesPath : string; // Path to Internet Upgrade application
  K_CMIUCheckUpdatesCMDLType : Integer; // Internet Upgrade application CMDL type
                                        // 0 - /CMS
                                        // 1 - /CMS /Pilot
//
//  Internet Upgrade Data
//////////////////////////////////////

var K_CMUseCustToolbarInd : Integer; // 0 - Provider|Instance Specific
                                     // 1 - Location Specific
                                     // 2 - Global Specific
                                     // 3 - Provider Specific (2019-11-25 SIR 24115)
    K_CMUseCustToolbarIndPev : Integer;
procedure K_CMPrepIniFileCustToolbarNames( out ActListsIni,ASmallButtonsIni : string );
procedure K_CMInitIniFileCustToolbarCont( );
// K_CMUseCustToolbarGlobal
procedure K_FillDICOMModalitiesList( ASL : TStrings );
function  K_GetDICOMUIDComponentFromGUID31( const ASGUID : string ) : string;


procedure K_CMEDASetIniInfo( const AIniInfo: string );
//procedure K_CMProviderMemIniToCurState();
//procedure K_CMProviderCurStateToMemIni();
//procedure K_CMLocationMemIniToCurState();
//procedure K_CMLocationCurStateToMemIni();
procedure K_CMEDDBSetActualTablesFieldsNames();
procedure K_CMEDAServerClientContextInit();
procedure K_CMEDAccessInit();
procedure K_CMHistoryEventsInit();
procedure K_CMDefineStartMode();
procedure K_CMD4WApplyPatientRuntimeInfo();
function  K_CMD4WApplyNewContextInfo() : string;
procedure K_CMEDAccessInit11();
function  K_CMEDAccessInit2() : Boolean;
function  K_CMSCheckStartAccessRights() : Boolean;

procedure K_CMInitEmbossAttrs( APImgViewConvData : TK_PCMSImgViewConvData;
                               AUNCInit : Boolean = false  );
procedure K_CMConvDIBBySlideViewConvData( var ADDIBObj: TN_DIBObj; ASDIBObj: TN_DIBObj;
                         APImgViewConvData : TK_PCMSImgViewConvData;
                         APixFmt: TPixelFormat; AExPixFmt: TN_ExPixFmt = epfBMP;
                         APEmbDIB1: TN_PDIBObj = nil;
                         APIsoMinMax : PInteger = nil; APXLatBCGHist : TN_PIArray = nil;
                         APXLatBCGColor : TN_PIArray = nil );
procedure K_CMColorizeInitData();
procedure K_CMColorizeBuildColors( APColors : PInteger; AColorsCount, APalIndex : Integer;
                                   ASwapRedBlueFlag : Boolean = false );
function  K_CMEDDBUtilInitData( AInitMTypes : Boolean ) : Boolean;
function  K_CMEDDBUtilSaveToDB( AReplacePatSlides : Boolean ) : Boolean;
function  K_CMGetViewFilterDumpStr( APFilterAttrs: TK_PCMSlideFilterAttrs ) : string;
function  K_CMRebuildSlidesArrayByFilter( APSlides : TN_PUDCMSlide; ASlidesCount : Integer;
                            var ASlidesArray: TN_UDCMSArray; out AStudiesCount : Integer;
                            APFilterAttrs: TK_PCMSlideFilterAttrs; AFreeUnusedSlides : Boolean = FALSE ) : Integer;
//procedure K_CMRebuildVisSlidesByFilter( );
function  K_CMSearchSlideByID( APSlide : TN_PUDCMSlide;
                                      ASlidesCount : Integer;
                                      const ASlideID : string ) : Integer;
type TK_CMUICommandFlags = set of (
  K_uicAddToBuffer, // Add Command To Buffer
  K_uicInsToBuffer, // Insert Command To Buffer before all Existing Commands
  K_uicLastCommand  // Last command in buffer commands list flag (needed to CMSClose)
);
function  K_ExecUICommand( AComCode: Integer; const AComInfo: string;
                           AUICommandFlags : TK_CMUICommandFlags = [] ) : HResult;
//function  K_ExecUICommand( AComCode: Integer; const AComInfo: string;
//                            AToBufFlag : Boolean = FALSE; ALastListCommand : Boolean = FALSE ): HResult;
procedure K_ExecUICommandsList( );
procedure K_CMRemoveFromVisSlides( ASlide: TN_UDCMSlide );

function K_CMSlidesImportFromFilesList( AImpFilesList: TStrings;
                                        const ABasePath : string = '';
                                        const ASourceDescr : string = '';
                                        ASkipedFilesList : TStrings = nil;
                                        ABeforeImportProc : TN_OneStrProcObj = nil ): Integer;
procedure K_CMImportFilesSelectDlg( AFilesList : TStrings; const AFilter : string = '';
                                    ADialogFlag : Integer = 0; ACaption : string = '' );
function  K_CMImportFolderSelectDlg( out AFolder: string; const ACaption : string = '' ) : Boolean;
function  K_CMSlidesImportAndProcessFromFilesList( AFilesList : TStrings ): Integer;
function  K_CMSlidesImportFromFiles( ): Integer;
function K_CMSIsDICOMSlide(const AFileName: string): Boolean;
function K_CMSlidesImportDICOM(const AFileName, AInitialDir: string): Boolean;
function  K_CMSlideWClipboardImport : Boolean;
function  K_CMPrepDICOMProfileSettingsDump( APDCMAttrs : TK_PCMDCMAttrs ) : string;
procedure K_CMDumpSlidesProfileSettings( AProfMTypeID : Integer;
                                         APDCMAttrs : TK_PCMDCMAttrs );
procedure K_CMScanSlidesSaveArray( ASlidesArray : TN_UDCMSArray;
                                   AProcDialogCapt : string;
                                   AShowProcDialogFlag : Boolean;
                                   AProfMTypeID : Integer;
                                   AShowFormat : string;
                                   APDCMAttrs : TK_PCMDCMAttrs );
procedure K_CMScanSlidesSave( ASlidesCount : Integer;
                              AProcDialogCapt : string;
                              AProfMTypeID : Integer;
                              AShowFormat : string;
                              APDCMAttrs : TK_PCMDCMAttrs );
function  K_CMScanSlidesSaveFromDIBArray( APDevProfile: TK_PCMTwainProfile;
                                         ADIBObjArr : TN_DIBObjArray ): Integer; overload;
function  K_CMScanSlidesSaveFromDIBArray( APDevProfile: TK_PCMTwainProfile;
                                          APDIBObj : TN_PDIBObj;
                                          ADIBCount : Integer ): Integer; overload;
{
function  K_CMSlidesSaveScanned1( APDevProfile: TK_PCMTwainProfile ) : Integer;
function  K_CMSlidesSaveScanned2( APDevProfile: TK_PCMTwainProfile ) : Integer;
}
procedure K_CMSlidesSaveScanned3( APDevProfile: TK_PCMDeviceProfile;
                                  ASlidesArray : TN_UDCMSArray;
                                  ASkipProfileAttrs : Boolean = FALSE );
var K_CMSlidesExportFilesOutOfMemory : Integer;
function  K_CMSlidesExportFilesList( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                                     const AFilesPath, AFileExt : string;
                                     ASlidesList, AMacroList : TStrings;
                                     AMaxWidth : Integer = 0;
                                     AMaxHeight : Integer = 0 ): Integer;
procedure K_CMSlidesSaveHistory( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                                 AHistActionCode : Integer );
function  K_CMFilesEmailingByMapi( const ASubject : string; AFilesList: TStrings ): Boolean;
function  K_CMSlidesEmailing( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                              AMaxWidth : Integer = 0; AMaxHeight : Integer = 0 ): Integer;
function  K_CMSlideExport( ASlide : TN_UDCMSlide ) : Boolean;
function  K_CMSlideWClipbordExport( ASlide : TN_UDCMSlide ) : Boolean;
function  K_CMSlidesWClipbordExport( APSlides: TN_PUDCMSlide; ASlidesCount: Integer ): Integer;
procedure K_CMSlideInitByCurContext( ANSlide : TN_UDCMBSlide );

function  K_CMSBuildSlidesArrayByList( ASrcSlidesArray : TN_UDCMSArray; ASlidesList : TList ) : TN_UDCMSArray;
function  K_CMSlidesCopyToClipboard( APSlides : TN_PUDCMSlide; ASlidesCount : Integer ) : Integer;
//function  K_CMSlidesDelete( ASlidesArray : TN_UDCMSArray ) : Integer;
function  K_CMSlidesClose( APSlides: TN_PUDCMSlide;
            ASlidesCount: Integer; ACloseFlags : TN_CMRFEdFreeFlags ): Integer;
function  K_CMSlidesSetDeleteState( APSlides : TN_PUDCMSlide; ASlidesCount : Integer;
                                    AMarkAsDelFlag : Boolean ) : Integer;
procedure K_CMDelSlidesFree();
function  K_CMSlidesDelete( APSlides : TN_PUDCMSlide; ASlidesCount : Integer;
                            AMarkAsDelFlag : Boolean; AClearNotDelSrcSlides : Boolean;
                            APatID : Integer = -1 ) : Integer;
procedure K_CMSlidesDeleteExecute( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                                   AMarkAsDelFlag : Boolean );
function  K_CMSlidesUnDelete( APSlides: TN_PUDCMSlide; ASlidesCount: Integer ): Integer;
//procedure K_CMSlidesDeleteExecute( ASlidesToDeleted : TN_UDCMSArray );
procedure K_CMSlidesLockForOpen( APSlides : TN_PUDCMSlide; ASlidesCount : Integer;
                                 ALockMode : TK_CMEDLockResultMode );
function  K_CMSlidesPasteFromClipboard() : Integer;

function  K_CMCopySlideWithoutSrcImg( ASrcSlide: TN_UDCMSlide ): TN_UDCMSlide;
function  K_CMSlidesPasteFromClipboard0( AProcessMessagesFlag : Boolean; out ANumOutOfMemory : Integer ): Integer;

function  K_CMSetCurSessionContext( ANCPatientID, ANCProviderID, ANCLocationID : Integer;
                                 APCMSlideFilterAttrs : TK_PCMSlideFilterAttrs = nil ): Integer;
procedure K_CMSetCurSessionContext1( ANCPatientID, ANCProviderID, ANCLocationID: Integer;
                                 APCMSlideFilterAttrs: TK_PCMSlideFilterAttrs  );
procedure K_CMBuildUICaptionsByCurContext( AML : TStrings = nil );
procedure K_CMRebuildSlidesFilterMTypes( );
//procedure K_CMUpdateUIByDeviceProfiles( );
procedure K_CMUpdateUIByDeviceProfiles0( ACaptMenuItem: TMenuItem; AFirstInd : Integer; ALastInd : Integer = -1 );
procedure K_CMUpdateUnUsedShortCuts( );
function  K_CMInitProfileIcons( out AImgListBig, AImgListSmall: TImageList ): Boolean;
function  K_CMSelectProfileIcons( out AImgListBig, AImgListSmall : TImageList;
                                  out AImgInd : Integer;
                                  out ADynIconFlag : Boolean ): Boolean;
procedure K_CMGetStaticIconByIndex( AIconInd : Integer; AIconBMP : TBitmap;
                                    ABigIconFlag : Boolean );
procedure K_CMGetStaticIconsLists( out AImgListBig, AImgListSmall : TImageList );
function  K_CMGetMessageDlgTexts( AMDButtons: TMsgDlgButtons = [] ): TN_SArray;

var K_CMMessageDlgDefaultCaption : string = 'MediaSuite';
function  K_CMPrepMessageDlg( const AMessage: string; AMDLT: TMsgDlgType;
               AMDButtons: TMsgDlgButtons = []; ACaption: string = '' ): TForm;
function  K_CMShowSoftMessageDlg( const AMessage: string; AMDLT: TMsgDlgType;
                     AShowInterval : Integer;
                     AOnFormClose : TN_ProcObj = nil;
                     ACaption: string = '';
                     ASkipCloseOnDeactivate : Boolean = FALSE ) : TForm;
function  K_CMShowMessageDlg( const AMessage : string; AMDLT : TMsgDlgType;
                              AMDButtons : TMsgDlgButtons = [];
                              ASkipLogFlag : Boolean = FALSE;
                              ACaption : string = ''; AShowInterval : Integer = 0 ) : Integer;
function  K_CMShowMessageDlg1( const AMessage : string; AMDLT : TMsgDlgType;
                               AMDButtons : TMsgDlgButtons = [];
                               ACaption: string = ''; AShowInterval : Integer = 0 ) : Integer;
procedure K_CMShowMessageDlgByTimer( AMessage : string; AMDLT : TMsgDlgType;
                             AStartTimer : Boolean = TRUE;
                             AMDButtons : TMsgDlgButtons = [];
                             ASkipLogFlag : Boolean = FALSE;
                             ACaption: string = '';
                             AShowInterval : Integer = 0 );
procedure U_CMErrorMessage(AMessage: string; AShowInterval: Integer = 10); //Uraprocedure K_CMSlideSetResolutionByDIB( APCMSLide : TN_PCMSlide; ADIBObj : TN_DIBObj );
procedure K_CMSlideSetAttrsByDIB( APCMSLide : TN_PCMSlide; ADIBObj : TN_DIBObj;
                                  ASkipGreyInit : Boolean );
function  K_CMSlideGetPatientFilesGroupPathSegm( APatId : Integer ) : string;
function  K_CMSlideGetPatientFilesPathSegm( APatID: Integer ): string;
function  K_CMSlideGetFileDatePathSegm( ADTCr: TDateTime ): string;
function  K_CMSlideGetFileIDPathSegm( const ASlideID : string ): string;
function  K_CMSlideGetImgFilesNamePat( const ASlideID: string ): string;
function  K_CMSlideGetDCMAttrsFileName(const ASlideID: string ): string;
function  K_CMSlideGetCurImgFileName(const ASlideID: string ): string;
function  K_CMSlideGetSrcImgFileName(const ASlideID: string ): string;
function  K_CMSlideGetMediaFileNamePref(const ASlideID: string ): string;
function  K_CMSlideGetAttrsFileName(const ASlideID: string ): string;
function  K_CMStudyGetFileName( const AStudyID: string ): string;
function  K_CMSlideGetImg3DFolderName(const ASlideID: string ): string;
function  K_CMSlideGetArchThumbFileName(const ASlideID: string ): string;

function  K_CMParseFilesPath( var FPath: string ): Boolean;

function  K_CMGetMediaFileName( ANSlide : TN_UDCMSlide ) : string;
function  K_CMPrepSlideMediaFile( ANSlide : TN_UDCMSlide; var AFName : string;
                                  AShowDialog : Boolean ) : Boolean;
procedure K_CMOpenMediaFile( ANSlide : TN_UDCMSlide );
procedure K_CMDeleteClientMediaFile( ANSlide : TN_UDCMSlide; AOnlyFileNameClear : Boolean = false );
//const     K_CMSCheckMemConstraintsUseECacheMode = FALSE;
const     K_CMSCheckMemConstraintsUseECacheMode = TRUE;
function  K_CMSCheckMemConstraints( ASlide : TN_UDCMSlide; AUnloadAll : Boolean = FALSE ) : Boolean;

function  K_CMSSetUDTableInfo( AText: string; AUDTable: TK_UDRArray) : Boolean;
function  K_CMInitAutoImgProcAttrs( APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs ): Boolean;
function  K_CMGetAutoImgProcAttrsDumpText( APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs ) : string;
procedure K_CMDumpAutoImgProcAttrs( APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs );
function  K_CMFlipRotateNegateByAutoImgProcAttrs( ADIBObj : TN_DIBObj;
                          APCMSMRImgAttrs : TK_PCMSMRImgAttrs;
                          APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs;
                          out ACurFlipRotateAttrs : Integer ) : Boolean;
procedure K_CMConvDIBByAutoImgProcAttrs( ASrcDIBObj: TN_DIBObj; out ADstDIBObj: TN_DIBObj;
                          APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs;
                          ASlidePixpermm : Float );
function  K_CMSlideConvByAutoImgProcAttrs( ASlide : TN_UDCMSlide;
             APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs;
             ARFVectorScale : Float ): TK_CMSlideSaveStateFlags;
function  K_CMGetUIHintByAutoImgProcAttrs(
             APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs ): string;
function  K_CMSlideCreateFromDIBObj( var ADIBObj: TN_DIBObj;
                    APCMAutoImgPAttrs : TK_PCMAutoImgProcAttrs;
                    AStream : TStream = nil;
                    ADIBStoreFormat : TN_UDDIBDataFormat = uddfNotDef;
                    ASkipThumbCreate : Boolean = FALSE ): TN_UDCMSlide;
function  K_CMSlideCreateFromDeviceDIBObj( var ADIBObj: TN_DIBObj;
                     APDevProfile : TK_PCMDeviceProfile;
                     ADIBNumber : Integer; ADevResolution : Float;
                     ASkipAutoCalibrated : Boolean = FALSE ): TN_UDCMSlide;
function  K_CMSlideReplaceByDeviceDIBObj( var AUDSlide : TN_UDCMSlide;
                     var ADIBObj : TN_DIBObj;
                     APDevProfile : TK_PCMDeviceProfile;
                     ADIBNumber : Integer; ADevResolution : Float;
                     ASkipAutoCalibrated : Boolean = FALSE ): TN_UDCMSlide;
function  K_CMSlideCreateFromMediaFile( const AMediaFName: string ): TN_UDCMSlide;
function  K_CMSlideCreateForMediaObject( const AMediaFExt: string ): TN_UDCMSlide;
function  K_CMSlideCreateForImg3DObject( ASkipImg3DPath : Boolean = FALSE ): TN_UDCMSlide;
function  K_CMSAddCloneChild( AUDRoot, AUDChildPat : TN_UDBase;
                              AInsBeforeAll : Boolean;
                              ALocUDRoot : TN_UDBase = nil ): TN_UDBase;
procedure K_CMSVObjSetDefaultAttrs( AUDVobj : TN_UDCompVis  );
function  K_CMSVObjNAngleRebuild( ALineComp : TN_UDPolyline; AArcComp : TN_UDArc;
                                  ATextComp : TN_UDParaBox; APTextBP : PFPoint ) : TFPoint;
function  K_CMSVObjFAngleRebuild( ALineComp1, ALineComp2, ALineComp3: TN_UDPolyline;
                                  AArcComp : TN_UDArc;
                                  ATextComp : TN_UDParaBox; APTextBP : PFPoint ) : TFPoint;
procedure K_CMSVObjCheckShift( ARFLogFramePRect : TRect; ACompPixRect : TRect;
                               var APixShiftX, APixShiftY : Integer;
                               AOutsideShift : Boolean;
                               AInsidePosGapX, AInsidePosGapY : Integer );
type TK_CMSVObjTextPosRebuildFlags = set of ( // TextBox Position Rebuild Flags Set
  cmtpfSkipFinalShow,   // skip Final RedrawAndShow after changing Component Position
  cmtpfSkipStartRedraw, // skip Starting RedrawAll before changing Component Position
  cmtpfVertCenter,      // Vertical Text centered before position Rebuild
  cmtpfHorCenter        // Horizontal Text centered before position Rebuild
);
procedure K_CMSVObjTextPosRebuild( ARFrame : TN_Rast1Frame; AComp : TN_UDCompVis;
                                   ARebuildFlags : TK_CMSVObjTextPosRebuildFlags );
var K_CMVobjTextFontIniRSize : double = 0.035;
function  K_CMVobjTextAttrsFromMemIni( const ASectName : string; AUDTextComp : TN_UDBase; AImgHeight : Integer ) : Boolean;
procedure K_CMVobjCTAAttrsFromCTA( AUDSrcTextComp, AUDTextComp : TN_UDBase );
procedure K_CMVobjSetFontSizeAuto( AUDTextComp : TN_UDBase; AImgHeight : Integer );
function  K_CMVobjCTAAttrsToMemIni( const ATSectName, ASSectName : string; AUDTextComp : TN_UDBase;
                                   ASaveAddAttrs : Boolean ) : Boolean;
function  K_CMVobjCTAGetMemIniContext( ACTAInd : Integer; out ACTAUse : Integer ) : string;
procedure K_CMVobjInitDotTextPos( AUDDotComp : TN_UDBase; ABPX, ABPY : Float;
                                  ASlidePixWidth, ASlidePixHeight : Integer );
function  K_CMVobjSetDotSizeByFontHeight( AUDDotComp : TN_UDBase; AFontHeight : Float ) : Float;
function  K_CMDEMOAddMarkToDIB ( ADIBObj : TN_DIBObj ) : Boolean;
function  K_CMDEMOAddConstraint( ACount : Integer = 1 ) : Integer;
procedure K_CMSPCAddCOMServer( AStr: string );
procedure K_CMSPCAddVObj( AStr: string );
procedure K_CMSPCAddVObjEvent( AStr: string; ARFAction : TN_RFrameAction );
procedure K_CMSFlashlightCalcSrcRect( AFlashLightRootComp : TN_UDCompVis;
                                       ARFScale : Float; APixSize : TPoint );
//function  K_CMSImportFromExtDB( const ASlidesXMLFName : string ) : Boolean;

function  K_CMDBGetImgFPath( out AFPath : string ): TK_CMEDResult;
function  K_CMSFormatTrialPeriod( AMinutes : Integer ): string;
function  K_CMSSlidesBWReorder2( AImgSlides: TN_UDCMSArray ): Integer;
function  K_CMSSlidesBWReorder4( var AImgSlides: TN_UDCMSArray ): Integer;
function  K_CMSeparateSlidesAndStudies( APSlide: TN_PUDCMSlide; ASlidesCount: Integer ): Integer;
procedure K_CMSMediaOpen( APSlide: TN_PUDCMSlide; ASlidesCount : Integer; ASkipEditMode : Boolean = FALSE );
function  K_CMGetLocationDetails( ALocID: Integer; APattern: string = '' ): string;
function  K_CMGetProviderDetails( AProvID : Integer; APattern : string = '' ) : string;
function  K_CMGetProviderName( AProvID: Integer ): string;
function  K_CMGetPatientDetails( APatID : Integer; APattern : string = '' ) : string;
function  K_CMGetPatientName( APatID: Integer; APCardNum : PString = nil ): string;
function  K_CMGetPatientName1( APatID: Integer; APCardNum : PString = nil ): string;
procedure K_CMD4WApplyBufContext( );
procedure K_CMSlideHistoryShowDlg( ASlide :TN_UDCMSlide );
function  K_CMGetVObjPAttr( AVObj : TN_UDBase; AAttrName : string  ): TN_POneUserParam;
procedure K_CMChangeVObjSelectedColor( AVObj : TN_UDBase; AMainColor : Integer  );
function  K_CMChangeCaptButDelay( ) : Boolean;
var K_CMPShowDebugDlgFlag : Boolean; // Show Copy Move Debug Wizard
function  K_CMSlidesCopyMoveByPatOld( ASrcPatID, ADstPatID, ACopyFlag: Integer ) : Integer;
function  K_CMSlidesCopyMoveByPat( ASrcPatID, ADstPatID, ACopyFlag: Integer;
                                   AShowResDlgFlag : Boolean ) : Integer;
function  K_CMPatObjCopyMoveProcWaitDlg( ACMPProcID : Integer; const AMessage : string ) : Boolean;
function  K_CMAllPatObjCopyMoveProcResume( APatID : Integer ) : Boolean;
function  K_CMAllPatObjCopyMoveProcWait( APatID : Integer;
                                            AWaitMessage : string ) : Boolean;
function  K_CMAllPatObjCopyMoveResumeAndWait( APatID : Integer ) : Boolean;

var K_CMSlidesCopyMoveLaunchTasksList : TStringList;
procedure K_CMSlidesCopyMoveLaunchByPat( ASrcPatID, ADstPatID, ACopyFlag: Integer );
function  K_CMSlidesCopyMoveArchivedCheck( ASrcPatID : Integer ) : Boolean;

//*******************************************
//   CMS DB Interface
//
//          Ini-file Settings:
// [CMSDB] - Global Ini Section
// ConnectionString - DB Connection attributes
// DBF - DB file path
function  K_CMDBGetSessionID( ) : string;
function  K_CMDBGetMSSQLConnectionString( AUserID: string = ''; AConInfo: string = '' ): string;
function  K_CMDBGetConnectionString ( AConInfo : string = '' ) : string;

///////////////////////////////////////////////
// DICOM Elemnt Format Type Codes
//
const
  K_DCT_AE = Byte('A') + (Byte('E') shl 8);
  K_DCT_AS = Byte('A') + (Byte('S') shl 8);
  K_DCT_AT = Byte('A') + (Byte('T') shl 8);
  K_DCT_CS = Byte('C') + (Byte('S') shl 8);
  K_DCT_DA = Byte('D') + (Byte('A') shl 8);
  K_DCT_DS = Byte('D') + (Byte('S') shl 8);
  K_DCT_DT = Byte('D') + (Byte('T') shl 8);
  K_DCT_FL = Byte('F') + (Byte('L') shl 8);
  K_DCT_FD = Byte('F') + (Byte('D') shl 8);
  K_DCT_IS = Byte('I') + (Byte('S') shl 8);
  K_DCT_LO = Byte('L') + (Byte('O') shl 8);
  K_DCT_LT = Byte('L') + (Byte('T') shl 8);
  K_DCT_OB = Byte('O') + (Byte('B') shl 8);
  K_DCT_OF = Byte('O') + (Byte('F') shl 8);
  K_DCT_OW = Byte('O') + (Byte('W') shl 8);
  K_DCT_PN = Byte('P') + (Byte('N') shl 8);
  K_DCT_SH = Byte('S') + (Byte('H') shl 8);
  K_DCT_SL = Byte('S') + (Byte('L') shl 8);
  K_DCT_SQ = Byte('S') + (Byte('Q') shl 8);
  K_DCT_SS = Byte('S') + (Byte('S') shl 8);
  K_DCT_ST = Byte('S') + (Byte('T') shl 8);
  K_DCT_TM = Byte('T') + (Byte('M') shl 8);
  K_DCT_UI = Byte('U') + (Byte('I') shl 8);
  K_DCT_UL = Byte('U') + (Byte('L') shl 8);
  K_DCT_UN = Byte('U') + (Byte('N') shl 8);
  K_DCT_US = Byte('U') + (Byte('S') shl 8);
  K_DCT_UT = Byte('U') + (Byte('T') shl 8);

  K_CMS_DICOM_DATA_SIGNATURE = 'CMS_DATA_SIGNATURE';

type TK_DICOMEncType = ( // DICOM Encoding Elements Type
  K_dcmetUnKnownFormat, // Uknown  Format
  K_dcmetImpLitEnd,   //Implicit VR Little Endian: Default Transfer Syntax for DICOM
  K_dcmetExpLitEnd,   //Explicit VR Little Endian
  K_dcmetExpBigEnd    //Explicit VR Big Endian
);
type TK_DICOMElemHType = ( // DICOM last read Element Header Type
  K_dcmehElem,    // Ordinary Element  Header
  K_dcmehSQS,     // Elements Set Start Header
  K_dcmehSQF,     // Elements Set Final Header
  K_dcmehSQElemS, // Set Element Start Header
  K_dcmehSQElemF  // Set Element Final Header
);
type TK_DICOMDataTag = record // DICOM Data Element Tag
  TGID : Word; // Element Tag Group ID
  TEID  : Word; // Element Tag ID
end;
type TK_PDICOMDataTag = ^TK_DICOMDataTag;

type TK_DICOMDataHead1 = record // DICOM Data Element Header 1
  HTag : TK_DICOMDataTag; // Tag Code
  HVR  : Word;            // Value Representation Code
  HSize: Word;            // Value Size
end;
type TK_PDICOMDataHead1 = ^TK_DICOMDataHead1;

type TK_DICOMDataHead2 = record // DICOM Data Element Header 2
  HTag   : TK_DICOMDataTag; // Tag Code
  HVR    : Word;            // Value Representation Code
  HBlank : Word;            // Blank
  HLSize : Integer;         // Value Size
end;
type TK_PDICOMDataHead2 = ^TK_DICOMDataHead2;

type TK_DICOMAccess = class
// DICOM Read/Write class
     private
  DCNotStreamOwner : Boolean;// DICOM not stream Owner flag
     public
  DCStream : TStream;    // DICOM file stream
  DCNextGroupStreamOffs   : Int64; // Next Group Stream Offset

  DCGroupLengthStreamOffs : Int64; // Current Group Length Stream Offset

  DCSeqElemLengthStreamOffs : Int64; // Current Sequence Element Length Stream Offset

  DCItemsStreamOffsStack : TN_I8Array; // Items Stream Offsets Stack
  DCItemsStreamOffsStackLevel : Integer;

  DCEncType : TK_DICOMEncType; // Data Encoding Type
  DCEFpos  : Int64;          // Current Element Start File Position
  DCETag  : TK_DICOMDataTag; // Current Element Data Tag
  DCEHType : TK_DICOMElemHType; // Current Element Header Type
  DCEVR : Word;        // Current Element Data Value Representation
  DCESize : Integer;         // Current Element Data Size
  DCDataBuf : TN_BArray;  // Group Data Buffer
//  DCDataBufPos : Integer; // Group Data Buffer Current Position
  DCLastImportInfo : string; // Last Import Info string

  destructor  Destroy(); override;
// DICOM File open/close operations
  function  DCFileCreate( const ADICOMFName: string ): Boolean;
  function  DCStreamStart( const ADCStream : TStream ) : Boolean;
  function  DCFileOpen( const ADICOMFName : string ) : Boolean;
  procedure DCFileClose( );
// DICOM File write operations
  procedure DCFileGroupStart( AGroupID : Word; ASkipGroup : Boolean = FALSE );
  procedure DCFileGroupFin( );
  procedure DCFileElemHeaderSet( APElemHeader : pointer; ATElemID : Word; ATagVR : Word );
  function  DCFileElemHeaderSetSise( APElemHeader : pointer; ASize : Integer ) : Integer;
  function  DCFileConvToBuf( const AValue; ATagVR : Word ) : Integer;
  function  DCFileConvToAnsiStr( const AValue; ATagVR : Word ) : AnsiString;
  function  DCFileElemHeaderWrite( ATElemID : Word; ASize : Integer; ATagVR : Word ) : Integer;
  procedure DCFileElemTailWrite( ASize : Integer; ARSize : Integer );
  procedure DCFileElemWrite( ATElemID : Word; const AValue; ASize : Integer; ATagVR : Word );

  procedure DCFileSeqItemHeaderWrite( ASize : Integer );
  procedure DCFileSeqItemWrite( const AValue; ASize : Integer );
  procedure DCFileSeqItemStart();
  procedure DCFileSeqItemFin();

  procedure DCFileSeqElemStart( ATElemID : Word );
  procedure DCFileSeqElemFin( );

  function  DCSlideExport( const ADICOMFName : string; AUDSlide : TN_UDCMSlide ): Boolean;
  function  DCSlideImport( const ADICOMFName : string; out AUDSlide : TN_UDCMSlide ): Integer;
// DICOM File read operations
  function  DCFileElemHeadRead( ) : Boolean;
  function  DCFileElemValueRead( AMaxLength : Integer = 0 ): Boolean;
  function  DCFileElemRead( AMaxLength : Integer = 0 ) : Boolean;
  procedure DCFileDump( const ADICOMFName, ADumpFName : string );
//  function  DCFileCreate( const ADICOMFName : string ) : Boolean;
//  procedure DCFileClose(  ) : Boolean;
//  procedure DCFileWriteData( AETagGroup : Word; AETagID : Word; APData : Pointer; ADSize );
//  procedure DCFileWriteDataToGroup( AETagGroup : Word; AETagID : Word; APData : Pointer; ADSize );
//  procedure DCFileWriteGroup( AETagGroup : Word; AETagID : Word );

end;

type TK_CMSImportNotes = class // Slide Import Notes Object
  SINUDRoot : TN_UDBase;
  SINUDNotes : TN_UDBase;
  SINSlideList : TStringList;
  SINImportDumpChanel : Integer;
  SINFontAttrs : TN_NFont;       // Font Attributes
  SINUseFontStyle : Boolean;
  SINTextColor : Integer;
  SINWSL : TStringList;
  constructor Create();
  destructor  Destroy(); override;
  procedure SINLoadNotesXML( const AXMLFName : string );
  procedure SINAddSlideNotes( AUDSlide : TN_UDCMSlide; const ASImpSlideID: string );
  procedure SINImportDump( const AMessage : string );
end;


procedure K_CMSAddCurState( AStrings: TStrings; AIndent: integer );
function  K_CMSCheckMemFreeSpaceDlg( const AMes : string ) : Boolean;
function  K_CMSlidesDelConfirmDlg( APSlide : TN_PUDCMSlide; ASlidesCount : Integer;
                                   AMarkAsDelFlag : Boolean ) : Boolean;
function  K_CMSlideDelConfirmDlg( ASlide : TN_UDCMSlide ) : Boolean;
function  K_CMCheckMasterLP( const ALogin, APassword : string ) : Boolean;
procedure K_CMHistReportCreate( var AReportDataSMatr: TN_ASArray; var ARepAtttrs : TK_CMHistRepAtttrs );
function  K_CMCreateUDDIBBySData( AMemPtr: Pointer;
               ADSize: Integer; AFreeBufProc: TK_FreeBuffer = nil): TN_UDDIB;
procedure K_CMGetUDDIBSData( AUDDIB : TN_UDDIB; out AMemPtr: Pointer;
                             out ADSize: Integer);

function  K_CMBuildTwainDevicesList( ADevList : TStrings ) : Boolean;
procedure K_CMDeviceProfileAutoTWAINMode( var ACMDPTWAINMode : string;
                                          const ACMDPProductName : string );
procedure K_CMRecoverDeviceProfile( AutoRecoverFlag : Boolean;
         AUDProfiles : TK_UDRArray; AUDProfileInd : Integer;
         APDeviceProfileBuf : Pointer; AEdFormClass: TN_BaseFormClass );

function  K_CMGetMLineInterimTextsDisplayMode( AUDMLineRoot: TN_UDBase ) : Integer;
procedure K_CMSetMLineInterimTextsDisplayMode( AUDMLineRoot: TN_UDBase;
                                               ADisplayMode: Boolean );
const  K_CMSFileSelfCheckStopMode = 16;
//procedure K_CMSInitRegSettingInfo( );
procedure K_CMSFileSelfCheckErrMessageDlg( const AErrFName : string; AErrMode : Integer ); // local
procedure K_CMSVObjArrowTipLineRebuild( ALineComp : TN_UDPolyline; ATipLength : Double ); // local
procedure K_CMSVObjRectRebuildByPoint( ALineComp : TN_UDPolyline; APFPoint : PFPoint; APointInd : Integer );
procedure K_CMSVObjRectReorderLineVertexes( ALineComp : TN_UDPolyline );
procedure K_CMSVObjEllipseRebuildByOuterRect( AEllipsLine, ARectLineComp : TN_UDPolyline );
function  K_CMInitLogFilesGPath( ) : string;
procedure K_CMCustomizeGPathProc( );
procedure K_CMInstallIniSetInfo( const AFName : string );
procedure K_CMParseLiDBTrialExpiredInfo( AMList : TStrings );
procedure K_CMSetFlashLightAttrs( AUDFlashlight : TN_UDCompVis;
                                          APFLIniData : TK_PCMFlashlightIniData );
function  K_CMFlipRotateSlideImage( AUDSlide : TN_UDCMSlide; AAngle: float;
               AFlipFlags : Integer; AChangeFlags : Boolean = FALSE ) : Boolean;
procedure K_CMReplaceSlideDIB( AUDSlide : TN_UDCMSlide; ADIB : TN_DIBObj; ASkipSizeChange : Boolean = FALSE );
procedure K_CMAddDeviceProfilesList( ASL : TStrings );

type TK_CMSADialogsHandlers = class // CMS stand alone Dialogs Handlers
  function  SADCheckLocationAttrs( AForm : TForm ) : Boolean;
  procedure SADLocAndProvFormActivate( AForm : TObject );
  procedure SADKeyPress( Sender: TObject; var Key: Char );
end;

//function  K_CMSASelectPatientDlg( var APatID : string ) : Boolean;
function  K_CMSAFillLocationsList( AStrings : TStrings; const ALocSID : string ) : Integer;
function  K_CMSAFillProvidersList( AStrings : TStrings; const AProvSID : string ) : Integer;
{
function  K_CMSASetPatientDataDlg( var APatID : string;
                    APCMSAPatientDBData : TK_PCMSAPatientDBData;
                    const ACaption : string ) : Boolean;
function  K_CMSASetProviderDataDlg( var AProvID : string;
                    APCMSAProviderDBData : TK_PCMSAProviderDBData;
                    const ACaption : string ) : Boolean;
}
function  K_CMSASetLocationNameDlg( var ALocName : string;
                                    const ACaption : string; AReadOnly : Boolean = FALSE ) : Boolean;
type TK_CMSGetStartContextSet = set of (
  K_gscLocation,
  K_gscProvider,
  K_gscPatient
);

function  K_CMGetStartContextDlg( AGSCSet : TK_CMSGetStartContextSet ) : Boolean;
procedure K_CMSCLLContextInit();
function  K_CMSCLLDOBFromText( const AStrDOB : string ) : TDateTime;
function  K_CMSCLLContextFromIniFile( const AFName :string; AInitContext : Boolean ) : Integer;
function  K_CMSCLLContextToIniFile( AFName :string ) : Boolean;
function  K_CMSCLLContextFromCommandLine( ) : Boolean;
procedure K_CMSCLLContextFromEDAPPL( ALocID, AProvID, APatID : Integer );
function  K_CMSCLLContextFromURLToIniFile( AFName :string ) : Boolean;
procedure K_CMSCLLContextFromURL( );
//procedure K_CMUpdateEDAPPLByCLLContext( );
//procedure K_CMSE2VDIBAdjust( var ADIBObj : TN_DIBObj );
function  K_CMSelectFilterApertureByResolution( ASlidePixpermm : float; AFType : Integer ) : Integer;
function  K_CMGetPatientGenderTextByTitle( const ATitle : string ) : string;

function  K_CMGetCurSlidesListLastSlides( ASlidesCount : Integer) : TN_UDCMSArray;


function K_CMBSlideCreateThumbnailDIBByAspect( AThumbAspect: Double ): TN_DIBObj;
function K_CMBSlideCreateThumbnailDIBByDIB( ADIBObj: TN_DIBObj ): TN_DIBObj;
function K_CMBSlideCreateThumbnailDIBByDIBEx( ADIBObj: TN_DIBObj ): TN_DIBObj;
function K_CMBSlideCreateThumbnailDIBByMapRoot( AMapRoot: TN_UDCompBase ): TN_DIBObj;
function K_CMBStudyCreateThumbnailDIBByMapRoot( AMapRoot: TN_UDCompBase ): TN_DIBObj;
function K_CMBSlideCreateThumbnailUDDIB( ADIBObj: TN_DIBObj ): TN_UDDIB;

//////////////////////////////////////
//  Export/Email File names
type TK_CMSlideEEFNameFlagsSet = set of (
K_efnPatSurname,
K_efnPatFirstname,
K_efnPatTitle,
K_efnPatCardNum,
K_efnPatDOB,
K_efnObjDTaken,
K_efnObjTTaken,
K_efnObjChart,
K_efnObjID
);

var
// Email Attached Files Size Set Index
  K_CMSlideEESizeInd : Integer;

// File Name Components Flags
  K_CMSlideEEFNameFlagsSet : TK_CMSlideEEFNameFlagsSet =
    [K_efnPatSurname,K_efnPatFirstname,K_efnPatTitle,K_efnPatCardNum,
     K_efnObjDTaken,K_efnObjID];

// File Name Pattern
  K_CMSlideEEFNamePattern : string = '(#PatSurname#)(#PatTitle#)(#PatFirstName#)(#PatCardNum#)(#PatDOB#)(#ObjChart#)(#ObjDTaken#)(#ObjTTaken#)_(#FileNum#)';

procedure K_CMSlideEEFNamePrepMacro( ASrcPatMacroList, AResFileMacroList : TStrings );
function  K_CMSlideEEFNameBuild( AFileMacroList : TStrings; ASlide : TN_UDCMSlide; AFnum : Integer ) : string;

//////////////////////////////////////
//  Studies
//
function  K_CMStudyCreateFromSample( AStudySample : TN_UDBase; const AStudyLabel : string;
                                     AStudyColorInd : Integer ) : TN_UDCMStudy;
function  K_CMStudyGetItemInvisibleRoot( AStudyItem : TN_UDBase ) : TN_UDBase;
function  K_CMStudyGetOneSlideByItem( AStudyItem : TN_UDBase ) : TN_UDCMSlide;
function  K_CMStudyGetAllSlidesByItem( AStudyItem : TN_UDBase; var AMountedSlides : TN_UDCMSArray; var AInd : Integer ) : TN_UDBase;
function  K_CMStudyItemAddSlidesPrep( AStudyItem : TN_UDBase; out AUDRoot : TN_UDBase ) : Integer;
function  K_CMStudyGetStudyByItem( AStudyItem : TN_UDBase ) : TN_UDCMStudy;
function  K_CMStudyItemFRFags( AStudyItem : TN_UDBAse ) : Integer;
function  K_CMStudyItemTeethFags( AStudyItem : TN_UDBAse ) : Int64;
function  K_CMStudyGetRemountContext( ARSlide : TN_UDCMSlide; ARItem: TN_UDBase;
                                      APRContext : TK_PCMStudyRemountOneSlideContext ) : TK_CMStudyRemountUpdateFlags;
function  K_CMRefreshOpenedView( AClearViewFlagsOnly : Boolean = FALSE ) : Integer;
function  K_CMSAddStudyCurSlidesToArray( AUDCMSArray : TN_UDCMSArray ) : TN_UDCMSArray;

//////////////////////////////////////
//  Ext ini-files processing
//
procedure K_CMEDAInitDFPLExec;
procedure K_CMEDAHideLoginPasswordForDump( AStrings : TStrings;
                                           AEncodeLogin : Boolean = FALSE );
function  K_CMEDAExtIniFileToMemIni( AIniFName : string;
                                     const AIniDFPLName : string = '' ): Boolean;
function  K_CMEDAMemIniToExtIniFile( AIniFName: string;
                                     const AIniDFPLName : string = ''): Boolean;
function  K_CMEDAExtIniFilesToMemIni( ASaveDefaults : Boolean = FALSE ): Integer;
function  K_CMEDAMemIniToExtIniFiles(): Integer;

function  K_CMSRebuildCommonRImage() : Boolean;

//////////////////////////////////////
//  Memory Allocation Control
//
var K_CMSReservedSpaceHMem : THandle;
function  K_CMSCheckMemForSlide( AUDSlide : TN_UDCMSlide; ABufCount : Integer = 0;
                                ADIBCount : Integer = 0; APixWidth  : Integer = 0;
                                APixHeight : Integer = 0 ) : Boolean;
function  K_CMSCheckMemForSlide1( AUDSlide : TN_UDCMSlide; ABufCount : Integer = 0;
                                ADIBCount : Integer = 0; APixWidth  : Integer = 0;
                                APixHeight : Integer = 0 ) : Boolean;
function  K_CMSCheckMemForSlideDlg( AUDSlide : TN_UDCMSlide; AWarning : string;
                                   ABufCount : Integer = 0; ADIBCount : Integer = 0 ) : Boolean;
procedure K_CMSCheckMemFreeDump();

//////////////////////////////////////
//  Slides Auto Resample
//
var K_CMSResampleOutOfMemCount : Integer; // number out of memory problems in K_CMSResampleSlides
function  K_CMSResampleSlides( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
                               AShowInfoProc : TK_NotifyStr1Proc = nil ): Integer;

//////////////////////////////////////
//  DB access utils
//
function  K_CMEDAGetDBStringValue( AField : TField ) : string;
function  K_CMEDAGetSlideSelectWhereStr( ACtrlFlags : TK_CMEDASelectWhereFlags;
                                         AFieldPref : string = '' ) : string;
procedure K_CMEDAGetSlideSysFieldsData( const ASysInfo: string; APCMSlideSDBF: TN_PCMSlideSDBF);

//////////////////////////////////////
//  Slide DICOM attributes processing
//
procedure K_CMPrepSlideDCMAttrs( APSrcDCMAttrs : TK_PCMDCMAttrs; var AResDCMAttrs : TK_CMDCMAttrs );
procedure K_CMPrepDialogDCMAttrs( APSrcDCMAttrs : TK_PCMDCMAttrs; var AResDCMAttrs : TK_CMDCMAttrs );

//////////////////////////////////////
//  VEUI and HPUI  utils
//
function  K_CMPrepHPContext( out AMediaSlide : TN_UDCMSlide ) : Integer;
procedure K_CMSwithToHPUI();
function  K_CMUICheckInitResult() : Boolean;
function  K_CMReopenDBConnection() : Boolean;
procedure K_CMPrepLaunchVEUI();

///////////////////////////////////////////////////////////
//  CMS Dental Unit
//
function  K_CMCheckDentalUnitActionExec() : Boolean;

procedure K_CMSWrkFilesInit();

function  K_CMCheckNewVersionProcessing() : Boolean;
function  K_CMDBGetOneProviderInfo( ADataSet : TADOQuery;
                       const ASQLIDFName : string; AppRTID : Integer;
                       const AProvSID : string;
                       APCMSAProviderDBData : TK_PCMSAProviderDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult;
function  K_CMDBCheckAppInstanceLostRecord( AAppInstDataSet : TDataSet; ATimestampFI, AFlagsFI: Integer;
                                                        ACurTS: TDateTime ) : Boolean;
function  K_CMShowEnterprise( ) : Boolean;
function  K_CMGetCustomRefNumber( ) : string;

function  K_CMGetECacheFilesPath( ) : string;
function  K_CMClearActCaption( const ActCapt : string ) : string;
function  K_CMGetDICOMAppEntityName() : string;
// 2020-12-12 save in Global Context
//procedure K_CMDICOMSettingsStoreModeApply();
procedure K_CMToothNumSchemeListRebuild();


//////////////////////////////////////
//  Check File Path Types
//
type TK_CFPState = (
  cfpsNotDef,  // result is not define
  cfpsOpOK,    // path operation is OK
  cfpsOpFails, // path operation fails
  cfpsOpSlow   // path operation too slow
);

type TK_CFPResult = record
  CFPCheckNum : Integer;     // Check Number
  CFPState    : TK_CFPState; // Path State after Check
  CFPTime     : Int64;       // Path Check time interval in CPU ticks
  CFPPathCode : Integer;     // Check Path CRC code
end;
type TK_PCFPResult = ^TK_CFPResult;

type TK_CFPFilePathCheckThread = class (TThread)
  CFPCheckLoopDelay : Integer;  // Check Loop Delay
  CFPPResult   : TK_PCFPResult; // Pointer to External Check Result (for return to Main Thread )

  CFPCheckStopFlag   : Boolean; // Stop check File Path process

  CFPSingleCheckFlag : Boolean; // Single Check File Path flag
  CFPForcePathFlag   : Boolean; // Force File Path flag

  CFPNewFilePathFlag : Boolean; // Change File Path to check
  CFPNewFilePath : string;      // New File Path
  CFPDump2CheckResultFlag : Boolean; // Dump2 CheckResult Flag

  procedure Execute(); override;
  function  CFPSetNewCheckPath( const APath : string ) : Integer;
  procedure CFPContinue();
  procedure CFPStop();
  procedure CFPSyncDump( );
  procedure CFPSyncReturnCheckResult();
  procedure CFPSyncGetCheckContext();
private
  CFPDumpStr : string;              // Dump Str
  CFPUT : TN_CPUTimer1;             // Check File Path Timer
  CFPCurResult : TK_CFPResult;  // Current Check Result
  CFPCurFilePath : string;      // Current File Path
  CFPCurCheckStopFlag : Boolean; // Stop check File Path process
  CFPCurSingleCheckFlag : Boolean; // Single Check File Path flag
  CFPCurForcePathFlag   : Boolean; // Force File Path flag
  CFPNewPathCode : Integer;  // New File Path COde
end; // type TK_CFPFilePathCheckThread = class (TThread)
var K_CMScanDataPathCheckThread : TK_CFPFilePathCheckThread;

var K_CMScanDataPathCheckResult : TK_CFPResult;
    K_CMScanDataPathCheckPrevResult : TK_CFPResult;
    K_CMScanDataPathPrevCheckNum : Integer;
    K_CMScanDataPathSlowCheckCount : Integer;

//
//  Check File Path Types
//////////////////////////////////////

////////////////////////////////////////////////////////////

type TK_CMLiModDisableSet = set of (// Set of Modules Disabled by Registration
  limdDICOM,
  limdImg3D,
  limdCosmetic,
  limdCMWEB,
  limdFunc3
);

type TK_CMSLiRegState = (
//  K_lrsLiKeyAbsent,     // CMS DB is registed and Licensing Key Info is absent
  K_lrsDBTrialExpired,  // CMS DB Trial Period expired
//  K_lrsVerTrialExpired, // CMS Version Trial Period expired
  K_lrsNumConExceeded,  // CMS Number of allowed connections exceeded
  K_lrsUnregCMSBuild,   // CMS Build Version is not registed
  K_lrsEnterpriseUnreg,  // CMS Enterprise Mode is Unregistered
  K_lrsBadDBVersion,    // CMS Bad DB Version Number
  K_lrsEnterpriseErr,   // CMS Enterprise Mode Errors Detected
  K_lrsCodePageErr,     // CMS Code Page Error Detected
  K_lrsOtherErr,        // CMS Other Error Detected
  K_lrsOK,              // CMS Licensing/Registration OK
  K_lrsDBTrial          // CMS DB Trial Period
//  K_lrsVerTrial         // CMS Version Trial Period
);

type TK_CMSLiRegStatus = (
  K_lrtLight,        // Light limited functionality
  K_lrtProfessional, // Full functionality
  K_lrtEnterprise,   // Special Enterprise functionality (Distributed File Storage - not used Now)
  K_lrtComplex       // Fine Tuning functionality (Devices and Module Limitation)
);

var
///////////////////////////////////////////////////////////
//  CMS Licensing/Registration Info
//
  K_CMSLiRegState      : TK_CMSLiRegState = K_lrsOK; // Licensing Registration State:
  K_CMSLiRegWarning    : string;  // Registration Warning
  K_CMSLiRegBuildInfo  : string;   // Registered CMS Build Version from CMS DB
  K_CMSLiRegCheckBuild : Boolean;  // Check CMS Build Registration
  K_CMSLiRegTrialExpiredInfo : string; // DB Trial Period Expired Exception Info
  K_CMSLiRegStatus     : TK_CMSLiRegStatus = K_lrtProfessional; // Registered CMS Functionality Status
  K_CMSLiRegModDisable : TK_CMLiModDisableSet; // CMS Modules limitations set
  K_CMSLiRegMacroInfo  : TStringList;
  K_CMSLiRegDevLimit   : Integer = 0; // 0 - unlimited, 1 - 3 - number of limited devices

  K_CMSLiRegValidDevTypesList : TStringList; // if Devices Limit is exceed the List contains Allowed Types

//  K_CMSLiCommonKeyDate   : TDateTime; // Key File Prepare Date
{//!!SkipOldReg
  K_CMSLiCommonDBSIDCode : string; // DB Server Identification Code
  K_CMSLiCommonDBRegCode : string; // DB Registration Code
  K_CMSLiCommonLiNum     : Integer; // Maximal Active Instances Counter (-1 any is OK)
  K_CMSLiCommonTrialMinutes : Integer; // Trial Period Minutes
  K_CMSLiCommonTwainNum  : Integer = -1; // Maximal TWAIN Device Counter (-1 any is OK)
  K_CMSLiCommonOtherNum  : Integer = -1; // Maximal Other Device Counter (-1 any is OK)
  K_CMSLiCommonVideoNum  : Integer = -1; // Maximal Video Device Counter (-1 any is OK)
  K_CMSLiTwainDevList    : TStringList; // Licesed Twain Device List
  K_CMSLiOtherDevList    : TStringList; // Licesed Other Device List
  K_CMSLiVideoDevList    : TStringList; // Licesed Video Device List

  K_CMSLiDBRegCheckMode  : Integer; // DB Registration Check Mode:
                                    // 0 - Undefined Mode - Current State will be fixed
                                    // 1 - DB was Registed without Key - Key Control will be Skiped
                                    // 2 - DB was Registed Using Key - Key Control is Needed
}
//  K_CMSLiVerTrialMinutes    : Integer;// CMS Version Trial Period Minutes Used

///////////////////////////////////////////////////////////
//  CMS External Data Access Context
//
  K_CMEDAccess : TK_CMEDAccess;       //External Data Access Object

///////////////////////////////////////////////////////////
//  CMS Enterprise Edition Context
//
  K_CMEnterpriseModeFlag: Boolean;    // Enterprise Edition Mode Flag

///////////////////////////////////////////////////////////
//  CMS GLobal Admin Session
//
  K_CMGAModeFlag : Boolean;  // Global Admin Mode Flag
  K_CMGAModeSkipAutoClearFlag : Boolean;  // Global Admin Mode Skip Auto Clear Flag
  K_CMGAModePrintTemplatesFName : string; // FileName with templates info - is Set in Alt+Shift+M dialog
  K_CMGAModePrintTemplatesSaveFlag : Boolean;   // Save Print Context Flag

///////////////////////////////////////////////////////////
//  CMS Miscellaneous Context
//
  K_CMSSBuildNum    : string; // CMS short build number
  K_CMSLastVersion  : string; // CMS last run version number, cur version is in N_CMSVersion

  K_CMSlidesToSkipMemFree  : TN_UDCMSArray; // Slides Skip Memory Free Array
  K_CMSlidesToMemFree      : TN_UDCMSArray; // Opened Slides which will be closed while other slides will be opened

  K_CMSlidesClipBoardArray  : TN_UDCMSArray; // Current Slides Clipboard Array
  K_CMSUNDOBuffer : TN_BArray; // UNDO extract data portion buffer

  K_CMImgStartMemFreeSize : UInt4; // Loaded Img Slides Start Memory Free size
  K_CMImgStopMemFreeSize  : UInt4; // Loaded Img Slides Stop Memory Free size (it is enough memory to continue)
//  K_CMImgCheckMemFragmSize: UInt4; // Loaded Img Slides Check Memory fragmentation size
//  K_CMImgMaxMemSize       : UInt4; // Loaded Img Slides Total Memory Maximal size (Stop Loading - for exaple - stop opening Slides List)
//  K_CMImgCurMemSize       : UInt4; // Loaded Img Slides Current Total Memory size

  K_CMSlideThumbSize: Integer; // Thumbnail Width or Height (which is bigger) in Pixels
  K_CMSlideThumbQuality: Integer; // Thumbnail store Quality Attribute

  K_CMEDAMultipleInstanceMode : Boolean; // Multiple CMS Active Instance on one Computer
  K_CMXrayCaptStreamLineMode : Boolean;  // XRAY Capturig StreamLine Mode

  K_CMSCheckMemFreeDIBSize : Integer; // Needed DIB size for memory free space check
  K_CMSCheckMemFreeBufSize : Integer; // Needed Buffer size for memory free space check
  K_CMSCheckMaxMemFreeTimeDelta : Double; // Check Maximal Memory Free Space Time Delta in Minutes
  K_CMSCheckMaxMemFreeTimeStamp : Double; // Last Memory Free Space Check Time Stamp

  K_CMSDuplicateSlideBeforeCrop : Boolean = TRUE; // Duplicate Slide Before Crop Flag
//  K_CMSDuplicateSlideBeforeCrop : Boolean = FALSE; // Duplicate Slide Before Crop Flag

  K_CMSCreateDeleteMode         : Integer; // Create/Delete mode
                                           // 0 - ordinary Create/Delete
                                           // 1 - Create/Delete while Import after convertion or it's Reverse
                                           // 2 - Delete while DB Integrity check procedure

  K_CMSDBRecoveryMode           : Boolean; // DB recovery Mode

///////////////////////////////////////////////////////////
//  CMS Mark as Deleted control
//
  K_CMMarkAsDelShowFlag: Boolean;   // Show Mark as Deleted Mode Flag
  K_CMMarkAsDelUseFlag: Boolean;    // Use Mark as Deleted Mode Flag (DBVer >=14 and UseExtDB)

///////////////////////////////////////////////////////////
//  CMS D4W COM Client Interface Context
//
  K_CMD4WSkipCloseUI    : Boolean = FALSE; // CMS Application UI Close Flag needed to prevent CMS close while not modal Capture device is launched
//  K_CMD4WCloseAppByUI   : Boolean = TRUE; // CMS Application Unconditional Close by UI Flag
  K_CMD4WCloseAppByUI   : Boolean = FALSE; // CMS Application Unconditional Close by UI Flag
  K_CMD4WCloseAppByUITest: Boolean = FALSE; // CMS Application Unconditional Close by UI Test Flag


//??  K_CMD4WMainFormCloseFlag : Boolean; // CMS Application Main Form Should Be Closed
  K_CMD4WAppFinState    : Boolean; // CMS Application is now closing - needed to prevent any DataAccess and COM activity
  K_CMD4WComServerExists: Boolean; // CMS Application Com Server Exists in Application
  K_CMD4WAppRunByCOMClient : Boolean; // CMS Application Run by D4W Client Flag
  K_CMD4WAppFinByClient : Boolean; // CMS Application is finished by D4W Client Flag

//  K_CMD4WSetCurDataContext: Boolean; // CMS Application Context was set by D4W Client Flag
  K_CMD4WLocationsInfo: string; // D4W Start Locations Info
  K_CMD4WPatientsInfo : string; // D4W Start Patients Info
  K_CMD4WProvidersInfo: string; // D4W Start Providers Info
  K_CMD4WUpdateInfo   : string; // D4W Start Update Info
  K_CMD4WPatDocPath   : string; // Path to D4W Patient Documents

  K_CMD4WUseFilteringInfoFlag : Boolean;          // Use D4W Filtering Attributes
  K_CMD4WSlideFilterAttrs: TK_CMSlideFilterAttrs; // D4W Filtering Attributes
// 05.01.2010 K_CMD4WSkipWaitApplyDataFlag: Boolean; // Skip Waiting for appling D4W Client Data Context Flag
// 05.01.2010 K_CMD4WWaitApplyDataFlag: Boolean; // Wait for appling D4W Client Data Context Flag
//  K_CMD4WRestoreVEUIFlag : Boolean;// Wait for appling D4W Client Data Context while Restore VEUI
  K_CMD4WWaitApplyDataCount: Integer;// Wait for appling D4W Client Data Context Counter
//  K_CMD4WNewPatMode: Integer; // Server action if Skip Change Patient is needed
//                              // 0 - reply Server is busy (in Modal dialog with previous Patient Slides)
//                              // 1 - done client request when server will not busy
//                              // 2 - close serever modal dialogs - not implement
  K_CMD4WCNewPatientID   : Integer = -1; // D4W New Patient ID request
  K_CMD4WCNewProviderID  : Integer;      // D4W New Provider ID request
  K_CMD4WCNewLocationID  : Integer;      // D4W New Location ID request
//  K_CMD4WCNewDemoModeFlag: Boolean;     // D4W New Demo Mode Flag !!! not used now
// 05.01.2010 K_CMD4WCNewWindowState : Integer = -1;// D4W New Window State
  K_CMD4WUICommandsList  : TStringList; // List of GUI Commands to Execute
  K_CMD4WCurCodePage     : Integer;     // D4W Current Code Page
  K_CMDBCurCodePage      : Integer;     // DB Current Code Page

  K_CMD4WSlideStudyOpenFlag : Boolean; // Open Slide Study and Select it in Study for Slides linked to Study Flag

  K_CMD4WHPNewPatientID    : Integer; // D4W HP New Patient ID
  K_CMD4WHPNewProviderID   : Integer; // D4W HP New Provider ID
  K_CMD4WHPNewLocationID   : Integer; // D4W HP New Location ID
  K_CMD4WHPFilmStripIDs    : string;  // D4W Slides IDs list to show in HP Film Strip
  K_CMD4WHPFilmStripPrevIDs: string;  // D4W Slides previouse IDs list to show in HP Film Strip
  K_CMD4WHPViewSlideID     : string;  // D4W Slide ID to show in High Resolution Mode
  K_CMD4WHPOpenInVEMode    : Integer; // D4W open CMS in View/Edit mode from HP
                                      // 0 - open current HR Slide
                                      // 1 - open Film Strip Slides
  K_CMD4WSkipCMSAwakeFlag  : Boolean; // Skip CMS Awake Flag by some COM commands from D4W
                                      // is needed while prev Provider has no Access Rights

///////////////////////////////////////////////////////////
//  CMS WEB COM Client Interface Context
//
  K_CMWEBCOMPatientID    : Integer; // WEB COM Patient ID
  K_CMWEBCOMProviderID   : Integer; // WEB COM Provider ID
  K_CMWEBCOMLocationID   : Integer; // WEB COM Location ID (always =0, LocID=0 LocName ='WEB access')
  K_CMWEBPatOrderSQL     : string;  // WEB Patients Order SQL clause
  K_CMWEBPatWhereSQL     : string;  // WEB Patients Where SQL clause
const
  K_CMWEBCOMLocationName = 'WEB Access';
//
//  CMS WEB COM Client Interface Context
///////////////////////////////////////////////////////////

var
///////////////////////////////////////////////////////////
//  CMS Virtual UI Context
//
{ // Prev Version
K_CMVUIMode : Boolean;     // if TRUE then CMSuite UI is virtualized by WEB brouser
K_CMVUIScanName : string;  // name cleint computer retrieved from CMScan
K_CMVUIDownloadFileProc : procedure (const WS: WideString) of object = nil;
// Synchronous Get Scan Computer Name (is used now)
K_CMVUIGetScanCompNameProc : function ( APort : Integer ) : string = nil;
// Asynchronous Get Scan Computer Name (may be used in future)
// In order to start Asynchronous Get Scan Computer one should:
// - call K_CMVUIGetScanCompNameStartProc
// - set process finish time
// for example
//   K_CMVUIGetScanCompNameStartProc(K_CMVUIScanPortNumber);
//   K_CMVUIGetScanCompNameFinDT := Now() + 5/ (24*3600); // finish check process after 5 seconds
//
// The process will be finished if Computer Name wil be recieved by  K_CMVUIGetScanCompNameCheckProc
// or current time is reach K_CMVUIGetScanCompNameFinDT
K_CMVUIGetScanCompNameStartProc : procedure ( APort : Integer );
K_CMVUIGetScanCompNameStopProc  : procedure ( );
K_CMVUIGetScanCompNameCheckProc : function  ( ) : string = nil; // should return:
// - real Computer name if it was recieved,
// - '' empty string if Computer name is still not recieved but code 200 was recieved
// - 'NOSCAN' if code 404 was recieved
K_CMVUIGetScanCompNameFinDT     : TDateTime;
//
K_CMVUIScanPortNumber : Integer;
K_CMVUIDataBaseHost : string;
K_CMVUIDataBaseIP : LongWord;
K_CMVUIDataBasePort : Word;
K_CMVUIURLList: TStringList;
////Igor 22102019////Igor MySQL 05.11.2019  Data from ConfigDB MySQL
K_CMVUICMSIdleTime: Integer;
//K_CMVUICMSDBPort: Integer;
//K_CMVUICMSDBHost: string;
K_CMVUICMSDBServerName: string;
K_CMVUICustomerID: string;
K_CMVUILongName: string; // Do not use now
K_CMVUICMSRootFolder: string;  // Use instead of CMSLogFiles
K_CMVUIDataBaseDriver: string; //!!!Ura 22.06.20
K_CMVUICustomersRoot: string;  //!!!Ura 22.06.20
K_CMVUIWorkfolderRoot: string; //!!!Ura 22.06.20
K_CMVUICheckProvIUDate: Integer;
// Prev Version }
K_CMVUIMode : Boolean;     // if TRUE then CMSuite UI is virtualized by WEB brouser
K_CMVUIScanName : string;  // name cleint computer retrieved from CMScan
K_CMVUIDownloadFileProc : procedure (const WS: WideString) of object = nil;
// Synchronous Get Scan Computer Name (is used now)
K_CMVUIGetScanCompNameProc : function ( APort : Integer; AParams : String ) : string = nil;
// Asynchronous Get Scan Computer Name (may be used in future)
// In order to start Asynchronous Get Scan Computer one should:
// - call K_CMVUIGetScanCompNameStartProc
// - set process finish time
// for example
//   K_CMVUIGetScanCompNameStartProc(K_CMVUIScanPortNumber);
//   K_CMVUIGetScanCompNameFinDT := Now() + 5/ (24*3600); // finish check process after 5 seconds
//
// The process will be finished if Computer Name wil be recieved by  K_CMVUIGetScanCompNameCheckProc
// or current time is reach K_CMVUIGetScanCompNameFinDT
K_CMVUIGetScanCompNameStartProc : procedure ( APort : Integer );
K_CMVUIGetScanCompNameStopProc  : procedure ( );
K_CMVUIGetScanCompNameCheckProc : function  ( ) : string = nil; // should return:
// - real Computer name if it was recieved,
// - '' empty string if Computer name is still not recieved but code 200 was recieved
// - 'NOSCAN' if code 404 was recieved
K_CMVUIGetScanCompNameFinDT     : TDateTime;
//
K_CMVUIScanPortNumber : Integer;
K_CMVUIDataBaseHost : string;
K_CMVUIDataBaseIP : LongWord;
K_CMVUIDataBasePort : Word;
K_CMVUIURLList: TStringList;
////Igor 22102019////Igor MySQL 05.11.2019  Data from ConfigDB MySQL
K_CMVUICMSIdleTime: Integer;
//K_CMVUICMSDBPort: Integer;
//K_CMVUICMSDBHost: string;
K_CMVUICMSDBServerName: string;
K_CMVUICustomerID: string;
K_CMVUILongName: string; // Do not use now
K_CMVUICMSRootFolder: string;  // Use instead of CMSLogFiles
K_CMVUIDataBaseDriver: string; //!!!Ura 22.06.20
K_CMVUICustomersRoot: string;  //!!!Ura 22.06.20
K_CMVUIWorkfolderRoot: string; //!!!Ura 22.06.20

//
//  CMS Virtual UI Context
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
//  CMScan WEB  Context
//
K_CMScanWEBMode : Boolean = FALSE; // if TRUE then CMSuite UI is virtualized by WEB brouser
//
//  CMScan WEB  Context
///////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
//  CMS Applicàtion Context
//
  K_CMTerminateByEDAError : Boolean; // Application should be treminated while External Data Access Error had been detected
//  K_CMLockPatientFlag     : Boolean; // Lock Patient Data Flag
  K_CMCloseOnFinActionFlag: Boolean;   // Should be set TRUE to close CMS inside TN_CMResForm.AddCMSActionFinish()
  K_CMCloseOnCurUICloseFlag: Boolean;  // Should be set TRUE to close CMS when Current UI Main Form Closing
  K_CMSwitchMainUIFlag: Boolean;       // Should be set TRUE when Main Form Closing to swith CMS UI to another
  K_CMCloseCurUIFlag: Boolean;         // Should be set TRUE to unconditional close UI Main Form (for HR Preview)
  K_CMOutOfMemoryFlag : Boolean;       // GLobal Out Of Memory Flag to real CMS Close

  K_CMAutoCloseLastActTS : TDateTime;  // CMS Auto close - last action Timestamp to control CMS close
const
  K_CMAutoCloseDaysDelta : Double = 19 / (24 * 60); // CMS Auto Close - wait time interval in days

var
///////////////////////////////////////////////////////////
//  CMS Auto Upgrade Context
//
  K_CMAUType   : string; // Auto Upgrade Type
  K_CMAUBridge : string; // Auto Upgrade Bridge

///////////////////////////////////////////////////////////
//  CMS Current Slides Context
//
  K_CMSkipSlidesSavingFlag: Boolean; // Skip SLides saving while CMS closing Flag
  K_CMCurSlideFilterAttrs: TK_CMSlideFilterAttrs; // Current Filtering Attributes
  K_CMCurVisSlidesArray  : TN_UDCMSArray; // Current Visible Slides Array

///////////////////////////////////////////////////////////
//  Devices Profiles Context
//
//  K_CMCaptProfileInd: Integer;     // Captured Profile Index
  K_CMDevIconsSInd  : Integer = 50; // Static Device Icons Start Index
  K_CMDevIconsFInd  : Integer = 59; // Static Device Icons Final Index
  K_CMDynIconsSInd  : Integer; // Dynamic Device Icons Start Index in Main ImageList
  K_CMDynTranspColor: Integer; // Dynamic Images Transparent Color
  K_CMUnUsedShortCuts : TStringList; // Unused Shortcuts for acquire devices
  K_CMDevToolButMaxCount  : Integer = 6; // Device Tool Buttons Max Counter
//  K_CMDevToolButMaxCount  : Integer = 4; // Device Tool Buttons Max Counter


///////////////////////////////////////////////////////////
//  Image Colorization Data
//
//  K_CMColorizePalNames  : TN_SArray;  // Colorize Palettes Names
  K_CMColorizePalColors : TN_AIArray; // Colorize Palettes Path Colors
  K_CMColorizePalIndex  : Integer;    // Current Colorize Palette Index

///////////////////////////////////////////////////////////
//  Image Sharpen/Smoothen Data
//
  K_CMSharpenMax  : Double;  // Image Sharpen Maximal Factor
//  K_CMSmoothenMax : Double;  // Image Smoothen Maximal Factor


///////////////////////////////////////////////////////////
//  CMS Colors
//
    K_CMSFrameActiveBGColor     : TColor;
    K_CMSFrameActiveFontColor   : TColor;
    K_CMSFrameInactiveBGColor   : TColor;
    K_CMSFrameInactiveFontColor : TColor;
    K_CMSFrameActivePictBGColor : Integer;
    K_CMSStudyThumbBGColor      : Integer;
    K_CMSStudyExportBGColor     : Integer;

///////////////////////////////////////////////////////////
//  CMS Study GUI modes
//
  K_CMStudySingleOpenGUIModeFlag     : Boolean; // Single Study Open Mode Flag
  K_CMStudyOpenOnCreateGUIModeFlag   : Boolean; // Study Open just created Mode Flag
  K_CMStudyAddSlidesGUIModeFlag      : Boolean; // Add Study Slides to resulting objects list to operate
  K_CMStudyOnlyThumbsShowGUIModeFlag : Boolean; // Study Skip Slide Thumbnails Show Mode Flag
//  K_CMShowArchivedSlidesFlag        : Boolean; // Show Archived Slide Thumbnails Mode Flag//  K_CMStudyDetailsDumpCInd           : Integer = 2; // Study Details Dump Chanel Index
  K_CMShowArchivedSlidesFlag         : Boolean; // Show Archived Slide Thumbnails Mode Flag//  K_CMStudyDetailsDumpCInd           : Integer = 2; // Study Details Dump Chanel Index
  K_CMStudyDetailsDumpCInd           : Integer = 0; // Study Details Dump Chanel Index
  K_CMSFixStudyDataMode              : Integer = 0; // =0 - nothing to do; =1 - show warning; =2 - put action to menu

///////////////////////////////////////////////////////////
//  CMS Design mode
//
// Now is used to skip user password to enter to diologs:
// Alt-Shift-M, DeviceSetup, Import after Convertion Reverse
//
  K_CMDesignModeFlag: Boolean;         // Design Mode Flag

///////////////////////////////////////////////////////////
//  CMS DEMO mode Data
//
  K_CMDemoModeFlag: Boolean;           // Demo Mode Flag
  K_CMDemoMaxSlidesCount: Integer;     // Patient Maximal Slides number in Demo Mode
  K_CMDemoMaxSlidesWarnCount: Integer; // Patient Maximal Slides number for Warning in Demo Mode
  K_CMDebVersionModeFlag : Boolean;    // Wrk Version Mode Flag
  K_CMDemoTestModal: Boolean;          // Demo Test Show Modal Flag
  K_CMDemoTestTop  : Boolean;          // Demo Test Stay on Top Flag

///////////////////////////////////////////////////////////
//  Flashlight (ROI) Annotation Ini Data
//
  K_CMFlashlightIni : TK_CMFlashlightIniData = (
    CMFLPixSize          :100; // Flashlight Initial Pixel Size
    CMFLScaleFactor      : 2;  // Flashlight Scale Factor
    CMFLBriFactor        : 0;  // Flashlight Brightness Factor
    CMFLCoFactor         : 3;  // Flashlight Contrast Factor
    CMFLSkipScaleFlag    : 0;  // Flashlight Skip Scale Mode Flag
    CMFLAutoEqualizeFlag : 0;  // Flashlight Use Auto Equalize Mode Flag
    CMFLRectFlag         : 0;  // Flashlight Rectangle Shape Flag
    CMFLGamFactor        : 0;  // Flashlight Gamma Factor
);
///////////////////////////////////////////////////////////
//  Flashlight Mode Ini Data
//
  K_CMFlashlightModeBasePixSize : Integer = 100;
  K_CMFlashlightModeIni : TK_CMFlashlightIniData = (
    CMFLPixSize         :100; // Flashlight Initial Pixel Size
    CMFLScaleFactor     : 2;  // Flashlight Scale Factor
    CMFLRectFlag        : 0; // Flashlight Rectangle Shape Flag
    CMFLNewAttrsFlag    : 1;  // Flashlight New Attrs Flag
    CMFLGamFactor       : 0;  // Flashlight Gamma Factor
    CMFLMode            : uddrmNoEffect;  // Mode (effect)
    CMFLEmbAngle        : 45; // Emboss Angle    (see CalcEmbossDIB)
    CMFLEmbCoef         : 10; // Emboss Coef     (see CalcEmbossDIB)
    CMFLEmbDepth        : 3;  // Emboss Depth    (see CalcEmbossDIB)
    CMFLEmbBaseGrey     : 128;// Emboss BaseGrey (see CalcEmbossDIB)
);

///////////////////////////////////////////////////////////
//  Rectangle Type Annotations Tool Common Data
//  (Rectangle, Ellipse, Arrow, Flashlight)
//
  K_CMRectTypeVObjMinSize   : Integer =  30;  // Rect Type Annotation Minimal Size

///////////////////////////////////////////////////////////
//  Arrow Line Annotation Data
//
  K_CMArrowLineTipSize   : Integer = 20;  // Arrow Line Annotation Tip Size in pixels
  K_CMArrowLineTipAngle  : Double  = 22.5;  // Arrow Line Annotation Tip Angle in degree

///////////////////////////////////////////////////////////
//  CMS Media Files Storing Mode
//
//  K_CMMediaFilesStoringMode: Integer = 0; // Media Files Stroring Modes:
  K_CMMediaFilesStoringMode: Integer = 1; // Media Files Stroring Modes:
                           // 0 - only Client Computer Local HDD Storing
                           // 1 - only File Server Storing
                           // 2 - both Client Computer and File Server Storing
  K_CMMediaFilesSplitSize: Integer = 30 * 1024 * 1024;
  K_CMMediaFilesMinSize  : Integer = 10 * 1024;

///////////////////////////////////////////////////////////
//  VideoCam Pedal Parameters
//
  K_CMCaptButDelay : Float;  // Capture Button (on Camera or Foot Pedal) Delay in seconds


///////////////////////////////////////////////////////////
//  CMS Objects maximal sizes
//
  K_CMImgMaxPixelsSize : Integer; // CMS Image maximal pixels size
  K_CMBufMaxCapacity   : Integer; // Buffers maximal size

///////////////////////////////////////////////////////////
//  CMS FullScreen
//
  K_CMSFullScreenForm  : TForm;   // CMS FullScreen Form

///////////////////////////////////////////////////////////
//  CMS VIP Customer Info
//
//  K_CMSVIPCTitle  : string = 'HCF';   // VIP Customer Title
  K_CMSVIPCTitle  : string;   // VIP Customer Title

///////////////////////////////////////////////////////////
//  CMS Slide Tumbnail Text Flags
//
  K_CMSThumbTextFlags : TK_CMSThumbTextFlagsSet;

///////////////////////////////////////////////////////////
//  CMS Slide Auto open just after Processing Dialog
//
  K_CMSlideAutoOpen : Boolean;

///////////////////////////////////////////////////////////
//  CMS Image 8/16 bit Modes
//
  K_CMSSkip16bitMode    : Boolean = TRUE;
  K_CMSRImageType       : Integer = 0;    // 0 - GDI+, 1 - ImLib, 2 - CMRI
  K_CMSRImageNotGDIType : Integer = 2;    // 1 - ImLib, 2 - CMRI

///////////////////////////////////////////////////////////
//  CMS Patient Slides Auto Update Interval
//
  K_CMPatSlidesAutoRefreshLag : Integer; // // Patient Slides Auto Refresh Lag in seconds

///////////////////////////////////////////////////////////
//  CMS Application Start Context - neded to apply in Interface FormShow Handler
//
type TK_CMSAppStartMode  = (K_cmamWait,K_cmamCOMVEUI,K_cmamCOMHPUI,K_cmamCOMWEB,K_cmamCOMFSAccess,K_cmamSleep,K_cmamDCMExe);
type TK_CMSAppStartState = (K_cmasOK,K_cmasSkipStartContext,K_cmasStop);
//type TK_CMSAppStartState = (K_cmasOK,K_cmasSkipStartContext,K_cmasStop,K_cmasRun);
type TK_CMSAppStartContext = record
  CMASActualFlag : Boolean;
  CMASMode   : TK_CMSAppStartMode;  // Application Start Mode
  CMASState  : TK_CMSAppStartState; // Application Start State
  CMASPatID  : Integer;
  CMASProvID : Integer;
  CMASLocID  : Integer;
  CMASPSlideFilterAttrs: TK_PCMSlideFilterAttrs;
  CMAInitNotComplete : Boolean; // Application Objects Initialization is not complete
end;
var K_CMSAppStartContext : TK_CMSAppStartContext;

///////////////////////////////////////////////////////////
//  CMS ZoomMode Form
//
  K_CMSZoomForm  : TForm;   // CMS Active Ed3Frame Zoom Form

///////////////////////////////////////////////////////////
//  CMS Draw Context
//
  K_CMStretchBltMode : Integer = COLORONCOLOR; // Canvas Draw Stretch Blt Mode
  K_CMSkipMouseMoveRedraw : Integer = 0;
//  K_CMSkipMouseMoveRedraw : Integer = 1;
//  K_CMSkipMouseMoveRedraw : Integer = 2;
  K_CMRedrawObject : TK_RedrawDelayObj;

///////////////////////////////////////////////////////////
//  CMS Ini LogFiles Path value for saving in DEMO Mode
//
  K_CMSIniLogPath : string;


///////////////////////////////////////////////////////////
//  CMS Server/Client Context
//
type TK_CMSServerClientInfo = record
  CMSSessionInfo : TK_WTSSessionInfo; // Session Info
  CMSClientVirtualName : string;      // Client Virtual Name - ComputerName in non Terminal Service, ClientName or Client IP Address in Terminal Service Mode
end;
var
  K_CMSServerClientInfo : TK_CMSServerClientInfo;

///////////////////////////////////////////////////////////
//  CMS Standalone Context
//
  K_CMStandaloneGUIMode: Boolean; // CMS is started in in Standalone

type TK_CMStandaloneMode = (K_cmsaIndependent,K_cmsaHybrid,K_cmsaLink);
var
  K_CMStandaloneMode : TK_CMStandaloneMode = K_cmsaIndependent;

///////////////////////////////////////////////////////////
//  CMS Terminal Session Context
//
  K_CMSWTSSessionInfo : TK_WTSSessionInfo;

///////////////////////////////////////////////////////////
//  CMS Local Archive New Img Format Flag
//
  K_CMLocalArchNewFileFormatFlag: Boolean = TRUE; // CMS Local Archive Images New Format Flag
//  K_CMLocalArchNewFileFormatFlag: Boolean = FALSE; // CMS Local Archive Images New Format Flag


///////////////////////////////////////////////////////////
//  CMS Command Line Link Type Info
//
type TK_CMSLinkCommandLineFormatMode = (K_cmclfNone,K_cmclfCL2000,K_cmclfVW,K_cmclfUDVW,K_cmclfIni);
var
  K_CMSLinkCommandLineFormatMode : TK_CMSLinkCommandLineFormatMode = K_cmclfCL2000;
  K_CMSLinkCommandLineUDFormat   : string;
  K_CMSCLLAttrs : TK_CMSCLLAttrs;
  K_CMSCLLIniFName : string;

///////////////////////////////////////////////////////////
//  CMS Previouse ErrLog Dump Name
//
  K_CMSPrevErrLogFName : string;

///////////////////////////////////////////////////////////
//  CMS DICOM Context
//
  K_CMGUIDICOMMenuVisFlag: Boolean; // CMS DICOM Menu Visible Flag

  K_CMDICOMNewFlag : Boolean = TRUE; // Use Golubinsky Lib
//  K_CMDICOMNewFlag   : Boolean = FALSE;

  K_CMDICOMNewFSFlag : Boolean = TRUE; // Store DICOM attrs file in CMSuite FS
//  K_CMDICOMNewFSFlag : Boolean = FALSE; // Store DICOM attrs file in CMSuite FS

  K_CMDICOMRetrieveAEName : string = '********'; // needed for DICOM RETREIVE

  K_CMDICOMAutoStoreFlag : Boolean = FALSE; // Auto Store Flag

///////////////////////////////////////////////////////////
//  CMS Disk Free Space and Access Check
//
  K_CMDisableDiskFreeSpaceCheck : Boolean = TRUE;
  K_CMDisableDiskAccessCheck    : Boolean = TRUE;


const
  K_CMSMainFormCaptPref1 = '[Deb]';
  K_CMSMainFormCaptPref2 = '[Admin] ';

type TK_CMSetSlidesAttrsFlags = set of (
  K_ssafSkipProcessDate, // Skip change date taken
  K_ssafSkipAutoOpen     // Skip Using AutoOpen Mode
);

/////////////////////////////
//  CMS 3D Image Info
//
const
  K_CMS3DImgResFolder    = 'ResFiles\';
  K_CMS3DImgResInfoFile  = 'Info.txt';
  K_CMS3DImgResThumbFile = 'Thumbnail.png';

/////UI Marked as deleted counter
//             //////////////////////////////////////////////////////
//  CMS
var
  K_CMMarkedAsDeletedCount: Integer; // Marked as Deleted counter

///////////////////////////////////////////////////////////
//  CMS DICOM QR settings store mode
//
//  K_CMDCMSettingsStoreMode : Integer; // 0 - use Location Context, 1 - use Global Context, 2 - use Client Context

const K_ImgFolder   = 'Img\';
const K_VideoFolder = 'Video\';
const K_Img3DFolder = 'Img3D\';


procedure K_CMSDebAction1Proc();

var
/////////////////////////////////////////
// Used for Regional Data Processing
  K_CMEDAMemIniFile   : TMemIniFile; // tmp MemIni Object for contexts processing
  K_CMEDAMemIniStrings: TStringList; // tmp Strings Object for contexts processing

///////////////////////////////////////////////////////////
//  CMS Capture to Study context
//
type
  TK_CMStudyCaptState = (K_cmscNon, K_cmscStudyCaptDlgIsClosed, K_cmscOK, K_cmscSkipPreview, K_cmscDeviceDlgShowLater);

//********************************************************** TK_CMSDCDAttrs ***
// Study Direct Capture Devices interface Attributes
//
type TK_CMSDCDAttrs = record
  CMSDCDDlg       : TN_BaseForm;    // Device CMS Capture Dlg (should be nil if not Modal Capture mode)
//  CMSDCDDlg       : TForm;    // Device CMS Capture Dlg (should be nil if not Modal Capture mode)
  CMSDCDDlgCPanel : TControl; // Device CMS Capture Dlg Panel with Controls which should be visible in Capture to Study Dlg
  CMSDCDLaunchDevUIProc    : TN_ProcObj; // Capture to Study using Device Self UI (not Device CMS Capture Dlg) procedure of object
  CMSDCDCaptureSlideProc   : TN_ProcObj; // Capture One Slide procedure of object for CaptureToStudy (outer) AutoTake, if nil then inner (device) AutoTake is implemented
  CMSDCDCaptureDisableProc : TN_ProcObj; // Device CMS Capture Dlg disable procedure of object
  CMSDCDCaptureEnableProc  : TN_ProcObj; // Device CMS Capture Dlg enable  procedure of object
  CMSDCDAutoTakeStateGetFunc : TK_FuncObjBool; // Device CMS Capture Dlg AutoTake get state (should be set to nil if AutoTake is device built-in or is absent)
  CMSDCDAutoTakeStateSetProc : TN_OneIntProcObj; // Device CMS Capture Dlg AutoTake set state (should be set to nil if AutoTake is device built-in or is absent)
end;

var
// K_CMStudyCaptAttrs.CMSDCDDlg  >> K_CMStudyCaptDevDlg
// K_CMStudyCaptAttrs.CMSDCDDlgCPanel  >> K_CMStudyCaptDevDlgCPanel
// K_CMStudyCaptAttrs.CMSDCDLaunchDevUIProc  >> K_CMStudyCaptDeviceSeriesRoutine
// K_CMStudyCaptAttrs.CMSDCDCaptureSlideProc  >> K_CMStudyCaptDeviceAutoStartRoutine
  K_CMStudyCaptState : TK_CMStudyCaptState;
  K_CMStudyCaptAttrs : TK_CMSDCDAttrs; // Current Device Capture Object Interface
  K_CMStudyCaptDevDlgCPanelParent : TWinControl;// CMS Device Capture Dlg Panel Parent Control in CMS Device Capture Dlg
  K_CMStudyCaptImgConfirmDlgCoords: TRect;      // CMS Capture to Study Confirm Dialog Coords
  K_CMStudyCaptPreviewTimeout     : Integer;    // CMS Capture to Study Preview Timeout

procedure K_CMStudyCaptAddSlide( ASlide : TN_UDCMSlide );
//procedure K_CMStudyCaptRemoveSlide( ASlide : TN_UDCMSlide );
procedure K_CMStudyCaptFinishByDevice();
function  K_CMDBFilePathPrepStr( const ASrcPath : string ) : string;

var K_CMEDDBSysInfoSPLDTC : TK_ExprExtType;

///////////////////////
// Photometry context
//
// Photometry UI Mode -1 - skip Photometry UI, Switch to Photometry action invisible (in GoTo menu)
//                     0 - CMSuite UI, Switch to Photometry UI action visible (in GoTo menu)
//                     1 - Photometry UI, Switch to CMSuite UI action visible (in GoTo menu)
K_CMSMainUIShowMode : Integer = -1;
//K_CMSMainUIShowMode : Integer = 0;
//K_CMSMainUIShowMode : Integer = 1;

//K_CMShowPMTStudiesFlag : Boolean = FALSE;
K_CMShowPMTStudiesFlag : Boolean = TRUE; // will be changed by UI in future

K_CMShowPMTStudiesOnlyFlag : Boolean = FALSE; // Set and Reset automaticaly while Main UI mode is changed

const
  K_CMPMTStudySampleSID = '100';
  K_CMPMTStudySampleSID1 = '101';
//
// Photometry context
///////////////////////

var
  K_CMEDADFPLExec     : TK_DFPLScriptExec; // DFPL Script Processor for contexts processing
  K_CMEDADefaultMemIni: TMemIniFile; // MemIni Object for saving Some Default IniFile Fields for futute restore


//////////////////////////////////////////////////
//  DICOM Export/Store Current context
//
var
  K_CMDCMD4WStudyUID : string;    // D4W DICOM Study UID
  K_CMDCMSeriesID    : Integer;   // Current DICOM Series ID
  K_CMDCMSeriesIDTS  : TDateTime; // Current DICOM Series ID DateTime
  K_CMDCMSeriesIDSCount : Integer;// Current DICOM Series ID  Slides Count
  K_CMDCMUIDPrefix   : string;    // DICOM UID prefix CentaurUID + DBUID
  K_CMDCMStoreBufLPath : string = 'DCMStore\';  // DICOM Store Buffer Local Path
//
//  DICOM Export/Store Current context
//////////////////////////////////////////////////

function K_CMDICOMVisible() : Boolean;
var
    K_CMEDAMemTextFragms : TN_MemTextFragms; // Text Fragms with DFPL scripts for contexts processing

var K_CMDBAPSW :string = '';
procedure K_CMGetDBAPSW();
procedure K_CMSetDBAPSW();

//procedure TestMemoryDestruction20180829();
implementation

uses
{$IF SizeOf(Char) = 2}
  AnsiStrings,
{$IFEND}
//  ShlObj, ActiveX,
  StrUtils, SysUtils, ExtDlgs, Messages, DateUtils, StdCtrls,
  N_Lib1, N_ClassRef, N_CMResF, N_CMMain5F, N_CompCL, N_CM1,
  N_IconSelF,
  N_Video, N_GCont, N_Gra0, N_Gra1, N_Gra3, N_Gra6,
  N_CMREd3Fr, N_InfoF, N_DGrid, N_BrigHist2F, N_EdParF,
  N_K_Tmp, N_ImLib, N_CMFPedalSF,
  K_VFunc, K_UDC, K_Gra1, K_URImage,
  K_CML1F, K_CML3F,{K_FCMSetSlidesAttrs,} K_FCMSetSlidesAttrs2,
  K_MapiControl, K_Arch, K_UDT2, K_UDConst, K_FCMSTextAttrs,
  K_FCMSIsodensity, K_FCMECacheProc,
  K_FCMSCalibrate, K_FEText, K_FCMCaptButDelay, K_FCMSlideIcons, K_FCMSlideIcon,
  K_FCMReportShow, K_FCMProfileTwain, K_FTestUnit, K_FCMSASelectPat, K_FCMSASetPatData,
  K_FCMClientScan, K_FCMDCMExe,
//  K_CMSLLL, K_FCMSAComClient;
  K_CMSLLL, K_FCMStart, K_CM1, K_FCMScan,
  K_FCMDeviceLimitWarn,K_CMTWAIN,K_CMCaptDevReg, K_FCMStudyCapt,
  K_FCMStudyCaptSlide, K_CMDCM, K_FCMSupport,K_CMDCMGLibW,K_FCMEnterDBAPSW;

var
//    K_CMEDAMemTextFragms : TN_MemTextFragms; // Text Fragms with DFPL scripts for contexts processing
//    K_CMEDAMemIniFile   : TMemIniFile; // tmp MemIni Object for contexts processing
//    K_CMEDAMemIniStrings: TStringList; // tmp Strings Object for contexts processing
    K_CMEDADFPLMacroList : TStringList;

{
procedure TestMemoryDestruction20180829();
var
  WSlidesArray : TN_UDCMSArray;
  i : Integer;
begin
  WSlidesArray := nil;
  K_CMEDAccess.EDASAGetPatientSlidesView( '-101', WSlidesArray );
  for i := High(WSlidesArray) downto 0 do
  begin
    if (WSlidesArray[i].R.ALength = 0) then
      WSlidesArray[i].ObjName := WSlidesArray[i].ObjName + '';
  end;

  for i := 0 to High(WSlidesArray) do
    WSlidesArray[i].UDDelete();

  WSlidesArray := nil;

end; // procedure TestMemoryDestruction20180829
}

//********************************************** K_CMSTeethChartStateToText ***
// Convert Teeth Chart State to Text
//
//     Parameters
// ATeethChartState - teeth chart state
// Result - Returns "" if OK else Error String
//
function K_CMSTeethChartStateToText(ATeethChartState: Int64): string;
var
  CPStr: PString;
  CInd: Integer;
  i: Integer;
begin
  Result := '';
  CPStr := @K_CMTNumUSANames[0];
  if K_CMToothNumSchemeFlag = K_CMTNumFDIScheme then
    CPStr := @K_CMTNumFDINames[0];
  for i := 0 to High(K_CMTNumTextInds) do
  begin
    CInd := K_CMTNumTextInds[i];
    if K_SetGetElementState(CInd, @ATeethChartState) then
    begin
      if Result <> '' then
        Result := Result + ',';
      Result := Result + PString(TN_BytesPtr(CPStr) + CInd * SizeOf(string))^;
    end;
  end;
end; // end of K_CMSTeethChartStateToText

//********************************************** K_CMSTeethChartTextToState ***
// Convert Teeth Chart Text to Int64 State
//
//     Parameters
// ATeethChartText - teeth chart text (comma separated item names)
// Result - Returns Teeth Chart State as Int64 set
//
function K_CMSTeethChartTextToState( const ATeethChartText : string; ADelim : Char = ',' ) : Int64;
var
  SL : TStringList;
  i, Ind : Integer;
begin
  Result := 0;
  if ATeethChartText = '' then Exit;

  SL := TStringList.Create;
  SL.Delimiter := ADelim;
  SL.DelimitedText := ATeethChartText;
  K_CMToothNumSchemeListRebuild();

  for i := 0 to SL.Count - 1 do
  begin
    if not K_CMToothNumSchemeList.Find( SL[i], Ind ) then Continue;
    K_SetInclude ( Integer(K_CMToothNumSchemeList.Objects[Ind]), @Result );
  end;

  SL.Free;
end; // function K_CMSTeethChartTextToState

//********************************************************** K_CMFilterDatesPrepEInterval ***
// Prepare slide filter Exact Interval
//
//     Parameters
// APFilterAttrs - teeth chart state
//
procedure K_CMFilterDatesPrepEInterval( AFADateMode    : TK_CMSlideFilterDateSelectMode;
                         var AFADate1, AFADate2 : TDateTime );
begin
  AFADate1 := Int(Now());
  AFADate2 := AFADate1 + 1 - 1 / (24 * 3600 * 1000); // // Get Date Day Last MSec
  case Ord(AFADateMode) of
    Ord(K_sfdsmPrevWeek) : begin
      AFADate1 := IncWeek( AFADate1, -1 );
    end;
    Ord(K_sfdsmPrevMonth) : begin
      AFADate1 := IncMonth( AFADate1, -1 );
    end;
    Ord(K_sfdsmPrevQuarter) : begin
      AFADate1 := IncMonth( AFADate1, -3 );
    end;
    Ord(K_sfdsmPrev1Year) : begin
      AFADate1 := IncYear( AFADate1, -1 );
    end;
    Ord(K_sfdsmPrev2Years) : begin
      AFADate1 := IncYear( AFADate1, -2 );
    end;
    Ord(K_sfdsmPrev3Years) : begin
      AFADate1 := IncYear( AFADate1, -3 );
    end;
  end;
end; // end of K_CMFilterDatesPrepEInterval

//********************************************************** K_CMFilterDatesInit ***
// Initialized slide filter dates
//
//     Parameters
// APFilterAttrs - teeth chart state
//
procedure K_CMFilterDatesInit( APFilterAttrs: TK_PCMSlideFilterAttrs );
begin
  if APFilterAttrs = nil then Exit;
  with APFilterAttrs^ do
  begin
    if FADateMode < K_sfdsmToday then Exit;

    K_CMFilterDatesPrepEInterval( FADateMode, FADate1, FADate2 );
  end;
end; // end of K_CMFilterDatesInit

//********************************************************** K_CMSTeethChartStateToText ***
// Clear slide filter attributes record
//
//     Parameters
// APFilterAttrs - teeth chart state
//
procedure K_CMFilterAttrsClear(APFilterAttrs: TK_PCMSlideFilterAttrs);
begin
  FillChar( APFilterAttrs^, SizeOf(TK_CMSlideFilterAttrs), 0 );
  APFilterAttrs^.FAMediaType := K_CMFilterAllMTypesVal;
end; // end of K_CMSTeethChartStateToText

//********************************************************** K_CMSlideCheckByFilter ***
// Test given slide by filtering attributes
//
//     Parameters
// ASlide - testing slide
// APFilterAttrs - pointer to filtering attributes
// Result - Returns TRUE if testing slide satisfies filtering conditions
//
function K_CMSlideCheckByFilter( ASlide: TN_UDCMSlide;
                                 APFilterAttrs: TK_PCMSlideFilterAttrs ): Boolean;
begin
  Result := TRUE;
  if APFilterAttrs = nil then Exit;
  with TN_PCMSlide(ASlide.R.P)^, APFilterAttrs^ do
  begin
    if FAMediaType <> K_CMFilterAllMTypesVal then
      Result := CMSMediaType = FAMediaType;
    if not Result then Exit;
    Result := (FATeethFlags = 0) or ((FATeethFlags and CMSTeethFlags) <> 0 );
    if not Result then Exit;
    Result := (FADateMode = K_sfdsmDatesAll) or
              ( (CMSDTTaken >= FADate1) and
                (CMSDTTaken <= FADate2) );
//              ( (FADateMode = K_sfdsmDatesExact) and
//                (CMSDTTaken = FADate1) ) or
//              ( (FADateMode = K_sfdsmDatesRange) and
//                (CMSDTTaken >= FADate1) and
//                (CMSDTTaken < FADate2) );
  end;
end; // end of K_CMSlideCheckByFilter

//********************************************************** K_CMSlideFilterText ***
// Test given slide by filtering attributes
//
//     Parameters
// ASlide - testing slide
// Result - Returns TRUE if testing slide satisfes filtering conditions
//
function K_CMSlideFilterText(ASlide: TN_UDCMSlide): string;
var
  MTInd: Integer;
  SL: TStrings;
begin
  with ASlide.P^ do
  begin
    if TN_UDCMBSlide(ASlide) is TN_UDCMStudy then
    begin
      Result := CMSSourceDescr
    end
    else
    begin
      Result := K_CMSTeethChartStateToText(CMSTeethFlags);
      if Result <> '' then
        Result := ', ' + Result;
      SL := K_CMEDAccess.EDAGetAllMediaTypes0;
      MTInd := SL.IndexOfObject(TObject(CMSMediaType));
      if MTInd < 0 then
        MTInd := 0;
      Result := SL[MTInd] + Result;
    end;
  end;
end; // end of K_CMSlideFilterText

//********************************************************** K_CMSlideViewCaption ***
// Build given slide caption for ThumbnailFrame and Edit Frame
//
//     Parameters
// ASlide - given slide
// Result - Returns TRUE if testing slide satisfes filtering conditions
//
function K_CMSlideViewCaption(ASlide: TN_UDCMSlide): string;
begin
  with ASlide.P^ do
  begin
    // DateSeparator := '/';
    // Result :=  FormatDateTime( 'dd/mm/yy', CMSDTTaken );
    Result := K_DateTimeToStr( CMSDTTaken, 'dd"/"mm"/"yy' );
    // Result :=  FormatDateTime( 'dd/mm/yyyy', CMSDTTaken );
  end;
end; // end of K_CMSlideViewCaption

{*** TK_CMExtDBuf ***}
{
//******************************************** TK_CMExtDBuf.Create ***
//
constructor TK_CMExtDBuf.Create;
begin
  ExtFieldsList := TStringList.Create;
  ExtDataIDs := TList.Create;
end; // end of TK_CMExtDBuf.Create

//******************************************** TK_CMExtDBuf.Destoy ***
//
destructor TK_CMExtDBuf.Destoy;
begin
  ExtFieldsValues := nil;
  ExtFieldNames := nil;
  ExtFieldsList.Free;
  ExtDataIDs.Free;
end; // end of TK_CMExtDBuf.Destoy

procedure TK_CMExtDBuf.DBAddExtFields( AFieldNames : array of string );
var i : Integer;
begin
  for i := Low(AFieldNames) to High(AFieldNames) do
    DBAddExtField( AFieldNames[i] )
end; // end of TK_CMExtDBuf.DBAddExtField

//******************************************** TK_CMExtDBuf.DBAddExtField ***
// Add external data field name for future data buffering
//
//    Parameters
// AFieldName - name of external data source field
//
procedure TK_CMExtDBuf.DBAddExtField( AFieldName: string );
begin
  ExtFieldsList.Add( AFieldName );
  SetLength( ExtFieldsValues, ExtFieldsList.Count );
  SetLength( ExtFieldNames, ExtFieldsList.Count );
  ExtFieldNames[High(ExtFieldNames)] := AFieldName;
end; // end of TK_CMExtDBuf.DBAddExtField

//******************************************** TK_CMExtDBuf.DBPrepDataIndByID ***
// Prepare Data index by given Data ID
//
//    Parameters
// ADataID - external data ID
// Result - Returns Data index in buffer
//
function TK_CMExtDBuf.DBPrepDataIndByID( ADataID: Integer ) : Integer;
begin
  Result := ExtDataIDs.IndexOf( Pointer(ADataID) );
  if Result < 0 then begin
    Result := ExtDataIDs.Count;
    ExtDataIDs.Add( Pointer(ADataID) );
  end;
end; // end of TK_CMExtDBuf.DBPrepDataIndByID


//******************************************** TK_CMExtDBuf.DBAddValuesArrayByInd ***
// Get value from external data given bu\y ID and  field name
//
//    Parameters
// ADataID - external data ID
// AFieldValues - new field values
//
procedure TK_CMExtDBuf.DBAddValuesArrayByInd( ADataInd: Integer;
                                             AFieldValues: TN_SArray );
var
  i, h : Integer;
  EnlargeBuffersFlag : Boolean;
begin
  EnlargeBuffersFlag := ExtDataIDs.Capacity > Length(ExtFieldsValues[0]);
  h := Min( High(AFieldValues), High(ExtFieldNames) );
  for i := 0 to h do begin
    if EnlargeBuffersFlag then
      SetLength( ExtFieldsValues[i], ExtDataIDs.Capacity );
    ExtFieldsValues[i][ADataInd] := AFieldValues[i];
  end;

end; // end of TK_CMExtDBuf.DBAddValuesArrayByInd

//******************************************** TK_CMExtDBuf.DBAddValuesArrayByID ***
// Add values array to buffer by given ID
//
//    Parameters
// ADataID - external data ID
// AFieldValues - new field values
//
function TK_CMExtDBuf.DBAddValuesArrayByID( ADataID: Integer;
                                            AFieldValues: TN_SArray ) : Integer;
begin
  Result := DBPrepDataIndByID( ADataID );
  DBAddValuesArrayByInd( Result, AFieldValues );
end; // end of TK_CMExtDBuf.DBAddValuesArrayByID

//******************************************** TK_CMExtDBuf.DBAddValuesListByID ***
// Add values list to buffer by given ID
//
//    Parameters
// ADataID - external data ID
// AFieldNValues - list of fields values (<Name>=<Value>)
//
function TK_CMExtDBuf.DBAddValuesListByID( ADataID: Integer;
                                           AFieldNValues: TStrings ) : Integer;
var
  i, j : Integer;
  FVals : TN_SArray;
begin
  Result := DBPrepDataIndByID( ADataID );
  SetLength( FVals, ExtFieldsList.Count );
  for i := 0 to ExtFieldsList.Count - 1 do begin
    j := ExtFieldsList.IndexOf( AFieldNValues.Names[i] );
    if j < 0 then Continue;
    FVals[j] := AFieldNValues.ValueFromIndex[i];
  end;
  DBAddValuesArrayByInd( Result, FVals );
end; // end of TK_CMExtDBuf.DBAddValuesListByID

//******************************************** TK_CMExtDBuf.DBGetFieldValueByID ***
// Get value from external data given bu\y ID and  field name
//
//    Parameters
// ADataID - external data ID
// AFieldName - name of external data source field
// Result - Returns value of given data ID and field
//
function TK_CMExtDBuf.DBGetFieldValueByID( ADataID: Integer;
                                           AFieldName: string ): string;
var
  FVals : TN_SArray;
  i, DInd : Integer;
begin
  DInd := ExtDataIDs.IndexOf( Pointer(ADataID) );
  if (DInd < 0)               and
     Assigned( OnGetExtData ) and
     (ExtFieldsList.Count > 0) then begin
    FVals := OnGetExtData( ADataID, ExtFieldNames );
    DInd := DBAddValuesArrayByID( ADataID, FVals );
  end;
  Result := '';
  if DInd >= 0 then begin
    i := ExtFieldsList.IndexOf( AFieldName );
    if i >= 0 then
      Result := ExtFieldsValues[i][DInd];
  end;

end; // end of TK_CMExtDBuf.DBGetFieldValueByID

//******************************************** TK_CMExtDBuf.DBGetAllValuesByID ***
// Get value from external data given bu\y ID and  field name
//
//    Parameters
// ADataID - external data ID
// AFieldValues - Strings for resulting values (<Name>=<Value>)
// AAddToValues - add to AFieldValues flag (if =FALSE, then AFieldValues would be clear before adding values)
//
procedure TK_CMExtDBuf.DBGetAllValuesByID( ADataID : Integer; AFieldValues : TStrings;
                                           AAddToValues : Boolean = false );
var
  FVals : TN_SArray;
  i, DInd : Integer;
begin
  DInd := ExtDataIDs.IndexOf( Pointer(ADataID) );
  if (DInd < 0)               and
     Assigned( OnGetExtData ) and
     (ExtFieldsList.Count > 0) then begin
    FVals := OnGetExtData( ADataID, ExtFieldNames );
    DInd := DBAddValuesArrayByID( ADataID, FVals );
  end;

  if (DInd < 0)  then
    DInd := 0; // Test mode only - have to be cleared later

  if DInd >= 0 then begin
    if not AAddToValues then
      AFieldValues.Clear;
    for i := 0 to ExtFieldsList.Count - 1 do
      AFieldValues.Add( ExtFieldsList[i] + '=' + ExtFieldsValues[i][DInd] );
  end;

end; // end of TK_CMExtDBuf.DBGetFieldValueByID
}
{*** end of TK_CMExtDBuf ***}


{*** TK_CMExtDSourceEmulator ***}
{

//******************************************** TK_CMExtDSourceEmulator.DSGetData ***
// Get values from external data source
//
//    Parameters
// ADataID - external data ID
// AFieldNames - array of field names of external data source
// Result - Returns array of values for given data ID and fields
//
function TK_CMExtDSourceEmulator.DSGetData( ADataID: Integer;
                                            AFieldNames: TN_SArray ): TN_SArray;
var
  i : Integer;
begin
   Result := Copy( AFieldNames );
   for i := 0 to High(Result) do
     Result[i] := DataPrefix + IntToStr(ADataID)+ ' ' + Result[i];
end; // end of TK_CMExtDSourceEmulator.DSGetData
}
{*** end of TK_CMExtDSourceEmulator ***}

{*** TK_CMDBSource ***}
{
//******************************************** TK_CMDBSource.Destroy ***
//
destructor TK_CMDBSource.Destroy;
begin
  DBDataSet.Free;
end; // end of TK_CMDBSource.Destroy


//******************************************** TK_CMDBSource.DSGetData ***
// Get values from CMS DB data source
//
//    Parameters
// ADataID - external data ID
// AFieldNames - array of field names of external data source
// Result - Returns array of values for given data ID and fields
//
function TK_CMDBSource.DSGetData( ADataID: Integer;
                                  AFieldNames: TN_SArray ): TN_SArray;
var
  SQLText : string;
  i : Integer;
begin
  Result := nil;
  if Length(AFieldNames) = 0 then Exit; // Error precaution
  if DBDataSet = nil then begin
    DBDataSet := TADOQuery.Create( Application );
    DBDataSet.Connection := DBConnection;
  end;
  SetLength( Result, Length(AFieldNames) );
  try
    SQLText := 'select ' + AFieldNames[0];
    for i := 1 to High(AFieldNames) do
      SQLText := SQLText + ','+ AFieldNames[i];
    DBDataSet.SQL.Text := SQLText + ' from ' + DBTableName + ' where ' + DBIDFieldName + '=' + IntToStr(ADataID);
    DBDataSet.Open;

    with DBDataSet.FieldList do
      for i := 1 to Count - 1 do
        Result[i] := Fields[i].AsString;

    DBDataSet.Close;
  except
    on E: Exception do begin
      EDAShowErrMessage(  'DB ERROR >> ' + E.Message );
      Exit;
    end;
  end;
end; // end of TK_CMDBSource.DSGetData
}
{*** end of TK_CMDBSource ***}

{ *** TK_CMEDAccess *** }

//********************************************* TK_CMEDAccess.Create ***
// Class TK_CMEDAccess constructor
//
constructor TK_CMEDAccess.Create;
begin

  CurSlidesSelectAttrs.SSPatID := -1; // for selecting any Patient in test mode

  TmpStrings := TStringList.Create;
  CurSlidesList := TList.Create;
  SaveSlidesList := TList.Create;
  DelSlidesList := TList.Create;
  CurPatID := -1;
  CurProvID := -1;
  CurLocID := -1;



{ // previouse version
  ContMemIni := TMemIniFile.Create(''); // MemIni Object for contexts processing
  DefaultMemIni  := TMemIniFile.Create(''); // MemIni Object for saving Some Main IniFile Fields for futute restore
  DFPLExec := TK_DFPLScriptExec.Create;
  DFPLExec.DstIniFile.Free;

  MemTextFragms := TN_MemTextFragms.CreateFromVFile
    (N_MemIniToString('CMS_Main', 'SaveDFPLLib', ''));
  DFPLExec.CallMemTextFragms := MemTextFragms.MTFragmsList;
}

  SlidesSaveMode := K_cmesFinEdit;
  if K_CMDemoModeFlag then
    SlidesSaveMode := K_cmesImmediately;

  SlidesDIBFormat := TN_UDDIBDataFormat( N_MemIniToInt( 'CMS_Main',
                                         'ImgFileFormat', Ord(uddfDIBSer1) ) );
  if (SlidesDIBFormat < uddfBMP) or (SlidesDIBFormat > uddfDIBSer3) then
    SlidesDIBFormat := uddfDIBSer1;

//  N_CheckAllAdd(Self, EDADataCheck); // Add Element to Objects Control List
  K_AMSCObj.AMSCheckObjAdd(Self, EDADataCheck); // Add Element to Objects Control List

  ImgFileCompressPower := 0;
  BlobEncParams.DFEncryptionType := K_dfeXOR;

  SlideECRoot := TN_UDCMSlide( K_CreateUDByRTypeName( 'TN_CMECSlide', 1,
                               N_UDCMSlideCI ) );

end; // end of TK_CMEDAccess.Create

//********************************************* TK_CMEDAccess.destructor ***
// Class TK_CMEDAccess destructor
//
destructor TK_CMEDAccess.Destroy;
begin
// Clear Study Samples Root
  if ArchStudySamplesLibRoot <> ArchStudySamplesInitLibRoot then // precaution
    ArchStudySamplesLibRoot.UDDelete();


// Remove Old ErrLog Files
  K_CMRemoveOldDump2HaltFiles(); // K_CMEDAccess.TmpString is used in K_CMRemoveOldDump2HaltFiles
  K_CMD4WAppFinState := TRUE;
//  N_CheckAllRemove(Self); // Remove Element from Objects Control List
  K_AMSCObj.AMSCheckObjRemove(Self); // Remove Element from Objects Control List


  TmpStrings.Free;
  CurSlidesList.Free;
  SaveSlidesList.Free;
  DelSlidesList.Free;
  PatientsFIOIndex.Free;

{ // previouse version
  ContMemIni.Free;
  DefaultMemIni.Free;
  MemTextFragms.Free;
  DFPLExec.DstIniFile := nil;
  DFPLExec.SrcIniFile := nil;
  DFPLExec.Free;
}
// 2014-02-02 !!! CMSHist := nil leads to memory leak 
//  SlideECRoot.P.CMSHist := nil; // Clear History Before Destroy
  SlideECRoot.Free;

  inherited;

end; // end of TK_CMEDAccess.destructor

//************************************* TK_CMEDAccess.EDACheckFSSettings ***
// Check Files Handling Context
//
//     Parameters
// Result  - Returns Files Handling Context State Code:
//#F
// 0 - Files Handling Context is OK
// 1 - Media Files Client Root Folder is not specified
//#/F
//
function TK_CMEDAccess.EDACheckFSSettings(): Integer;
begin
  Result := 0;
  if SlidesClientMediaRootFolder <> '' then
    Exit;
  Result := 1;
end; // end of TK_CMEDAccess.EDACheckFSSettings

//************************ TK_CMEDAccess.EDAMemIniFilesMovingInfoToCurState ***
// Get Current Files Moving Context from Common ini-file
//
//     Parameters
// APCRFC  - pointer to Change Root Folder Context Record
//
procedure TK_CMEDAccess.EDAMemIniFilesMovingInfoToCurState
  (APCRFC: TK_PChangeRootFolderContext);
begin
  with APCRFC^ do
  begin
    RootFolder := N_MemIniToString('ChangeRootFolderInfo', 'RootFolder', '');
    CopiedFNum := N_MemIniToInt('ChangeRootFolderInfo', 'CopiedFNum', 0);
    CopiedFSize := Round(N_MemIniToDbl('ChangeRootFolderInfo', 'CopiedFSize',
        0));
    RootFDA := N_MemIniToBool('ChangeRootFolderInfo', 'RootFDA');
    MediaFCopy := N_MemIniToBool('ChangeRootFolderInfo', 'MediaFCopy');
    MediaFSplit := N_MemIniToBool('ChangeRootFolderInfo', 'MediaFSplit');
    Img3DFCopy := N_MemIniToBool('ChangeRootFolderInfo', 'Img3DFCopy');
    MovingFSDDescr := N_MemIniToInt('ChangeRootFolderInfo', 'MovingFSDDescr',
      0);
    OpProvID := -1;
    if RootFolder <> '' then
      OpProvID := N_MemIniToInt('ChangeRootFolderInfo', 'OpProvID', -1);
  end;
end; // end of TK_CMEDAccess.EDAMemIniFilesMovingInfoToCurState

//********************************************* TK_CMEDAccess.EDAFilesMovingInfoToMemIni ***
// Put Current Files Moving Context to Common MemIni
//
procedure TK_CMEDAccess.EDAFilesMovingInfoToMemIni();
begin
  with SlidesCRFC do
  begin
    N_StringToMemIni('ChangeRootFolderInfo', 'RootFolder', RootFolder);
    N_IntToMemIni('ChangeRootFolderInfo', 'CopiedFNum', CopiedFNum);
    N_DblToMemIni('ChangeRootFolderInfo', 'CopiedFSize', '%g', CopiedFSize);
    N_BoolToMemIni('ChangeRootFolderInfo', 'RootFDA', RootFDA);
    N_BoolToMemIni('ChangeRootFolderInfo', 'MediaFCopy', MediaFCopy);
    N_BoolToMemIni('ChangeRootFolderInfo', 'MediaFSplit', MediaFSplit);
    N_BoolToMemIni('ChangeRootFolderInfo', 'Img3DFCopy', Img3DFCopy);
    N_IntToMemIni('ChangeRootFolderInfo', 'MovingFSDDescr', MovingFSDDescr);
    N_IntToMemIni('ChangeRootFolderInfo', 'OpProvID', CurProvID);
  end;
end; // end of TK_CMEDAccess.EDAFilesMovingInfoToMemIni

//********************************************* TK_CMEDAccess.EDASaveFilesMovingInfo ***
// Put Current Files Moving Context to MemIni and save it
//
procedure TK_CMEDAccess.EDASaveFilesMovingInfo();
begin
  EDAFilesMovingInfoToMemIni();
  EDASaveContextsData([K_cmssSkipSlides, K_cmssSkipInstanceBinInfo,
    K_cmssSkipGlobalInfo,  K_cmssSkipPatientInfo, K_cmssSkipProviderInfo,
    K_cmssSkipLocationInfo, K_cmssSkipExtIniInfo]);
end; // end of TK_CMEDAccess.EDASaveFilesMovingInfo

//************************************** TK_CMEDAccess.EDAGetSlideCurImage0 ***
// Get given Slide Current Image only
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetSlideCurImage0( ASlide: TN_UDCMSlide): TK_CMEDResult;
begin
  Result := K_edOK;
end; // function TK_CMEDAccess.EDAGetSlideCurImage0

//********************************************* TK_CMEDAccess.EDAGetSyncTimestamp ***
// Get Synchronized Timestamp
//
//     Parameters
// ATime   - Client Computer Timestamp
// Result  - Returns Timestamp Synchronized to Server
//
function TK_CMEDAccess.EDAGetSyncTimestamp(ATime: TDateTime = 0): TDateTime;
begin
  if ATime = 0 then
    ATime := Now();
  Result := ATime;
end; // end of TK_CMEDAccess.EDAGetSyncTimestamp

{ // previouse version
//********************************************* TK_CMEDDBAccess.EDAExtIniFileToMemIni ***
// Add content of given Ini-file to Current MemIni
//
//     Parameters
// AIniFName - external Ini-file Name
// AIniDFPLName - name of DFPL script to copy data
// Result - Returns operation resulting code
//
// If AIniDFPLName = '' then AIniFName file name is used as DFPL script name
//
function TK_CMEDAccess.EDAExtIniFileToMemIni( AIniFName : string;
                                              const AIniDFPLName : string = '' ): TK_CMEDResult;
var
  UseDFPLScript : Boolean;
begin
  AIniFName := K_ExpandFileName(AIniFName);
  if not FileExists(AIniFName) then
  begin
    Result := K_edFails;
    N_Dump2Str('Ini File ' + AIniFName + ' not found');
    Exit;
  end;
  Result := K_edOK;
  ContMemIni.Rename(AIniFName, TRUE);
  TmpStrings.Clear;
  ContMemIni.GetStrings(TmpStrings);
  N_Dump2Str(#13#10 + '*** Source Ini  ' + AIniFName);
  N_Dump2Strings(TmpStrings, 5);
  N_Dump2Str('*** end of source ' + AIniFName + #13#10);
  DFPLExec.DstIniFile := N_CurMemIni;
  DFPLExec.SrcIniFile := ContMemIni;

  UseDFPLScript := FALSE;
  if AIniDFPLName <> '' then
    UseDFPLScript := DFPLExec.DFPLExecTFSection( AIniDFPLName + '|Load' );

  if not UseDFPLScript then
    UseDFPLScript := DFPLExec.DFPLExecTFSection(ExtractFileName(AIniFName) + '|Load');

  if not UseDFPLScript then
    K_AddMemIni(ContMemIni, N_CurMemIni)
  else
  begin
    N_Dump2Str( #13#10 + '*** DFPL Script to add' );
    N_Dump2Strings(DFPLExec.LastCommandsStrings, 5);
    N_Dump2Str( '*** end of DFPL Script' + #13#10 );
  end;

end; // end of TK_CMEDAccess.EDAExtIniFileToMemIni

//********************************************* TK_CMEDDBAccess.EDAExtIniFilesToMemIni ***
// Add content of Ini-files to Current MemIni
//
//     Parameters
// Result - Returns TRUE
//
// List of Ini-files is get from [CMSIniFiles] section of Current MemIni
//
function TK_CMEDAccess.EDAExtIniFilesToMemIni(): Integer;
var
  i: Integer;
  WIniFiles: TStringList;
  IniFName: string;
  IniDFPLName: string;

begin
  WIniFiles := TStringList.Create;
  N_CurMemIni.ReadSectionValues('CMSIniFiles', WIniFiles);
  Result := 0;
// Save MemIni Default Fields to Default
//  if (WIniFiles.Count > 0) then
  if (WIniFiles.Count > 0) and not (Self is TK_CMEDDBAccess) then
  begin
    DFPLExec.SrcIniFile := N_CurMemIni;
    DFPLExec.DstIniFile := DefaultMemIni;
    DFPLExec.DFPLExecTFSection( 'SaveDefaults' );
//DefaultMemIni.GetStrings(TmpStrings);
//N_InitWAR();
//K_GetFormTextEdit.EditStrings(TmpStrings);
  end;

  N_Dump2Str(#13#10'****** CMSIniFiles DUMP');
  for i := 0 to WIniFiles.Count - 1 do
  begin
    N_Dump2Str(#13#10 + WIniFiles[i]);
    IniDFPLName := WIniFiles.Names[i];
    if K_StrStartsWith( '//', IniDFPLName ) then Continue;
    IniFName := WIniFiles.ValueFromIndex[i];
    if (IniFName = '') or
       (K_CMEDAccess.EDAExtIniFileToMemIni( IniFName, IniDFPLName ) <> K_edOK) then
      Continue;
    N_Dump2Str(#13#10);
    Inc(Result);
  end;
  WIniFiles.Free;
end; // end of TK_CMEDAccess.EDAExtIniFilesToMemIni

//********************************************* TK_CMEDDBAccess.EDAMemIniToExtIniFile ***
// Add content of given Ini-file to Current MemIni
//
//     Parameters
// AIniFName - external Ini-file Name
// AIniDFPLName - name of DFPL script to copy data
// Result - Returns operation resulting code
//
// If AIniDFPLName = '' then AIniFName file name is used as DFPL script name
//
function TK_CMEDAccess.EDAMemIniToExtIniFile(AIniFName: string; const AIniDFPLName : string = ''): TK_CMEDResult;
var
  UseDFPLScript : Boolean;
begin
  Result := K_edFails;
  AIniFName := K_ExpandFileName(AIniFName);
  if not FileExists(AIniFName) then
  begin
    N_Dump2Str('Ini File ' + AIniFName + ' not found');
    Exit;
  end;
  ContMemIni.Rename(AIniFName, TRUE);
  DFPLExec.SrcIniFile := N_CurMemIni;
  DFPLExec.DstIniFile := ContMemIni;

  UseDFPLScript := FALSE;
  if AIniDFPLName <> '' then
    UseDFPLScript := DFPLExec.DFPLExecTFSection( AIniDFPLName + '|Save' );

  if not UseDFPLScript then
    UseDFPLScript := DFPLExec.DFPLExecTFSection(ExtractFileName(AIniFName) + '|Save');

  if not UseDFPLScript then Exit;
  N_Dump2Str('Add Ini Info to ' + AIniFName);
  ContMemIni.UpdateFile();
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAMemIniToExtIniFile

//********************************************* TK_CMEDDBAccess.EDAMemIniToExtIniFiles ***
// Save content from Current MemIni to Ini-files
//
//     Parameters
// Result - Returns operation resulting code
//
// List of Ini-files is get from [CMSIniFiles] section of Current MemIni
//
function TK_CMEDAccess.EDAMemIniToExtIniFiles(): Integer;
var
  i: Integer;
  WIniFiles: TStringList;
  IniFName: string;
  IniDFPLName: string;
begin
  WIniFiles := TStringList.Create;
  N_CurMemIni.ReadSectionValues('CMSIniFiles', WIniFiles);
  Result := 0;
  for i := 0 to WIniFiles.Count - 1 do
  begin
    IniDFPLName := WIniFiles.Names[i];
    if K_StrStartsWith( '//', IniDFPLName ) then Continue;
    IniFName := WIniFiles.ValueFromIndex[i];
    if (IniFName = '') or
      (K_CMEDAccess.EDAMemIniToExtIniFile( IniFName, IniDFPLName ) <> K_edOK) then
      Continue;
    Inc(Result);
  end;
  WIniFiles.Free;
end; // end of TK_CMEDAccess.EDAMemIniToExtIniFiles
}

//********************************************* TK_CMEDAccess.EDAAssign ***
// Assign by given External Data Access object
//
//     Parameters
// ACMEDA - given source External Data Access object
//
procedure TK_CMEDAccess.EDAAssign(ACMEDA: TK_CMEDAccess);
begin
  // SkipProcessMessages := ACMEDA.SkipProcessMessages;
  AccessReady := ACMEDA.AccessReady;

  CurSlidesList.Assign(ACMEDA.CurSlidesList);
  SaveSlidesList.Assign(ACMEDA.SaveSlidesList);
  DelSlidesList.Assign(ACMEDA.DelSlidesList);

  CurSlidesSelectAttrs := ACMEDA.CurSlidesSelectAttrs;

  ArchSlidesRoot := ACMEDA.ArchSlidesRoot;
  ArchMTypesInfo := ACMEDA.ArchMTypesInfo;
  ArchGlobInfo := ACMEDA.ArchGlobInfo;

  PatientsInfo := ACMEDA.PatientsInfo;
  ProvidersInfo := ACMEDA.ProvidersInfo;
  LocationsInfo := ACMEDA.LocationsInfo;

  UndeletedFileNames := ACMEDA.UndeletedFileNames;

  ArchMLibRoot := ACMEDA.ArchMLibRoot;
  ArchMLibMRMPat := ACMEDA.ArchMLibMRMPat;
end; // end of TK_CMEDAccess.EDAAssign

//********************************************* TK_CMEDAccess.EDAArchUDCompsInit ***
// Init by common archive context
//
//     Parameters
// Result - Returns given source External Data Access object
//
function TK_CMEDAccess.EDAArchUDCompsInit(): TK_CMEDResult;
var
  WRoot : TN_UDBase;
begin

  Result := K_edOK;

  // Init VObjects Context
  ArchMLibRoot := K_UDCursorForceDir(K_ArchiveCursor + 'ME\MeasureObjects');

  // Temporary Code To Check Line Vertex Sign HotPoint loss
  ArchMLibMRMPat := ArchMLibRoot.DirChildByObjName('Line').DirChild(0);
  if not(ArchMLibMRMPat is TN_UDPolyline) then
    ArchMLibMRMPat := ArchMLibRoot.DirChildByObjName('Line').DirChild(1);

  if ArchMLibMRMPat = nil then
  begin
    ExtDataErrorString :=
      'Measure Object "Line" is absent --> \ME\MeasureObjects\Line';
    Result := K_edExDataError;
    EDAShowErrMessage(TRUE);
  end
  else
    with TN_PPointAttr2
      (TN_PContAttr(TN_UDPolyline(ArchMLibMRMPat)
          .PSP.CPolyline.CPolylineAttr.P()).CAMarkers.P()).PAHotPoint do
      if (X <> 0.5) or (Y <> 0.5) then
      begin
        ExtDataErrorString := 'Line Vertexes Hotpoint Attributes <> (0.5,0.5)';
        EDAShowErrMessage(TRUE);
      end;

  ArchMLibMRMPat := ArchMLibRoot.DirChildByObjName('Measurements');
  if ArchMLibMRMPat = nil then
  begin
    ExtDataErrorString :=
      'Measurements Pattern Root is absent --> \ME\MeasureObjects\Measurements';
    Result := K_edExDataError;
    EDAShowErrMessage(TRUE);
    Exit;
  end;

  ArchGlobInfo := TK_UDRArray(K_UDCursorGetObj(K_ArchiveCursor + 'GlobInfo'));
  if ArchGlobInfo = nil then
  begin
    ArchGlobInfo := TK_UDRArray(K_CurArchive.AddOneChildV(K_CreateUDByRTypeCode(Ord(nptInt))));
    ArchGlobInfo.ObjName := 'GlobInfo';
    PInteger(ArchGlobInfo.PDE(K_CMAMIDSlideInd))^ := K_CMEDSlideInitID;
    PInteger(ArchGlobInfo.PDE(K_CMAMIDMTypeInd))^ := K_CMEDMTypeInitID;
    PInteger(ArchGlobInfo.PDE(K_CMAMIDMFileInd))^ := K_CMEDMFileInitID;
  end;

  ArchMTypesInfo := TK_UDRArray(ArchGlobInfo.DirChildByObjName('MediaTypesData'));

  if ArchMTypesInfo = nil then
  begin
    ArchMTypesInfo := TK_UDRArray(ArchGlobInfo.AddOneChildV
        (K_CreateUDByRTypeCode(Ord(nptString))));
    ArchMTypesInfo.ObjName := 'MediaTypesData';
  end;

  with K_UDCursorForceDir(K_ArchiveCursor + 'ME\PrintObjects') do
  begin
    ArchPrnPageRoot := DirChildByObjName('PageRoot');
    if ArchPrnPageRoot = nil then
    begin
      ExtDataErrorString :=
        'Printing Page Root Component is absent --> \ME\PrintObjects\PageRoot';
      Result := K_edExDataError;
      EDAShowErrMessage(TRUE);
      Exit;
    end;

    ArchPrnPageSlidesRoot := ArchPrnPageRoot.GetObjByRPath('PageFrame\SlidesRoot');
    if ArchPrnPageSlidesRoot = nil then
    begin
      ExtDataErrorString :=
        'Printing Page Slides Root Component is absent --> \ME\PrintObjects\PageRoot\PageFrame\SlidesRoot';
      Result := K_edExDataError;
      EDAShowErrMessage(TRUE);
      Exit;
    end;

    ArchPrnPageParams := DirChildByObjName('PageParams');
    if ArchPrnPageParams = nil then
    begin
      ExtDataErrorString :=
        'Printing Page Parameters Component is absent --> \ME\PrintObjects\PageParams';
      Result := K_edExDataError;
      EDAShowErrMessage(TRUE);
      Exit;
    end;

    // Select PrintObjects for PrintManager
    ArchPrnSlidePatRoot := DirChildByObjName('SlideRootN');
{
    if K_CMDesignModeFlag then // Needed for new PrintManager
      ArchPrnSlidePatRoot := DirChildByObjName('SlideRootN')
    else                       // Needed for old PrintManager (Old PrintManager can use new PrintObjects)
      ArchPrnSlidePatRoot := DirChildByObjName('SlideRoot');
}
    if ArchPrnSlidePatRoot = nil then
    begin
      ExtDataErrorString :=
        'Printing Page Slide Pattern Root Component is absent --> \ME\PrintObjects\SlideRoot';
      Result := K_edExDataError;
      EDAShowErrMessage(TRUE);
      Exit;
    end;

    if ArchPrnSlidePatRoot.GetObjByRPath('SlideParent\SlidePosScale') = nil then
    begin
      ExtDataErrorString :=
        'Printing Page Slide Pattern Slide Parent Component is absent --> \ME\PrintObjects\SlideRoot\SlideParent\SlidePosScale';
      Result := K_edExDataError;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

  WRoot := K_UDCursorGetObj(K_ArchiveCursor + 'ME');
  GFiltersImgProcAttrs := TK_UDRArray(WRoot.DirChildByObjName('GFiltersImgProcAttrs'));
  if GFiltersImgProcAttrs = nil then
  begin
    GFiltersImgProcAttrs := TK_UDRArray(WRoot.AddOneChildV(
                          K_CreateUDByRTypeName( 'TK_CMAutoImgProcAttrs', 6 )));
    GFiltersImgProcAttrs.ObjName := 'GFiltersImgProcAttrs';
  end;

//  Init Study Samples Library context
  K_UDCursorForceDir(K_ArchiveCursor + 'ME\StudySamplesLib');
  K_UDCursorForceDir(K_ArchiveCursor + 'ME\StudySamplesLib\StubImages');
  ArchStudySamplesInitLibRoot := K_UDCursorForceDir(K_ArchiveCursor + 'ME\StudySamplesLib\StudySamples');
  if ArchStudySamplesInitLibRoot.DirLength = 0 then
    with ArchStudySamplesInitLibRoot.AddOneChildV( K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMStudyCI) ) do
      ObjName := 'EmptyStudySample';
end; // end of TK_CMEDAccess.EDAArchUDCompsInit

//********************************************* TK_CMEDAccess.EDAAppUDTreeInit ***
// Init by current archive
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAAppUDTreeInit(): TK_CMEDResult;
begin

  Result := K_edOK;
  if UDRootInstanceInfo = nil then
  begin
    Result := K_edExDataError;
    ExtDataErrorString := 'InstanceInfo Root object is absent';
    EDAShowErrMessage(TRUE);
    Exit;
  end;

  K_UDCursorGet('AI:').SetRoot(UDRootInstanceInfo);

  with K_UDCursorForceDir('AI:CurrentData') do
  begin
    UndeletedFileNames := TK_UDStringList(DirChildByObjName('UndeletedFileNames'));
    if UndeletedFileNames = nil then
    begin
      // Create New UndeletedFileNames
      UndeletedFileNames := TK_UDStringList.Create();
      UndeletedFileNames.ObjName := 'UndeletedFileNames';
      AddOneChildV(UndeletedFileNames);
      UndeletedFileNames.SaveLoadFlag := 1;
    end;

    PatientsInfo := TK_UDRArray(DirChildByObjName('PatientsData'));
    if PatientsInfo = nil then
    begin
      PatientsInfo := TK_UDRArray
        (AddOneChild(K_CreateUDByRTypeCode(Ord(nptString))));
      PatientsInfo.ObjName := 'PatientsData';
    end;

    ProvidersInfo := TK_UDRArray(DirChildByObjName('ProvidersData'));
    if ProvidersInfo = nil then
    begin
      ProvidersInfo := TK_UDRArray
        (AddOneChild(K_CreateUDByRTypeCode(Ord(nptString))));
      ProvidersInfo.ObjName := 'ProvidersData';
    end;

    LocationsInfo := TK_UDRArray(DirChildByObjName('LocationsData'));
    if LocationsInfo = nil then
    begin
      LocationsInfo := TK_UDRArray
        (AddOneChild(K_CreateUDByRTypeCode(Ord(nptString))));
      LocationsInfo.ObjName := 'LocationsData';
    end;
  end;

  // *** Objects for Setting on User Side
  with K_UDCursorForceDir('AI:SysObjects') do
  begin
    N_CM_VideoStat := TK_UDRArray(DirChildByObjName('VideoStat'));
    if N_CM_VideoStat = nil then
    begin
      N_CM_VideoStat := K_CreateUDByRTypeName('TN_CMVideoStatRecord', 0);
      N_CM_VideoStat.ObjName := 'VideoStat';
      AddOneChild(N_CM_VideoStat);
    end; // if N_CM_VideoStat = nil then
  end;

  // Set UDCursor for Device Context Tree
  if (ProfilesSaveMode <> K_cmdpClientName) and
     (ProfilesSaveMode <> K_cmdpClientIP) then Exit;
  K_UDCursorGet('DI:').SetRoot(UDRootInstanceInfo);
  Result := EDADevProfilesUDTreeInit();
end; // end of TK_CMEDAccess.EDAAppUDTreeInit

//********************************************* TK_CMEDAccess.EDADevProfilesUDTreeInit ***
// Device Profiles UDTree Init
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDADevProfilesUDTreeInit(): TK_CMEDResult;

  procedure AddProfilesToList( AUDDevs : TK_UDRArray );
  var
    i : Integer;
    k : Integer;
    n : Integer;
  begin
    k := AUDDevs.ALength();
    if k = 0 then Exit;
    n := ProfilesList.ALength();
    ProfilesList.ASetLength( n + k );
    for i := 0 to k - 1 do
      with TK_PCMDevProfListElem(ProfilesList.PDE( i + n))^ do
      begin
        CMDPLEAInd := i;
        K_SetUDRefField( CMDPLEARef, AUDDevs );
      end;
  end; // procedure AddProfilesToList

  procedure AddProfilesToList1( AUDDevs : TK_UDRArray );
  var
    i : Integer;
    k : Integer;
    n : Integer;
    m, m1 : Integer;
    j : Integer;
    PInd : PInteger;
    PCMDevElem : TK_PCMDevProfListElem;

    function SearchElem( APInd : PInteger; ACount : Integer; AVal : Integer ) : Integer;
    begin
      Result := K_IndexOfIntegerInRArray( AVal, APInd, ACount, SizeOf(TK_CMDevProfListElem) );
    end; // function SearchElem(
  begin
    k := AUDDevs.ALength();
    if k = 0 then Exit;
    n := ProfilesList.ALength();
    ProfilesList.ASetLength( n + k ); // Add Full List Size
    PInd := @TK_PCMDevProfListElem(ProfilesList.PDE(0)).CMDPLEAInd;
    j := 0;

    for i := 0 to k - 1 do
    begin
      with TK_PCMDevProfListElem(ProfilesList.PDE( j + n))^ do
      begin
        m := SearchElem( PInd, n, i );
        if m >= 0 then
        begin
          PCMDevElem := ProfilesList.PDE(m);
          if PCMDevElem.CMDPLEARef = AUDDevs then Continue; // Found Profile in list
          Inc(m);
          if m < n then
          begin
          // Continue Search
            Inc( PChar(PCMDevElem), SizeOf(TK_CMDevProfListElem) );
            m1 := SearchElem( @PCMDevElem.CMDPLEAInd, n - m, i );
            if m1 >= 0 then
            begin
             // Continue Search
              m := m + m1;
              PCMDevElem := ProfilesList.PDE(m);
              if PCMDevElem.CMDPLEARef = AUDDevs then Continue; // Found Profile in list
              Inc(m);
              if m < n then
              begin
                Inc( PChar(PCMDevElem), SizeOf(TK_CMDevProfListElem) );
                m := SearchElem( @PCMDevElem.CMDPLEAInd, n - m, i );
                if m >= 0 then Continue; // Found Profile in list
              end;
            end;
          end;
        end;
        CMDPLEAInd := i;
        K_SetUDRefField( CMDPLEARef, AUDDevs );
        Inc(j);
      end;
    end;
    ProfilesList.ASetLength( n + j ); // Return Real List Size
  end; // procedure AddProfilesToList1

begin
  N_Dump2Str( 'EDADevProfilesUDTreeInit' );
  Result := K_edOK;
  with K_UDCursorForceDir('DI:DeviceProfiles') do
  begin
    SavedIcons := K_UDCursorForceDir('DI:DeviceProfiles\SavedIcons');

    TwainProfiles := TK_UDRArray(DirChildByObjName('TwainProfiles'));
    if TwainProfiles = nil then
    begin
//      N_Dump1Str( 'CMS Remote Client Setup Device Context=' + IntToStr(Integer(ProfilesSaveMode)) );
      TwainProfiles := K_CreateUDByRTypeName('TK_CMTwainProfile', 0);
      TwainProfiles.ObjName := 'TwainProfiles';
      AddOneChildV(TwainProfiles);
    end;

    OtherProfiles := TK_UDRArray(DirChildByObjName('OtherProfiles'));
    if OtherProfiles = nil then
    begin
      OtherProfiles := K_CreateUDByRTypeName('TK_CMOtherProfile', 0);
      OtherProfiles.ObjName := 'OtherProfiles';
      AddOneChildV(OtherProfiles);
    end;

    OtherProfiles3D := TK_UDRArray(DirChildByObjName('OtherProfiles3D'));
    if OtherProfiles3D = nil then
    begin
      OtherProfiles3D := K_CreateUDByRTypeName('TK_CMOtherProfile3D', 0);
      OtherProfiles3D.ObjName := 'OtherProfiles3D';
      AddOneChildV(OtherProfiles3D);
    end;

    VideoProfiles := TK_UDRArray(DirChildByObjName('VideoProfiles'));
    if VideoProfiles = nil then
    begin
      VideoProfiles := K_CreateUDByRTypeName('TK_CMVideoProfile', 0);
      VideoProfiles.ObjName := 'VideoProfiles';
      AddOneChildV(VideoProfiles);
    end;

    ProfilesList := TK_UDRArray(DirChildByObjName('ProfilesList'));
    if ProfilesList = nil then
    begin
      ProfilesList := K_CreateUDByRTypeName('TK_CMDevProfListElem', 0);
      ProfilesList.ObjName := 'ProfilesList';
      AddProfilesToList( TwainProfiles );
      AddProfilesToList( OtherProfiles );
      AddProfilesToList( VideoProfiles );
      AddOneChildV( ProfilesList );
    end   // if ProfilesList = nil then
    else
    begin // if ProfilesList <> nil then
      if ProfilesList.R.ALength() <
         TwainProfiles.R.ALength() + OtherProfiles.R.ALength() + VideoProfiles.R.ALength() then
      begin
      // Add absent Device Profiles to list - special case
      // when CMS DB was downgrade to version without ProfilesList
      // and than upgrade to version with ProfilesList
        AddProfilesToList1( TwainProfiles );
        AddProfilesToList1( OtherProfiles );
        AddProfilesToList1( VideoProfiles );
      end;
    end;  // if ProfilesList <> nil then

//    if (K_CMLimitDevProfilesToRTDBContext() > 0) then // debug
    if (K_CMSAppStartContext.CMASMode = K_cmamCOMVEUI) and
       (K_CMLimitDevProfilesToRTDBContext() > 0) then
      K_FCMShowDeviceLimitWarning(); // Show Warning   // Device Limitation should be done for VEUI only

    N_Dump1Str( format( 'DB>> Device Profiles: Twain=%d Other=%d Video=%d',
        [TwainProfiles.R.ALength(),OtherProfiles.R.ALength(),VideoProfiles.R.ALength()] ) );
  end;
end; // end of TK_CMEDAccess.EDADevProfilesUDTreeInit

//********************************************* TK_CMEDAccess.EDAProviderUDTreeInit ***
// Init User context by current archive
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAProviderUDTreeInit(): TK_CMEDResult;
begin
  Result := K_edOK;
  if UDRootProviderInfo = nil then
  begin
    Result := K_edExDataError;
    ExtDataErrorString := 'UserInfo Root object is absent';
    EDAShowErrMessage(TRUE);
    Exit;
  end;

  K_UDCursorGet('UI:').SetRoot(UDRootProviderInfo);
  with K_UDCursorForceDir('UI:UFilterProfiles') do
  begin
    UFiltersProfiles := TK_UDRArray(DirChildByObjName('UProfiles'));
    if UFiltersProfiles = nil then
    begin
      UFiltersProfiles := K_CreateUDByRTypeName('TK_CMUFilterProfile', 4);
      UFiltersProfiles.ObjName := 'UProfiles';
      AddOneChildV(UFiltersProfiles);
    end;
  end;

  if ProfilesSaveMode <> K_cmdpProvider then Exit;
  K_UDCursorGet('DI:').SetRoot(UDRootProviderInfo);
  Result := EDADevProfilesUDTreeInit();

end; // end of TK_CMEDAccess.EDAProviderUDTreeInit

//****************************************** TK_CMEDAccess.EDAUDFiltersInit ***
// Init Global Filetrs context
//
//     Parameters
// Result - Returns operation resulting code
//
procedure TK_CMEDAccess.EDAUDFiltersInit();
var
  i : Integer;
begin
  K_UDCursorGet('GI:').SetRoot(UDRootGlobalInfo);
  with K_UDCursorForceDir('GI:GFilterProfiles') do
  begin
    GFiltersProfiles := TK_UDRArray(DirChildByObjName('GFilters'));
    if GFiltersProfiles = nil then
    begin
    // Create empty object
      GFiltersProfiles := TK_UDRArray(AddOneChildV(
                            K_CreateUDByRTypeName( 'TK_CMUFilterProfile', 6 )));
      GFiltersProfiles.ObjName := 'GFilters';
    end;
  end;

  // Init profiles by initial ImgProcAttrs
  for i := 0 to GFiltersProfiles.AHigh do
  begin
    with TK_PCMUFilterProfile(GFiltersProfiles.PDE(i))^ do
    begin
      if K_aipfModified in CMUFPAutoImgProcAttrs.CMAIPFlags then Continue;
      CMUFPAutoImgProcAttrs := TK_PCMAutoImgProcAttrs(GFiltersImgProcAttrs.PDE(i))^;
    end;
  end;

end; // end of TK_CMEDAccess.EDAUDFiltersInit

//***************************************** TK_CMEDAccess.EDAGlobUDTreeInit ***
// Init Global CMS context by current archive
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGlobUDTreeInit(): TK_CMEDResult;
begin
  EDAUDFiltersInit();
  Result := K_edOK;
  if ProfilesSaveMode <> K_cmdpGAGlobal then Exit;
  K_UDCursorGet('DI:').SetRoot(UDRootGlobalInfo);
  Result := EDADevProfilesUDTreeInit();

end; // end of TK_CMEDAccess.EDAGlobUDTreeInit

//**************************************** TK_CMEDAccess.EDASaveContextsData ***
// Save Current Application Context
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASaveContextsData( ASaveFlags: TK_CMEDSaveStateFlags = [] ): TK_CMEDResult;
var
  i: Integer;
  CurBSlide : TN_UDCMBSlide;
begin
  Result := K_edOK;
  {
    if K_GetPArchive(K_CurArchive).ArchWasChanged and
    not K_SaveArchive( K_CurArchive ) then
    Result := K_edFails;
  }
  // Save Archive Slides and Profiles Data
  if not (K_cmssSkipSlides in ASaveFlags) or
     not (K_cmssSkipAllContexts in ASaveFlags) then
  begin

    // Clear Archive Slides ROI Refs
    if ArchSlidesRoot = nil then
      Exit;
    for i := 0 to ArchSlidesRoot.DirHigh() do
    begin
      CurBSlide := TN_UDCMBSlide(ArchSlidesRoot.DirChild(i));
      if CurBSlide is TN_UDCMStudy then Continue;
      with TN_UDCMSlide(CurBSlide) do
      begin
        PrepROIView([K_roiClearRefs]);
        if not K_CMLocalArchNewFileFormatFlag then Continue;
      // Save Changed Images
        EDASlideDIBToFile( DirChild(K_CMSlideIndCurImg), TRUE );
        EDASlideDIBToFile( DirChild(K_CMSlideIndSrcImg), TRUE );
      end;
    end; // end of Save Slides

    K_SaveArchive(K_CurArchive, [K_lsfSkipJoinChangedSLSR]);

    // Restore Archive Slides ROI Refs
    if ArchSlidesRoot = nil then
      Exit;

    for i := 0 to ArchSlidesRoot.DirHigh() do
    begin
      CurBSlide := TN_UDCMBSlide(ArchSlidesRoot.DirChild(i));
      if CurBSlide is TN_UDCMStudy then Continue;
      TN_UDCMSlide(CurBSlide).PrepROIView( [K_roiRestoreIfImage] );
    end;
  end;

  if K_cmssSkipAllContexts in ASaveFlags then
    Exit;

  // if not (K_cmssSkipGlobalInfo in ASaveFlags) then
  EDAGlobalCurStateToMemIni();
  if K_cmssSaveGlobal2Info in ASaveFlags then
    EDANotGAGlobalToMemIni();
  if not(K_cmssSkipInstanceInfo in ASaveFlags) then
    EDAInstanceCurStateToMemIni();
  if not(K_cmssSkipPatientInfo in ASaveFlags) then
    EDAPatientCurStateToMemIni();
  if not(K_cmssSkipProviderInfo in ASaveFlags) then
    EDAProviderCurStateToMemIni();
  if not(K_cmssSkipProviderInfo in ASaveFlags) and not
    (K_cmssSkipInstanceInfo in ASaveFlags) then
    EDAProviderInstanceCurStateToMemIni();
  if not(K_cmssSkipLocationInfo in ASaveFlags) then
    EDALocationCurStateToMemIni();

  if not(K_cmssSkipExtIniInfo in ASaveFlags) then
    K_CMEDAMemIniToExtIniFiles();
//    EDAMemIniToExtIniFiles();

  // Save IniFile Current State for restore if CMS is not closed now
  TmpStrings.Clear;
  if not K_CMD4WAppFinState then
    N_CurMemIni.GetStrings( TmpStrings );

  // Restore MemIni Default Fields to Default before IniFile saving
  if not (Self is TK_CMEDDBAccess) and (K_CMEDADFPLExec <> nil) then
  begin
    K_CMEDADFPLExec.SrcIniFile := K_CMEDADefaultMemIni;
    K_CMEDADFPLExec.DstIniFile := N_CurMemIni;
    K_CMEDADFPLExec.DFPLExecTFSection( 'RestoreDefaults' );
  end;

  // Restore FileGPaths.LogFiles to Default before IniFile saving
  if K_CMSIniLogPath <> '' then
    N_StringToMemIni( K_FileGPathsIniSection, 'LogFiles', K_CMSIniLogPath );

  // Save IniFile
  K_SaveMemIniToFile( N_CurMemIni );

  // Restore IniFile Current State if CMS is not closed now
  if not K_CMD4WAppFinState then
    N_CurMemIni.SetStrings( TmpStrings );

end; // end of TK_CMEDAccess.EDASaveContextsData

//********************************************* TK_CMEDAccess.EDAAppContextToCurState ***
// Add Current Context Init
//
//     Parameters
// ANPatId  - new Patient ID
// ANProvID - new Provider ID
// ANLocID  - new Location ID
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAAppContextToCurState( ANPatId, ANProvID,
  ANLocID: Integer ): TK_CMEDResult;
begin
  Result := K_edOK;

  // Set New Location
  if CurLocID <> ANLocID then
    EDALocationMemIniToCurState();
  CurLocID := ANLocID;

  // Set New Provider
  if CurProvID <> ANProvID then
  begin
    // Get Ini Context
    EDAProviderMemIniToCurState();
    // Get Binary Context
    EDAProviderUDTreeInit();

    EDAProviderInstanceMemIniToCurState();
  end;
  CurProvID := ANProvID;

  // Set New Patient
  if CurPatID <> ANPatId then
    EDAPatientMemIniToCurState();
  CurPatID := ANPatId;
  CurSlidesSelectAttrs.SSPatID := ANPatId;

end; // end of TK_CMEDAccess.EDAAppContextToCurState

//********************************************* TK_CMEDAccess.EDAInit ***
// Init External Data Access Object when Application is Ready to Initialization
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAInit(): TK_CMEDResult;
begin
  Result := EDAArchUDCompsInit();
  if Result <> K_edOK then
    Exit;
  ArchSlidesRoot := K_UDCursorForceDir(K_ArchiveCursor + 'Slides');
  UDRootInstanceInfo := K_UDCursorForceDir(K_ArchiveCursor + 'AppInfo');
  UDRootProviderInfo := K_UDCursorForceDir(K_ArchiveCursor + 'UserInfo');
  UDRootGlobalInfo := K_UDCursorForceDir(K_ArchiveCursor + 'GInfo');

  Result := EDAAppUDTreeInit();
  if Result = K_edOK then
    Result := EDAGlobUDTreeInit();
  if Result <> K_edOK then Exit;
  K_UDCursorGet('DI:').SetRoot(UDRootInstanceInfo);
  Result := EDADevProfilesUDTreeInit();

  if ATimer = nil then
    ATimer := TTimer.Create(N_CM_MainForm);
  ATimer.Interval := K_CMEDAActivateTimerDeltaMS;
  ATimer.OnTimer := EDATimerAction;
  ATimer.Enabled := TRUE;

  EDAStudyTemplatesPrepare();
end; // end of TK_CMEDAccess.EDAInit

//******************************************** TK_CMEDAccess.EDATimerAction ***
// Timer Action handler
//
procedure TK_CMEDAccess.EDATimerAction( Sender : TObject );
begin
  ATimer.Enabled := FALSE;

  // Check Dental Unit Action
  K_CMCheckDentalUnitActionExec();
  Inc(ATimerCount);

  ATimer.Enabled := TRUE;
end; // procedure TK_CMEDAccess.EDATimerAction

//********************************************* TK_CMEDAccess.EDASetInstanceState ***
// Set CMS Instance not active state
//
//     Parameters
// ASetActive - if TRUE set CMS Instance Active state, else not Active state
// Result - Returns operation resulting code
//
// Check Media Object File Existance and Consistancy
//
function TK_CMEDAccess.EDASetInstanceState( ASetActive : Boolean; AStateFlag : Integer ) : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDASetInstanceState

//********************************************* TK_CMEDAccess.EDACheckSlideMedia ***
// Check Slide Media Object
//
//     Parameters
// ASlide - Slide to check
// Result - Returns operation resulting code
//
// Check Media Object File Existance and Consistancy
//
function TK_CMEDAccess.EDACheckSlideMedia(ASlide: TN_UDCMSlide; ASkipShowDlg : Boolean = FALSE): TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDACheckSlideMedia

//********************************************* TK_CMEDAccess.EDARemovePathFolders0 ***
// Clear Slide File Folders after File Deletion
//
//     Parameters
// AFName - Slide File Name
// ABasePath - Slide Base File Path
// Result - Returns operation resulting code
//
procedure TK_CMEDAccess.EDARemovePathFolders0(AFName: string; const ABasePath: string);
begin
  while TRUE do
  begin
    AFName := ExtractFilePath(AFName);
    if AFName = ABasePath then
      break;
    AFName := ExcludeTrailingPathDelimiter(AFName);
    N_Dump2Str('Remove Folder ' + AFName);
    if not RemoveDir(AFName) then
      break;
  end;
end; // end of TK_CMEDAccess.EDARemovePathFolders0

//********************************************* TK_CMEDAccess.EDADelSlideMediaFiles ***
// Delete Slide Media Files and Folders before Slide Deletion
//
//     Parameters
// ASlide - Slide
// Result - Returns operation resulting code
//
//
function TK_CMEDAccess.EDADelSlideMediaFiles(ASlide: TN_UDCMSlide)
  : TK_CMEDResult;
begin
  Result := K_edOK;
  K_CMDeleteClientMediaFile(ASlide);
end; // end of TK_CMEDAccess.EDADelSlideMediaFiles

//********************************************* TK_CMEDAccess.EDAInitSlideViewAttrs ***
// Initialised Slide View Attributes After Load from DB
//
procedure TK_CMEDAccess.EDAInitSlideViewAttrs(ASlide: TN_UDCMSlide);
begin
  with ASlide.P().CMSDB, ViewAttrs do
  begin
    SFlags := SFlags - [cmsfShowColorize, cmsfShowIsodensity, cmsfShowEmboss];

    IsoRangeFactor := 5;

    EmbDepth := 3;
    EmbDirAngle := 45;
    EmbRFactor := 10.0;
    EmbBase := 128;
  end;

end; // end of TK_CMEDAccess.EDAInitSlideViewAttrs
{
//********************************************* TK_CMEDAccess.EDALockActiveContext ***
// Save Current Patient, Provader Location context to Application Active
// Instance State
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDALockActiveContext() : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDALockActiveContext
}
//*********************************** TK_CMEDAccess.EDAAddSessionHistRecord ***
// Add Current Context Session Record
//
//     Parameters
// ANPatID  - new patient ID, if =-1 then Current Patient will be used
// ANProvID - new provider ID, if =-1 then Current Provider will be used
// ANLocID  - new location ID, if =-1 then Current Location will be used
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAAddSessionHistRecord( ANPatID : Integer = -1;
                                                  ANProvID : Integer = -1;
                                                  ANLocID  : Integer = -1 ) : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAAddSessionHistRecord

//************************************* TK_CMEDAccess.EDALockActiveContext1 ***
// Save Current Patient, Provader Location context to Application Active
// Instance State
//
//     Parameters
// ANPatID  - new patient ID
// ANProvID - new provider ID
// ANLocID  - new location ID
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDALockActiveContext1( ANPatID, ANProvID, ANLocID : Integer ) : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDALockActiveContext1

{
  //******************************************** TK_CMEDAccess.EDALockSlide ***
  // Lock given slide for edit
  //
  //   Parameters
  // ASlide - slide to lock
  // Result - Returns operation resulting code
  //
  function TK_CMEDAccess.EDALockSlide( ASlide: TN_UDCMSlide ): TK_CMEDResult;
  begin
  Result := K_edOK;
  Include( ASlide.P().CMSRFlags, cmsfIsLocked );
  end; // end of TK_CMEDAccess.EDALockSlide

  //******************************************** TK_CMEDAccess.EDAUnlockSlide ***
  // Unlock given slide after edit
  //
  //   Parameters
  // ASlide - slide to lock
  // Result - Returns operation resulting code
  //
  function TK_CMEDAccess.EDAUnlockSlide( ASlide: TN_UDCMSlide ): TK_CMEDResult;
  begin
  Result := K_edOK;
  with ASlide.P()^ do
  if (cmsfIsLocked in CMSRFlags) and
  not (cmsfIsOpened in CMSRFlags) then
  Exclude( CMSRFlags, cmsfIsLocked );
  end; // end of TK_CMEDAccess.EDAUnlockSlide
}

//********************************************* TK_CMEDAccess.EDALockSlides ***
// Lock given slides for edit
//
//     Parameters
// APSlide - pointer to slides array start element to lock
// ASlidesCount - number of slides to lock
// ALockResultMode - specified SkipDeleted or SkipExtLocked mode
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDALockSlides(APSlide: TN_PUDCMSlide;
  ASlidesCount: Integer; ALockResultMode: TK_CMEDLockResultMode;
  APatID: Integer = -1): TK_CMEDResult;
var
  i: Integer;
begin
  // !! Code is correct only if APatID = -1
  // Code Should be redesigned but it will work correct in demo mode because
  Result := K_edOK;
  if Length(LockResSlides) < ASlidesCount then
  begin
    SetLength(LockResSlides, ASlidesCount);
    SetLength(LockResState, ASlidesCount);
    // SetLength( LockResultUpdateState, ASlidesCount );
    // SetLength( LockResultSrcInds, ASlidesCount );
  end;
  Move(APSlide^, LockResSlides[0], ASlidesCount * SizeOf(TN_UDCMSlide));
  // FillChar( LockResultUpdateState[0], ASlidesCount, -1 );
  // K_FillIntArrayByCounter( @LockResSlides[0], ASlidesCount );
  LockResCount := ASlidesCount;
  for i := 0 to ASlidesCount - 1 do
  begin
    LockResState[i].LSSrcInd := i;
    LockResState[i].LSUpdate := [];
    with APSlide.P()^ do
      if (ALockResultMode = K_cmlrmOpenLock) then
        Include(CMSRFlags, cmsfIsUsed)
      else
        Include(CMSRFlags, cmsfIsLocked);
    Inc(APSlide);
  end;
end; // end of TK_CMEDAccess.EDALockSlides

//********************************************* TK_CMEDAccess.EDAUnlockAllLockedSlides ***
// Unlock slides using current lock slides context
//
//     Parameters
// ALockResultMode - lock slides mode (for proper unlock)
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAUnlockAllLockedSlides( ALockResultMode: TK_CMEDLockResultMode): TK_CMEDResult;
begin
  Result := K_edOK;
  if LockResCount <> 0 then
    Result := EDAUnlockSlides( @LockResSlides[0], LockResCount, ALockResultMode);
  LockResCount := 0;
end; // end of TK_CMEDAccess.EDAUnlockAllLockedSlides



//********************************************* TK_CMEDAccess.EDAUnlockSlides ***
// Unlock given slides after edit
//
//     Parameters
// APSlide - pointer to slides array start element to lock
// ASlidesCount - number of slides to lock
// ALockResultMode - lock slides mode (for proper unlock)
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAUnlockSlides( APSlide: TN_PUDCMSlide;
                                        ASlidesCount: Integer;
                                        ALockResultMode: TK_CMEDLockResultMode ) : TK_CMEDResult;
var
  i: Integer;
begin
  Result := K_edOK;
  for i := 1 to ASlidesCount do
  begin
    with APSlide.P()^ do
    begin
      if ALockResultMode = K_cmlrmSaveOpenLock then
      begin
        Exclude(CMSRFlags, cmsfIsLocked);
        Include(CMSRFlags, cmsfIsUsed);
      end
      else
      begin
        if not(cmsfIsOpened in CMSRFlags) then
        begin
          if not(cmsfSkipUnlock in CMSRFlags) then
            Exclude(CMSRFlags, cmsfIsLocked);
        end;
        Exclude(CMSRFlags, cmsfIsUsed);
      end;
    end;
    Inc(APSlide);
  end;
end; // end of TK_CMEDAccess.EDAUnlockSlides


//********************************************* TK_CMEDAccess.EDADelSlide ***
// Delete given Slide from Current Slides Set
//
//     Parameters
// APSlide - pointer to slides array start element to delete
// ASlidesCount - number of slides to delete
// ASaveInCurSlidesSet - if TRUE save deleted slides in Current Slides Set
// AClearDelSlides - if TRUE deleted slides are destroyd (are not added to Deleted List)
// Result - Returns number of slides removed from CurSlidesList
//
function TK_CMEDAccess.EDADelSlides( APSlide: TN_PUDCMSlide;
                                     ASlidesCount: Integer;
                                     ASaveInCurSlidesSet : Boolean;
                                     AClearDelSlides : Boolean = FALSE ): Integer;
var
  i, Ind: Integer;
begin
  Result := 0;
  if APSlide = nil then
  begin
    Result := CurSlidesList.Count;
    DelSlidesList.Assign(CurSlidesList, laOr);
    CurSlidesList.Clear();
    SaveSlidesList.Clear();
  end
  else
    for i := 1 to ASlidesCount do
    begin
      Ind := CurSlidesList.IndexOf(APSlide^);
      if Ind >= 0 then
      begin
        if not ASaveInCurSlidesSet then
          CurSlidesList.Delete(Ind);
        Ind := SaveSlidesList.IndexOf(APSlide^);
        if Ind >= 0 then
          SaveSlidesList.Delete(Ind);
        Inc(Result)
      end;
      if AClearDelSlides then
        APSlide^.UDDelete()
      else
        DelSlidesList.Add(APSlide^);
      Inc(APSlide)
    end;
end; // end of TK_CMEDAccess.EDADelSlides

//********************************************* TK_CMEDAccess.EDAAddSlide ***
// Add given Slide to Current Slides Set
//
//     Parameters
// ASlide - given Slide
// ASkipECahe - if TRUE only create ASlide temporary uniq ObjName (prevent real EmCache saving)
// ASlidesCount - uniq ObjName create parameter (not used now)
//
procedure TK_CMEDAccess.EDAAddSlide( ASlide: TN_UDBase;
                                     ASkipECahe: Boolean = false;
                                     ASlidesCount : Integer = 0 );
begin
  // Set temporary Image ID
//  ASlide.ObjName := IntToStr(CurSlidesList.Count) + 'new';
  TN_UDCMSlide(ASlide).InitSelfName();
  // ASlide.ObjName := IntToStr( CurSlidesList.Count )+'999'; // Set temporary Image ID
  N_Dump1Str( format( 'EDAAddSlide %s SkipECache=%s SC=%d', [ASlide.ObjName, N_B2S(ASkipECahe), ASlidesCount] ) );
  CurSlidesList.Add(ASlide);
  if ASkipECahe then Exit;

  EDASaveSlideToECache(TN_UDCMSlide(ASlide));

//  if K_CMStudyCaptModeState <> 0 then Exit;
  if K_CMStudyCaptState < K_cmscOK then Exit;

  // Direct Capture into Study
  K_CMStudyCaptAddSlide( TN_UDCMSlide(ASlide) );

end; // end of TK_CMEDAccess.EDAAddSlide

//********************************************* TK_CMEDAccess.EDARemoveSlide ***
// Remove given Slide from Current Slides Set
//
//     Parameters
// ASlide - given Slide
//
//  Only new unsaved slides sould be removed by T\this function
//
procedure TK_CMEDAccess.EDARemoveSlide( ASlide : TN_UDBase );
begin
  if not (cmsfIsNew in TN_UDCMSlide(ASlide).P().CMSRFlags) then
  begin
    N_Dump2Str( 'EDARemoveSlide is not new ID=' + ASlide.ObjName );
    Exit;
  end;
  N_Dump2Str( 'EDARemoveSlide ID=' + ASlide.ObjName );
  CurSlidesList.Remove( ASlide );
  EDAClearSlideECache( TN_UDCMSlide(ASlide) );
  ASlide.UDDelete;
end; // end of TK_CMEDAccess.EDARemoveSlide

//********************************************* TK_CMEDAccess.EDAClearCurSlidesSet ***
// Clear Current Slides Set
//
procedure TK_CMEDAccess.EDAClearCurSlidesSet();
// var
// PSkipSelf : PByte;


  procedure ClearList(LL: TList);
  var
    i: Integer;
    UDSlide : TN_UDBase;
  begin
    for i := 0 to LL.Count - 1 do
    begin
      UDSlide := TN_UDBase(LL[i]);

      if N_CM_MainForm.CMMStudyLastOpened = TN_UDBase(UDSlide) then
      begin // Clear Study Open context
        N_CM_MainForm.CMMStudyLastOpened := nil;
        N_CM_MainForm.CMMStudyPrevLayout := eflNotDef;
        N_Dump2Str( 'EDAClearCurSlidesSet >> Clear Study in Open Context' );
      end;

      if UDSlide.RefCounter <> 0 then
      begin
        {
          // Clear Drawings SkipSelf
          PSkipSelf := TN_UDCMSLide(LL[i]).GetPMeasureRootSkipSelf();
          if PSkipSelf <> nil then
          PSkipSelf^ := 0;
        }
        Continue;
      end
      else
      // K_CMDeleteClientMediaFile( TN_UDCMSlide(LL[i]) );
        UDSlide.UDDelete();
    end;
    LL.Clear;
  end;

begin
  // To prevent AMSC Check Errors
  K_CMCurVisSlidesArray := nil;
  LockResCount := 0;

  if UndeletedFileNames <> nil then
    K_UnDeletedFileNames := UndeletedFileNames.SL;
  ClearList(CurSlidesList);
  ClearList(DelSlidesList);
  SaveSlidesList.Clear;
  K_UnDeletedFileNames := nil;
end; // end of TK_CMEDAccess.EDAClearCurSlidesSet

//********************************************* TK_CMEDAccess.EDADelUnusedImgFiles ***
// Clear Current Archive Unused Image Files
//
procedure TK_CMEDAccess.EDADelUnusedImgFiles();
var
  i: Integer;
  UDSect: TN_UDBase;
  UDSlide: TN_UDBase;
  FNL: TStringList;
  F: TSearchRec;
  FPath: string;

  procedure AddImgFiles(AChildInd: Integer);
  begin
    UDSect := UDSlide.DirChild(AChildInd);
    if (UDSect = nil) or ((UDSect.ObjFlags and K_fpObjSLSRFlag) = 0) then
      Exit;
    FNL.Add(ChangeFileExt(ExtractFileName(K_ExpandFileName(UDSect.ObjInfo)),
        ''));
  end;

begin
  FNL := TStringList.Create;
  for i := 0 to ArchSlidesRoot.DirHigh do
  begin
    UDSlide := ArchSlidesRoot.DirChild(i);
    AddImgFiles(K_CMSlideIndCurImg);
    AddImgFiles(K_CMSlideIndSrcImg);
  end;
  FNL.Sort;
  // Process CMArchSections Folder
  FPath := K_ExpandFileName('(#CMArchSections#)');
  if FindFirst(FPath + '*.*', faAnyFile, F) = 0 then
    repeat
      if (F.Name[1] = '.') or ((F.Attr and faDirectory) <> 0) or FNL.Find
        (ChangeFileExt(F.Name, ''), i) then
        Continue;
      K_DeleteFile(FPath + F.Name);
    until FindNext(F) <> 0;
    FindClose(F);

  FNL.Free;

end; // end of TK_CMEDAccess.EDADelUnusedImgFiles

//********************************************* TK_CMEDAccess.EDAGetAnyDataInfo ***
// Get List of fields values for Data given by ID
//
//     Parameters
// AUDTab  - Data Table Object
// ADataID - Data row ID
// AInfo   - fileds values list (<Name>=<Value>) (if = NIL then Object Strings are returned - do not delete resulting string in this case)
// AAddToValues - add to AFieldValues flag (if =FALSE, then AFieldValues would be clear before adding values)
// Result - Returns AInfo or Self StringsList if AInfo = nil (Self StringsList is always clear before adding new values)
//
function TK_CMEDAccess.EDAGetAnyDataInfo(AUDTab: TK_UDRArray; ADataID: Integer;
  AInfo: TStrings = nil; AAddToValues: Boolean = false): TStrings;
var
  Ind: Integer;

begin
  if AInfo = nil then
  begin
    AInfo := TmpStrings;
    AAddToValues := false;
  end;
  if not AAddToValues then
  begin
    AInfo.Clear;
    if K_CMSVIPCTitle <> '' then
      AInfo.Add( 'VIPCTitle=' + K_CMSVIPCTitle );
  end;
  Result := AInfo;

  Ind := EDAArchUDTabIndexOf(IntToStr(ADataID), AUDTab);
  ExtResultCode := K_edAbsentData;
  if Ind = 0 then
    Exit;

  ExtResultCode := K_edOK;
  EDAGetArchUDTabRowStrings(AUDTab, Ind, AInfo);
end; // end of TK_CMEDAccess.EDAGetAnyDataInfo

//********************************************* TK_CMEDAccess.EDAAddCurSlideSection ***
// Add Current Slide Section
//
//     Parameters
// ASlideChildInd - Slide Child Index for section adding
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAAddCurSlideSection(ASlideChildInd: Integer)
  : TN_UDBase;
var
  UD: TN_UDBase;
begin
  UD := CurSlide.DirChild(ASlideChildInd);

  // Insert Section Node
  Result := TN_UDBase.Create;
  with Result do
  begin
    ObjFlags := K_fpObjSLSRFlag + K_fpObjSLSRMLoad;
    if not K_CMLocalArchNewFileFormatFlag then
    begin // Old Img Files Format
      ObjInfo := CurSlide.ObjName;
      ObjName := 'CurImgSect';
      if ASlideChildInd = K_CMSlideIndSrcImg then
      begin
        ObjName := 'SrcImgSect';
        ObjInfo := ObjInfo + '_';
      end;
      ObjInfo := 'SF_' + ObjInfo + '.sdb';
    end
    else
    begin // New Img Files Format
      if ASlideChildInd = K_CMSlideIndCurImg then
        ObjInfo := CurSlide.GetCurImgFileName('')
      else
        ObjInfo := CurSlide.GetSrcImgFileName('');
    end;

    UD.Owner := nil;
    AddOneChild(UD);
    N_Dump2Str('DB>> Add slide section node FName=' + ObjInfo);
    ObjInfo := '(#CMArchSections#)' + ObjInfo;
    CurSlide.PutDirChildSafe(ASlideChildInd, Result);
    CurSlide.RebuildVnodes(0);
  end;

end; // end of TK_CMEDAccess.EDAAddCurSlideSection

//******************************************* TK_CMEDAccess.EDACompressData ***
// Compress Data
//
//     Parameters
// APData - on input pointer to source binary data first byte, on output pointer
//     to resulting binary data first byte
// ADataSize  - on input source binary data size in bytes on output resulting
//     binary data size in bytes
// ACurCompressPower - current compress power if -1 then common
// BlobCompressPower will be used
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDACompressData(var APData: Pointer;
  var ADataSize: Integer; ACurCompressPower: Integer = -1): TK_CMEDResult;
var
  CompressedCount: Integer;
begin
  Result := K_edOK;
  if ADataSize = 0 then
    Exit;
  if ACurCompressPower = -1 then
    ACurCompressPower := CurDataCompressPower;
  if ACurCompressPower = 0 then
    Exit;
  CompressedCount := ADataSize + 10000;
  if CompressedCount > Length(BlobComprBuf) then
  begin
    BlobComprBuf := nil;
    SetLength(BlobComprBuf, CompressedCount);
  end;
  ADataSize := N_CompressMem(APData, ADataSize, @BlobComprBuf[0],
    CompressedCount, ACurCompressPower);
  if ADataSize = -1 then
  begin
    Result := K_edExDataError;
    ExtDataErrorCode := K_eeDBBlobCompress;
    ExtDataErrorString := 'BLOB compression error';
    Exit;
  end;
  APData := @BlobComprBuf[0];
end; // end of TK_CMEDAccess.EDACompressData

//********************************************* TK_CMEDAccess.EDAUncompressData ***
// Uncompress data
//
//     Parameters
// APData   - on input pointer compressed data in output pointer on uncompressed data
// ADataSize - resulting data size in bytes
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAUncompressData(var APData: Pointer;
  var ADataSize: Integer): TK_CMEDResult;
var
  UncompressedCount: Integer;
begin
  Result := K_edOK;
  UncompressedCount := N_GetUncompressedSize(APData, ADataSize);
  if UncompressedCount <> -1 then
  begin // Uncompress Data
    if UncompressedCount > Length(BlobComprBuf) then
    begin
      BlobComprBuf := nil;
      SetLength(BlobComprBuf, UncompressedCount);
    end;
    ADataSize := N_DecompressMem(APData, ADataSize, @BlobComprBuf[0],
      UncompressedCount);
    if ADataSize <> -1 then
    begin
      APData := @BlobComprBuf[0];
    end
    else
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBBlobDecompress;
      ExtDataErrorString := 'BLOB decompression error';
    end;
  end;

end; // end of TK_CMEDAccess.EDAUncompressData

//********************************************* TK_CMEDAccess.EDAPutDataToStream ***
// Put Data to stream
//
//     Parameters
// AStream - stream object
// APData - pointer to binary data first byte
// ADataSize  - binary data size in bytes
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAPutDataToStream(AStream: TStream; APData: Pointer;
                                   ADataSize: Integer): TK_CMEDResult;
begin
  Result := K_edOK;
  if APData = nil then
    Exit;
  try
    if ADataSize <> 0 then
    begin
      if BlobEncParams.DFEncryptionType = K_dfePlain then
        AStream.Write(APData^, ADataSize)
      else
      begin
        BlobEncParams.DFCreateFlags := [K_dfcEncryptSrc];
        K_DFStreamWriteAll(AStream, BlobEncParams, APData, ADataSize);
      end;
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBBlobWrite;
      ExtDataErrorString := 'EDAPutDataToStream ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDAccess.EDAPutDataToStream

{
//********************************************* TK_CMEDAccess.EDALogChanAddFullStr ***
// Add given string to CMS Log if cmpfDatabase flag is set
//
//     Parameters
// AStr - given string
//
procedure TK_CMEDAccess.EDALogChanAddFullStr(AStr: string);
begin
  N_Dump2Str(AStr);
end; // end of TK_CMEDAccess.EDALogChanAddFullStr

//********************************************* TK_CMEDAccess.EDALogChanAddAllStr ***
// Add given string to CMS Log if cmpfDatabase flag is set
//
//     Parameters
// AStr - given string
//
procedure TK_CMEDAccess.EDALogChanAddAllStr(AStr: string);
begin
  N_Dump2Str(AStr);
end; // end of TK_CMEDAccess.EDALogChanAddAllStr
}
//********************************************* TK_CMEDAccess.EDASlideDataToFile ***
// Save given Data to file given by name
//
//     Parameters
// APData - pointer to binary data first byte
// ADataSize  - on input source binary data size in bytes, on output - resulting data size (in file)
// AImgFName - Image File Name
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASlideDataToFile(APData: Pointer;
  var ADataSize: Integer; const AImgFName: string): TK_CMEDResult;
var
  FStream: TFileStream;

begin
  Result := EDACompressData(APData, ADataSize, ImgFileCompressPower);
  if Result <> K_edOK then
  begin
    N_Dump2Str('Image DA File "' + AImgFName + '" compression Error');
    Exit;
  end;
//  try
  FStream := TFileStream.Create(AImgFName, fmCreate);
  Result := EDAPutDataToStream(FStream, APData, ADataSize);
  ADataSize := FStream.Size;
//  FlushFileBuffers( FStream.Handle );
  if not FlushFileBuffers(FStream.Handle) then
    N_Dump1Str( format( '!!! File %s >> FlushFileBuffers Error >> %s', [AImgFName,SysErrorMessage(GetLastError())] ) );
  FStream.Free;
  N_Dump2Str('Image DA File "' + AImgFName + '" is saved');
{
  except
    Result := K_edExDataError;
    N_Dump1Str('Image DA File "' + AImgFName + '" saving is failed');
  end;
}
end; // end of TK_CMEDAccess.EDASlideDataToFile

//********************************************* TK_CMEDAccess.EDASlideDataFromFile ***
// Get given DIBObj from file given by name
//
//     Parameters
// APData - pointer to buffer for data
// ADSize - resulting data size
// AImgFName - Image File Name
// AFSize - file size in bytes
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASlideDataFromFile(out APData: Pointer;
  out ADSize: Integer; const AImgFName: string; out AFSize : Integer ): TK_CMEDResult;
begin
  Result := K_edExDataError;
  ADSize := 0;
  AFSize := 0;
//    if K_DFOpen(AImgFName, DFile, [K_dfoProtected]) then
  if K_DFOpen(AImgFName, ExtDFile, []) then
  begin
    ADSize := ExtDFile.DFPlainDataSize;
    if Length(BlobBuf) < ADSize then
    begin
      BlobBuf := nil;
      SetLength(BlobBuf, ADSize);
    end;
    if K_DFReadAll(@BlobBuf[0], ExtDFile) then
    begin
      APData := @BlobBuf[0];
      Result := EDAUncompressData(APData, ADSize);
    end;
  end;
  AFSize := ExtDFile.DFSize;
  if ExtDFile.DFErrorCode <> K_dfrOK then
  begin
    if ExtDFile.DFErrorCode = K_dfrErrFileNotExists then
      ExtDataErrorCode := K_eeFileExists
    else
      ExtDataErrorCode := K_eeFileCorrupted;
    raise Exception.Create( format('Image file "%s"  >>  %s',
                 [AImgFName, K_DFGetErrorString( ExtDFile.DFErrorCode )] ) );
  end;
end; // end of TK_CMEDAccess.EDASlideDataFromFile

//********************************************* TK_CMEDAccess.EDASlideDIBToFile ***
// Save Slide DIB given from UDSection object
//
//     Parameters
// AUDSect - slide Current or Original DIB UDSection
// ASkipFreeDIBMemFlag - if TRUE then TN_UDDIB should not be removed from memory
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASlideDIBToFile( AUDSect: TN_UDBase; ASkipFreeDIBMemFlag : Boolean = FALSE ): TK_CMEDResult;
var
  PData : Pointer;
  DSize : Integer;
begin
  Result := K_edOK;
  if AUDSect = nil then Exit; // Sectiion Is Absent
//  if (AUDSect.ClassFlags and K_ChangedSLSRBit) <> 0 then
  if (AUDSect.ClassFlags and (K_ChangedSubTreeBit or K_ChangedSLSRBit)) <> 0 then
  begin
    if not K_CMLocalArchNewFileFormatFlag then
    begin
    // Old Format
      K_SaveCurArchiveSection(AUDSect);
      N_Dump2Str('Save Img Arch Section ' + AUDSect.ObjInfo);
    end
    else
    begin
      // Save Image To File
      K_CMGetUDDIBSData( TN_UDDIB(AUDSect.DirChild(0)), PData, DSize );
      Result := EDASlideDataToFile( PData, DSize,
                            K_ExpandFileName(AUDSect.ObjInfo) );
      // Clear Section Change Flags
      AUDSect.ClassFlags := AUDSect.ClassFlags and not (K_ChangedSubTreeBit or K_ChangedSLSRBit);
      N_Dump2Str('Save Img New Format ' + AUDSect.ObjInfo);
    end;
  end;

  if ASkipFreeDIBMemFlag then Exit;
  // Remove Section Image UDChild
  AUDSect.RemoveDirEntry(0);
end; // end of TK_CMEDAccess.EDASlideDIBToFile

//********************************************* TK_CMEDAccess.EDASlideDIBFromFile ***
// Load Slide DIB to given UDSection object
//
//     Parameters
// AUDSect - slide Current or Original DIB UDSection
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASlideDIBFromFile( AUDSect: TN_UDBase ): TK_CMEDResult;
var
  PData : Pointer;
  DSize : Integer;
  FSize : Integer;
  UDDIB : TN_UDDIB;
  SectionLoadFlag : Boolean;
  FName : string;
begin
//  Result := K_edOK;
  SectionLoadFlag := not K_CMLocalArchNewFileFormatFlag;
  if not SectionLoadFlag then
  begin
    try
      // Load Image From File
      PData := nil;
      DSize := 0;
      FName := K_ExpandFileName(AUDSect.ObjInfo);
      Result := EDASlideDataFromFile( PData, DSize, FName, FSize );
      if Result  <> K_edOK then Exit;

      UDDIB := K_CMCreateUDDIBBySData( PData, DSize, EDAFreeBuffer );
      if UDDIB = nil then
      begin
        Result := K_edFails;
        Exit;
      end;

      if AUDSect.ObjName = 'SrcImgSect' then
        UDDIB.ObjName := 'SrcImg';

      AUDSect.AddOneChild( UDDIB );
      N_Dump2Str('Load New Img Format ' +  AUDSect.ObjInfo);
    except
      on E: Exception do
      begin
        EDAFreeBuffer(PData);
        if UpperCase(ExtractFileExt(FName)) = '.CMI' then
          raise Exception.Create(E.Message);
        SectionLoadFlag := TRUE; // Try Old Format
      end; // on E: Exception do
    end; // except
  end;

  Result := K_edOK;
  if not SectionLoadFlag then Exit;
  // Old Format
  K_LoadCurArchiveSection(AUDSect);
  N_Dump2Str('Load Image Section ' +  AUDSect.ObjInfo);

end; // end of TK_CMEDAccess.EDASlideDIBFromFile

//********************************************* TK_CMEDAccess.EDAFreeBuffer ***
// Free Buffer given by pointer if it is too large
//
//     Parameters
// APBuf - pointre to buffer
//
procedure TK_CMEDAccess.EDAFreeBuffer(APBuf: Pointer);
begin
  if (Length(BlobBuf) > 0) and (@BlobBuf[0] = APBuf) then
  begin
    if Length(BlobBuf) > K_CMBufMaxCapacity then
      BlobBuf := nil;
  end
  else if (Length(BlobComprBuf) > 0) and (@BlobComprBuf[0] = APBuf) then
  begin
    if Length(BlobComprBuf) > K_CMBufMaxCapacity then
      BlobComprBuf := nil;
  end;
end; // end of TK_CMEDAccess.EDAFreeBuffer

//***************************************** TK_CMEDAccess.EDAShowErrMessage ***
// Add given string to CMS Log if Data Access error was detected
//
//     Parameters
// AShowMessage - if TRUE then Show MessageDialog
//
procedure TK_CMEDAccess.EDAShowErrMessage(AShowMessage: Boolean);
var
  ErrStr: string;
begin
  ErrStr := 'Data Access ERROR >> ' + ExtDataErrorString;
  N_Dump1Str(ErrStr);
//  N_LCAdd(N_CMSDump1LCInd, ErrStr);

  EDAPrepStateAfterException;
  if K_CMTerminateByEDAError then
  begin
    raise Exception.Create(ExtDataErrorString);
  end;
  if AShowMessage then
    K_CMShowMessageDlg( //sysout
      ErrStr, mtError, [], TRUE, '' );
end; // end of TK_CMEDAccess.EDAShowErrMessage

//************************************* TK_CMEDDBAccess.EDAAnsiTextToString ***
// Convert DB Text given by pointer to string
//
//     Parameters
// ADSize - size of source DB text in bytes (including terminated ZERO)
// APData - on input pointer to DB Text, on output pointer converted text
// Result - Returnes size of resulting text in bytes
//
function TK_CMEDAccess.EDAAnsiTextToString( var APData: Pointer; ADSize: Integer ): Integer;
begin
  if SizeOf(Char) = 2 then
  begin
    // Convert to Wide
//    StrTextBuf := string(PAnsiChar(APData));
    StrTextBuf := N_AnsiToString(PAnsiChar(APData));
    Result := Length(StrTextBuf) * 2;
    if Result > 0 then
      APData := @StrTextBuf[1]
    else
      APData := @StrTextBuf; // Return Pointer to WideChar #0 - PChar to empty string
//      APData := nil; // it works in D7 and D10 but I don't no
                       // is correct to use PChar = nil as pointer to empty string
  end
  else
    Result := ADSize;
end; // end of TK_CMEDAccess.EDAAnsiTextToString

//************************************ TK_CMEDDBAccess.EDAStringsToAnsiText ***
// Convert Strings to DB Text
//
//     Parameters
// APStrChar - pointer to source string first char
// AStrLeng - source string length
// APData - resulting pointer to text buffer
// Result - Returnes size of serialized data in bytes
//
function TK_CMEDAccess.EDAStringToAnsiText( APStrChar: PChar; AStrLeng : Integer;
                                            out APData: Pointer ): Integer;
begin
  Result := 1 + AStrLeng;
  if SizeOf(Char) = 2 then
  begin // String is Wide
    AnsiTextBuf := N_StringToAnsi(APStrChar);
    if AnsiTextBuf <> '' then
      APData := @AnsiTextBuf[1]
    else
      APData := @AnsiTextBuf; // Return  pointer to AnsiChar #0 - PAnsiChar to Empty String
  end
  else
    APData := APStrChar;
end; // end of TK_CMEDAccess.EDAStringToAnsiText

//********************************************* TK_CMEDDBAccess.EDAStringsToAnsiText ***
// Convert Strings to DB Text
//
//     Parameters
// AStrings - source strings to convert
// APData - resulting pointer to text buffer
// Result - Returnes size of serialized data in bytes
//
function TK_CMEDAccess.EDAStringsToAnsiText(AStrings: TStrings;
  out APData: Pointer): Integer;
var
  StrLeng : Integer;
begin
  StrLeng := K_GetStringsToBuf(StrTextBuf, AStrings, 0);
  Result := EDAStringToAnsiText( @StrTextBuf[1], StrLeng, APData );
{
  Result := 1 + K_GetStringsToBuf(StrTextBuf, AStrings, 0);
  if SizeOf(Char) = 2 then
  begin // String is Wide
//    AnsiTextBuf := AnsiString(StrTextBuf);
    AnsiTextBuf := N_StringToAnsi(StrTextBuf);
    APData := @AnsiTextBuf[1];
  end
  else
    APData := @StrTextBuf[1];
}
end; // end of TK_CMEDAccess.EDAStringsToAnsiText

//********************************************* TK_CMEDAccess.EDAGetLocationMacroInfo ***
// Get List of fields values for given Location
//
//     Parameters
// ADataID - Location ID (if =-1 then Current Location ID will be used)
// AInfo   - fields values list (<Name>=<Value>) (if = NIL then Object Strings are returned - do not delete resulting string in this case)
// AAddToValues - add to AFieldValues flag (if =FALSE, then AFieldValues would be clear before adding values)
// Result - Returns AInfo or Self StringsList if AInfo = nil (Self StringsList is always clear before adding new values)
//
function TK_CMEDAccess.EDAGetLocationMacroInfo(ADataID: Integer = -1;
  AInfo: TStrings = nil; AAddToValues: Boolean = false): TStrings;
begin
  Result := AInfo;
  if ADataID = -1 then
    ADataID := CurLocID;
  if LocationsInfo <> nil then
    Result := EDAGetAnyDataInfo(LocationsInfo, ADataID, AInfo, AAddToValues);
end; // end of TK_CMEDAccess.EDAGetLocationMacroInfo

//************************************ TK_CMEDAccess.EDAGetPatientMacroInfo ***
// Get List of fields values for given Patient
//
//     Parameters
// ADataID - Patient ID (if =-1 then Current Patient ID will be used)
// AInfo   - fileds values list (<Name>=<Value>)
// AAddToValues - add to AFieldValues flag (if =FALSE, then AFieldValues would be clear before adding values)
// Result - Returns AInfo or Self StringsList if AInfo = nil (Self StringsList is always clear before adding new values)
//
function TK_CMEDAccess.EDAGetPatientMacroInfo(ADataID: Integer = -1;
  AInfo: TStrings = nil; AAddToValues: Boolean = false): TStrings;
begin
  Result := AInfo;
  if ADataID = -1 then
    ADataID := CurPatID;
  if PatientsInfo <> nil then
    Result := EDAGetAnyDataInfo(PatientsInfo, ADataID, AInfo, AAddToValues);
end; // end of TK_CMEDAccess.EDAGetPatientMacroInfo

//*********************************** TK_CMEDAccess.EDAGetProviderMacroInfo ***
// Get List of fields values for given Provider
//
//     Parameters
// ADataID - Provider ID (if =-1 then Current Provider ID will be used)
// AInfo   - fileds values list (<Name>=<Value>)
// AAddToValues - add to AFieldValues flag (if =FALSE, then AFieldValues would be clear before adding values)
// Result - Returns AInfo or Self StringsList if AInfo = nil (Self StringsList is always clear before adding new values)
//
function TK_CMEDAccess.EDAGetProviderMacroInfo(ADataID: Integer = -1;
  AInfo: TStrings = nil; AAddToValues: Boolean = false): TStrings;
begin
  Result := AInfo;
  if ADataID = -1 then
    ADataID := CurProvID;
  if ProvidersInfo <> nil then
    Result := EDAGetAnyDataInfo(ProvidersInfo, ADataID, AInfo, AAddToValues);
end; // end of TK_CMEDAccess.EDAGetProviderMacroInfo

//******************************** TK_CMEDAccess.EDAGetProviderAccessRights ***
// Get Provider Access Rights
//
//     Parameters
// ADataID - Provider ID (if =-1 then Current Provider ID will be used)
// Result - Returns Given Provider Access Rights
//
function TK_CMEDAccess.EDAGetProviderAccessRights( ADataID: Integer = -1 ): TK_CMUserAccessRights;
var
 Ind, ARFInd : Integer;
begin
  Ind := -1;
  Result := TK_CMUserAccessRights(Short(Ind)); // All Rights as Default
  if ProvidersInfo = nil then Exit; // Providers Info is absent

  with ProvidersInfo.R do
    ARFInd := 1 + K_IndexOfStringInRArray( 'ProviderFlags', PME(1, 0), AColCount - 1, ElemSize );
  if ARFInd = 0 then Exit; // Access Rights Field is absent

  if ADataID = -1 then
    ADataID := CurProvID;
  Ind := EDAArchUDTabIndexOf( IntToStr(ADataID), ProvidersInfo );
  if Ind = 0 then Exit;    // Given Provider Info is absent


  with ProvidersInfo.R do
    Ind := StrToIntDef( PString(PME( ARFInd, Ind ))^, -1 );
  Result := TK_CMUserAccessRights(Short(Ind)); // Returns New Access Rights

end; // end of TK_CMEDAccess.EDAGetProviderAccessRights

//******************************* TK_CMEDAccess.EDAGetUserDefineMediaFilter ***
// Get User Defined Media Filter Data
//
//     Parameters
// AFilterName - Provider ID (if =-1 then Current Provider ID will be used)
// APUDFilterAttrs - Pointer to Filter data
//
procedure TK_CMEDAccess.EDAGetUserDefineMediaFilter( const AFilterName: string;
                                APUDFilterAttrs : TK_PCMSlideFilterAttrs );
begin
  K_CMFilterAttrsClear( APUDFilterAttrs );
  K_LoadSPLDataFromText( APUDFilterAttrs^, K_GetTypeCodeSafe( 'TK_CMSlideFilterAttrs' ).All,
       N_MemIniToString( 'UserMediaFilters', AFilterName,
       '<TK_CMSlideFilterAttrs />' ) );
end; // end of TK_CMEDAccess.EDAGetUserDefineMediaFilter

//******************************* TK_CMEDAccess.EDAPutUserDefineMediaFilter ***
// Put User Defined Media Filter Data
//
//     Parameters
// AFilterName - Provider ID (if =-1 then Current Provider ID will be used)
// APUDFilterAttrs - Pointer to Filter data
//
procedure TK_CMEDAccess.EDAPutUserDefineMediaFilter( const AFilterName: string;
                                APUDFilterAttrs : TK_PCMSlideFilterAttrs );
begin
  N_StringToMemIni( 'UserMediaFilters', AFilterName,
    K_SaveSPLDataToText( APUDFilterAttrs^, K_GetTypeCodeSafe( 'TK_CMSlideFilterAttrs' ).All ) );
end; // end of TK_CMEDAccess.EDAPutUserDefineMediaFilter

{
  //******************************************** TK_CMEDAccess.EDASetPatientInfo ***
  // Set List of fields values for given Patient
  //
  //    Parameters
  // ADataID - Patient ID
  // AInfo   - fileds values list (<Name>=<Value>)
  //
  procedure TK_CMEDAccess.EDASetOnePatientInfo( ADataID: Integer;
  AInfo: TStrings );
  begin
  PatDBuf.DBAddValuesListByID( ADataID, AInfo );
  end; // end of TK_CMEDAccess.EDASetPatientInfo

  //******************************************** TK_CMEDAccess.EDASetProviderInfo ***
  // Set List of fields values for given Provider
  //
  //    Parameters
  // ADataID - Patient ID
  // AInfo   - fileds values list (<Name>=<Value>)
  //
  procedure TK_CMEDAccess.EDASetProviderInfo( ADataID: Integer;
  AInfo: TStrings );
  begin
  ProvDBuf.DBAddValuesListByID( ADataID, AInfo );
  end; // end of TK_CMEDAccess.EDASetProviderInfo

  //******************************************** TK_CMEDAccess.EDASetLocationInfo ***
  // Set List of fields values for given Provider
  //
  //    Parameters
  // ADataID - Patient ID
  // AInfo   - fileds values list (<Name>=<Value>)
  //
  procedure TK_CMEDAccess.EDASetLocationInfo( ADataID: Integer;
  AInfo: TStrings );
  begin
  LocDBuf.DBAddValuesListByID( ADataID, AInfo );
  end; // end of TK_CMEDAccess.EDASetLocationInfo
}

//************************************* TK_CMEDAccess.EDACurSlidesToStrings ***
// Copy Slides to Strings Object from Current Slides Set
//
//     Parameters
// AStrings - Strings to to which slides are copied
//
// AStrings AStrings[i] contains Slide ID, AStrings.Objects[i] contains
// reference to Slide Object
//
procedure TK_CMEDAccess.EDACurSlidesToStrings(AStrings: TStrings);
var
  i: Integer;
  // UDSlide : TN_UDCMSlide;
  UDSlide: TN_UDBase;
begin
  for i := 0 to CurSlidesList.Count - 1 do
  begin
    UDSlide := TN_UDBase(CurSlidesList[i]);
    AStrings.AddObject(UDSlide.ObjName, UDSlide);
  end;
end; // end of TK_CMEDAccess.EDACurSlidesToStrings

//******************************** TK_CMEDAccess.EDACalcBySlidesSelectAttrs ***
// Calculate Slides number by Current Slides Select Attributes
//
//     Parameters
// ASlidesCount - resulkting slides counter
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDACalcBySlidesSelectAttrs(out ASlidesCount: Integer)
  : TK_CMEDResult;
var
  i: Integer;
begin
  Result := K_edExDataError;
  ASlidesCount := 0;
  if ArchSlidesRoot = nil then
  begin
    ExtDataErrorString := 'CMS archive Slides Root Node is absent';
    EDAShowErrMessage(false);
    Exit;
  end;
  for i := 0 to ArchSlidesRoot.DirHigh() do
  begin
    CurSlide := TN_UDCMSlide(ArchSlidesRoot.DirChild(i));
    with CurSlide.P()^ do
      if (CurSlidesSelectAttrs.SSPatID = CMSPatId) then
        Inc(ASlidesCount);
  end;
  N_Dump2Str('DB>> Patient ID=' + IntToStr(CurSlidesSelectAttrs.SSPatID)
      + ' Slides Number=' + IntToStr(ASlidesCount));
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDACalcBySlidesSelectAttrs

//************************************ TK_CMEDAccess.EDARefreshCurSlidesSet ***
// Refresh Current Slides Set from Extenal Data
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDARefreshCurSlidesSet( out ANewSlidesCount,
               ADelSlidesCount, AUpdateSlidesCount : Integer ): TK_CMEDResult;
begin
  ANewSlidesCount := 0;
  ADelSlidesCount := 0;
  AUpdateSlidesCount := 0;
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDARefreshCurSlidesSet

//**************************************** TK_CMEDAccess.EDAGetCurSlidesSet ***
// Get Current Slides Set from Extenal Data
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetCurSlidesSet(): TK_CMEDResult;
var
  i: Integer;
begin
  EDAClearCurSlidesSet();
  Result := K_edExDataError;
  if ArchSlidesRoot = nil then
    Exit;
  for i := 0 to ArchSlidesRoot.DirHigh() do
  begin
    CurSlide := TN_UDCMSlide(ArchSlidesRoot.DirChild(i));

    // *** Check Slide Selection Condition
    with CurSlide.P()^ do
    begin
      if (CurSlidesSelectAttrs.SSPatID = -1) then
        CurSlidesSelectAttrs.SSPatID := CMSPatId;

      if CMSPatId <> CurSlidesSelectAttrs.SSPatID then
        Continue;
    end;
    // ***

    CurSlidesList.Add(CurSlide);
  end;
  N_Dump2Str('DB>> Select slides for patient ID=' + IntToStr
      (CurSlidesSelectAttrs.SSPatID));
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAGetCurSlidesSet

//*************************************** TK_CMEDAccess.EDAGetUDCMSlidesByID ***
// Get Slides from Extenal Data by given IDs
//
//     Parameters
// APID   - pointer to first slide ID
// ACount - number of slides ID
// ASlides - resulting array of slides
// Result - Returns operation resulting code
//
// Resulting array ASlides length may be less than number of slides ID ACount if
// some Slides with given IDs are not found
//
function TK_CMEDAccess.EDAGetUDCMSlidesByID(APID: PInteger; ACount: Integer;
  var ASLides: TN_UDCMSArray): TK_CMEDResult;
var
  i, Ind: Integer;
  SID: string;
begin
  Result := K_edExDataError;
  N_Dump2Str('DB>> Get slides by given IDs');
  if ArchSlidesRoot = nil then
    Exit;
  SetLength(ASLides, ACount);
  Ind := 0;
  for i := 0 to ACount - 1 do
  begin
    SID := IntToStr(APID^);
    CurSlide := TN_UDCMSlide(ArchSlidesRoot.DirChildByObjName(SID));
    if CurSlide <> nil then
    begin
      ASLides[Ind] := CurSlide;
      Inc(Ind);
    end
    else
      N_Dump2Str('DB>> Slide not found ID=' + SID);
    Inc(APID);
  end;
  SetLength(ASLides, Ind);
  N_Dump2Str(format('DB>> Get %d slides by given IDs', [Ind]));
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAGetUDCMSlidesByID

//***************************************** TK_CMEDAccess.EDASaveSlidesList ***
// Save Slides Current Set
//
//     Parameters
// ASLides - list of slide to save
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASaveSlidesList(ASLides: TList): TK_CMEDResult;
var
  i, j, n: Integer;
  LResult: TK_CMEDResult;
  CSlide: TN_UDCMBSlide;
  SavedCursor: TCursor;
  SlidesWereSaved: Boolean;
  Slides: TList;
  // SkipSelf : Byte;
  // PSkipSelf : PByte;
  // WaitD4WData : Boolean;
begin

  N_Dump2Str('DB>> EDASaveSlidesList start');

//  N_CheckAllExec('Before Slides saving');
  K_AMSCObj.AMSCheckExec('Before Slides saving');
  if DelSlidesList.Count > 0 then
  begin // to check if EDAClearDeletedSlides is needed
    K_CMShowMessageDlg( '!!! Clear Deleted Slides Before Saving !!!', mtWarning );

    Result := EDAClearDeletedSlides( FALSE ); // Clear Deleted Slides
    if Result <> K_edOK then
      Exit;
  end;

  Slides := CurSlidesList;
  if (ASLides <> nil) and (ASLides.Count > 0) then
    Slides := ASLides;

  // Mark Editing Slides to skip their saving
  n := 0; // Calculate number of changed images
  for i := 0 to Slides.Count - 1 do
  begin
    CSlide := TN_UDCMBSlide(Slides[i]);

//    if CSlide is TN_UDCMSlide then
    TN_UDCMSlide(CSlide).CMSUndoBuf.UBSetSlideChangeDataFlags();

    if [cmsfIsNew, cmsfCurImgChanged, cmsfMapRootChanged,
        cmsfThumbChanged,cmsfAttribsChanged] * CSlide.P.CMSRFlags <> [] then
      Inc(n); // Calc Changed Slides
  end;

  N_Dump2Str( format( 'DB>> EDASaveSlidesList save is needed Count=%d', [n] ) );
  Result := EDASetNewSlidesID(Slides); // Set New Slides ID
  if Result <> K_edOK then
    Exit;

  K_TreeViewsUpdateModeSet;
  SavedCursor := Screen.Cursor;
  Screen.Cursor := crHourglass;
  SlidesWereSaved := false;
  j := 0;

  // WaitD4WData := not K_CMD4WWaitApplyDataFlag and not K_CMD4WAppFinState;
  // if WaitD4WData then
  // K_CMD4WWaitApplyDataFlag := TRUE;

  Inc(K_CMD4WWaitApplyDataCount);

  for i := 0 to Slides.Count - 1 do
  begin
    CSlide := TN_UDCMBSlide(Slides[i]);
    // !!    if not CSlide.CMSideMarker then begin
    with CSlide.P^ do
      if not (cmsfSkipChangesSave in CMSRFlags) then
      begin
        if CSlide is TN_UDCMStudy then
          LResult := EDAStudySave( TN_UDCMStudy(CSlide) )
        else
          LResult := EDASaveSlide( TN_UDCMSlide(CSlide) );

        if LResult <> K_edOK then
        begin
          Result := LResult;
          if (Slides <> CurSlidesList) and
             (cmsfIsNew in CMSRFlags) then
          begin
            if CurSlidesList.Remove(CSlide) >= 0 then // Remove new Slide if saving error
              Inc(RemovedFromCurSlidesSetCount);
          end;
        end;

        SlidesWereSaved := SlidesWereSaved or (CurSlide <> nil);
        if CurSlide <> nil then
        begin
          N_Dump1Str( '!! >> Save Slide ID=' + CurSlide.ObjName );
          Inc(j);
          // N_CM_MainForm.CMMFShowString( IntToStr(j) + ' media object(s) are saved ... Please wait' );
          N_CM_MainForm.CMMFShowString( format( K_CML1Form.LLLSave1.Caption,
//              ' %d media object(s) of %d are saved ... Please wait',
                                       [j, n] ) );
        end;
      end // if not (cmsfSkipChangesSave in CMSRFlags) then
      else
      begin
        CMSRFlags := CMSRFlags - [cmsfCurImgChanged, cmsfMapRootChanged, cmsfAttribsChanged];
      end;
    // !!    end;
    // !!    CSlide.CMSideMarker := FALSE; // Clear Slide Marker
  end; // for i := 0 to Slides.Count - 1 do
  N_SerialBuf.Init0(); // Clear Maximal Buffer

  Screen.Cursor := SavedCursor;
  N_CM_MainForm.CMMFShowString('');
  K_TreeViewsUpdateModeClear;

// 2014-08-26 Remove ASLides Clear (error found in EXE compiled by XE5)
  if Slides = ASLides then
    ASLides.Clear; // Clear Slides List to save

  if SlidesWereSaved then // will work only in Local DB Mode
    EDASaveContextsData([K_cmssSkipAllContexts]);

  // if not WaitD4WData then Exit;
  // Apply Saved D4W Data
  // K_CMD4WApplyBufContext( );
  // K_CMD4WWaitApplyDataFlag := FALSE;

  Dec(K_CMD4WWaitApplyDataCount);

// 2015-11-18 add condition (K_CMSAppStartContext.CMASMode = K_cmamCOMVEUI) because of
// relaunch HPreview inside K_CMD4WApplyBufContext after 3DViewer real import Views in VEUI mode
// 2017-07-02 add condition (N_CM_MainForm.CMMCurFMainForm <> nil) because of
// attempt to set current context inside K_CMD4WApplyBufContext after 3DViewer real import Views in HPreview mode,
// it can be done only after N_CM_MainForm.CMMCurFMainForm is shown
  if (K_CMD4WWaitApplyDataCount = 0)        and
     not K_CMD4WAppFinState                 and
     (N_CM_MainForm.CMMCurFMainForm <> nil) and
     (K_CMSAppStartContext.CMASMode = K_cmamCOMVEUI) then
    K_CMD4WApplyBufContext();

  K_AMSCObj.AMSCheckExec('After Slides saving');
  N_Dump2Str('DB>> EDASaveSlidesList fin');

end; // end of TK_CMEDAccess.EDASaveSlidesList

//**************************************** TK_CMEDAccess.EDASaveSlidesArray ***
// Save Given Slides Array
//
//     Parameters
// APSlide - pointer to slides array start element to save
// ASlidesCount - number of slides to save
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASaveSlidesArray( APSlide: TN_PUDCMSlide;
                                           ASlidesCount: Integer ): TK_CMEDResult;
var
  i: Integer;
begin
  Result := K_edOK;
  if ASlidesCount <= 0 then
    Exit;
  for i := 0 to ASlidesCount - 1 do
  begin
    SaveSlidesList.Add(APSlide^);
    Inc(APSlide);
  end;
  Result := EDASaveSlidesList(SaveSlidesList);
  SaveSlidesList.Clear;
end; // end of TK_CMEDAccess.EDASaveSlidesArray

//********************************** TK_CMEDAccess.EDAGetSlidesFPathContext ***
// Prepare Access State after Exception
//
function TK_CMEDAccess.EDAGetSlidesFPathContext( ALocID : Integer = -1 ): TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAGetSlidesFPathContext

//******************************** TK_CMEDAccess.EDAPrepStateAfterException ***
// Get Slides Files Access Context
//
//     Parameters
// Result - Returns operation resulting code
//
procedure TK_CMEDAccess.EDAPrepStateAfterException;
begin
end; // end of TK_CMEDAccess.EDAPrepStateAfterException

//********************************* TK_CMEDAccess.EDAGetArchUDTabRowStrings ***
// Get Archive table given row values as Strings
//
//     Parameters
// AUDTab - archive table
// ARow   - table row index
// ASList - Strings object for resulting values
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetArchUDTabRowStrings(AUDTab: TK_UDRArray;
  ARow: Integer; ASList: TStrings): TK_CMEDResult;
var
  PStr0, PStr: PString;
  i: Integer;

begin

  with AUDTab.R do
  begin
    Result := K_edExDataError;
    if ARow >= ARowCount then
      Exit;
    Result := K_edOK;
    PStr0 := P();
    PStr := PME(0, ARow);
    for i := 0 to AColCount - 1 do
    begin
      ASList.Add(PStr0^ + '=' + PStr^);
      Inc(PStr0);
      Inc(PStr);
    end;
  end;

end; // end of TK_CMEDAccess.EDAGetArchUDTabRowStrings

//*************************************** TK_CMEDAccess.EDAArchUDTabIndexOf ***
// Index of string in Archive table
//
//     Parameters
// ASStr  - search string
// AUDTab - archive table
// AFInd  - table field index
// Result - Returns index of foundling table row or 0
//
function TK_CMEDAccess.EDAArchUDTabIndexOf(ASStr: string; AUDTab: TK_UDRArray;
  AFInd: Integer = 0): Integer;
begin
  with AUDTab.R do
    Result := K_IndexOfStringInRArray(ASStr, PME(AFInd, 1), ARowCount - 1,
      AColCount * ElemSize);
  Inc(Result);
end; // end of TK_CMEDAccess.EDAArchUDTabIndexOf

//************************************ TK_CMEDAccess.EDAArchUDTabFieldIndex ***
// Index of Field in Archive table
//
//     Parameters
// AFieldName  - search FieldName
// AUDTab - archive table
// AddFieldFlag - if =TRUE absent feild will be added to table
// Result - Returns index of foundling table row or 0
//
function TK_CMEDAccess.EDAArchUDTabFieldIndex( AFieldName: string; AUDTab: TK_UDRArray;
                                               AddFieldFlag : Boolean = TRUE ): Integer;
begin
  with AUDTab.R do
  begin
    Result := K_IndexOfStringInRArray(AFieldName, PME(0, 0), AColCount(), ElemSize);
    if (Result >= 0) or not AddFieldFlag then Exit;
    Result := AColCount();
    ASetLength( Result + 1, ARowCount );
    PString(PME(Result,0))^ := AFieldName;
    N_Dump2Str( 'DB>> EDAArchUDTabFieldIndex Add new column ' + AFieldName );
  end;
end; // end of TK_CMEDAccess.EDAArchUDTabFieldIndex

//******************************************* TK_CMEDAccess.EDAGetArchUDTab ***
// Get Archive table
//
//     Parameters
// APath  - archive table path
// AUDTab - archive table
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetArchUDTab(const APath: string;
  var AUDTab: TK_UDRArray): TK_CMEDResult;
begin
  Result := K_edOK;
  if AUDTab <> nil then
    Exit;
  AUDTab := TK_UDRArray(K_UDCursorGetObj(K_ArchiveCursor + APath));
  if not K_IsUDRArray(AUDTab) then
    Result := K_edExDataError;
end; // end of TK_CMEDAccess.EDAGetArchUDTab

//**************************************** TK_CMEDAccess.EDAFixIDsRangeArch ***
// Get Start ID for given ID index and Range
//
//     Parameters
// AIDInd     - needed ID index
// ARangeSize - needed range size
// Result - Returns start ID or -1 if error detected
//
function TK_CMEDAccess.EDAFixIDsRangeArch(AIDInd, ARangeSize: Integer): Integer;
var
  PSlideMaxID: PInteger;
begin
  ExtResultCode := EDAGetArchUDTab('GlobInfo', ArchGlobInfo);
  Result := -1;
  if ExtResultCode = K_edExDataError then
    Exit;
  if ArchGlobInfo.R.ALength < AIDInd + 1 then
    ArchGlobInfo.R.ASetLength(AIDInd + 1);
  PSlideMaxID := ArchGlobInfo.PDE(AIDInd);
  case AIDInd of
    K_CMAMIDSlideInd:
      PSlideMaxID^ := Max(PSlideMaxID^, K_CMEDSlideInitID);
    K_CMAMIDMTypeInd:
      PSlideMaxID^ := Max(PSlideMaxID^, K_CMEDMTypeInitID);
    K_CMAMIDMFileInd:
      PSlideMaxID^ := Max(PSlideMaxID^, K_CMEDMFileInitID);
  end;
  Result := PSlideMaxID^;
  if ARangeSize <= 0 then
    Exit;
  PSlideMaxID^ := Result + ARangeSize;
  K_SetChangeSubTreeFlags(ArchGlobInfo);
  K_SetArchiveChangeFlag();
end; // end of TK_CMEDAccess.EDAFixIDsRangeArch

//************************************ TK_CMEDAccess.EDAGetNewSlidesStartID ***
// Get Start ID for new Slides
//
//     Parameters
// ANCount - number of new Slides
// Result - Returns start ID or -1 if error detected
//
function TK_CMEDAccess.EDAGetNewSlidesStartID(ANCount: Integer): Integer;
begin
  Result := EDAFixIDsRangeArch(K_CMAMIDSlideInd, ANCount);
end; // end of TK_CMEDAccess.EDAGetNewSlidesStartID

//***************************************** TK_CMEDAccess.EDASetNewSlidesID ***
// Set Slides Current Set new Slides ID
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASetNewSlidesID(ASLides: TList): TK_CMEDResult;
var
  NCount: Integer;
  i, StartID: Integer;
  CSlide: TN_UDCMBSlide;
  NSlides: TN_UDCMBSArray;
  PSlideFields: TN_PCMSlide;

begin
  Result := K_edOK;
  // *** found created slides
  NCount := 0;
  SetLength(NSlides, ASLides.Count);
  for i := 0 to High(NSlides) do
  begin
    CSlide := ASLides[i];
    // !!    if CSlide.CMSideMarker or
    // !!       not (cmsfIsNew in CSlide.P().CMSRFlags) then Continue;
    if not(cmsfIsNew in CSlide.P().CMSRFlags) then
      Continue;
    NSlides[NCount] := CSlide;
    Inc(NCount);
  end;

  if NCount = 0 then
    Exit; // no created slides found

  // *** Fix Uniq IDs for created slides
  StartID := EDAGetNewSlidesStartID(NCount);
  if StartID < 0 then
  begin
    Result := K_edExDataError;
    Exit;
  end;

  // *** Set IDs for created slides
  for i := 0 to NCount - 1 do
  begin
    with NSlides[i] do
    begin
      PSlideFields := P();
      with PSlideFields^ do
      begin
        // PCMSlide := P();
        // CMSSelfId := StartID;
        ObjName := IntToStr(StartID);
        CMSRFlags := CMSRFlags + [cmsfAttribsChanged, cmsfMapRootChanged];
        if not((cmsfIsMediaObj in CMSDB.SFlags) or
               (cmsfIsImg3DObj in CMSDB.SFlags)) and
           not(cmsfSkipNewFile in CMSRFlags)     and
           (NSlides[i] is TN_UDCMSlide) then
          Include(CMSRFlags, cmsfCurImgChanged);
      end;
    end;
    Inc(StartID);
  end;
end; // end of TK_CMEDAccess.EDASetNewSlidesID

//************************************* TK_CMEDAccess.EDAClearDeletedSlides ***
// Clear Deleted Slides from External Data
//
//     Parameters
// AMarkAsDelFlag - if = TRUE then only mark as deleted is needed
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAClearDeletedSlides( AMarkAsDelFlag : Boolean ): TK_CMEDResult;
var
  i: Integer;
  UDSlide, UDSect: TN_UDBase;
  FileName: string;
  SlideName: string;

  procedure DeleteSectionFile(SetInd: Integer);
  var
    FName: string;
    FPath: string;
  begin
    UDSect := UDSlide.DirChild(SetInd);
    if (UDSect = nil) or
       ((UDSect.ObjFlags and K_fpObjSLSRFlag) = 0) then Exit;
    FName := K_ExpandFileName(UDSect.ObjInfo);
    FPath := ExtractFilePath(FName);
    FName := ChangeFileExt(ExtractFileName(FName), '.*');
    K_DeleteFolderFiles(FPath, FName, []);
  end;

begin
  Result := K_edOK;

  if UndeletedFileNames <> nil then
  begin
    with UndeletedFileNames do
      for i := SL.Count - 1 downto 0 do
      begin
        FileName := SL[i];
        if not FileExists(FileName) or DeleteFile(FileName) then
          SL.Delete(i);
      end;

    if ArchSlidesRoot = nil then
      Exit;
    K_UnDeletedFileNames := UndeletedFileNames.SL;
  end;

  for i := DelSlidesList.Count - 1 downto 0 do
  begin
    UDSlide := TN_UDBase(DelSlidesList[i]);
    K_CMDeleteClientMediaFile(TN_UDCMSlide(UDSlide));
    DeleteSectionFile(K_CMSlideIndCurImg);
    DeleteSectionFile(K_CMSlideIndSrcImg);
    SlideName := UDSlide.ObjName;
    if ArchSlidesRoot.DeleteOneChild(UDSlide) < 0 then
      UDSlide.UDDelete // Delete Slide which is not saved in archive
    else
      N_Dump2Str('DB>> Delete slide ID=' + SlideName);
    DelSlidesList.Delete(i);
  end;
  K_UnDeletedFileNames := nil;
end; // end of TK_CMEDAccess.EDAClearDeletedSlides

//***************************************** TK_CMEDAccess.EDAUnDeleteSlides ***
// Remove Deletion Mark from given slides
//
//     Parameters
// APSlides   - slides array start element to undelete
// APSlidesCount - slides to email counter
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAUnDeleteSlides( APSlides: TN_PUDCMSlide; ASlidesCount: Integer ): TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAUnDeleteSlides

//******************************** TK_CMEDAccess.EDARenameSlideNewMediaFile ***
// Rename new Media Slide TMP MediaFile to Permanent MediaFile Name
//
//     Parameters
// ASlide - given Slide
// APermFNamePref - File Server Name prefix (witout extension)
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDARenameSlideNewMediaFile(ASlide: TN_UDCMSlide;
  const APermFNamePref: string = ''): TK_CMEDResult;
var
  TMPFName, RealFName: string;
begin
  Result := K_edOK;
  with ASlide, P^ do
  begin
    TMPFName := GetMediaFileClientName();
    CMSDB.MediaFExt := ExtractFileExt(TMPFName);

    if APermFNamePref = '' then
      RealFName := GetMediaFileClientName()
    else
      RealFName := APermFNamePref + CMSDB.MediaFExt;

    // if not K_ForceDirPath( ExtractFilePath(RealFName) ) then begin
    if not K_ForceFilePath(RealFName) then
    begin
      ExtDataErrorString :=
        'Unable to create MediaFile Path "' + RealFName + '"';
      Result := K_edExDataError;
      Exit;
    end;

    if SameText( ExtractFileDrive(TMPFName), ExtractFileDrive(RealFName) ) then
    begin // move
      if not RenameFile(TMPFName, RealFName) then
      begin
        ExtDataErrorString :=
         'Unable to rename MediaFile "' + TMPFName + '" to "' + RealFName + '"';
        Result := K_edExDataError;
        Exit;
      end;
    end
    else //copy + delete
    begin
      if 0 <> K_CopyFile( TMPFName, RealFName ) then
      begin
        ExtDataErrorString :=
          'Unable to copy MediaFile "' + TMPFName + '" to "' + RealFName + '"';
        Result := K_edExDataError;
        Exit;
      end;
      if not K_DeleteFile(  TMPFName ) then
        N_Dump2Str('EDARenameSlideNewMediaFile >> !!! Unable to delete Media File >>' + TMPFName  );
    end;

    N_Dump1Str('New Media File  is saved to "' + RealFName + '"');
  end;
end; // end of TK_CMEDAccess.EDARenameSlideNewMediaFile

//********************************* TK_CMEDAccess.EDAStoreSlideNewMediaData ***
// Rename new Media Slide TMP MediaFile to Permanent MediaFile Name
//
//     Parameters
// ASlide - given Slide
// APermFName - Server permanent file name
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAStoreSlideNewMediaData(ASlide: TN_UDCMSlide) : TK_CMEDResult;
begin
  Result := EDARenameSlideNewMediaFile(ASlide);
end; // end of TK_CMEDAccess.EDAStoreSlideNewMediaData

//******************************************** TK_CMEDAccess.EDASetCurSlide ***
// Set given Slide as current
//
//     Parameters
// ASlide - given Slide
// AUpdateMode - if =TRUE then SLides DataSet will be prepared for Load Slide Data
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASetCurSlide( ASlide: TN_UDCMSlide;
                                     AUpdateMode: Boolean = false ): TK_CMEDResult;
begin
  CurSlide := ASlide;
  Result := K_edOK;
  with CurSlide, P^ do
  begin
    if (cmsfIsNew in CMSRFlags) and (cmsfIsMediaObj in CMSDB.SFlags) then
      Result := EDAStoreSlideNewMediaData(CurSlide);
    if Result <> K_edOK then
      Exit;
    Exclude(CMSRFlags, cmsfIsNew);
    if RefCounter > 0 then
      Exit;
    Result := K_edExDataError;
    if ArchSlidesRoot = nil then
      Exit;
    // Add to Archive
    Result := K_edOK;
    // ArchSlidesRoot.BuildUniqChildName( '', CurSlide );
    ArchSlidesRoot.AddOneChildV(CurSlide);
    N_Dump2Str('DB>> Add new slide ID=' + ObjName);
    K_SetChangeSubTreeFlags(ArchSlidesRoot);
  end;
end; // end of TK_CMEDAccess.EDASetCurSlide

//**************************************** TK_CMEDAccess.EDASaveSlideFields ***
// Save given Slide fields
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASaveSlideFields(): TK_CMEDResult;
begin
  if TN_UDCMBSlide(CurSlide) is TN_UDCMSlide then
    with CurSlide, P()^ do
      if CMSDB.PixWidth = 0 then
        SetAttrsByCurImgParams( FALSE );
  K_SetChangeSubTreeFlags(CurSlide);
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDASaveSlideFields

//************************************* TK_CMEDAccess.EDASaveSlideThumbnail ***
// Save given Slide Thumbnail
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASaveSlideThumbnail(): TK_CMEDResult;
var
  UD: TN_UDBase;
begin
  UD := CurSlide.GetThumbnail();
  K_SetChangeSubTreeFlags(UD);
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDASaveSlideThumbnail

//*************************************** TK_CMEDAccess.EDASaveSlideContent ***
// Save given Slide Graphic
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASaveSlideCurImage(): TK_CMEDResult;
var
  UD: TN_UDBase;
begin
  UD := CurSlide.DirChild(K_CMSlideIndCurImg);

  if UD = nil then
    raise Exception.Create('Slide ID=' + CurSlide.ObjName +
        ' has no Current Image!');
  // Assert( UD <> nil, 'Slide ID=' + CurSLide.ObjName + ' has no Current Image!' );

  // if not (UD is TN_UDFile) and
  // ((UD.ObjFlags and K_fpObjSLSRFlag) = 0) then
  if (UD is TN_UDDIB) then
    // Insert Section Node
    UD := EDAAddCurSlideSection(K_CMSlideIndCurImg)
  else
    with TN_UDDIB(UD.DirChild(0)).PISP^ do
      // Correct DIBDataFormat for "old" Slides
      if CDIBDataFormat = uddfNotDef then
      begin
        CDIBDataFormat := SlidesDIBFormat;
        if CDIBFlagsN = [] then
          CDIBFlagsN := [uddfnUseUDData,uddfnFreeUDData];
      end;

  K_SetChangeSubTreeFlags(UD, [K_cstfSetSLSRChangeFlag]);
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDASaveSlideCurImage

//************************************** TK_CMEDAccess.EDASaveSlideSrcImage ***
// Save given Slide Original Image
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASaveSlideSrcImage(): TK_CMEDResult;
var
  UD: TN_UDBase;
begin
  UD := CurSlide.DirChild(K_CMSlideIndSrcImg);
  Result := K_edOK;
  if UD = nil then
    Exit;

  // ??  if ((UD.ObjFlags and K_fpObjSLSRFlag) = 0) then
  // if not (UD is TN_UDFile) and
  // ((UD.ObjFlags and K_fpObjSLSRFlag) = 0) then
  if (UD is TN_UDDIB) then
    // Insert Section Node
    UD := EDAAddCurSlideSection(K_CMSlideIndSrcImg)
  else
    with TN_UDDIB(UD.DirChild(0)).PISP^ do
      // Correct DIBDataFormat for "old" Slides
      if CDIBDataFormat = uddfNotDef then
      begin
        CDIBDataFormat := SlidesDIBFormat;
        if CDIBFlagsN = [] then
          CDIBFlagsN := [uddfnUseUDData,uddfnFreeUDData];
      end;

  K_SetChangeSubTreeFlags(UD, [K_cstfSetSLSRChangeFlag]);
end; // end of TK_CMEDAccess.EDASaveSlideSrcImage

//********************************************** TK_CMEDAccess.EDASaveSlide ***
// Save given Slide
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASaveSlide( ASlide: TN_UDCMSlide ): TK_CMEDResult;
begin
  Result := K_edOK;
  CurSlide := nil;
  // PCMSlide := ASlide.P();
  with ASlide.P()^ do
  begin
    ASlide.CMSUndoBuf.UBSlidePrepForSaving();
    if (cmsfHasSrcImg in CMSDB.SFlags) and (cmsfSaveSrcImg in CMSDB.SFlags) then
    begin
      Result := EDASetCurSlide(ASlide);
      if Result <> K_edOK then
        Exit;
      Result := EDASaveSlideSrcImage();
      if Result <> K_edOK then
        Exit;
      Exclude(CMSDB.SFlags, cmsfSaveSrcImg);
      Include(CMSRFlags, cmsfAttribsChanged);
    end;

    if cmsfAttribsChanged in CMSRFlags then
    begin
      if CurSlide = nil then
      begin
        Result := EDASetCurSlide(ASlide);
        if Result <> K_edOK then
          Exit;
      end;
      Result := EDASaveSlideFields();
      if Result <> K_edOK then
        Exit;
      Exclude(CMSRFlags, cmsfAttribsChanged);
    end;

    if (cmsfThumbChanged in CMSRFlags) or (cmsfCurImgChanged in CMSRFlags) or
      (cmsfMapRootChanged in CMSRFlags) then
    begin
      if CurSlide = nil then
      begin
        Result := EDASetCurSlide(ASlide);
        if Result <> K_edOK then
          Exit;
      end;
      Result := EDASaveSlideThumbnail();
      if Result <> K_edOK then
        Exit;
      CMSRFlags := CMSRFlags - [cmsfThumbChanged, cmsfMapRootChanged];
    end;

    if (cmsfCurImgChanged in CMSRFlags) then
    begin
      Result := EDASaveSlideCurImage();
      if Result <> K_edOK then
        Exit;
      Exclude(CMSRFlags, cmsfCurImgChanged);
    end;

  end;
  if CurSlide = nil then
    Exit;
  K_SetArchiveChangeFlag();
end; // end of TK_CMEDAccess.EDASaveSlide

//********************************************* TK_CMEDAccess.EDAGetSlideFields ***
// Save given Slide fields
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetSlideFields(ASlide: TN_UDCMSlide; AGetStudyLinkInfo : Boolean = FALSE; ADataSet : TObject = nil ): TK_CMEDResult;
begin
  Result := K_edOK;
  EDAInitSlideViewAttrs(ASlide);
end; // end of TK_CMEDAccess.EDAGetSlideFields

//********************************************* TK_CMEDAccess.EDAGetSlideMapRoot ***
// Get given Slide Map Root
//
//     Parameters
// ASlide - given Slide
// ASkipLoadFlag - if =TRUE then slide Map Root shoud not be loaded
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetSlideMapRoot( ASlide: TN_UDCMSlide;
  ASkipLoadFlag: Boolean = false; ASkipCurImgLoad: Boolean = false )
  : TK_CMEDResult;
var
  UDDataRoot: TN_UDBase;
begin
  Result := K_edOK;
  UDDataRoot := ASlide.DirChild(K_CMSlideIndMapRoot);
  Assert((UDDataRoot <> nil) or
         (cmsfIsMediaObj in ASlide.P()^.CMSDB.SFlags), ASlide.ObjName + ' has no Map Root!');
end; // end of TK_CMEDAccess.EDAGetSlideMapRoot

//********************************************* TK_CMEDAccess.EDAGetSlideCurImage ***
// Get given Slide Graphic
//
//     Parameters
// ASlide - given Slide
// ASkipLoadFlag - if =TRUE then slide content shoud not be loaded
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetSlideCurImage(ASlide: TN_UDCMSlide;
  ASkipLoadFlag: Boolean = false): TK_CMEDResult;
var
  UDDataRoot: TN_UDBase;
begin
  Result := K_edOK;
  UDDataRoot := ASlide.DirChild(K_CMSlideIndCurImg);
  // Assert( UDDataRoot <> nil, ASlide.ObjName + ' has no Current Image!' );
  if UDDataRoot = nil then
    Result := K_edAbsentData
  else
  begin
    if ((UDDataRoot.ObjFlags and K_fpObjSLSRFlag) = 0) or
      (UDDataRoot.DirLength > 0) then
      Exit;
    // Slide Stored in Local Archive and CurImg Section is not in memory - Load Section
    if not ASkipLoadFlag then
    begin
      N_Dump2Str('Get Slide Current Image ID=' + ASlide.ObjName);
      if not ASlide.CMSSkipMemFree4CurImage then
        K_CMSCheckMemConstraints(ASlide);
//      K_LoadCurArchiveSection(UDDataRoot);
      EDASlideDIBFromFile(UDDataRoot);
      ASlide.CMSSkipMemFree4CurImage := FALSE;
    end;
    if UDDataRoot.DirLength = 0 then // Section loading errors
      Result := K_edExDataError;
  end;
end; // end of TK_CMEDAccess.EDAGetSlideCurImage

//********************************************* TK_CMEDAccess.EDAGetSlideSrcImage ***
// Get given Slide Original Image
//
//     Parameters
// ASlide - given Slide
// ASkipLoadFlag - if =TRUE then slide source image shoud not be loaded
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetSlideSrcImage(ASlide: TN_UDCMSlide;
  ASkipLoadFlag: Boolean = false): TK_CMEDResult;
var
  UDDataRoot: TN_UDBase;
begin
  Result := K_edOK;
  UDDataRoot := ASlide.DirChild(K_CMSlideIndSrcImg);
  if UDDataRoot = nil then
    Result := K_edAbsentData
  else
  begin
    if (UDDataRoot.ObjFlags and K_fpObjSLSRFlag) = 0 then
      Exit;
    if (UDDataRoot.DirLength() = 0) and not ASkipLoadFlag then
    begin // Load Section
      N_Dump2Str('Get Slide Original Image ID=' + ASlide.ObjName);
      K_CMSCheckMemConstraints(ASlide);
//      K_LoadCurArchiveSection(UDDataRoot);
      EDASlideDIBFromFile(UDDataRoot);
    end;
    if UDDataRoot.DirLength = 0 then // Section loading errors
      Result := K_edExDataError;
  end;
end; // end of TK_CMEDAccess.EDAGetSlideSrcImage

//********************************************* TK_CMEDAccess.EDAGetPatSlidesDates ***
// Get ordered array of distinct taken dates for all slides of current patient
//
//     Parameters
// ADatesArray - resulting array of ordered current patient slides taken distinct dates
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetPatSlidesDates( ASkipTime : Boolean ): TN_DArray;
var
  i, j : Integer;
  PrevVal : Double;
begin
  SetLength( Result, CurSlidesList.Count );
  if CurSlidesList.Count = 0 then Exit;
// Get Real Slides Dates
  for i := 0 to High(Result) do
  begin
    Result[i] := TN_UDCMSlide(CurSlidesList[i]).P().CMSDTTaken;
    if ASkipTime then Result[i] := Floor( Result[i] );
  end;

// Sort Slides Dates
  N_CFuncs.DescOrder := FALSE;
  N_SortArrayOfElems( @Result[0], CurSlidesList.Count, SizeOf(Double),
                      N_CFuncs.CompOneDouble );

// Remove Equal Dates
  PrevVal := 0;
  j := 0;
  for i := 0 to High(Result) do
  begin
    if PrevVal = Result[i] then Continue;
    PrevVal := Result[i];
    Result[j] := PrevVal;
    Inc(j);
  end;
  SetLength( Result, j );

end; // end of TK_CMEDAccess.EDAGetPatSlidesDates

//******************************* TK_CMEDAccess.EDASetSlideMediaFileTMPName ***
// Set given slide Media File Temporary name using file name extension
//
//     Parameters
// ASlide - given Slide
// AMediaFExt - file name extension
//
procedure TK_CMEDAccess.EDASetSlideMediaFileTMPName( ASlide: TN_UDCMSlide;
                                                     const AMediaFExt: string );
var
//  FileInd: Integer;
  TMPPath: string;
//  FilesStoringModes: Integer;
  PCMSlide : TN_PCMSlide;
  LocFName : string;
begin
  PCMSlide := ASlide.P();
  with PCMSlide^ do
  begin
    if AMediaFExt <> '' then
      CMSDB.MediaFExt := AMediaFExt;

    TMPPath := SlidesClientMediaRootFolder + ASlide.GetFilesPathSegm();

    K_ForceDirPath( TMPPath );
//    FileInd := 0;
//    CMSDB.MediaFExt := N_CreateUniqueFileName( TMPPath + 'MF_' + ASlide.ObjName + '_',
//                                               FileInd, CMSDB.MediaFExt );
    LocFName := IntToStr(CurSlidesList.Count) + 'new';

    CMSDB.MediaFExt := TMPPath + 'MF_' + LocFName + CMSDB.MediaFExt;
    N_Dump1Str('TMP Media File name "' + CMSDB.MediaFExt + '"');
  end; // with Result.P()^ do
end; // procedure TK_CMEDAccess.EDASetSlideMediaFileTMPName

//********************************* TK_CMEDAccess.EDAGetMediaFileClientName ***
// Get given slide Media File Client Name
//
//     Parameters
// ASlide - given Slide
//
function TK_CMEDAccess.EDAGetMediaFileClientName( ASlide: TN_UDCMSlide ) : string;
var
  UDMedia: TN_UDCompBase;
begin
  Result := '';
  with ASlide.P()^ do
    if CMSDB.MediaFExt <> '' then
    begin
      if CMSDB.MediaFExt[1] <> '.' then
        // Return TMP MediaFName (before Slide is stored to DB)
        Result := CMSDB.MediaFExt
      else
        // Return MediaFName already stored in DB File
        Result := ASlide.GetMediaFileName( K_CMEDAccess.SlidesClientMediaRootFolder +
                                           ASlide.GetFilesPathSegm() );
    end
    else
    begin
      // Old Slide Structure with TN_UDFile as file name Container
      // UDMedia := ANSlide.GetMediaObj();
      UDMedia := ASlide.GetMapRoot();
      if (UDMedia = nil) or not(UDMedia is TN_UDFile) then
        Exit; // precaution
      Result := TN_UDFile(UDMedia).GetFullFileName;
    end;
end; // procedure TK_CMEDAccess.EDAGetMediaFileClientName

//***************************** TK_CMEDAccess.EDASetPatientSlidesUpdateFlag ***
// Set Patient Slides Update Flag
//
procedure TK_CMEDAccess.EDASetPatientSlidesUpdateFlag();
begin
end; // procedure TK_CMEDAccess.EDASetPatientSlidesUpdateFlag

//******************************* TK_CMEDAccess.EDAGetPatientSlidesUpdateTS ***
// Set Patient Slides Update Flag
//
procedure TK_CMEDAccess.EDAGetPatientSlidesUpdateTS();
begin
end; // procedure TK_CMEDAccess.EDAGetPatientSlidesUpdateTS

//************************************** TK_CMEDAccess.EDAGetSlideThumbnail ***
// Get given Slide Thumbnail
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetSlideThumbnail(ASlide: TN_UDCMBSlide) : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAGetSlideThumbnail

//**************************************** TK_CMEDAccess.EDAStudyGetMapRoot ***
// Get given Study Map Root
//
//     Parameters
// AStudy - given Study
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAStudyGetMapRoot(AStudy: TN_UDCMStudy) : TK_CMEDResult;
begin
  Result := EDAGetSlideMapRoot( TN_UDCMSlide(AStudy) );
end; // end of TK_CMEDAccess.EDAStudyGetMapRoot

//********************************************* TK_CMEDAccess.EDAStudySetCur ***
// Set given Study as current
//
//     Parameters
// AStudy - given Study
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAStudySetCur( AStudy: TN_UDCMStudy ) : TK_CMEDResult;
begin
  Result := EDASetCurSlide( TN_UDCMSlide(AStudy) );
end; // end of TK_CMEDAccess.EDAStudySetCur

//********************************************* TK_CMEDAccess.EDAStudySavingStart ***
// Start Study Saving Transaction
//
function TK_CMEDAccess.EDAStudySavingStart() : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAStudySavingStart

//********************************************* TK_CMEDAccess.EDAStudySavingFinish ***
// Finish Study Saving Transaction
//
function TK_CMEDAccess.EDAStudySavingFinish() : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAStudySavingFinish

//********************************************* TK_CMEDAccess.EDAStudySaveFields ***
// Save given Study Fields
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAStudySaveFields(): TK_CMEDResult;
begin
  Result := EDASaveSlideFields();
end; // end of TK_CMEDAccess.EDAStudySaveFields

//********************************************* TK_CMEDAccess.EDAStudySave ***
// Save given Study
//
//     Parameters
// ASlide - given Study
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAStudySave(AStudy: TN_UDCMStudy): TK_CMEDResult;
begin
  Result := K_edOK;
  CurSlide := nil;
  // PCMSlide := ASlide.P();
  with AStudy.P()^ do
  begin
    if cmsfAttribsChanged in CMSRFlags then
    begin
      if CurSlide = nil then
      begin
        Result := EDAStudySetCur( AStudy );
        if Result <> K_edOK then
          Exit;
      end;
      Result := EDAStudySaveFields();
      if Result <> K_edOK then
        Exit;
      Exclude(CMSRFlags, cmsfAttribsChanged);
      Exclude(CMSRFlags, cmsfCurImgChanged);
    end;

    if (cmsfThumbChanged in CMSRFlags) or
       (cmsfMapRootChanged in CMSRFlags) then
    begin
      if CurSlide = nil then
      begin
        Result := EDAStudySetCur( AStudy );
        if Result <> K_edOK then
          Exit;
      end;
      Result := EDASaveSlideThumbnail();
      if Result <> K_edOK then
        Exit;
      CMSRFlags := CMSRFlags - [cmsfThumbChanged, cmsfMapRootChanged];
    end;

    Exclude(CMSRFlags, cmsfIsNew);
  end;

  if CurSlide = nil then
    Exit;
  N_SetSubTreeWasChanged(CurSlide);
  K_SetArchiveChangeFlag();
end; // end of TK_CMEDAccess.EDAStudySave

//*********************************** TK_CMEDAccess.EDAStudyCaptStartPosGet ***
// Get Study direct capture start position
//
//     Parameters
// ASlide - given Study
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAStudyCaptStartPosGet( AStudy: TN_UDCMStudy ): TK_CMEDResult;
var
  Ind : Integer;
begin
  Result := K_edOK;
  if AStudy.CMSStudyCaptStartPos > 0 then Exit;

  if AStudy.ObjInfo <> '' then
  begin // Clear Previouse Value
    Ind := Pos( '#', AStudy.ObjInfo );
    if Ind > 1 then
      AStudy.CMSStudyCaptStartPos := StrToIntDef( Copy( AStudy.ObjInfo, 1, Ind - 1 ), 0 );
  end;
end; // function TK_CMEDAccess.EDAStudyCaptStartPosGet

//**************************** TK_CMEDAccess.EDAStudyCaptStartPosSavingPrep ***
// Study direct capture start position saving prepare
//
//     Parameters
// ASlide - given Study
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAStudyCaptStartPosSavingPrep( AStudy: TN_UDCMStudy ): TK_CMEDResult;
var
  Ind : Integer;
begin
  Result := K_edOK;

  if AStudy.ObjInfo <> '' then
  begin // Clear Previouse Value
    Ind := Pos( '#', AStudy.ObjInfo ) + 1;
    if Ind > 1 then
      AStudy.ObjInfo := Copy( AStudy.ObjInfo, Ind, Length(AStudy.ObjInfo) );
  end;

  // Set new if needed
  if AStudy.CMSStudyCaptStartPos > 0 then
    AStudy.ObjInfo := IntToStr( AStudy.CMSStudyCaptStartPos ) + '#' + AStudy.ObjInfo;
end; // function TK_CMEDAccess.EDAStudyCaptStartPosSavingPrep

//********************************************* TK_CMEDAccess.EDAStudyDismountOneSlideFromItem ***
// Mount given not mount Slide to given Empty Study Item
//
//     Parameters
// AItem  - Empty Study Item to mount Slide
// ASlide - Slide to mount
// AStudy - Study to Mount Slide
// ARuntimeInfoOnly
// Result - Returns operation Resulting Code
//
function TK_CMEDAccess.EDAStudyDismountOneSlideFromItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide = nil; AStudy: TN_UDCMStudy = nil; ARuntimeInfoOnly : Boolean = FALSE ) : TK_CMEDResult;
var
  ItemThumbParent : TN_UDBase;
  Sample : TN_UDBase;
  SampleItem : TN_UDBase;
  PUP: TN_POneUserParam;
  ItemThumbRootNum : Integer;
  SampleItemThumbRootNum : Integer;
begin
  Result := K_edOK;
  if AItem = nil then Exit;
  if ASlide = nil then ASlide := K_CMStudyGetOneSlideByItem(AItem);
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);

  N_DumpStr( K_CMStudyDetailsDumpCInd, format(
              'Study >> Dismount Start Slide=%s from Study=%s Item=%s  RuntimeInfo=%s',
              [ASlide.ObjName,AStudy.ObjName,AItem.ObjName,N_B2Str(ARuntimeInfoOnly)] ) );

  // Clear Item Used Flag
  PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'NotEmptyItem');
  PByte(PUP.UPValue.P)^ := 0;

  AStudy.UnSelectItem( AItem );

  // Return Empty Item Attributes from Sample
  Sample := AStudy.DirChild(K_CMStudyIndSrcSample);
  SampleItem := Sample.DirChild(K_CMSlideIndMapRoot).DirChildByObjName(AItem.ObjName);
  SampleItemThumbRootNum := SampleItem.IndexOfChildObjName( 'ImagePanel' );
  ItemThumbRootNum := AItem.IndexOfChildObjName( 'ImagePanel' );

 // Return Sample Item Footer
  with TN_UDParaBox(AItem.DirChild(ItemThumbRootNum + 1)).PISP()^ do
    TN_POneTextBlock(CPBTextBlocks.P).OTBMText :=
        TN_POneTextBlock(TN_UDParaBox(SampleItem.DirChild(SampleItemThumbRootNum + 1)).PISP().CPBTextBlocks.P).OTBMText;

  // Return Sample Stub Image instead of Slide Tumbnaile
  ItemThumbParent := AItem.DirChild(ItemThumbRootNum).DirChild(0);
  ItemThumbParent.PutDirChild( 0, SampleItem.DirChild(SampleItemThumbRootNum).DirChild(0).DirChild(0) );


  // Remove Slide Link to Study Item
  ASlide.PutDirChildSafe( K_CMSlideIndStudyItem, nil );

  if ARuntimeInfoOnly then Exit;

  // Clear Slide Study Mount Runtime Fields
  ASlide.CMSStudyID := 0;
  ASlide.CMSStudyItemID := 0;

end; // function TK_CMEDAccess.EDAStudyDismountOneSlideFromItem

//********************************************* TK_CMEDAccess.EDAStudyMountOneSlideToEmptyItem ***
// Mount given not mount Slide to given Empty Study Item
//
//     Parameters
// AStudy - Study to Mount Slide
// AItem  - Empty Study Item to mount Slide
// ASlide - Slide to mount
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// Result - Returns operation Resulting Code
//
function TK_CMEDAccess.EDAStudyMountOneSlideToEmptyItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE  ) : TK_CMEDResult;
var
  ItemThumbParent : TN_UDBase;
  PUP: TN_POneUserParam;
  ItemThumbRootNum : Integer;
begin
  Result := K_edOK;
  if AItem = nil then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);
  N_DumpStr( K_CMStudyDetailsDumpCInd, format( 'Study >> Mount start Slide=%s to Study=%s Item=%s  RuntimeInfo=%s',
              [ASlide.ObjName,AStudy.ObjName,AItem.ObjName,N_B2Str(ARuntimeLinksOnly)] ) );

  // Set Item Used Flag
  PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'NotEmptyItem');
  PByte(PUP.UPValue.P)^ := 1;

  ItemThumbRootNum := AItem.IndexOfChildObjName( 'ImagePanel' );

  // Set Item Footer
  with TN_UDParaBox(AItem.DirChild(ItemThumbRootNum + 1)).PISP()^ do
    TN_POneTextBlock(CPBTextBlocks.P).OTBMText := K_DateTimeToStr( ASlide.P.CMSDTTaken, 'dd"/"mm"/"yy' );

  ItemThumbParent := AItem.DirChild(ItemThumbRootNum).DirChild(0);
  // Put Slide Tumbnail instead of Sample Stub Image
  ItemThumbParent.PutDirChild(0, ASlide.DirChild(K_CMSlideIndThumbnail) );

  // Set Slide Link to Study Item
  ASlide.PutDirChildSafe( K_CMSlideIndStudyItem, AItem );

  if ARuntimeLinksOnly then Exit;

  // Set Slide Study Mount Runtime Fields
  ASlide.CMSStudyID := StrToInt(AStudy.ObjName);
  ASlide.CMSStudyItemID := StrToInt(AItem.ObjName);
  ASlide.CMSStudyItemPos := 0;
end; // function TK_CMEDAccess.EDAStudyMountOneSlideToEmptyItem

{
//***************************** TK_CMEDAccess.EDAStudyRemountOneSlideToItem ***
// Remount given Slide to given Study Item Context
//
//     Parameters
// ARSlide - Slide to remount
// ARItem  - Study Item to remount
// APRContext - pointer to Remount Context structure
// Result - Returns Remount Update Flags
//
function TK_CMEDAccess.EDAStudyRemountOneSlideToItem( ARItem: TN_UDBase; ARSlide : TN_UDCMSlide;
                                        APRContext : TK_PCMStudyRemountOneSlideContext;
                                        var ARUpdateFlags : TK_CMStudyRemountUpdateFlags ) : TK_CMEDResult;
begin
  Result := K_edOK;

  ARUpdateFlags := K_CMStudyGetRemountContext( ARSlide, ARItem, APRContext );

  if ARUpdateFlags = [] then Exit; // Same Slide or Dismount Empty Item

  with APRContext^ do
  begin

    EDAStudySavingStart();

    if CMRItemSlide <> nil then // Dismount Previouse Slide from given Study Item
       Result := K_CMEDAccess.EDAStudyDismountOneSlideFromItem( CMRItem,
                             CMRItemSlide, CMRItemStudy, FALSE );
    if CMRSlideItem <> nil then // Dismount Slide from Prevouse Study
    begin
      Result := K_CMEDAccess.EDAStudyDismountOneSlideFromItem( CMRSlideItem,
                             CMRSlide, CMRSlideStudy, FALSE  );
    // Rebuild Study Thumbnail and Save
      if K_srufRedrawSlideStudy in ARUpdateFlags then
      begin
        CMRSlideStudy.CreateThumbnail();
        CMRSlideStudy.SetChangeState();
        EDAStudySave( CMRSlideStudy );
      end;
    end;

    if CMRSlide <> nil then
    // Mount given Slide to given Study Item
      Result := EDAStudyMountOneSlideToEmptyItem( CMRItem, CMRSlide, CMRItemStudy );

    if K_srufRedrawItemStudy in ARUpdateFlags then
    begin
    // Rebuild Study Thumbnail and Save
      CMRItemStudy.CreateThumbnail();
      CMRItemStudy.SetChangeState();
      EDAStudySave( CMRItemStudy );
    end;

    EDAStudySavingFinish();

  end;
end; // function TK_CMEDAccess.EDAStudyRemountOneSlideToItem
}

//************************** TK_CMEDAccess.EDAStudyDismountAllSlidesFromItem ***
// Mount given not mount Slide to given Empty Study Item
//
//     Parameters
// AItem  - Empty Study Item to mount Slide
// ASlide - Slide to mount
// AStudy - Study to Mount Slide
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// ASelfItemFRFlags - Self Item FlipRotate Flags
// AMountItemFRFlags - Future Mount Item FlipRotate Flags
// Result - Returns operation Resulting Code
//
function TK_CMEDAccess.EDAStudyDismountAllSlidesFromItem( AItem: TN_UDBase; out ASlides : TN_UDCMSArray;
                   AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                   ASelfItemFRFlags : Integer = 0; ASelfItemTeethFlags : Int64 = 0;
                   AMountItemFRFlags : Integer = 0; AMountItemTeethFlags : Int64 = 0 ) : TK_CMEDResult;
var
  ItemThumbParent : TN_UDBase;
  Sample : TN_UDBase;
  SampleItem : TN_UDBase;
  i, Ind : Integer;
  LinkedSlidesRoot : TN_UDBase;
  PUP: TN_POneUserParam;
//  ItemRotateFlags : Integer;
  PSlideFlipRotate : PInteger;
  ItemThumbRootNum : Integer;
  SampleItemThumbRootNum : Integer;
  DismountObjs : string;
  SlideFRFags : Integer;
  SlideTeethFlags : Int64;
  SlideRebuildThumb : Boolean;
  PSlide : TN_PCMSlide;
begin
  Result := K_edOK;
  ASlides := nil;
  if AItem = nil then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);

  N_DumpStr( K_CMStudyDetailsDumpCInd, format(
              'Study >> Dismount AllSlides start from Study=%s Item=%s RuntimeInfo=%s Self(FRFlags=%d TFlags=$%x) Mount(FRFlags=%d TFlags=$%x) ',
              [AStudy.ObjName,AItem.ObjName,N_B2S(ARuntimeLinksOnly),
               ASelfItemFRFlags,ASelfItemTeethFlags,AMountItemFRFlags,AMountItemTeethFlags] ) );

  // Clear Item Used Flag
  PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'NotEmptyItem');
  PByte(PUP.UPValue.P)^ := 0;

  // Set Skip Multi Image Additional Frame Flag
  PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'ShowMImageFrame');
  if PUP <> nil then
    PByte(PUP.UPValue.P)^ := 1;

  AStudy.UnSelectItem( AItem );

  // Prepare to Return Empty Item Attributes from Sample
  Sample := AStudy.DirChild(K_CMStudyIndSrcSample);
  SampleItem := Sample.DirChild(K_CMSlideIndMapRoot).DirChildByObjName(AItem.ObjName);
  SampleItemThumbRootNum := SampleItem.IndexOfChildObjName( 'ImagePanel' );
  ItemThumbRootNum := AItem.IndexOfChildObjName( 'ImagePanel' );

 // Return Sample Item Footer
  with TN_UDParaBox(AItem.DirChild(ItemThumbRootNum + 1)).PISP()^ do
    TN_POneTextBlock(CPBTextBlocks.P).OTBMText :=
        TN_POneTextBlock(TN_UDParaBox(SampleItem.DirChild(SampleItemThumbRootNum + 1)).PISP().CPBTextBlocks.P).OTBMText;

  Ind := 0;
  LinkedSlidesRoot := K_CMStudyGetAllSlidesByItem( AItem, ASlides, Ind );

  N_DumpStr( K_CMStudyDetailsDumpCInd, format( 'Study >> Dismount Count=%d',
                                               [Length(ASlides)] ) );

  // Clear Study Item Invisible Slides links - clear Root Childs where links to Slides are saved
  if LinkedSlidesRoot <> nil then
    LinkedSlidesRoot.ClearChilds();

  // Return Sample Stub Image instead of Slide Tumbnaile
  ItemThumbParent := AItem.DirChild(ItemThumbRootNum).DirChild(0);
  ItemThumbParent.PutDirChild( 0, SampleItem.DirChild(SampleItemThumbRootNum).DirChild(0).DirChild(0) );

  // Remove Slides Link to Study Item
  for i := 0 to High(ASlides) do
  begin
    ASlides[i].PutDirChildSafe( K_CMSlideIndStudyItem, nil );

    if ARuntimeLinksOnly then Continue;

  // Clear Slide Study Mount Runtime Fields
    ASlides[i].CMSStudyID := 0;
    ASlides[i].CMSStudyItemID := 0;
    ASlides[i].CMSStudyItemPos := 0;

    DismountObjs := DismountObjs + ASlides[i].ObjName + ' ';

    PSlide := ASlides[i].P();
    with PSlide^ do
    if ((CMSDB.SFlags * [cmsfIsMediaObj,cmsfIsImg3DObj]) = []) then
    begin
      SlideTeethFlags := CMSTeethFlags;
      if (ASelfItemTeethFlags <> 0) and (ASelfItemTeethFlags = CMSTeethFlags) then
      begin // Clear Slide Teeth Flags if needed
        CMSDTPropMod  := EDAGetSyncTimestamp();
        CMSRFlags := CMSRFlags + [cmsfAttribsChanged];
        CMSTeethFlags := 0;
      end; // if (AItemTeethFlags <> 0) and (CMSTeethFlags = 0) then


      SlideFRFags := 0;
      SlideRebuildThumb := FALSE;
      if (ASelfItemFRFlags <> 0) then
      begin // Clear Slide FlipRotate Flags if needed
        PSlideFlipRotate := @(ASlides[i].GetPMapRootAttrs.MRFlipRotateAttrs);
        SlideFRFags := PSlideFlipRotate^;
        if PSlideFlipRotate^ = ASelfItemFRFlags then
        begin // Apply Item FlipRotate to Slide
          // Should be done before all - needed inside CreateThumbnail()
          CMSDTMapRootMod := EDAGetSyncTimestamp();
          CMSDTPropMod    := CMSDTMapRootMod;
          CMSRFlags := CMSRFlags + [cmsfMapRootChanged,cmsfAttribsChanged,cmsfThumbChanged];

          ASlides[i].ClearMapImage(); // Should be done before all !!!
          PSlideFlipRotate := @(ASlides[i].GetPMapRootAttrs.MRFlipRotateAttrs);

          PSlideFlipRotate^ := 0;
          if (ASelfItemFRFlags and 4) <> 0 then
            ASlides[i].SwitchMapRootSize();
          ASlides[i].AffConvVObjects( N_BackwardFlags[ASelfItemFRFlags], 1 ); // Vector Objects Convertion is needed even if Thumbnail is not created

          if (AMountItemFRFlags = 0) and not ASlides[i].CMSArchived then // Skip Thumbnail Creation because Slides will be mounted to another item
          begin
            ASlides[i].CreateThumbnail();
            SlideRebuildThumb := TRUE;
          end;
        end; // if PSlideFlipRotate^ = 0 then
      end; // if ASelfItemFRFlags <> 0 then

      N_DumpStr( K_CMStudyDetailsDumpCInd, format(
              'Study >> Dismount Slide ID=%s (FRFlags=%d TFlags=$%x) RebuildThumb=%s SaveFlags=$%x',
              [ASlides[i].ObjName,SlideFRFags,SlideTeethFlags,N_B2S(SlideRebuildThumb),Short(CMSRFlags)] ) );

    end; // if ((CMSDB.SFlags * [cmsfIsMediaObj,cmsfIsImg3DObj]) = []) then
  end; // for i := 0 to High(ASlides) do
  N_DumpStr( K_CMStudyDetailsDumpCInd, format(
              'Study >> Dismount AllSlides fin SlidesCount=%d IDs >> %s',
              [Length(ASlides), DismountObjs] ) );
end; // function TK_CMEDAccess.EDAStudyDismountAllSlidesFromItem

//************************* TK_CMEDAccess.EDAStudyMountAllSlidesToEmptyItem ***
// Mount given not mount Slide to given Empty Study Item
//
//     Parameters
// AItem  - Empty Study Item to mount Slide
// ASlides - Slides to mount array
// AStudy - Study to Mount Slide
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// ASelfItemFRFlags - Self Item FlipRotate Flags
// Result - Returns operation Resulting Code
//
function TK_CMEDAccess.EDAStudyMountAllSlidesToEmptyItem( AItem: TN_UDBase; ASlides : TN_UDCMSArray; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                                          ASelfItemFRFlags : Integer = 0; ASelfItemTeethFlags : Int64 = 0 ) : TK_CMEDResult;
var
  InvisItemSlidesParent : TN_UDBase;
  ItemThumbParent : TN_UDBase;
  PUP: TN_POneUserParam;
  i : Integer;
  SlideItemPosCode : Integer;
//  ItemRotateFlags : Integer;
  PSlideFlipRotate : PInteger;
  ItemThumbRootNum : Integer;
  SlideFRFags : Integer;
  SlideTeethFlags : Int64;
  SlideRebuildThumb : Boolean;
  PSlide : TN_PCMSlide;
begin
  Result := K_edOK;
  if (AItem = nil) or (Length(ASlides) = 0) then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);
  N_DumpStr( K_CMStudyDetailsDumpCInd, format( 'Study >> Mount All start %d Slides to Study=%s Item=%s RuntimeInfo=%s Self(FRFlags=%d TFlags=$%x)',
              [Length(ASlides), AStudy.ObjName,AItem.ObjName,N_B2Str(ARuntimeLinksOnly),ASelfItemFRFlags,ASelfItemTeethFlags] ) );

  // Set Item Used Flag
  PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'NotEmptyItem');
  PByte(PUP.UPValue.P)^ := 1;

  // Show Multi Image Additional Frame Flag
  if Length(ASlides) > 1 then
  begin
    PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'ShowMImageFrame');
    if PUP <> nil then
      PByte(PUP.UPValue.P)^ := 0;
  end;

  ItemThumbRootNum := AItem.IndexOfChildObjName( 'ImagePanel' );

  // Set Item Footer
  with TN_UDParaBox(AItem.DirChild(ItemThumbRootNum + 1)).PISP()^ do
    TN_POneTextBlock(CPBTextBlocks.P).OTBMText := K_DateTimeToStr( ASlides[0].P.CMSDTTaken, 'dd"/"mm"/"yy' );

  // Prepare Study Item invisible Slides Root
  SlideItemPosCode := 0;
  if Length(ASlides) > 1 then
    SlideItemPosCode := K_CMStudyItemAddSlidesPrep( AItem, InvisItemSlidesParent ) - Length(ASlides);

  for i := 0 to High(ASlides) do
  begin
    // Set Slide Link to Study Item and Item Link
    ASlides[i].PutDirChildSafe( K_CMSlideIndStudyItem, AItem );

    if i > 0 then // Link invisible Slide to Study Item
      InvisItemSlidesParent.AddOneChild( ASlides[i].DirChild(K_CMSlideIndThumbnail) );

    if ARuntimeLinksOnly then Continue;

    // Set Slide Study Mount Runtime Fields
    ASlides[i].CMSStudyID := StrToInt(AStudy.ObjName);
    ASlides[i].CMSStudyItemID := StrToInt(AItem.ObjName);
    ASlides[i].CMSStudyItemPos := SlideItemPosCode;

    Inc(SlideItemPosCode);
    PSlide := ASlides[i].P();
    with PSlide^ do
    if ((CMSDB.SFlags * [cmsfIsMediaObj,cmsfIsImg3DObj]) = []) then
    begin
      SlideTeethFlags := CMSTeethFlags;
      if (ASelfItemTeethFlags <> 0) and (CMSTeethFlags = 0) then
      begin // Set Slide Teeth Flags if needed
        CMSDTPropMod  := EDAGetSyncTimestamp();
        CMSRFlags := CMSRFlags + [cmsfAttribsChanged];
        CMSTeethFlags := ASelfItemTeethFlags;
      end; // if (AItemTeethFlags <> 0) and (CMSTeethFlags = 0) then

      SlideFRFags := 0;
      SlideRebuildThumb := FALSE;
      if (ASelfItemFRFlags <> 0) then
      begin // Set Slide FlipRotate Flags if needed
        PSlideFlipRotate := @(ASlides[i].GetPMapRootAttrs.MRFlipRotateAttrs);
        SlideFRFags := PSlideFlipRotate^;
        if PSlideFlipRotate^ = 0 then
        begin // Apply Item FlipRotate to Slide
          // Should be done before all - needed inside CreateThumbnail()
          CMSDTMapRootMod := EDAGetSyncTimestamp();
          CMSDTPropMod    := CMSDTMapRootMod;
          CMSRFlags := CMSRFlags + [cmsfMapRootChanged,cmsfAttribsChanged,cmsfThumbChanged];

          ASlides[i].ClearMapImage(); // Should be done before all !!!
          PSlideFlipRotate := @(ASlides[i].GetPMapRootAttrs.MRFlipRotateAttrs);
          PSlideFlipRotate^ := ASelfItemFRFlags;
          if (ASelfItemFRFlags and 4) <> 0 then
            ASlides[i].SwitchMapRootSize();
          ASlides[i].AffConvVObjects( ASelfItemFRFlags, 1 );
          if not ASlides[i].CMSArchived then
          begin
            ASlides[i].CreateThumbnail();
            SlideRebuildThumb := TRUE;
          end;
        end; // if PSlideFlipRotate^ = 0 then
      end; // if ASelfItemFRFlags <> 0 then
      N_DumpStr( K_CMStudyDetailsDumpCInd, format(
            'Study >> Mount Slide ID=%s (FRFlags=%d TFlags=$%x) RebuildThumb=%s SaveFlags=$%x',
            [ASlides[i].ObjName,SlideFRFags,SlideTeethFlags,N_B2S(SlideRebuildThumb),Short(CMSRFlags)] ) );

    end; // if ((CMSDB.SFlags * [cmsfIsMediaObj,cmsfIsImg3DObj]) = []) then
  end; // for i := 0 to High(ASlides) do

  // Clear Pos Code for Study Item current visible Slide
  if not ARuntimeLinksOnly and (SlideItemPosCode <> 1) then
    ASlides[0].CMSStudyItemPos := 0;

  // Put Slide Tumbnail instead of Sample Stub Image for current visible Slide
  // move this code to the end of routine - because Thumbnail could be changed while Item FlipRotate
//  ItemThumbParent := AItem.DirChild(0).DirChild(0);
  ItemThumbParent := AItem.DirChild(ItemThumbRootNum).DirChild(0);
  ItemThumbParent.PutDirChild(0, ASlides[0].DirChild(K_CMSlideIndThumbnail) );

end; // function TK_CMEDAccess.EDAStudyMountAllSlidesToEmptyItem

//******************************* TK_CMEDAccess.EDAStudyMountAddSlideToItem ***
// Mount (add) given not mount Slide to given Study Item
//
//     Parameters
// AItem  - Study Item to mount Slide
// ASlide - Slide to add to Item
// AStudy - Study to Mount Slide
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// Result - Returns operation Resulting Code
//
function TK_CMEDAccess.EDAStudyMountAddSlideToItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                         ASelfItemFRFlags : Integer = -1; ASelfItemTeethFlags : Int64 = -1 ) : TK_CMEDResult;
var
  InvisItemSlidesParent : TN_UDBase;
  SlideItemPosCode : Integer;
  PrevCurSlide : TN_UDCMSlide;
  ItemRotateFlags : Integer;
  ItemTeethFlags : Int64;
  PSlideFlipRotate : PInteger;
  PUP: TN_POneUserParam;
  SlideFRFags : Integer;
  SlideTeethFlags : Int64;
  SlideRebuildThumb : Boolean;
  PSlide : TN_PCMSlide;

begin
  Result := K_edOK;
  if (AItem = nil) or (ASlide = nil) then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);
  N_DumpStr( K_CMStudyDetailsDumpCInd, format( 'Study >> Mount Add start Slide=%s to Study=%s Item=%s Pos=%d RuntimeInfo=%s SelfFRF=%d SelfTF=$%x',
              [ASlide.ObjName,AStudy.ObjName,AItem.ObjName,ASlide.CMSStudyItemPos,
               N_B2Str(ARuntimeLinksOnly),ASelfItemFRFlags,ASelfItemTeethFlags] ) );

  InvisItemSlidesParent := nil;
  if ASlide.CMSStudyItemPos = 0 then
  begin // Add Slide To Item
    PrevCurSlide := K_CMStudyGetOneSlideByItem(AItem);
    if PrevCurSlide = ASlide then
    begin
      N_DumpStr( K_CMStudyDetailsDumpCInd, 'Study >> Mount Add same visible Slide' );
      Exit;
    end;

    if PrevCurSlide <> nil then
    begin // Add current to invisible
    // Prepare Study Item invisible Slides Root
      SlideItemPosCode := K_CMStudyItemAddSlidesPrep( AItem, InvisItemSlidesParent );
      InvisItemSlidesParent.AddOneChild( PrevCurSlide.DirChild(K_CMSlideIndThumbnail) );
      PrevCurSlide.CMSStudyItemPos := SlideItemPosCode;
    end; // if PrevCurSlide <> nil then

    if not ARuntimeLinksOnly then
    begin
      // Define Item FlipRotate Flags
      ItemRotateFlags := ASelfItemFRFlags;
      if ItemRotateFlags = -1 then
        ItemRotateFlags := K_CMStudyItemFRFags( AItem );

      ItemTeethFlags := ASelfItemTeethFlags;
      if ItemTeethFlags = -1 then
        ItemTeethFlags := K_CMStudyItemTeethFags( AItem );

      PSlide := ASlide.P();
      with PSlide^ do
      if ((CMSDB.SFlags * [cmsfIsMediaObj,cmsfIsImg3DObj]) = []) then
      begin
        SlideTeethFlags := CMSTeethFlags;
        if (ItemTeethFlags <> 0) and (CMSTeethFlags = 0) then
        begin // Set Slide Teeth Flags if needed
          CMSDTPropMod  := EDAGetSyncTimestamp();
          CMSRFlags := CMSRFlags + [cmsfAttribsChanged];
          CMSTeethFlags := ItemTeethFlags;
        end; // if (ItemTeethFlags <> 0) and (CMSTeethFlags = 0) then

        SlideFRFags := 0;
        SlideRebuildThumb := FALSE;
        if ItemRotateFlags <> 0 then
        begin // Set Slide FlipRotate Flags if needed
          PSlideFlipRotate := @(ASlide.GetPMapRootAttrs.MRFlipRotateAttrs);
          SlideFRFags := PSlideFlipRotate^;
          if PSlideFlipRotate^ = 0 then
          begin // Apply Item FlipRotate to Slide
            // Should be done before all - needed inside CreateThumbnail()
            CMSDTMapRootMod := EDAGetSyncTimestamp();
            CMSDTPropMod    := CMSDTMapRootMod;
            CMSRFlags := CMSRFlags + [cmsfMapRootChanged,cmsfAttribsChanged,cmsfThumbChanged];

            ASlide.ClearMapImage(); // Should be done before all !!!
            PSlideFlipRotate := @(ASlide.GetPMapRootAttrs.MRFlipRotateAttrs);
            PSlideFlipRotate^ := ItemRotateFlags;
            if (ItemRotateFlags and 4) <> 0 then
              ASlide.SwitchMapRootSize();
            ASlide.AffConvVObjects( ItemRotateFlags, 1 );
            if not ASlide.CMSArchived then
            begin
              ASlide.CreateThumbnail();
              SlideRebuildThumb := TRUE;
            end;
          end; // if PSlideFlipRotate^ = 0 then
        end; // if ItemRotateFlags <> 0 then

        N_DumpStr( K_CMStudyDetailsDumpCInd, format(
            'Study >> Mount Add Slide ID=%s (FRFlags=%d TFlags=$%x) RebuildThumb=%s SaveFlags=$%x',
            [ASlide.ObjName,SlideFRFags,SlideTeethFlags,N_B2S(SlideRebuildThumb),Short(CMSRFlags)] ) );

      end; // if ((CMSDB.SFlags * [cmsfIsMediaObj,cmsfIsImg3DObj]) = []) then
    end; // if not ARuntimeLinksOnly then

    Result := EDAStudyMountOneSlideToEmptyItem( AItem, ASlide, AStudy, ARuntimeLinksOnly )
  end
  else
  begin // Restore Study Links while Set or Refresh CurSlidesSet
    K_CMStudyItemAddSlidesPrep( AItem, InvisItemSlidesParent );
    InvisItemSlidesParent.AddOneChild( ASlide.DirChild(K_CMSlideIndThumbnail) );
    ASlide.PutDirChildSafe( K_CMSlideIndStudyItem, AItem ); // 01.09.2018 - to prevent Arhived Add/Del Queue error
  end; // Restore Study Links while Set or Refresh CurSlidesSet

  // Show Multi Image Additional Frame Flag
  if InvisItemSlidesParent.DirLength() > 0 then
  begin
    PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'ShowMImageFrame');
    if PUP <> nil then
      PByte(PUP.UPValue.P)^ := 0;
  end; // if InvisItemSlidesParent.DirLength() > 0 then

end; // function TK_CMEDAccess.EDAStudyMountAddSlideToItem

//******************************* TK_CMEDAccess.EDAStudyRemoveSlideFromItem ***
// Remove Slide from given Study Item
//
//     Parameters
// AItem  - Study Item to mount Slide
// ASlide - Slide to add to Item
// AStudy - Study to Mount Slide
// Result - Returns operation Resulting Code
//
function TK_CMEDAccess.EDAStudyRemoveSlideFromItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil ) : TK_CMEDResult;
var
  InvisItemSlidesParent, PrevItemSlideThumb : TN_UDBase;
  PrevCurSlide : TN_UDCMSlide;
  PUP: TN_POneUserParam;

begin
  Result := K_edOK;
  if (AItem = nil) or (ASlide = nil) then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);
  N_DumpStr( K_CMStudyDetailsDumpCInd, format( 'Study >> Remove start Slide=%s to Study=%s Item=%s',
              [ASlide.ObjName,AStudy.ObjName,AItem.ObjName] ) );

  K_CMStudyItemAddSlidesPrep( AItem, InvisItemSlidesParent );
  PrevItemSlideThumb := InvisItemSlidesParent.DirChild(InvisItemSlidesParent.DirHigh);


  if PrevItemSlideThumb <> nil then
  begin
    // Set Skip Multi Image Additional Frame Flag
    if InvisItemSlidesParent.DirLength() = 1 then
    begin
      PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'ShowMImageFrame');
      if PUP <> nil then
        PByte(PUP.UPValue.P)^ := 1;
    end;

    // Remove Slide Link to Study
    ASlide.PutDirChildSafe( K_CMSlideIndStudyItem, nil );

    // Add previouse linked Slide Thumbnail as visible
    InvisItemSlidesParent.RemoveDirEntry(InvisItemSlidesParent.DirHigh);
//    AItem.DirChild(0).DirChild(0).PutDirChild( 0, PrevItemSlideThumb );
    with AItem do
      DirChild(IndexOfChildObjName( 'ImagePanel' )).DirChild(0).PutDirChild( 0, PrevItemSlideThumb );

    PrevCurSlide := TN_UDCMSlide(PrevItemSlideThumb.Owner);
    PrevCurSlide.CMSStudyItemPos := 0;
    N_DumpStr( K_CMStudyDetailsDumpCInd, format( 'Study >> Restore  CurVisSlide=%s',
                                                 [ASlide.ObjName] ) );
  end
  else
  begin
    EDAStudyDismountOneSlideFromItem( AItem, ASlide, AStudy, TRUE );
  end;
end; // function TK_CMEDAccess.EDAStudyRemoveSlideFromItem

//******************************** TK_CMEDAccess.EDAStudyReplaceSlideInItem ***
// Replace Slide in given Study Item
//
//     Parameters
// AItem  - Study Item to replace Slide
// ASlide - Slide to replace in Item
// AStudy - Study to replace Slide
// Result - Returns operation Resulting Code
//
function TK_CMEDAccess.EDAStudyReplaceSlideInItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil ) : TK_CMEDResult;
var
  ItemThumbParent : TN_UDBase;
  ItemRotateFlags : Integer;
  ItemTeethFlags : Int64;
  PSlideFlipRotate : PInteger;

begin
  Result := K_edOK;
  if (AItem = nil) or (ASlide = nil) then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);
  N_DumpStr( K_CMStudyDetailsDumpCInd, format( 'Study >> Replace start Slide=%s to Study=%s Item=%s',
              [ASlide.ObjName,AStudy.ObjName,AItem.ObjName] ) );

  ItemRotateFlags := K_CMStudyItemFRFags( AItem );
  ItemTeethFlags  := K_CMStudyItemTeethFags( AItem );

  with ASlide.P^ do
  if ((CMSDB.SFlags * [cmsfIsMediaObj,cmsfIsImg3DObj]) = []) then
  begin // Image (not 3D and not Video - precaution)

    if (ItemTeethFlags <> 0) and (CMSTeethFlags = 0) then
    begin // Set Slide Teeth Flags if needed
      CMSDTPropMod  := EDAGetSyncTimestamp();
      CMSRFlags := CMSRFlags + [cmsfAttribsChanged];
      CMSTeethFlags := ItemTeethFlags;
    end; // if (ItemTeethFlags <> 0) and (CMSTeethFlags = 0) then

    if ItemRotateFlags <> 0 then
    begin // Set Slide FlipRotate Flags if needed
      PSlideFlipRotate := @(ASlide.GetPMapRootAttrs.MRFlipRotateAttrs);
      if PSlideFlipRotate^ = 0 then
      begin // Apply Item FlipRotate to Slide
        // Should be done before all - needed inside CreateThumbnail()
        CMSDTMapRootMod := EDAGetSyncTimestamp();
        CMSDTPropMod    := CMSDTMapRootMod;
        CMSRFlags := CMSRFlags + [cmsfMapRootChanged,cmsfAttribsChanged,cmsfThumbChanged];

        ASlide.ClearMapImage(); // Should be done before all !!!
        PSlideFlipRotate := @(ASlide.GetPMapRootAttrs.MRFlipRotateAttrs);
        PSlideFlipRotate^ := ItemRotateFlags;
        if (ItemRotateFlags and 4) <> 0 then
          ASlide.SwitchMapRootSize();
        ASlide.AffConvVObjects( ItemRotateFlags, 1 );
        if not ASlide.CMSArchived then
          ASlide.CreateThumbnail();
      end; // if PSlideFlipRotate^ = 0 then
    end; // if ItemRotateFlags <> 0 then

  end; // if ((CMSDB.SFlags * [cmsfIsMediaObj,cmsfIsImg3DObj]) = []) then

//  ItemThumbParent := AItem.DirChild(0).DirChild(0);
  with AItem do
    ItemThumbParent := DirChild(IndexOfChildObjName( 'ImagePanel' )).DirChild(0);

  // Remove Previouse Slide Link to Item
  ItemThumbParent.DirChild(0).Owner.PutDirChildSafe( K_CMSlideIndStudyItem, nil );

  // Put Slide Tumbnail instead of Previous Slide Thumbnail
  ItemThumbParent.PutDirChild(0, ASlide.DirChild(K_CMSlideIndThumbnail) );

  // Set Slide Link to Study Item
  ASlide.PutDirChildSafe( K_CMSlideIndStudyItem, AItem );

  // Set Slide Study Mount Runtime Fields
  ASlide.CMSStudyID := StrToInt(AStudy.ObjName);
  ASlide.CMSStudyItemID := StrToInt(AItem.ObjName);
  ASlide.CMSStudyItemPos := 0;
end; // function TK_CMEDAccess.EDAStudyReplaceSlideInItem

//******************************* TK_CMEDAccess.EDAStudyItemSlideSetCurrent ***
// Set given Slide current visible in given Study Item
//
//     Parameters
// AItem  - Empty Study Item to mount Slide
// ASlide - Slide to add to Item
// AStudy - Study to Mount Slide
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// Result - Returns operation Resulting Code
//
function TK_CMEDAccess.EDAStudyItemSlideSetCurrent( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE ) : TK_CMEDResult;
var
  ItemSlidesParent : TN_UDBase;
  Ind : Integer;
begin
  Result := K_edOK;
  if (AItem = nil) or (ASlide = nil) then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);
  N_DumpStr( K_CMStudyDetailsDumpCInd, format( 'Study >> Set CurVis start Slide=%s to Study=%s Item=%s Pos=%d RuntimeInfo=%s',
              [ASlide.ObjName,AStudy.ObjName,AItem.ObjName,ASlide.CMSStudyItemPos,N_B2Str(ARuntimeLinksOnly)] ) );

  // Delete given Slide from Item invisible Slides Set
  K_CMStudyItemAddSlidesPrep( AItem, ItemSlidesParent );
  Ind := ItemSlidesParent.DeleteOneChild( ASlide.DirChild(K_CMSlideIndThumbnail) );
  if Ind < 0 then // Slide is not found in Invisible precaution (Nothing to do)
    N_DumpStr( K_CMStudyDetailsDumpCInd, '!!!Study >> Set CurVis Slide is absent in invisible set' )
  else
  begin
  // Add given Slide to Item
    ASlide.CMSStudyItemPos := 0; // Clear Invisible Flag
    Result := EDAStudyMountAddSlideToItem( AItem, ASlide, AStudy, ARuntimeLinksOnly );
  end;
end; // function TK_CMEDAccess.EDAStudyItemSlideSetCurrent

//********************************** TK_CMEDAccess.EDAStudyTemplatesPrepare ***
function TK_CMEDAccess.EDAStudyTemplatesPrepare: TK_CMEDResult;
begin
  Result := K_edOK;
  ArchStudySamplesLibRoot := ArchStudySamplesInitLibRoot;
end; // function TK_CMEDAccess.EDAStudyTemplatesPrepare

//*********************************** TK_CMEDAccess.EDAGetBuildInMediaTypes ***
// Get build in Media Types list
//
//     Parameters
// AMTypes - Media Types List
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetBuildInMediaTypes(AMTypes: TStrings)
  : TK_CMEDResult;
var
  i: Integer;
  WSTr : string;
begin
  AMTypes.Clear;
//  N_CurMemIni.ReadSectionValues('CMSFixMediaTypes', AMTypes);
  AMTypes.Assign( K_CMSFixMediaTypes );

  for i := 0 to AMTypes.Count - 1 do
  begin
    AMTypes.Objects[i] := TObject(StrToInt(AMTypes.Names[i]));
    if i < K_CML1Form.LLLFixMediaTypes.Items.Count then
      WStr := K_CML1Form.LLLFixMediaTypes.Items[i]
    else
      WStr := AMTypes.ValueFromIndex[i];
    AMTypes[i] := WStr;
  end;
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAGetBuildInMediaTypes

//********************************************* TK_CMEDAccess.EDAPrepIniMediaTypeTexts ***
// Translate Media Type Texts to Current Language
//
//
procedure TK_CMEDAccess.EDAPrepIniMediaTypeTexts();
var
  Ind, i, Num: Integer;

begin
  if AllMediaTypes = nil then Exit;
{
//  TmpStrings.Clear;
//  N_CurMemIni.ReadSectionValues('CMSFixMediaTypes', TmpStrings);
//  Ind := TmpStrings.Count;
  Ind := K_CMSFixMediaTypes.Count;

//  N_CurMemIni.ReadSectionValues('CMSIniMediaTypes', TmpStrings);
  TmpStrings.Clear;
  TmpStrings.Assign( K_CMSIniMediaTypes );
  Num := Min(TmpStrings.Count, K_CML1Form.LLLIniMediaTypes.Items.Count) - 1;

  for i := 0 to Num do
  begin
    if AllMediaTypes[i+Ind] = TmpStrings.ValueFromIndex[i] then
      AllMediaTypes[i+Ind] := K_CML1Form.LLLIniMediaTypes.Items[i]; // Replace by MType Lang Name
  end;
}
  Num := Min(K_CMSIniMediaTypes.Count, K_CML1Form.LLLIniMediaTypes.Items.Count) - 1;
  for i := 0 to Num do
  begin
    Ind := AllMediaTypes.IndexOf( K_CMSIniMediaTypes.ValueFromIndex[i] );
    if Ind >= 0 then
      AllMediaTypes[Ind] := K_CML1Form.LLLIniMediaTypes.Items[i]; // Replace by MType Lang Name
  end;
end; // end of TK_CMEDAccess.EDAPrepIniMediaTypeTexts

//********************************************* TK_CMEDAccess.EDAGetAllMediaTypes0 ***
// Get all Media Types list
//
//     Parameters
// Result - Self buffer strings list with all media types
//
function TK_CMEDAccess.EDAGetAllMediaTypes0(): TStrings;
var
  i: Integer;
  PStr: PString;
begin
  ExtResultCode := K_edOK;
  if AllMediaTypes = nil then
  begin
    // *** Create and Init Bufferd Media Types List
    AllMediaTypes := TStringList.Create;
    TStringList(AllMediaTypes).CaseSensitive := false;
    ExtResultCode := EDAGetBuildInMediaTypes(AllMediaTypes);

    ExtResultCode := EDAGetArchUDTab('GlobInfo\MediaTypesData', ArchMTypesInfo);
    if ExtResultCode = K_edOK then
    begin
      for i := 1 to ArchMTypesInfo.R.ARowCount - 1 do
      begin
        PStr := ArchMTypesInfo.R.PME(0, i);
        AllMediaTypes.AddObject(PString(TN_BytesPtr(PStr) + SizeOf(string))^,
          TObject(StrToInt(PStr^)));
      end;
    end;
    EDAPrepIniMediaTypeTexts();
  end; // end of Buffered Media Types List Creation

  Result := AllMediaTypes;
end; // end of TK_CMEDAccess.EDAGetAllMediaTypes0

//********************************************* TK_CMEDAccess.EDAGetAllMediaTypes ***
// Get all Media Types list
//
//     Parameters
// AMTypes - Media Types List
// Result - Returns operation resulting code
//
// Returns both build in and users defined Media Types list.
//
function TK_CMEDAccess.EDAGetAllMediaTypes(AMTypes: TStrings): TK_CMEDResult;
begin
  ExtResultCode := K_edOK;
  if AMTypes <> nil then
    AMTypes.Assign(EDAGetAllMediaTypes0());
  Result := ExtResultCode;
end; // end of TK_CMEDAccess.EDAGetAllMediaTypes

//********************************************* TK_CMEDAccess.EDACheckMediaTypeInCurSlidesSet ***
// Check Media Type in Current SLides Set
//
//     Parameters
// AMTypID - Media Type ID
// Result  - Returns TRUE if Given Media Type is used in Current SLides Set
//
function TK_CMEDAccess.EDACheckMediaTypeInCurSlidesSet(AMTypID: Integer)
  : Boolean;
var
  i: Integer;
begin
  Result := false;
  for i := 0 to CurSlidesList.Count - 1 do
    with TN_UDCMSlide(CurSlidesList[i]).P()^ do
      if CMSMediaType = AMTypID then
      begin
        Result := TRUE;
        Exit;
      end;
end; // end of TK_CMEDAccess.EDACheckMediaTypeInCurSlidesSet

//********************************************* TK_CMEDAccess.EDADeleteMediaTypeByID ***
// Delete Media Type by given ID
//
//     Parameters
// AMTypID   - Media Type ID
// APatsList - list of patients which have slides with given Media Type
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDADeleteMediaTypeByID( AMTypID: Integer; out APatID: Integer ): TK_CMEDResult;
var
  Ind, i: Integer;
  SMtypeID: string;
  CurPatientUseMTFlag: Boolean;

label UsedMediaType;

begin
  Result := EDAGetArchUDTab('GlobInfo\MediaTypesData', ArchMTypesInfo);
  if Result <> K_edOK then
    Exit;

  SMtypeID := IntToStr(AMTypID);
  Ind := EDAArchUDTabIndexOf(SMtypeID, ArchMTypesInfo);
  if Ind = 0 then
    Exit; // Absent MT ID

  // Check Current Slides Set
  CurPatientUseMTFlag := EDACheckMediaTypeInCurSlidesSet(AMTypID);
  if CurPatientUseMTFlag then
  begin
    APatID := CurSlidesSelectAttrs.SSPatID;
UsedMediaType: //*******
    Result := K_edUsedMediaType;
    Exit;
  end;

  Result := K_edExDataError;
  if ArchSlidesRoot = nil then
    Exit;

  // Check Archive Slides
  for i := 0 to ArchSlidesRoot.DirHigh do
    with TN_UDCMSlide(ArchSlidesRoot.DirChild(i)).P()^ do
      if CMSMediaType = AMTypID then
      begin
        APatID := CMSPatId;
        goto UsedMediaType // return immediate result if Patients list is not given
      end;

  // Delete Media Type
  Result := K_edOK;
  N_Dump2Str( 'DB>> Delete media type ' + SMtypeID + '=' + PString
              (ArchMTypesInfo.R.PME(1, Ind))^ );
  ArchMTypesInfo.R.DeleteRows(Ind);
  K_SetChangeSubTreeFlags(ArchMTypesInfo);
  K_SetArchiveChangeFlag();
  FreeAndNil(AllMediaTypes);

end; // end of TK_CMEDAccess.EDADeleteMediaTypeByID

//********************************************* TK_CMEDAccess.EDAddNewMediaType ***
// Add new Media Type with given Aliase
//
//     Parameters
// AMTypID - resulting new Media Type ID
// AMTypeTitle - given new Media Type Title
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAddNewMediaType( out AMTypID: Integer; const AMTypeTitle: string): TK_CMEDResult;
var
  L, Ind: Integer;
  PStr: PString;
begin

  Result := EDAGetArchUDTab('GlobInfo\MediaTypesData', ArchMTypesInfo);
  if Result <> K_edOK then
    Exit;

  Ind := EDAArchUDTabIndexOf(AMTypeTitle, ArchMTypesInfo, 1);
  Result := K_edExistedMediaType;
  if Ind > 0 then
    Exit; // Existed MT ID
  Result := K_edOK;
  with ArchMTypesInfo.R do
  begin
    AMTypID := EDAFixIDsRangeArch(K_CMAMIDMTypeInd, 1);
    L := ARowCount;
    ASetLength(AColCount, L + 1);
    PStr := PME(0, L);
    PStr^ := IntToStr(AMTypID);
    N_Dump2Str('DB>> Add media type ' + PStr^ + '=' + AMTypeTitle);
    Inc(PStr);
    PStr^ := AMTypeTitle;
  end;
  K_SetChangeSubTreeFlags(ArchMTypesInfo);
  K_SetArchiveChangeFlag();
  FreeAndNil(AllMediaTypes);
end; // end of TK_CMEDAccess.EDAddNewMediaType

//********************************************* TK_CMEDAccess.EDARenameMediaType ***
// Rename given Media Type with given Aliase
//
//     Parameters
// AMTypID - Media Type ID
// AMTypeAliase - given new Media Type aliase
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDARenameMediaType(AMTypID: Integer;
  AMTypeTitle: string): TK_CMEDResult;
var
  Ind, i: Integer;
  PStr: PString;
  SID: string;
begin

  Result := EDAGetArchUDTab('GlobInfo\MediaTypesData', ArchMTypesInfo);
  if Result <> K_edOK then
    Exit;
  Ind := 0;
  SID := IntToStr(AMTypID);
  with ArchMTypesInfo.R do
  begin
    // Check MediaTypes
    for i := 1 to ARowCount - 1 do
    begin
      PStr := PME(0, i);
      if SID = PStr^ then
        Ind := i;
      Inc(PStr);
      if (Ind = i) or (PStr^ <> AMTypeTitle) then
        Continue;
      Result := K_edExistedMediaType;
      break;
    end;
    if Result <> K_edOK then
      Exit;

    Result := K_edExDataError;
    if Ind = 0 then
      Exit; // Renaming ID is not found
    // Rename MediaType
    Result := K_edOK;
    PStr := PME(1, Ind);
    PStr^ := AMTypeTitle;
    N_Dump2Str('DB>> Rename media type ' + PString
        (TN_BytesPtr(PStr) - SizeOf(string))^ + '=' + AMTypeTitle);
  end;
  K_SetChangeSubTreeFlags(ArchMTypesInfo);
  K_SetArchiveChangeFlag();
  FreeAndNil(AllMediaTypes);
end; // end of TK_CMEDAccess.EDARenameMediaType

//********************************************* TK_CMEDAccess.EDAddInitialMediaTypes ***
// Set initial Media Types to DB if needed
//
//     Parameters
// APInitMTypesNum - pointer to resulting added Initial Media Types number
// Result - Returns operation resulting code
//
// Initial Media Types Info is get from Ini-File [CMSIniMediaTypes]
//
function TK_CMEDAccess.EDAddInitialMediaTypes(APInitMTypesNum: PInteger = nil)
  : TK_CMEDResult;
var
  i, MTypeID: Integer;
  WrkSL: TStringList;
begin

  if APInitMTypesNum <> nil then
    APInitMTypesNum^ := 0;

  Result := EDAGetArchUDTab('GlobInfo\MediaTypesData', ArchMTypesInfo);
  if Result <> K_edOK then
    Exit;

  if EDAFixIDsRangeArch(K_CMAMIDMTypeInd, 0) > K_CMEDMTypeInitID then
    Exit; // Nothing to do
  // No Media Types are added - try to add initial Media Types From Ini-File
  WrkSL := TStringList.Create();
//  N_CurMemIni.ReadSectionValues('CMSIniMediaTypes', WrkSL);
  WrkSL.Assign( K_CMSIniMediaTypes );
  for i := 0 to WrkSL.Count - 1 do
    EDAddNewMediaType(MTypeID, WrkSL.ValueFromIndex[i]);

  if APInitMTypesNum <> nil then
    APInitMTypesNum^ := WrkSL.Count;
  WrkSL.Free;
end; // end of TK_CMEDAccess.EDAddInitialMediaTypes

//********************************************* TK_CMEDAccess.EDAClearAllEData ***
// Clear all external Data
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAClearAllEData(): TK_CMEDResult;
var
  i: Integer;
begin
  Result := K_edOK;
  EDAClearCurSlidesSet();
  if ArchSlidesRoot <> nil then
  begin
    for i := 0 to ArchSlidesRoot.DirHigh() do
      DelSlidesList.Add(ArchSlidesRoot.DirChild(i));
    EDAClearDeletedSlides( FALSE );
    K_SetChangeSubTreeFlags(ArchSlidesRoot);
  end;

  if ArchGlobInfo <> nil then
  begin
    PInteger(ArchGlobInfo.PDE(K_CMAMIDSlideInd))^ := K_CMEDSlideInitID;
    PInteger(ArchGlobInfo.PDE(K_CMAMIDMTypeInd))^ := K_CMEDMTypeInitID;
    PInteger(ArchGlobInfo.PDE(K_CMAMIDMFileInd))^ := K_CMEDMFileInitID;
    K_SetChangeSubTreeFlags(ArchGlobInfo);
  end;

  if ArchMTypesInfo <> nil then
  begin
    ArchMTypesInfo.R.ASetLength(2, 1);
    K_SetChangeSubTreeFlags(ArchMTypesInfo);
  end;
  FreeAndNil(AllMediaTypes);

  UDRootInstanceInfo.ClearChilds();
  UDRootProviderInfo.ClearChilds();
  UDRootGlobalInfo.ClearChilds();

  EDAAppUDTreeInit();
  EDAGlobUDTreeInit();
  EDADevProfilesUDTreeInit();
  K_SetArchiveChangeFlag();
end; // end of TK_CMEDAccess.EDAClearAllEData

//********************************************* TK_CMEDAccess.EDAGetInfo ***
// Get external data info
//
//     Parameters
// APInfo - pointer to Info data record
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetInfo( APInfo: Pointer ): TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAGetInfo

//********************************************* TK_CMEDAccess.EDAGetDirFreeSpace ***
// Get Disk Free Space
//
//     Parameters
// AFPath - directory path for free space detect
// ADAFlag - if FALSE then Sybase sf_GetPathFreeSpace will be used
//           Windows GetDiskFreeSpaceEx will be used else.
// AFreeSpace - resulting disk free space
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetDirFreeSpace( const AFPath: string;
                        ADAFlag: Boolean; out AFreeSpace: Int64 ): TK_CMEDResult;
var
  PathPar0: string;
  PathPar: string;
  FreeSpaceAvailable, TotalSpace: Int64;

begin
  Result := K_edOK;
  AFreeSpace := 0;
  PathPar := AFPath;
  // Search for Existing Parent Directory for Space Check
  while not DirectoryExists(PathPar) do
  begin
    PathPar0 := ExtractFilePath(ExcludeTrailingPathDelimiter(PathPar));
    if PathPar0 = PathPar then
      Exit;
    PathPar := PathPar0;
  end;
  // Get Free Space
  if GetDiskFreeSpaceEx(@PathPar[1], FreeSpaceAvailable, TotalSpace, nil) then
    AFreeSpace := FreeSpaceAvailable;
end; // end of TK_CMEDAccess.EDAGetDirFreeSpace

//********************************************* TK_CMEDAccess.EDAGetImgDiskFreeSpace ***
// Get Images Disk Free Space
//
//     Parameters
// AFreeSpace - resulting disk free space
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetImgDiskFreeSpace( out AFreeSpace: Int64 ): TK_CMEDResult;
begin
  Result := EDAGetDirFreeSpace( K_GetDirPath( 'CMArchSections'), TRUE, AFreeSpace );
end; // end of TK_CMEDAccess.EDAGetImgDiskFreeSpace

//********************************************* TK_CMEDAccess.EDAGetVideoDiskFreeSpace ***
// Get Video Disk Free Space
//
//     Parameters
// AFreeSpace - resulting disk free space
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetVideoDiskFreeSpace( out AFreeSpace: Int64 ): TK_CMEDResult;
begin
  Result := EDAGetDirFreeSpace( SlidesClientMediaRootFolder, TRUE, AFreeSpace );
end; // end of TK_CMEDAccess.EDAGetVideoDiskFreeSpace

//********************************************* TK_CMEDAccess.EDAGetDiskFreeSpace ***
// Get Disk Free Space
//
//     Parameters
// AFreeSpace - resulting disk free space
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetDiskFreeSpace( out AFreeSpace: Int64 ): TK_CMEDResult;
var
  ImgFreeSpaceAvailable, VideoFreeSpaceAvailable: Int64;

begin
  EDAGetImgDiskFreeSpace( ImgFreeSpaceAvailable );
  Result := EDAGetVideoDiskFreeSpace( VideoFreeSpaceAvailable );
  AFreeSpace := Min( VideoFreeSpaceAvailable, ImgFreeSpaceAvailable );
end; // end of TK_CMEDAccess.EDAGetDiskFreeSpace

//********************************************* TK_CMEDAccess.EDAVideoFolderAccessPrevCheck ***
// Video Folder access previous check Flag
//
//     Parameters
// Result - Returns TRUE if Video Folder Access Check before Video Slide Creation is needed
//
function TK_CMEDAccess.EDAVideoFolderAccessPrevCheck: Boolean;
begin
  Result := FALSE;
end; // end of TK_CMEDAccess.EDAVideoFolderAccessPrevCheck

//********************************************* TK_CMEDAccess.EDACheckImgFilesFolderAccess ***
// Check Image Files Access
//
//     Parameters
// Result - Returns:
//#F
//   0 - CMS can write files to and read it from  given folder
//   1 - given folder does not exist
//   2 - CMS can not write files to given folder
//   3 - CMS can not delete files from given folder
//#/F
//
function TK_CMEDAccess.EDACheckImgFilesFolderAccess() : Integer;
begin
  Result := 0;
end; // function TK_CMEDAccess.EDACheckImgFilesFolderAccess

//********************************************* TK_CMEDAccess.EDACheckImgFilesFolderAccess ***
// Check Video Files Access
//
//     Parameters
// Result - Returns:
//#F
//   0 - CMS can write files to and read it from  given folder
//   1 - given folder does not exist
//   2 - CMS can not write files to given folder
//   3 - CMS can not delete files from given folder
//#/F
//
function TK_CMEDAccess.EDACheckVideoFilesFolderAccess() : Integer;
begin
  Result := 0;
end; // function TK_CMEDAccess.EDACheckImgFilesFolderAccess

{
//********************************************* TK_CMEDAccess.EDACheckVideoFolderAccessDlg ***
// Check Video Folder access dialog
//
//     Parameters
// Result - Returns TRUE if Video Folder Access is OK
//
function TK_CMEDAccess.EDACheckVideoFolderAccessDlg: Boolean;
begin
  Result := TRUE;
end; // end of TK_CMEDAccess.EDACheckVideoFolderAccessDlg
}
//********************************************* TK_CMEDAccess.EDACheckFilesAccessBySlidesSet ***
// Check Images and/or Video Files Access by Slides Set
//
//     Parameters
// APUDSlide - pointer to 1-st slide in slides array
// ASlidesCount - slides count
// AddWarnStr   - aditional warning string if problem will not be resolved
// AMDButtons  - set of Message Dialog buttons
// AMDResult   - Message Dialog OK result corresponding to AMDButtons
// Result - Returns string with problem Folders Name:
//#F
//   '' - no problems with access to folders
//   'Images' - problem with access to Images files folder
//   'Video'  - problem with access to Video files folder
//   'Images and Video' - problem with access to Images and Video files folders
//#/F
//
function TK_CMEDAccess.EDACheckFilesAccessBySlidesSet( APUDSlide: TN_PUDCMSlide;
                                            ASlidesCount : Integer;
                                            const AddWarnStr : string;
                                            AMDButtons : TMsgDlgButtons = [];
                                            AMDResult : word = mrOk ): Integer;
begin
  Result := 0;
end; // function TK_CMEDAccess.EDACheckFilesAccessBySlidesSet

//********************************************* TK_CMEDAccess.EDACheckAllFilesAccess ***
// Check All Images and/or Video Files Access
//
//     Parameters
// AFImgCheck  - if = TRUE then check Images files access
// AFImgCheck  - if = TRUE then check Video files access
// AddWarnStr2 - aditional warning string to 2-d dialog if problem will not be resolved
// AddWarnStr1 - aditional warning string to 1-st dialog when problem was detected
// Result - Returns code:
//#F
//  -3 - first dialog returns Cancel and problem with access to Images and Video files folder
//  -2 - first dialog returns Cancel and problem with access to Video files folder
//  -1 - first dialog returns Cancel and problem with access to Images files folder
//   0 - no problems with access to folders
//   1 - problem with access to Images files folder
//   2 - problem with access to Video files folder
//   3 - problem with access to Images and Video files folder
//#/F
//
function  TK_CMEDAccess.EDACheckAllFilesAccess( AFImgCheck: Boolean;
                                                AFVideoCheck: Boolean;
                                                AFImg3DCheck: Boolean;
                                                  const AddWarnStr2 : string;
                                                  const AddWarnStr1 : string = '';
                                                  AMDButtons : TMsgDlgButtons = [];
                                                  AMDResult : word = mrOk ): Integer;
begin
  Result := 0;
end; // function TK_CMEDAccess.EDACheckAllFilesAccess

//*********************************** TK_CMEDAccess.EDACheckFoldersEquality ***
// Check to Folders for equivalence
//
//     Parameters
// AFPath1 - 1-st compared folder path
// AFDA1  - 1-st compared folder direc access flag
// AFPath2 - 2-nd compared folder path
// AFDA2  - 2-nd compared folder direc access flag
// Result - Returns TRUE if folders are the same
//
function TK_CMEDAccess.EDACheckFoldersEquality( AFPath1 : string;
                                                AFPath2 : string ) : Boolean;
const
  CheckName = '123456789.123';

var
  TmpName: string;

begin
  Result := AFPath1 = AFPath2;
  if Result then Exit;

  TmpName := K_ExpandFileName('(#TmpFiles#)' + CheckName);
  if not FileExists(TmpName) then
    with TFileStream.Create(TmpName, fmCreate) do
    begin
      Write(TmpName[1], 1);
      Free;
    end;
  AFPath1 := AFPath1 + CheckName;
  AFPath2 := AFPath2 + CheckName;
  K_DeleteFile( AFPath2 );
  if 0 = K_CopyFile(TmpName, AFPath1, [K_cffOverwriteNewer]) then
  begin
    Result := FileExists( AFPath2 + CheckName );
    K_DeleteFile( AFPath1 );
  end;
end; // function TK_CMEDAccess.EDACheckFoldersEquality

//********************************************* TK_CMEDAccess.EDAPrepFreeSpaceWarnText ***
// Check to Folders for equivalence
//
//     Parameters
// AFreeSpace - disk free space
// ADriveName - disk drive name
// Result - Returns Free Space Warning 1-st line text
//
function TK_CMEDAccess.EDAPrepFreeSpaceWarnText( AFreeSpace : Int64; ADriveName : string ) : string;
begin
  if ADriveName <> '' then
    ADriveName := ' ' + ADriveName;
  ADriveName := ADriveName + '.';
  Result := format( K_CML1Form.LLLFreeSpaceWarn1.Caption + #13#10,
//                    'You have %s Hard Drive space only available on your Server %s'+ #13#10,
                    [N_DataSizeToString(AFreeSpace), ADriveName] );
//  Result := 'You have ' + N_DataSizeToString(AFreeSpace) + ' Hard Drive space only available on your Server' + ADriveName + #13#10;
end; // function TK_CMEDAccess.EDAPrepFreeSpaceWarnText

//********************************************* TK_CMEDAccess.EDACheckMinDiskFreeSpace ***
// Ñheñk Minimal Server Free Space
//
function TK_CMEDAccess.EDACheckMinDiskFreeSpace( ) : Boolean;
begin
  Result := FALSE;
end; // procedure TK_CMEDAccess.EDACheckMinDiskFreeSpace

//********************************************* TK_CMEDAccess.EDADumpSlidesToTmpStrings ***
// Dump given Slides to TmpStrings field
//
//     Parameters
// APUDSlide - pointer to 1-st slide in slides array
// ASlidesCount - slides count
//
procedure TK_CMEDAccess.EDADumpSlidesToTmpStrings( APUDSlide: TN_PUDCMSlide;
                                                   ASlidesCount : Integer );
var
  i : Integer;
begin
  for i := 1 to ASlidesCount do  // SLides Loop
  begin
    if APUDSlide^ <> nil then
      with APUDSlide^, P^ do
        TmpStrings.Add( format( '%s L%d R%d %s',
               [ObjName,
               (CMSTeethFlags shr 60) and 3,
               (CMSTeethFlags shr 28) and 3,
               K_DateTimeToStr( CMSDTTaken, 'dd"-"mm"-"yyyy' )] ) )
    else
      TmpStrings.Add( '*' );
    Inc(APUDSlide);
  end;
end; // procedure TK_CMEDAccess.EDADumpSlidesToTmpStrings

//**************************************** TK_CMEDAccess.EDASelectDataFiles ***
// Collect Media Object Files scan files subtree function
//
//     Parameters
// APathName - testing path
// AFileName - testing file name
//
function TK_CMEDAccess.EDASelectDataFiles( const APathName, AFileName: string; AScanLevel : Integer ): TK_ScanTreeResult;
begin
  Result := K_tucSkipSubTree;
//  if APathName = SkipDataFolder then Exit;
  if (SkipDataFolder <> '') and K_CheckTextPattern( APathName, SkipDataFolder ) then Exit;
  Result := K_tucOK;
  if AFileName = ''  then
    Exit;
  if RelPathStartInd > 1 then
    TmpStrings.Add( Copy(APathName + AFileName, RelPathStartInd, 1000) )
  else
    TmpStrings.Add(APathName + AFileName);

end; // end of TK_CMEDAccess.EDASelectDataFiles

//****************************************** TK_CMEDAccess.EDACalcFilesSize ***
// Calc Files size - scan files subtree function
//
//     Parameters
// APathName - testing path
// AFileName - testing file name
//
function TK_CMEDAccess.EDACalcFilesSize( const APathName, AFileName : string; AScanLevel : Integer ) : TK_ScanTreeResult;
begin
  Result := K_tucSkipSubTree;
//  if APathName = SkipDataFolder then Exit;
  if (SkipDataFolder <> '') and K_CheckTextPattern( APathName, SkipDataFolder ) then Exit;
  Result := K_tucOK;
  if AFileName = ''  then
    Exit;
  Int64Data := Int64Data + N_GetFileSize( APathName + AFileName );
end; // end of TK_CMEDAccess.EDACalcFilesSize

//************************************ TK_CMEDAccess.EDAWaitForEventUserDlg ***
// Show Dialog which should be closed after some event comes or User
// click on dialog buttons
//
//     Parameters
// ACheckEventFunc - testing user event procedure
// AMessage   - message text
// AMDLT      - message dialog type (mtWarning, mtError, mtInformation, mtConfirmation)
// AMDButtons - message dialog buttons set
// ACaption   - message window caption
// Result     - Returns -1 if Event has come, or MessgeDialog result code:
//  = 0 - mrNone
//  = 1 - mrOk
//  = 2 - mrCancel
//  = 3 - mrAbort
//  = 4 - mrRetry
//  = 5 - mrIgnore
//  = 6 - mrYes
//  = 7 - mrNo
//  = 8 - mrAll
//  = 9 - mrNoToAll
//  =10 - mrYesToAll
//

function TK_CMEDAccess.EDAWaitForEventUserDlg( ACheckEventFunc : TK_FuncObjBool;
                                    const AMessage: string; AMDLT: TMsgDlgType;
                                    AMDButtons: TMsgDlgButtons = []; ACaption: string = '' ) : Integer;
var
  i : Integer;
begin
  WaitEventForm := K_CMPrepMessageDlg( AMessage, AMDLT, AMDButtons, ACaption );
  WaitEventForm.OnCloseQuery := EDAOnWaitDlgFormCloseQuery;
  for i := 0 to WaitEventForm.ControlCount - 1 do
    if WaitEventForm.Controls[i] is TButton then
     TButton(WaitEventForm.Controls[i]).OnClick := EDAOnWaitDlgFormButtonClick;

  WaitEventForm.Show();

  // Wait Loop
  Result := 0;
  while TRUE do
  begin
    if WaitEventForm <> nil then
    begin
      if not ACheckEventFunc() then
      begin
        Sleep(100);
        Application.ProcessMessages();
        Continue;
      end;
      Result := -1;
      EDAWaitDlgFormClear();
    end  // if WaitEventForm <> nil then
    else
      Result := WaitDlgResult;
    Break;
  end; // while TRUE do

end; // end of TK_CMEDAccess.EDAWaitForEventUserDlg

//******************************** TK_CMEDAccess.EDAOnWaitDlgFormCloseQuery ***
// Wait form OnCLoseQuery handler
//
procedure TK_CMEDAccess.EDAOnWaitDlgFormCloseQuery( Sender: TObject; var CanClose: Boolean );
begin
  EDAOnWaitDlgFormButtonClick( Sender );
end; // procedure TK_CMEDAccess.EDAOnWaitDlgFormCloseQuery

//******************************** TK_CMEDAccess.EDAOnWaitDlgFormButtonClick ***
// Wait form OnCLoseQuery handler
//
procedure TK_CMEDAccess.EDAOnWaitDlgFormButtonClick( Sender: TObject );
begin
  if WaitEventForm = nil then Exit; // precaution
  WaitDlgResult := WaitEventForm.ModalResult;
  WaitEventForm.Release();
  WaitEventForm := nil;
end; // procedure TK_CMEDAccess.EDAOnWaitDlgFormButtonClick

//*************************************** TK_CMEDAccess.EDAWaitDlgFormClear ***
// Clear Opend Wait Dialog Form
//
procedure TK_CMEDAccess.EDAWaitDlgFormClear();
begin
  if WaitEventForm = nil then Exit; // precaution
  WaitEventForm.OnCloseQuery := nil;
  WaitEventForm.Release();
  WaitEventForm := nil;
end; // procedure TK_CMEDAccess.EDAWaitDlgFormClear

//*********************************************** TK_CMEDAccess.EDAGetDBUID ***
// Get Data Base UID for DICOM Export
//
function TK_CMEDAccess.EDAGetDBUID: string;
var
  GUID: TGUID;
begin
  Result := N_MemIniToString( 'CMS_Main', 'GUID', '' );
  if Result <> '' then Exit;
  CreateGUID( GUID );
  Result := GUIDToString( GUID );
  N_StringToMemIni( 'CMS_Main', 'GUID', Result );

  // Save GUID to Global Context
  K_CMEDAccess.EDASaveContextsData(
     [K_cmssSkipSlides, K_cmssSkipInstanceBinInfo,
      K_cmssSkipInstanceInfo, K_cmssSkipPatientInfo,
      K_cmssSkipProviderInfo, K_cmssSkipLocationInfo,
      K_cmssSkipExtIniInfo,
      K_cmssSaveGlobal2Info] );
end; // function TK_CMEDAccess.EDAGetDBUID

//************************************* TK_CMEDAccess.EDAGetDCMStudiesAttrs ***
// Build Slides DICOM Studies IDs and TimeStamps
//
//     Parameters
// APSlides - pointer to slides array start element
// ASlidesCount - number of slides
// AStudiesSID - resulting array of slides corresponding studies IDs
// AStudiesTS - resulting array of slides corresponding studies TimeStamps
//
procedure TK_CMEDAccess.EDAGetDCMStudiesAttrs( APSlide: TN_PUDCMSlide;
               ASlidesCount: Integer; out AStudiesSID : TN_SArray;
               out AStudiesTS : TN_DArray );
var
  i : Integer;

begin
  SetLength( AStudiesSID, ASlidesCount );
  SetLength( AStudiesTS, ASlidesCount );
  if ASlidesCount = 0 then Exit;

  for i := 0 to ASlidesCount - 1 do
  begin
    with APSlide^, P^ do
    begin
      AStudiesSID[i] := ObjName;
      AStudiesTS[i]  := CMSDTCreated;
    end;
    Inc(APSlide);
  end;
end; // end of TK_CMEDAccess.EDAGetDCMStudiesAttrs

//*********************************** TK_CMEDDBAccess.EDAGetDCMStudiesAttrs ***
// Build Slides DICOM Studies UIDs, IDs and TimeStamps
//
//     Parameters
// APSlides - pointer to slides array start element
// ASlidesCount - number of slides
// AStudiesUID  - resulting array of slides corresponding studies UIDs
// AStudiesSID  - resulting array of slides corresponding studies IDs
// AStudiesTS   - resulting array of slides corresponding studies TimeStamps
//
procedure TK_CMEDAccess.EDAGetDCMStudiesUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
             ADCMFNames : TN_SArray;
             out AStudiesUID, AStudiesSID : TN_SArray; out AStudiesTS : TN_DArray );
var
  i : Integer;

begin
  SetLength( AStudiesUID, ASlidesCount );
  SetLength( AStudiesSID, ASlidesCount );
  SetLength( AStudiesTS, ASlidesCount );
  if ASlidesCount = 0 then Exit;

  for i := 0 to ASlidesCount - 1 do
  begin
    with APSlide^, P^ do
    begin
      if not ((cmsfIsMediaObj in CMSDB.SFlags) or (cmsfIsImg3DObj in CMSDB.SFlags)) then
      begin
        if K_CMDCMD4WStudyUID <> '' then
          AStudiesUID[i] := K_CMDCMD4WStudyUID
        else
        if K_CMDCMUIDPrefix <> '' then
          AStudiesUID[i] := K_CMDCMUIDPrefix + '.1.' + ObjName
        else
          AStudiesUID[i] := '1.' + ObjName;
        AStudiesSID[i] := ObjName;
        AStudiesTS[i]  := CMSDTCreated;
      end; // Slide is Image
    end; // with APSlide^, P^ do
    Inc(APSlide);
  end; // for i := 0 to ASlidesCount - 1 do
end; // procedure TK_CMEDAccess.EDAGetDCMStudiesUIDAttrs

//************************************ TK_CMEDDBAccess.EDAGetDCMSeriesAttrs ***
// Build Slides DICOM Series UIDs, IDs and TimeStamps
//
//     Parameters
// APSlides - pointer to slides array start element
// ASlidesCount - number of slides
// ASeriesUID   - resulting array of slides corresponding series UIDs
// ASeriesSID   - resulting array of slides corresponding series IDs
// ASeriesTS    - resulting array of slides corresponding series TimeStamps
//
procedure TK_CMEDAccess.EDAGetDCMSeriesUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
             ADCMFNames : TN_SArray;
             out ASeriesUID, ASeriesSID  : TN_SArray; out ASeriesTS  : TN_DArray );
var
  i : Integer;

begin
  SetLength( ASeriesUID, ASlidesCount );
  SetLength( ASeriesSID, ASlidesCount );
  SetLength( ASeriesTS, ASlidesCount );
  if ASlidesCount = 0 then Exit;

  for i := 0 to ASlidesCount - 1 do
  begin
    with APSlide^, P^ do
    begin
      if not ((cmsfIsMediaObj in CMSDB.SFlags) or (cmsfIsImg3DObj in CMSDB.SFlags)) then
      begin
        if K_CMDCMSeriesID <> 0 then
        begin
          ASeriesSID[i] := IntToStr(K_CMDCMSeriesID);
          ASeriesUID[i] := '5.' + ASeriesSID[i];
          ASeriesTS[i] := K_CMDCMSeriesIDTS;
        end
        else
        begin
          ASeriesUID[i] := '2.' + ObjName;
          ASeriesSID[i] := ObjName;
          ASeriesTS[i]  := CMSDTCreated;
        end;

        if K_CMDCMUIDPrefix <> '' then
          ASeriesUID[i] := K_CMDCMUIDPrefix + '.' + ASeriesUID[i];
      end; // Slide is Image
    end; // with APSlide^, P^ do
    Inc(APSlide);
  end; // for i := 0 to ASlidesCount - 1 do
end; // procedure TK_CMEDAccess.EDAGetDCMSeriesUIDAttrs

//********************************** TK_CMEDDBAccess.EDAGetDCMSlideUIDAttrs ***
// Build Slides DICOM Content UIDs, IDs, Change TimeStamps and Acquisition TimeStamps
//
//     Parameters
// APSlides - pointer to slides array start element
// ASlidesCount - number of slides
// AContentUID  - resulting array of slides corresponding content UIDs
// AContentSID  - resulting array of slides corresponding content IDs
// AContentTS   - resulting array of slides corresponding content TimeStamps
// AcqTS        - resulting array of slides corresponding content acquisition TimeStamps
//
procedure TK_CMEDAccess.EDAGetDCMSlideUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
             out ADCMFNames, AContentUID, AContentSID : TN_SArray; out AContentTS, AcqTS : TN_DArray );
var
  i : Integer;

begin
  SetLength( ADCMFNames, ASlidesCount );
  SetLength( AContentUID, ASlidesCount );
  SetLength( AContentSID, ASlidesCount );
  SetLength( AContentTS, ASlidesCount );
  SetLength( AcqTS, ASlidesCount );
  if ASlidesCount = 0 then Exit;

  for i := 0 to ASlidesCount - 1 do
  begin
    with APSlide^, P^ do
    begin
      if not ((cmsfIsMediaObj in CMSDB.SFlags) or (cmsfIsImg3DObj in CMSDB.SFlags)) then
      begin
        AContentUID[i] := '3.' + ObjName;
        if K_CMDCMUIDPrefix <> '' then
          AContentUID[i] := K_CMDCMUIDPrefix + '.' + AContentUID[i];
        AContentSID[i] := ObjName;
        AContentTS[i]  := CMSDTTaken;
        AcqTS[i]       := CMSDTTaken;
      end; // Slide is Image
    end; // with APSlide^, P^ do
    Inc(APSlide);
  end; // for i := 0 to ASlidesCount - 1 do
end; // procedure TK_CMEDAccess.EDAGetDCMSlideUIDAttrs

//************************************* TK_CMEDAccess.EDAGetDCMSlideUCAttrs ***
// Build DICOM UIDs and TimeStamps slides corresponding attrs
//
//     Parameters
// APSlides - pointer to slides array start element
// ASlidesCount - number of slides
// ADCMFNames  - resulting array of slides corresponding DICOM attrs files
// AStudiesUID - resulting array of slides corresponding studies UIDs
// AStudiesSID - resulting array of slides corresponding studies IDs
// AStudiesTS  - resulting array of slides corresponding studies TimeStamps
// ASeriesUID  - resulting array of slides corresponding series UIDs
// ASeriesSID  - resulting array of slides corresponding series IDs
// ASeriesTS   - resulting array of slides corresponding series TimeStamps
// AContentUID - resulting array of slides corresponding slides UIDs
// AContentSID - resulting array of slides corresponding slides IDs
// AContentTS  - resulting array of slides corresponding slides change TimeStamps
// AcqTS       - resulting array of slides corresponding acqisition TimeStamps
//
procedure TK_CMEDAccess.EDAGetDCMSlideUCAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
               out ADCMFNames, AStudiesUID, AStudiesSID : TN_SArray; out AStudiesTS : TN_DArray;
               out ASeriesUID, ASeriesSID  : TN_SArray; out ASeriesTS  : TN_DArray;
               out AContentUID, AContentSID : TN_SArray; out AContentTS, AcqTS : TN_DArray );

begin
  EDAGetDCMSlideUIDAttrs( APSlide, ASlidesCount, ADCMFNames, AContentUID, AContentSID, AContentTS, AcqTS );
  EDAGetDCMStudiesUIDAttrs( APSlide, ASlidesCount, ADCMFNames, AStudiesUID, AStudiesSID, AStudiesTS );
  EDAGetDCMSeriesUIDAttrs( APSlide, ASlidesCount, ADCMFNames, ASeriesUID, ASeriesSID, ASeriesTS );
end; // procedure TK_CMEDAccess.EDAGetDCMSomeAttrs

//******************************** TK_CMEDAccess.EDAScanFilesTreeSelectFile ***
// Select Emergency Cache Files scan files subtree function
//
//     Parameters
// APathName - testing path
// AFileName - testing file name
//
// Resulting files names (not file path, name only) are added to TmpStrings
//
function TK_CMEDAccess.EDAScanFilesTreeSelectFile( const APathName, AFileName: string; AScanLevel : Integer ) : TK_ScanTreeResult;
begin
  Result := K_tucSkipSubTree;
  if AFileName = '' then
    Exit;
  TmpStrings.Add(AFileName);
end; // end of TK_CMEDAccess.EDAScanFilesTreeSelectFile

//******************************************* TK_CMEDAccess.EDAStartCapture ***
// Start capture
//
function TK_CMEDAccess.EDAStartCapture( ACMScanCaptureFlags : TK_CMScanCaptureFlags;
                                        APCurDevProfile: TK_PCMDeviceProfile ) : Boolean;
begin
// Save current profile parameters
  PCurDevProfile := APCurDevProfile;
  CurDevProfilePar1 := APCurDevProfile.CMDPStrPar1;
  CurDevProfilePar2 := APCurDevProfile.CMDPStrPar2;
  Result := TRUE; 
end; // procedure TK_CMEDAccess.EDAStartCapture

//********************************************* TK_CMEDAccess.EDAFinCapture ***
// Finish capture
//
procedure TK_CMEDAccess.EDAFinCapture();
begin
  if (CurDevProfilePar1 = PCurDevProfile.CMDPStrPar1) and
     (CurDevProfilePar2 = PCurDevProfile.CMDPStrPar2) then Exit;

  with K_CMEDAccess do
    EDASaveContextsData( [K_cmssSkipSlides] ); // Save Contexts
end; // procedure TK_CMEDAccess.EDAFinCapture

//******************************************* TK_CMEDAccess.EDAForceDirPath ***
// Force Directory Path
//
//     Parameters
// AFPath - Server Files Base Path
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAForceDirPath( const AFPath: string ): Boolean;
var
  i: Integer;

begin
  Result := TRUE;
  if not DirectoryExists( AFPath ) then
  begin
    N_Dump2Str( 'DB >> EDAForceDirPath Try create ' + AFPath );
    for i := 1 to 20 do
    begin
      Result := K_ForceDirPath( AFPath );
      if Result then Break;
      N_Dump1Str( 'DB >> EDAForceDirPath fails ' + IntToStr(i) );
      sleep( 1000 );
    end;
  end;
end; // end of TK_CMEDAccess.EDAForceDirPath

//******************************************* TK_CMEDAccess.EDAClearGAMode ***
// Clear Global Administrator mode
//
function  TK_CMEDAccess.EDAClearGAMode() : TK_CMEDResult;
begin
  K_CMGAModeFlag := FALSE;
  N_CMResForm.aGoToGAEnter.Checked := FALSE;
  Result := K_edOK;
  if K_CMGAModePrintTemplatesSaveFlag then
    Result := EDAPrintLocMemIniSave();
  N_Dump2Str( 'GA Mode is cleared' );
end; // procedure TK_CMEDAccess.EDAClearGAMode

//**************************************** TK_CMEDAccess.EDAClearSlidesCRFC ***
// Clear Slides Change Root Folder Context
//
procedure TK_CMEDAccess.EDAClearSlidesCRFC;
begin
  with SlidesCRFC do
  begin
    RootFolder := ''; // New Root Folder
    CopiedFNum := 0; // Copied Files Number
    CopiedFSize := 0; // Copied Files Size
    RootFDA := false; // Direct Access to Files at New Root Folder from Client Computer
    MediaFCopy := false; // Media Files Move to New Root Folder Flag
    MediaFSplit := false; // Media Files Split at New Root Folder Flag
    Img3DFCopy  := false; // 3D Img Move to New Root Folder Flag
    MovingFSDDescr := 0; // Moving Files Source and Destination description
    OpProvID := -1; // Operating Provider ID
    ChangePathStage := 0;
  end;
end; // end of TK_CMEDAccess.EDAClearSlidesCRFC

//****************************** TK_CMEDAccess.EDAVobjAttrsMemIniToCurState ***
// Apply Global Context from MemIni to Current State
//
procedure TK_CMEDAccess.EDAVobjAttrsMemIniToCurState;
var
  UDAttrs: TN_UDCompBase;
  PUP: TN_POneUserParam;
//  PFont: TN_PNFont;
//  POneTextBlock: TN_POneTextBlock;
begin
  UDAttrs := TN_UDCompBase(ArchMLibRoot.DirChildByObjName('CommonAttrs'));
  if UDAttrs <> nil then
  begin
    PUP := N_GetUserParPtr(UDAttrs.R, 'LineWidth');
    if PUP <> nil then
      with PUP.UPValue do
        PFloat(P)^ := N_MemIniToDbl('VObjAttrs', 'LineWidth', PFloat(P)^);

    PUP := N_GetUserParPtr(UDAttrs.R, 'MainColor');
    if PUP <> nil then
      with PUP.UPValue do
        PColor(P)^ := N_StrToColor(N_MemIniToString('VObjAttrs', 'LineColor',
            N_ColorToHTMLHex(PColor(P)^)));
  end;
// Restore Text Attrs from context to library
  UDAttrs := TN_UDCompBase(ArchMLibRoot.DirChildByObjName('Text'));
  if UDAttrs <> nil then
    K_CMVobjTextAttrsFromMemIni( 'VObjAttrs', UDAttrs, 0 );

  UDAttrs := TN_UDCompBase(ArchMLibRoot.DirChildByObjName('MLine').DirChildByObjName('Text'));
  if UDAttrs <> nil then
    K_CMVobjTextAttrsFromMemIni( 'VObjAttrs', UDAttrs, 0 );

  UDAttrs := TN_UDCompBase(ArchMLibRoot.DirChildByObjName('NAngle').DirChildByObjName('Text'));
  if UDAttrs <> nil then
    K_CMVobjTextAttrsFromMemIni( 'VObjAttrs', UDAttrs, 0 );

  UDAttrs := TN_UDCompBase(ArchMLibRoot.DirChildByObjName('FAngle').DirChildByObjName('Text'));
  if UDAttrs <> nil then
    K_CMVobjTextAttrsFromMemIni( 'VObjAttrs', UDAttrs, 0 );

  UDAttrs := TN_UDCompBase(ArchMLibRoot.DirChildByObjName('Dot').DirChildByObjName('Text'));
  if UDAttrs <> nil then
    K_CMVobjTextAttrsFromMemIni( 'VObjAttrs', UDAttrs, 0 );
end; // end of TK_CMEDAccess.EDAVobjAttrsMemIniToCurState

//********************************* TK_CMEDAccess.EDAGlobalMemIniToCurState ***
// Apply Global Context from MemIni to Current State (in GA mode)
//
procedure TK_CMEDAccess.EDAGlobalMemIniToCurState;
begin
  N_Dump2Str( 'EDAGlobalMemIniToCurState start' );

//  K_CMLockPatientFlag := N_MemIniToBool('CMS_Main', 'LockPatient', false);
//  K_CMD4WNewPatMode := N_MemIniToInt('CMS_Main', 'NewPatientMode', 0);

  if N_CM_MainForm <> nil then
    N_CM_MainForm.CMMDevGroupInd := N_MemIniToInt('CMS_Main', 'DeviceGroupInd', 0);
  // !!SkipOldReg  K_CMSLiDBRegCheckMode := N_MemIniToInt( 'CMS_Main', 'DBRegCheckMode', 0 );

  K_CMSSkip16bitMode := N_MemIniToBool('CMS_Main', 'Skip16bitMode', FALSE );

  K_CMSRImageNotGDIType := N_MemIniToInt('CMS_Main', 'RImageNotGDIType', 2 );
  K_CMSRImageType := N_MemIniToInt('CMS_Main', 'RImageType', K_CMSRImageNotGDIType );
  if (K_CMSRImageType <> 0) and (K_CMSRImageType <> K_CMSRImageNotGDIType) then
    K_CMSRImageType := K_CMSRImageNotGDIType;

  K_CMPShowDebugDlgFlag := N_MemIniToBool('CMS_UserDeb', 'CopyMovePatDataDlg', FALSE );

//  K_CMGUIDICOMMenuVisFlag := N_MemIniToBool( 'CMS_Main', 'DICOMImportVisible', FALSE );
  K_CMGUIDICOMMenuVisFlag := N_MemIniToBool( 'CMS_Main', 'DICOMImportVisible', K_CMDemoModeFlag );

  K_CMSLastVersion := N_MemIniToString('CMS_Main', 'LastRunVersion', '' );

  K_CMDisableDiskAccessCheck    := N_MemIniToBool( 'CMS_UserMain', 'DisableDiskAccessCheck', FALSE );
  K_CMDisableDiskFreeSpaceCheck := N_MemIniToBool( 'CMS_UserMain', 'DisableDiskFreeSpaceCheck', FALSE );

  N_Dump1Str( format( '!!!DiskCheckModes Access=%s FreeSpace=%s',
              [N_B2S(not K_CMDisableDiskAccessCheck),
               N_B2S(not K_CMDisableDiskFreeSpaceCheck)] ) );

// 2020-12-12 save in Global Context
//  K_CMDCMSettingsStoreMode := N_MemIniToInt( 'CMS_Main', 'DCMQRSetStoreMode', 1 );
//
//  K_CMDICOMSettingsStoreModeApply();

end; // end of TK_CMEDAccess.EDAGlobalMemIniToCurState

//********************************* TK_CMEDAccess.EDAGlobalCurStateToMemIni ***
// Apply Global Context from Current State to MemIni (in GA mode)
//
procedure TK_CMEDAccess.EDAGlobalCurStateToMemIni;
begin
  N_IntToMemIni('CMS_Main', 'DeviceGroupInd', N_CM_MainForm.CMMDevGroupInd);

  N_BoolToMemIni('CMS_Main', 'Skip16bitMode', K_CMSSkip16bitMode );
  N_IntToMemIni('CMS_Main', 'RImageType', K_CMSRImageType);

  N_BoolToMemIni('CMS_Main', 'DICOMImportVisible', K_CMGUIDICOMMenuVisFlag );
  N_StringToMemIni('CMS_Main', 'LastRunVersion', N_CMSVersion );

// 2020-12-12 save in Global Context
//  if K_CMDCMSettingsStoreMode = 1 then
//    N_CurMemIni.DeleteKey( 'CMS_Main', 'DCMQRSetStoreMode' )
//  else
//    N_IntToMemIni( 'CMS_Main', 'DCMQRSetStoreMode', K_CMDCMSettingsStoreMode  );
//
//  K_CMDICOMSettingsStoreModeApply();

end; // end of TK_CMEDAccess.EDAGlobalCurStateToMemIni

//************************************* TK_CMEDAccess.EDAGAGlobalToCurState ***
// Get GA Global Context to Current State
//
function TK_CMEDAccess.EDAGAGlobalToCurState : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAGAGlobalToCurState

//******************************** TK_CMEDAccess.EDAGlobal2MemIniToCurState ***
// Apply Global Context from MemIni to Current State (not in GA mode)
//
procedure TK_CMEDAccess.EDAGlobal2MemIniToCurState;
var
  WScanDataPath : string;
begin
  N_Dump2Str( 'EDAGlobal2MemIniToCurState start' );
  if N_MemIniToBool('CMS_Main', 'WinDrawSmoothMode', false) then
    K_CMStretchBltMode := HALFTONE
  else
    K_CMStretchBltMode := COLORONCOLOR;

  N_UDDIBRectStretchBltMode := K_CMStretchBltMode;

  K_CMPatSlidesAutoRefreshLag := N_MemIniToInt('CMS_Main', 'PatSlidesAutoRefreshLag', 0); // Patient Slides Auto Refresh Lag in seconds

  K_CMScanDataPathOnClientPC    := N_MemIniToBool( 'CMS_Main', 'ScanDataPathOnClientPC', FALSE );
  K_CMScanDataPathOnClientPCAuto:= N_MemIniToBool( 'CMS_Main', 'ScanDataPathOnClientPCAuto', FALSE );
  K_CMScanDataPath    := N_MemIniToString( 'CMS_Main', 'ScanDataPath', '' );
  K_CMScanDataPathOld := N_MemIniToString( 'CMS_Main', 'ScanDataPathOld', '' );


  if K_CMDesignModeFlag then // for debug
    K_CMScanClientName := K_CMSServerClientInfo.CMSClientVirtualName // For Testing in not TerminalServer Environment
  else
    K_CMScanClientName := '';


  if not K_CMVUIMode then
  begin // CMSuite
    if K_CMSServerClientInfo.CMSSessionInfo.WTSClientProtocolType <> WTS_PROTOCOL_TYPE_CONSOLE then
      K_CMScanClientName := K_CMSServerClientInfo.CMSSessionInfo.WTSClientName;
  end
  else // CMSuiteWEB
    K_CMScanClientName := K_CMVUIScanName;

  if K_CMScanClientName <> '' then
  begin
    WScanDataPath := K_CMScanGetCurDataPath( );
    K_CMScanIsInstalled  := (WScanDataPath <> '') and
                            DirectoryExists( WScanDataPath + K_CMScanClientName + '\' );
//    K_CMScanIsInstalled  := (K_CMScanDataPath <> '') and
//                            DirectoryExists( K_CMScanDataPath + K_CMScanClientName + '\' );
    K_CMScanWasInstalled := not K_CMScanIsInstalled      and
                            (K_CMScanDataPathOld <> '')  and
                            DirectoryExists( K_CMScanDataPathOld + K_CMScanClientName + '\');
    N_Dump1Str('DB>> ScanDataInfo:'#13#10 +
    'ScanDataPath "' + K_CMScanDataPath + '"'#13#10 +
    'ScanDataPathOld "' + K_CMScanDataPathOld + '"'#13#10 +
    'ScanDataPath ClientPC=' + N_B2S(K_CMScanDataPathOnClientPC) +
                   ' ClientPCAuto=' + N_B2S(K_CMScanDataPathOnClientPCAuto) +
                   ' IsInstalled=' + N_B2S(K_CMScanIsInstalled) +
                   ' WasInstalled=' + N_B2S(K_CMScanWasInstalled) + #13#10 +
    'UsedScanDataPath "' + WScanDataPath + '"');
{
    N_Dump1Str('DB>> ScanDataPath "' + K_CMScanDataPath + '"');
    N_Dump1Str('DB>> ScanDataPathOld "' + K_CMScanDataPathOld + '"');
    N_Dump1Str('DB>> ScanDataPath ClientPC=' + N_B2S(K_CMScanDataPathOnClientPC) +
                   ' ClientPCAuto=' + N_B2S(K_CMScanDataPathOnClientPCAuto) +
                   ' IsInstalled=' + N_B2S(K_CMScanIsInstalled) +
                   ' IsInstalled=' + N_B2S(K_CMScanWasInstalled) );
    N_Dump1Str('DB>> UsedScanDataPath "' + WScanDataPath + '"');
}
  end // if K_CMScanClientName <> '' then
  else
  begin
    K_CMScanIsInstalled := FALSE;
    K_CMScanWasInstalled := FALSE;
  end;

  K_CMIURemindeTS     := N_MemIniToInt('CMS_Main', 'IURemindeTS', 0 );   // Internet Upgrade Last Timestamp
  K_CMIURemindeInDays := N_MemIniToInt('CMS_Main', 'IURemindeInDays', -1 ); // Internet Upgrade Interval in days
  K_CMIUCheckUpdatesPath := N_MemIniToString('CMS_Main', 'IUCheckUpdatesPath',
                                  K_ExpandFileName('(#BasePath#)') + 'IU\IU.exe' ); // Path to Internet Upgrade application
//                     'C:\CMS\IU\IU.exe' ); // Path to Internet Upgrade application
  K_CMIUCheckUpdatesCMDLType := N_MemIniToInt('CMS_Main', 'IUCheckUpdatesCMDLType', 0 ); // Internet Upgrade application CMDL type
  N_Dump1Str( format( 'DB>> IU TS=%g D=%d E=%s T=%d', [K_CMIURemindeTS, K_CMIURemindeInDays,
                                             K_CMIUCheckUpdatesPath, K_CMIUCheckUpdatesCMDLType] ) );

// Move this code to EDAInstanceMemIniToCurState 2019-11-18
//  K_CMVUIScanPortNumber := N_MemIniToInt('CMS_WEBSettings', 'CMScanPortNumber', 81 );

  if (N_CM_MainForm <> nil) and
     Assigned(N_CM_MainForm.CMMCurUpdateCustToolBar) and (K_CMUseCustToolbarInd = 2) then
  begin
    K_CMInitIniFileCustToolbarCont( );
    N_CM_MainForm.CMMCurUpdateCustToolBar();
  end;

   K_CMDCMStoreCommitmentFlag := N_MemIniToBool( 'CMS_Main', 'DMCStoreCommitment', FALSE );
   K_CMDCMStoreAutoFlag := N_MemIniToBool( 'CMS_Main', 'DCMStoreAuto', FALSE );

end; // end of TK_CMEDAccess.EDAGlobal2MemIniToCurState

//******************************** TK_CMEDAccess.EDAGlobal2CurStateToMemIni ***
// Apply Global Context from Current State to MemIni (not in GA mode)
//
procedure TK_CMEDAccess.EDAGlobal2CurStateToMemIni;
begin
  // !!SkipOldReg  N_IntToMemIni( 'CMS_Main', 'DBRegCheckMode', K_CMSLiDBRegCheckMode );
  N_BoolToMemIni( 'CMS_Main', 'WinDrawSmoothMode', K_CMStretchBltMode = HALFTONE );

  N_BoolToMemIni( 'CMS_Main', 'ScanDataPathOnClientPC', K_CMScanDataPathOnClientPC );
  N_BoolToMemIni( 'CMS_Main', 'ScanDataPathOnClientPCAuto', K_CMScanDataPathOnClientPCAuto );
  N_StringToMemIni( 'CMS_Main', 'ScanDataPath', K_CMScanDataPath);
  N_StringToMemIni( 'CMS_Main', 'ScanDataPathOld', K_CMScanDataPathOld);

  N_IntToMemIni( 'CMS_Main', 'PatSlidesAutoRefreshLag', K_CMPatSlidesAutoRefreshLag); // Patient Slides Auto Refresh Lag in seconds

  N_IntToMemIni( 'CMS_Main', 'IURemindeTS', Round(K_CMIURemindeTS) );   // Internet Upgrade Last Timestamp
  N_IntToMemIni( 'CMS_Main', 'IURemindeInDays', K_CMIURemindeInDays ); // Internet Upgrade Interval in days
  N_IntToMemIni( 'CMS_Main', 'IUCheckUpdatesCMDLType', K_CMIUCheckUpdatesCMDLType ); // Internet Upgrade application CMDL type
  if not SameText( K_CMIUCheckUpdatesPath, K_ExpandFileName('(#BasePath#)') + 'IU\IU.exe' ) then
  // if CurPath <> Default path then // 2020-09-01
    N_StringToMemIni( 'CMS_Main', 'IUCheckUpdatesPath', K_CMIUCheckUpdatesPath ); // Path to Internet Upgrade application

// Move this code to EDAInstanceCurStateToMemIni 2019-11-18
//  N_IntToMemIni('CMS_WEBSettings', 'CMScanPortNumber', K_CMVUIScanPortNumber );

  N_BoolToMemIni( 'CMS_Main', 'DMCStoreCommitment', K_CMDCMStoreCommitmentFlag );
  N_BoolToMemIni( 'CMS_Main', 'DCMStoreAuto', K_CMDCMStoreAutoFlag );

end; // end of TK_CMEDAccess.EDAGlobal2CurStateToMemIni

//********************************** TK_CMEDAccess.EDANotGAGlobalToCurState ***
// Get not GA Global Context to Current State
//
function TK_CMEDAccess.EDANotGAGlobalToCurState : TK_CMEDResult;
begin
  EDAGlobal2MemIniToCurState();
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDANotGAGlobalToCurState

//************************************ TK_CMEDAccess.EDANotGAGlobalToMemIni ***
// Put not GA Global Context to MemIni  (save inside all contexts saving procedure)
//
// Saving context is set in all contexts saving procedure
//
function TK_CMEDAccess.EDANotGAGlobalToMemIni : TK_CMEDResult;
begin
  EDAGlobal2CurStateToMemIni();
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDANotGAGlobalToMemIni

//*********************************** TK_CMEDAccess.EDANotGAGlobalToMemIni1 ***
// Put not GA Global Context to MemIni (separate saving)
//
function TK_CMEDAccess.EDANotGAGlobalToMemIni1 : TK_CMEDResult;
begin
  Result := EDANotGAGlobalToMemIni();
end; // end of TK_CMEDAccess.EDANotGAGlobalToMemIni1

//********************************************* TK_CMEDAccess.EDAInstanceCurStateToMemIni ***
// Apply Instance Context from Current State to MemIni
//
procedure TK_CMEDAccess.EDAInstanceCurStateToMemIni;
begin
// 2025-09-12
//  N_IntToMemIni('CMS_Main', 'MediaFilesStoringMode', K_CMMediaFilesStoringMode);
//  N_StringToMemIni( 'FileGPaths', 'CMMediaFiles', K_CMEDAccess.SlidesClientMediaRootFolder );
  N_StringToMemIni('CMS_Main', 'CMMediaFiles', SlidesClientMediaRootFolder);
  N_DblToMemIni('CMS_Main', 'CaptButtonDelay', '%g', K_CMCaptButDelay);
  N_BoolToMemIni('CMS_Main', 'SlideAutoOpen', K_CMSlideAutoOpen );
  N_StringToMemIni('CMS_Main', 'ScanDataPathAuto', K_CMScanDataPathAuto);

  N_IntToMemIni('CMS_WEBSettings', 'CMScanPortNumber', K_CMVUIScanPortNumber );
end; // end of TK_CMEDAccess.EDAInstanceCurStateToMemIni

//********************************************* TK_CMEDAccess.EDAInstanceMemIniToCurState ***
// Apply Instance Context from MemIni to Current State
//
procedure TK_CMEDAccess.EDAInstanceMemIniToCurState;
var
  SMemConstr: string;
begin
  N_Dump2Str( 'EDAInstanceMemIniToCurState start' );
  SMemConstr := N_MemIniToString('CMS_Main', 'ImgMemConstraints', '200000000 400000000 600000000 800000000');
  if SMemConstr <> '' then
    K_CMImgStopMemFreeSize := N_ScanInteger(SMemConstr);
  if SMemConstr <> '' then
    K_CMImgStartMemFreeSize := N_ScanInteger(SMemConstr);
  N_Dump1Str( format( 'ImgMemConstraints FreeStartSize=%u FreeStopSize=%u',
                       [K_CMImgStartMemFreeSize, K_CMImgStopMemFreeSize] ) );
{ 2015-09-12
  // Only Server - default mode
  K_CMMediaFilesStoringMode := N_MemIniToInt('CMS_Main', 'MediaFilesStoringMode', 1);
}
  K_CMMediaFilesStoringMode := 1;     // 2015-09-12

  SlidesClientMediaRootFolder := N_MemIniToString('CMS_Main', 'CMMediaFiles', '');
  if SlidesClientMediaRootFolder = '' then
    SlidesClientMediaRootFolder := K_GetDirPath('CMMediaFiles');
  SlidesClientMediaRootFolder := IncludeTrailingPathDelimiter(SlidesClientMediaRootFolder);
  N_Dump2Str('MediaClientRootFolder "' + SlidesClientMediaRootFolder + '"');

  K_CMCaptButDelay  := N_MemIniToDbl('CMS_Main', 'CaptButtonDelay', 2);
  K_CMSlideAutoOpen := N_MemIniToBool('CMS_Main', 'SlideAutoOpen', FALSE);

  N_FPCBObj.FPCBInitDU();

  K_CMScanDataPathAuto := N_MemIniToString( 'CMS_Main', 'ScanDataPathAuto', '' );

  K_CMVUIScanPortNumber := N_MemIniToInt('CMS_WEBSettings', 'CMScanPortNumber', 81 );

end; // end of TK_CMEDAccess.EDAInstanceMemIniToCurState

//********************************************* TK_CMEDAccess.EDAPatientCurStateToMemIni ***
// Apply Patient Context from Current State to MemIni
//
procedure TK_CMEDAccess.EDAPatientCurStateToMemIni;
begin
  N_BoolToMemIni('CMS_Main', 'StudyOnlyThumbsShowMode', K_CMStudyOnlyThumbsShowGUIModeFlag );
end; // end of TK_CMEDAccess.EDAPatientCurStateToMemIni

//********************************************* TK_CMEDAccess.EDAPatientMemIniToCurState ***
// Apply Patient Context from MemIni to Current State
//
procedure TK_CMEDAccess.EDAPatientMemIniToCurState;
begin
  N_Dump2Str( 'EDAPatientMemIniToCurState start' );
  N_StringToMemIni  ( 'K_FormCMPrintState', 'PageTitle', '' ); // clear tittle after patient change
  K_CMStudyOnlyThumbsShowGUIModeFlag := N_MemIniToBool('CMS_Main', 'StudyOnlyThumbsShowMode', FALSE );
  N_CMResForm.aViewStudyOnly.Checked := K_CMStudyOnlyThumbsShowGUIModeFlag;
end; // end of TK_CMEDAccess.EDAPatientMemIniToCurState

//******************************* TK_CMEDAccess.EDAProviderCurStateToMemIni ***
// Apply Provider Context from Current State to MemIni
//
procedure TK_CMEDAccess.EDAProviderCurStateToMemIni;
var
  WStr : string;
begin
  with N_CM_MainForm do
  begin
    // N_IntToMemIni( 'CMS_Main', 'ThumbsRFrameWidth', ThumbsRFrame.Width );
//    N_IntToMemIni('CMS_Main', 'EdFramesLayout', Integer(CMMFEdFrLayout));
    WStr := IntToStr( Integer(CMMFEdFrLayout) );
    N_StringToMemIni( 'CMS_Main', 'EdFramesLayout', WStr );
    N_Dump1Str( 'DB >> FramesLayout=' + WStr );
  end;

  N_BoolToMemIni( 'CMS_Main', 'UIShowEmbossDetails', N_CMResForm.aToolsEmbossAttrs.Visible );

  N_BoolToMemIni('CMS_Main', 'XRayCaptStreamLine', K_CMXrayCaptStreamLineMode);
  N_BoolToMemIni('CMS_Main', 'VTBAlterations', N_CMResForm.aVTBAlterations.Checked);
  // N_BoolToMemIni( 'CMS_Main', 'VTBCapture',     N_CMResForm.aVTBCapture.Checked );
  // N_BoolToMemIni( 'CMS_Main', 'VTBSystem',      N_CMResForm.aVTBSystem.Checked );
  // N_BoolToMemIni( 'CMS_Main', 'VTBViewFilt',    N_CMResForm.aVTBViewFilt.Checked );
  N_BoolToMemIni('CMS_Main', 'VTBAllTopToolbars', N_CMResForm.aVTBAllTopToolbars.Checked);

  N_StringToMemIni('CMS_Main', 'CurTeethFilter',
    IntToStr(K_CMCurSlideFilterAttrs.FATeethFlags));
  N_StringToMemIni('CMS_Main', 'CurMTypeFilter',
    IntToStr(K_CMCurSlideFilterAttrs.FAMediaType));

  N_IntToMemIni('CMS_Main', 'FlashlightRectFlag', K_CMFlashlightIni.CMFLRectFlag);

  N_SPLValToMemIni( 'CMS_Main', 'ThumbTextFlags', K_CMSThumbTextFlags,
                     K_GetTypeCodeSafe( 'TK_CMSThumbTextFlagsSet' ).DTCode );

  N_IntToMemIni('CMS_Flashlight', 'PixSize', K_CMFlashlightModeIni.CMFLPixSize);
  N_IntToMemIni('CMS_Flashlight', 'RectFlag', K_CMFlashlightModeIni.CMFLRectFlag);
  N_IntToMemIni('CMS_Flashlight', 'Mode', Ord(K_CMFlashlightModeIni.CMFLMode) );
  N_DblToMemIni('CMS_Flashlight', 'ScaleFactor', '%g', K_CMFlashlightModeIni.CMFLScaleFactor);
  N_DblToMemIni('CMS_Flashlight', 'GamFactor', '%g', K_CMFlashlightModeIni.CMFLGamFactor);
  N_DblToMemIni('CMS_Flashlight', 'EmbAngle', '%g', K_CMFlashlightModeIni.CMFLEmbAngle);
  N_DblToMemIni('CMS_Flashlight', 'EmbCoef', '%g', K_CMFlashlightModeIni.CMFLEmbCoef);
  N_IntToMemIni('CMS_Flashlight', 'EmbDepth', K_CMFlashlightModeIni.CMFLEmbDepth);
  N_IntToMemIni('CMS_Flashlight', 'EmbBaseGrey', K_CMFlashlightModeIni.CMFLEmbBaseGrey);

  N_IntToMemIni('CMS_Main', 'EmailAttachSizeInd',K_CMSlideEESizeInd);
//  N_IntToMemIni('CMS_Main', 'EmailExportNameFlagsSet', Byte(K_CMSlideEEFNameFlagsSet));
  N_IntToMemIni('CMS_Main', 'EmailExportNameFlagsSet', Word(K_CMSlideEEFNameFlagsSet));

//  N_BoolToMemIni( 'CMS_Main', 'UseCustToolbarGlobal', K_CMUseCustToolbarGlobal );
  N_IntToMemIni( 'CMS_Main', 'UseCustToolbarGlobal', K_CMUseCustToolbarInd );

  N_IntToMemIni('CMS_Main', 'StudyCaptPreviewTimeout', K_CMStudyCaptPreviewTimeout);
end; // end of TK_CMEDAccess.EDAProviderCurStateToMemIni

//******************************* TK_CMEDAccess.EDAProviderMemIniToCurState ***
// Apply Provider Context from MemIni to Current State
//
procedure TK_CMEDAccess.EDAProviderMemIniToCurState;
var
  WStr : string;
  PalDefInd : Integer;
begin
  N_Dump2Str( 'EDAProviderMemIniToCurState start' );
  with N_CM_MainForm do
  begin
    // ThumbsRFrame.Width := N_MemIniToInt( 'CMS_Main', 'ThumbsRFrameWidth', 90 );

    WStr := N_MemIniToString( 'CMS_Main', 'EdFramesLayout', '1' );
    N_Dump1Str( 'DB >> FramesLayout=' + WStr );
    CMMFSetEdFramesLayout0( TN_EdFrLayout( StrToIntDef( WStr, 1 ) ) );
//    CMMFSetEdFramesLayout0(TN_EdFrLayout(N_MemIniToInt('CMS_Main',
//          'EdFramesLayout', 1)));

    N_CMResForm.aToolsEmbossAttrs.Visible :=
       N_MemIniToBool( 'CMS_Main', 'UIShowEmbossDetails', false );

    K_CMXrayCaptStreamLineMode := N_MemIniToBool('CMS_Main', 'XRayCaptStreamLine', false);
    N_CMResForm.aServXRAYStreamLine.Checked := K_CMXrayCaptStreamLineMode;

    N_CMResForm.aVTBAlterations.Checked := N_MemIniToBool('CMS_Main', 'VTBAlterations', TRUE);
    // N_CMResForm.aVTBCapture.Checked  := N_MemIniToBool( 'CMS_Main', 'VTBCapture', True );
    // N_CMResForm.aVTBSystem.Checked   := N_MemIniToBool( 'CMS_Main', 'VTBSystem', True );
    // N_CMResForm.aVTBViewFilt.Checked := N_MemIniToBool( 'CMS_Main', 'VTBViewFilt', True );
    N_CMResForm.aVTBAllTopToolbars.Checked := N_MemIniToBool('CMS_Main', 'VTBAllTopToolbars', TRUE);

//    CMFilterProfiles

//    Realign();
  end;
  K_CMCurSlideFilterAttrs.FATeethFlags := StrToInt64Def(
          N_MemIniToString('CMS_Main', 'CurTeethFilter', ''), 0);
  K_CMCurSlideFilterAttrs.FAMediaType := StrToIntDef(
          N_MemIniToString('CMS_Main', 'CurMTypeFilter', ''), K_CMFilterAllMTypesVal);

  K_CMToothNumSchemeFlag := N_MemIniToBool('CMS_Main', 'FDIToothScheme', TRUE);

  // Default Palete Should be MultiColor1
  PalDefInd := K_CMSColorizePalettes.IndexOfName('Multicolour 1');
  if PalDefInd = -1 then PalDefInd := 0;
  K_CMColorizePalIndex := N_MemIniToInt('CMS_Main', 'ColorPalIndex', PalDefInd);
//  K_CMColorizePalIndex := N_MemIniToInt('CMS_Main', 'ColorPalIndex', 0);

  EDAVobjAttrsMemIniToCurState();

  K_CMFlashlightIni.CMFLRectFlag := N_MemIniToInt('CMS_Main', 'FlashlightRectFlag', 0);

  K_CMSThumbTextFlags := [ttsObjDateTaken, ttsObjTeethChart];
  N_MemIniToSPLVal( 'CMS_Main', 'ThumbTextFlags', K_CMSThumbTextFlags,
                     K_GetTypeCodeSafe( 'TK_CMSThumbTextFlagsSet' ).DTCode );
  N_CM_MainForm.CMMInitThumbFrameTexts(); // apply K_CMSThumbTextFlags

  N_CurMemIni.DeleteKey( 'N_Forms', 'K_FormCMSZoomMode' ); // Clear ZoomMode Form Coordinates

  K_CMFlashlightModeIni.CMFLPixSize := N_MemIniToInt('CMS_Flashlight', 'PixSize', 100);
  K_CMFlashlightModeIni.CMFLRectFlag := N_MemIniToInt('CMS_Flashlight', 'RectFlag', 0);
  K_CMFlashlightModeIni.CMFLMode := TN_UDDIBRectMode(N_MemIniToInt('CMS_Flashlight', 'Mode', 0));
  K_CMFlashlightModeIni.CMFLScaleFactor := N_MemIniToDbl('CMS_Flashlight', 'ScaleFactor', 2);
  K_CMFlashlightModeIni.CMFLGamFactor := N_MemIniToDbl('CMS_Flashlight', 'GamFactor', 0);
  K_CMFlashlightModeIni.CMFLEmbAngle := N_MemIniToDbl('CMS_Flashlight', 'EmbAngle', 45);
  K_CMFlashlightModeIni.CMFLEmbCoef := N_MemIniToDbl('CMS_Flashlight', 'EmbCoef', 10);
  K_CMFlashlightModeIni.CMFLEmbDepth := N_MemIniToInt('CMS_Flashlight', 'EmbDepth', 3);
  K_CMFlashlightModeIni.CMFLEmbBaseGrey := N_MemIniToInt('CMS_Flashlight', 'EmbBaseGrey', 128);

// 2019-10-16 - default Original Size Selection
  K_CMSlideEESizeInd := N_MemIniToInt('CMS_Main', 'EmailAttachSizeInd', 4);
//  K_CMSlideEESizeInd := N_MemIniToInt('CMS_Main', 'EmailAttachSizeInd', 0);

  K_CMSlideEEFNameFlagsSet := // Default Value
    [K_efnPatSurname,K_efnPatFirstname,K_efnPatTitle,K_efnPatCardNum,
     K_efnObjDTaken,K_efnObjID];

//  K_CMSlideEEFNameFlagsSet := TK_CMSlideEEFNameFlagsSet(Byte(
  K_CMSlideEEFNameFlagsSet := TK_CMSlideEEFNameFlagsSet(Word(
       N_MemIniToInt('CMS_Main', 'EmailExportNameFlagsSet', Word(K_CMSlideEEFNameFlagsSet))
                                                       ));
  Include( K_CMSlideEEFNameFlagsSet, K_efnObjID );

//  K_CMUseCustToolbarGlobal := N_MemIniToBool( 'CMS_Main', 'UseCustToolbarGlobal', FALSE );
  K_CMUseCustToolbarIndPev := K_CMUseCustToolbarInd;
  K_CMUseCustToolbarInd := N_MemIniToInt( 'CMS_Main', 'UseCustToolbarGlobal', -1 );
  if K_CMUseCustToolbarInd = -1 then // Not Integer Value
  begin // 'UseCustToolbarGlobal' Not Integer Value
    WStr := N_MemIniToString( 'CMS_Main', 'UseCustToolbarGlobal', ' ' );
    if (WStr = ' ' ) or (WStr[1] = 'F') then
      K_CMUseCustToolbarInd := 0 // 'UseCustToolbarGlobal' Absent OR Old Value 'FALSE'
    else
      K_CMUseCustToolbarInd := 1 // 'UseCustToolbarGlobal' Old Value 'TRUE'
  end;

//    if K_CMUseCustToolbarInd = 3 then
  if Assigned(N_CM_MainForm.CMMCurUpdateCustToolBar) and (K_CMUseCustToolbarInd = 3) then
  begin
    K_CMInitIniFileCustToolbarCont( );
    N_CM_MainForm.CMMCurUpdateCustToolBar();
    K_CMUseCustToolbarIndPev := K_CMUseCustToolbarInd;
  end;
{
  K_CMInitIniFileCustToolbarCont( );
  with N_CM_MainForm do
  begin
    if Assigned(CMMCurUpdateCustToolBar) then
      CMMCurUpdateCustToolBar();
    CMMFChangeToolBarsVisibility();
  end;
}
  K_CMStudyCaptPreviewTimeout := N_MemIniToInt('CMS_Main', 'StudyCaptPreviewTimeout', 0);
end; // end of TK_CMEDAccess.EDAProviderMemIniToCurState

//*********************** TK_CMEDAccess.EDAProviderInstanceCurStateToMemIni ***
// Apply Provider/Instance Context from Current State to MemIni
//
procedure TK_CMEDAccess.EDAProviderInstanceCurStateToMemIni;
begin
  with N_CM_MainForm do
  begin
//    if CMMCurFThumbsRFrame <> nil then
    if CMMCurFThumbsResizeTControl <> nil then
      CMMCurFThumbsResizeWidth := CMMCurFThumbsResizeTControl.Width;
    N_IntToMemIni('CMS_Main', 'ThumbsRFrameWidth', CMMCurFThumbsResizeWidth);
    N_Dump2Str( 'Save ThumbsRFrameWidth >> ' + IntToStr(CMMCurFThumbsResizeWidth) )
  end;
end; // end of TK_CMEDAccess.EDAProviderInstanceCurStateToMemIni

//*********************** TK_CMEDAccess.EDAProviderInstanceMemIniToCurState ***
// Apply Provider/Instance Context from MemIni to Current State
//
procedure TK_CMEDAccess.EDAProviderInstanceMemIniToCurState;
begin
  N_Dump2Str( 'EDAProviderInstanceMemIniToCurState start' );
  with N_CM_MainForm do
  begin
//    CMMCurFThumbsRFrame.Width := N_MemIniToInt('CMS_Main', 'ThumbsRFrameWidth', 90);

// This check is needed because in some cases this method may be called before Interface Form context is ready
    if CMMCurFThumbsResizeTControl <> nil then
    begin
      CMMCurFThumbsResizeWidth := N_MemIniToInt('CMS_Main', 'ThumbsRFrameWidth', 90);
      CMMCurFThumbsResizeTControl.Width := CMMCurFThumbsResizeWidth;
      N_Dump2Str( 'Set ThumbsRFrameWidth >> ' + IntToStr(CMMCurFThumbsResizeWidth) )
    end;

// 2019-11-26 SIR 24115
//    if (N_MemIniToString( 'CMS_Main', 'CustToolbarSmallButtons',  '' ) = '') {and
//       (N_MemIniToString( 'CMS_Main', 'GCustToolbarSmallButtons',  '' ) = '') and
//       (N_MemIniToString( 'CMS_Main', 'GGCustToolbarSmallButtons',  '' ) = '')} then
{    begin //
    // Init ToolBar Settings - empty Cust Toolbar Context
      N_BoolToMemIni( 'CMS_Main', 'CustToolbarSmallButtons',  FALSE );

      if N_MemIniToString( 'CMCustToolbar', '0', '' ) = '' then
      begin // Init Init Cust Toolbar Context
        N_StringToMemIni( 'CMCustToolbar', '0', 'aEditUndoLast' );
        N_StringToMemIni( 'CMCustToolbar', '1', 'aEditUndoRedo' );
        N_StringToMemIni( 'CMCustToolbar', '2', 'aToolsBriCoGam' );
        N_StringToMemIni( 'CMCustToolbar', '3', 'aToolsNegate11' );
        N_StringToMemIni( 'CMCustToolbar', '4', 'aToolsEmboss' );
        N_StringToMemIni( 'CMCustToolbar', '5', 'aToolsColorize' );
        N_StringToMemIni( 'CMCustToolbar', '6', 'aToolsIsodens' );
        N_StringToMemIni( 'CMCustToolbar', '7', 'aToolsRotateLeft' );
        N_StringToMemIni( 'CMCustToolbar', '8', 'aToolsRotateRight' );
        N_StringToMemIni( 'CMCustToolbar', '9', 'aToolsRotate180' );
        N_StringToMemIni( 'CMCustToolbar', '10', 'aToolsFlipHorizontally' );
        N_StringToMemIni( 'CMCustToolbar', '11', 'aToolsFlipVertically' );
        N_Dump1Str( 'Init CMCustToolbar Context' );
      end; // Init Cust Toolbar Context

      N_MemIniToStrings( 'CMCustToolbar', K_CMEDAccess.TmpStrings );
      N_StringsToMemIni( 'CMCustToolbar0', K_CMEDAccess.TmpStrings );
      N_Dump1Str( 'Init CMCustToolbar0' );
    end;// Init Cust Toolbar Context


    if Assigned(CMMCurUpdateCustToolBar) and
       ((K_CMUseCustToolbarInd = 0) or (K_CMUseCustToolbarIndPev <> K_CMUseCustToolbarInd)) then
      CMMCurUpdateCustToolBar();

    CMMFChangeToolBarsVisibility();
}
//    if Assigned(N_CM_MainForm.CMMCurUpdateCustToolBar) and (K_CMUseCustToolbarInd = 0) then
    if Assigned(N_CM_MainForm.CMMCurUpdateCustToolBar) and
      ( (K_CMUseCustToolbarInd = 0) or                              // UseCustToolbar ProviderInstance Type or
        (K_CMUseCustToolbarIndPev <> K_CMUseCustToolbarInd) ) then  // prev UseCustToolbar Type <> Provider UseCustToolbar Type (1 or 2)
    begin
    // K_CMUseCustToolbarInd = 0 or 1 or 2
      K_CMInitIniFileCustToolbarCont( );
      N_CM_MainForm.CMMCurUpdateCustToolBar();
    end;

    CMMFChangeToolBarsVisibility(); // Needed because it was not done in EDAProviderMemIniToCurState

  end; // with N_CM_MainForm do
end; // end of TK_CMEDAccess.EDAProviderInstanceMemIniToCurState

//******************************* TK_CMEDAccess.EDALocationCurStateToMemIni ***
// Apply Location Context from Current State to MemIni
//
procedure TK_CMEDAccess.EDALocationCurStateToMemIni;
begin
end; // end of TK_CMEDAccess.EDALocationCurStateToMemIni

//******************************* TK_CMEDAccess.EDALocationMemIniToCurState ***
// Apply Location Context from MemIni to Current State
//
procedure TK_CMEDAccess.EDALocationMemIniToCurState;
begin
  N_Dump2Str( 'EDALocationMemIniToCurState start' );
  if Assigned(N_CM_MainForm.CMMCurUpdateCustToolBar) and (K_CMUseCustToolbarInd = 1) then
  begin
    K_CMInitIniFileCustToolbarCont( );
    N_CM_MainForm.CMMCurUpdateCustToolBar();
  end;
end; // end of TK_CMEDAccess.EDALocationMemIniToCurState

//************************************* TK_CMEDAccess.EDALocationToCurState ***
// Apply Location Context from MemIni to Current State
//
function TK_CMEDAccess.EDALocationToCurState() : TK_CMEDResult;
begin
  EDALocationMemIniToCurState();
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDALocationMemIniToCurState

//************************************ TK_CMEDAccess.EDALocationToMemIni1 ***
// Put not GA Global Context to MemIni (context separate saving)
//
function TK_CMEDAccess.EDALocationToMemIni1: TK_CMEDResult;
begin
  // Set saving context
  K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
  K_CMEDADFPLExec.DstIniFile := K_CMEDAMemIniFile;
  // Put not GA Global Context to MemIni
  Result := EDANotGAGlobalToMemIni();
end; // function TK_CMEDAccess.EDALocationToMemIni1

//************************************ TK_CMEDAccess.EDAHidePasswordForDump ***
// Put Data to stream
//
//     Parameters
// AStrings - String to hide password
//
procedure TK_CMEDAccess.EDAHidePasswordForDump( AStrings : TStrings; AEncodeLogin : Boolean = FALSE );
{
var
  Ind : Integer;
  PSW : string;
  PSW1 : array [1..100] of AnsiChar;

  procedure PutEncodedString();
  var
    i, n : Integer;
  begin
    // Hide real passowrd Value
    AStrings[Ind] := AStrings.Names[Ind] + '=******';

    // Prepare encoded PSW
    n := Length(PSW);
    Move( N_StringToAnsi( PSW )[1], PSW1[1], n );
    for i := n downto 1 do
    begin
      PSW1[2*i] := AnsiChar(Byte(PSW1[i]) + 1);
      // Random char from '0'$30 to '}//'$7D

{
      PSW1[2*i - 1] := AnsiChar($30 + Round(Random($7D - $30)));
    end; // for i := n downto 1 do
    PSW1[2*n + 1] := #0; // Put terminating Zero

    // Put 'CRC=...' line with encoded Password after '...assword=******' Line
    Inc(Ind);
    PSW := 'CRC=' + N_AnsiToString( AnsiString(@PSW1[1]) );
    if Ind < AStrings.Count then
      AStrings.Insert( Ind, PSW )
    else
      AStrings.Add( PSW );
  end; // PutEncodedString();
}
begin
  K_CMEDAHideLoginPasswordForDump(AStrings, AEncodeLogin );
{
  //Check Login
  if AEncodeLogin then
  begin
    Ind := K_SearchInStrings( AStrings, 'ogin=', 0, 0, FALSE, FALSE, TRUE );
    if Ind >= 0 then
    begin // Hide login value
      PSW := AStrings.ValueFromIndex[Ind];
      if PSW <> '' then
      begin // login is not empty
        PutEncodedString();
      end; // if PSW <> '' then
    end;
  end; // if AEncodeLogin then

  // Check Password
  Ind := K_SearchInStrings( AStrings, 'assword=', 0, 0, FALSE, FALSE, TRUE );
  if Ind >= 0 then
  begin // Hide password value
    PSW := AStrings.ValueFromIndex[Ind];
    if PSW <> '' then
    begin // Password is not empty
      PutEncodedString();
    end; // if PSW <> '' then
  end;
}
end; // procedure TK_CMEDAccess.EDAHidePasswordForDump

//************************************** TK_CMEDAccess.EDASaveSlideToECache ***
// Save given Slide to Emergency Cache using given State Flags
//
//     Parameters
// AUDSlide - Slide to save
//
procedure TK_CMEDAccess.EDASaveSlideToECache(AUDSlide: TN_UDCMSlide);
begin
  AUDSlide.CMSlideECSFlags := [];
end; // end of TK_CMEDAccess.EDASaveSlideToECache

//********************************************* TK_CMEDAccess.EDAClearSlideECache ***
// Clear given Slide Emergency Cache Files
//
//     Parameters
// AUDSlide - Slide to Save
//
procedure TK_CMEDAccess.EDAClearSlideECache(AUDSlide: TN_UDCMSlide);
begin
end; // end of TK_CMEDAccess.EDAClearSlideECache

//********************************************* TK_CMEDAccess.EDASlidesDTakenOrder ***
// Compare to Slides by DateTaken
//
//     Parameters
// Ptr1 - first slide pointer
// Ptr2 - second slide pointer
//
function TK_CMEDAccess.EDASlidesDTakenOrder(Ptr1, Ptr2: Pointer): Integer;
var
  RDif: Double;
begin
  RDif := TN_PUDCMSlide(Ptr1).P.CMSDTTaken - TN_PUDCMSlide(Ptr2).P.CMSDTTaken;
  Result := 0;
  if RDif > 0 then
    Result := -1
  else if RDif < 0 then
    Result := 1;
end; // end of TK_CMEDAccess.EDASlidesDTakenOrder

//************************************** TK_CMEDAccess.EDABuildHistActionCode ***
// Build Slide History  Action Code
//
//     Parameters
// AHistActType - History Action Type
// AHist1 - 1-st level code
// AHist2 - 2-nd level code
// AHist3 - 3-d  level code
// AHist4 - 4-th  level code
// Result - Returns History action Code
//
function TK_CMEDAccess.EDABuildHistActionCode
  (AHistActType: TK_CMSlideHistActType; AHist1: Byte = 0; AHist2: Byte = 0;
  AHist3: Byte = 0; AHist4: Byte = 0): Integer;
begin
  Result := (Ord(AHistActType) shl 28) or ((AHist1 and $F) shl 24) or
    (AHist2 shl 16) or (AHist3 shl 8) or AHist4;
end; // end of TK_CMEDAccess.EDABuildHistActionCode

//************************************** TK_CMEDAccess.EDAChangeHistActionType ***
// Get Slide History Change Action Code by Undo Action Code
//
//     Parameters
// AActCode - History Undo Action Code
// Result - Returns History Action Code
//
function TK_CMEDAccess.EDAChangeHistActionType(AActCode: Integer;
  AHistActType: TK_CMSlideHistActType): Integer;
begin
  Result := (Ord(AHistActType) shl 28) or (AActCode and not $F0000000);
end; // end of TK_CMEDAccess.EDAChangeHistActionType

//************************************** TK_CMEDAccess.EDAGetHistActionType ***
// Get Slide History Change Action Type
//
//     Parameters
// AUActCode - History Action Code
// Result - Returns History Action Type
//
function TK_CMEDAccess.EDAGetHistActionType(AActCode: Integer)
  : TK_CMSlideHistActType;
begin
  Result := TK_CMSlideHistActType((AActCode shr 28) and 3);
end; // end of TK_CMEDAccess.EDAGetHistActionType

//************************************** TK_CMEDAccess.EDAGetHistActionInfo ***
// Get Slide History Action Info
//
//     Parameters
// AActCode - source History Action Code
// AHist1 - resulting 1-st level code
// AHist2 - resulting 2-nd level code
// AHist3 - resulting 3-d  level code
// AHist4 - resulting 4-th level code
// Result - Returns History Action Type
//
function TK_CMEDAccess.EDAGetHistActionInfo(AActCode: Integer;
  out AHist1, AHist2, AHist3, AHist4: Byte): TK_CMSlideHistActType;
begin
  Result := EDAGetHistActionType(AActCode);
  AHist1 := (AActCode shr 24) and $F;
  AHist2 := (AActCode shr 16) and $FF;
  AHist3 := (AActCode shr 8) and $FF;
  AHist4 := AActCode and $FF;
end; // end of TK_CMEDAccess.EDAGetHistActionInfo

//************************************** TK_CMEDAccess.EDAGetVObjHistType ***
// Get Slide History Vector Object Type
//
//     Parameters
// AUDVObj - Vector Object
// Result - Returns History Action Type
//
function TK_CMEDAccess.EDAGetVObjHistType(AUDVObj: TN_UDBase)
  : TK_CMSlideHistVObjType;
begin
  Result := K_shVOTypeMeasureLine; // to prevent warning
  if AUDVObj.ObjName[1] = 'D' then
    // Dot Text
    Result := K_shVOTypeDot
  else if AUDVObj.ObjName[1] = 'M' then
    // Mearsure Line
    Result := K_shVOTypeMeasureLine
  else if (AUDVObj.ObjName[1] = 'H') then
    // Freehand
    Result := K_shVOTypeFreeHand
  else if (AUDVObj.ObjName[1] = 'R') then
    // Rectangle
    Result := K_shVOTypeRect
  else if (AUDVObj.ObjName[1] = 'E') then
    // Ellipse
    Result := K_shVOTypeEllipse
  else if (AUDVObj.ObjName[1] = 'A') then
    // Arrow
    Result := K_shVOTypeArrow
  else if (AUDVObj.ObjName[1] = 'L') then
    // Polyline
    Result := K_shVOTypePolyLine
  else if (AUDVObj.ObjName[1] = 'Z') then
    // FlashLight
    Result := K_shVOTypeFlashlight
  else if (AUDVObj.ObjName[1] = 'T') then
  begin
    // Text
    Result := K_shVOTypeText;
    if (AUDVObj.Owner.ObjName[2] = 'L') or (AUDVObj.Owner.ObjName[2] = 'A') then
      Result := K_shVOTypeMeasureText;
  end
  else if AUDVObj.ObjName[2] = 'A' then
  begin
    // Angle
    Result := K_shVOTypeFreeAngle;
    if AUDVObj.ObjName[1] = 'N' then
      Result := K_shVOTypeAngle;
  end;
end; // end of TK_CMEDAccess.EDAGetVObjHistType

//************************************** TK_CMEDAccess.EDAGetHistActionText ***
// Get Slide History Action Text
//
//     Parameters
// AActCode - History Action Code
// ASkipUndoText - if TRUE then "Undo" text is skiped from change Action (needed if only last change should be placed to report)
// AShowExpFExt  - if TRUE then export format text is skiped from export Action (needed for video or deleted slide)
// AExpFExt      - video export format text (is used if video slide statistics for existing slide is shown)
// ASrcDescr     - slide source name (addtional info create event)
// Result - Returns History Action Text
//
function TK_CMEDAccess.EDAGetHistActionText( AActCode: Integer;
                                        ASkipUndoText, AShowExpFExt : Boolean;
                                        const AExpFExt, ASrcDescr : string ): string;
var
  HistActType: TK_CMSlideHistActType;
  Hist1, Hist2, Hist3, Hist4: Byte;

  function GetHistText( const ATexts : array of string; AInd : Integer ) : string;
  begin
    if Length(ATexts) > AInd then
      Result := ATexts[AInd]
    else
      Result := 'undefined';
  end;

begin

  HistActType := EDAGetHistActionInfo(AActCode, Hist1, Hist2, Hist3, Hist4);
  if HistActType = K_shATNotChange then
  begin
    // Events not changing Slide
    Result := GetHistText( K_CMSHistNCActTexts, Hist1 );
    if (Hist1 = Byte(Ord(K_shNCAExportFile))) and AShowExpFExt then
    begin
      Result := Result + ' ';
      if AExpFExt = '' then
        Result := Result + GetHistText( K_CMSHistExpFormatTexts, Hist2 )
      else
        Result := Result + AExpFExt;
    end
    else
    if Hist1 = Byte(Ord(K_shNCAOther1)) then
    begin
      Result := Result + GetHistText( K_CMSHistNCAOther1Texts, Hist2 );
      if (Hist2 = Byte(Ord(K_shNCA1UAFilterChange))) or
         (Hist2 = Byte(Ord(K_shNCA1GAFilterChange))) then
      begin // Add Advanced filter Number
        if Hist2 = Byte(Ord(K_shNCA1GAFilterChange)) then
          Hist3 := Hist3 + 9;
        Result := Result + ' ' + IntToHex( Hist3 + 1, 1 );
      end
    end
    else
    if Hist1 = Byte(Ord(K_shNCAArchive)) then
    begin
      Result := Result + GetHistText( K_CMSHistNCAArchTexts, Hist2 );
    end
    else
    if Hist1 = Byte(Ord(K_shNCADICOM)) then
    begin
      Result := Result + GetHistText( K_CMSHistNCADCMTexts, Hist2 );
    end
  end
  else
  begin
    Result := GetHistText( K_CMSHistCActTexts, Hist1 );
    if (Hist1 = Byte( Ord(K_shCACreate) )) or
       (Hist1 = Byte( Ord(K_shCACreateIAC) )) then
    begin
      if ASrcDescr <> '' then
        Result := Result + ' (' + ASrcDescr + ')';
    end
    else if Hist1 = Byte(Ord(K_shCAProps)) then
      Result := Result + ' ' + GetHistText( K_CMHistPropActTexts, Hist2 )
    else if Hist1 = Byte(Ord(K_shCAImage)) then
      Result := Result + ' ' + GetHistText( K_CMSHistImgActTexts, Hist2 )
    else if Hist1 = Byte(Ord(K_shCAVOObject)) then
    begin
//      if Hist2 = Ord(K_shVOActCalibrate) then
//        Result := GetHistText( K_CMSHistVObjActTexts, Hist2 )
//      else
      Result := Result + ' ' + GetHistText( K_CMSHistVObjTypeTexts, Hist3 ) + ' ' +
          GetHistText( K_CMSHistVObjActTexts, Hist2 )
    end
    else if Hist1 = Byte(Ord(K_shCADBRecovery)) then
      Result := Result + ' ' + GetHistText( K_CMSHistRDBActTexts, Hist2 );

    if (HistActType = K_shATUndoChange) and not ASkipUndoText then
      Result := K_CML3Form.LLLEVUndo.Caption + ' ' + Result;
//      Result := 'Undo ' + Result;
    if (AActCode and K_shATFSkipSaveChangesFlag) <> 0 then
      Result := K_CML3Form.LLLEVReadOnly.Caption + ' ' + Result;
//      Result := 'R/O ' + Result;
  end;

end; // end of TK_CMEDAccess.EDAGetHistActionText

//************************************** TK_CMEDAccess.EDAAddHistActionToSlideBuffer ***
// Add Slide History  Action
//
//     Parameters
// ASlide - Slide to add History Action
// AActCode - Action Code
//
procedure TK_CMEDAccess.EDAAddHistActionToSlideBuffer( ASlide: TN_UDCMSlide;
                                                       AActCode: Integer );
var
  i: Integer;
  PCMSlideEdHist: TN_PCMSlideHist;
  EdHistActType: TK_CMSlideHistActType;
  AHistActType: TK_CMSlideHistActType;
begin
  if AActCode = -1 then Exit; // Skip Internal Wrk Action Code
  with ASlide.P^ do
  begin
    i := CMSHist.AHigh;
    AHistActType := EDAGetHistActionType(AActCode);
    if i >= 0 then
    begin
      PCMSlideEdHist := CMSHist.P(i);
      EdHistActType := EDAGetHistActionType(PCMSlideEdHist^.SHistActCode);
      if ((AHistActType = K_shATUndoChange) and (EdHistActType = K_shATChange)) or
         ((AHistActType = K_shATRedoChange) and (EdHistActType = K_shATUndoChange)) then
      begin
        // Remove Action
        CMSHist.DeleteElems(i);
        Exit;
      end;
    end;

    // Add Action
    if AHistActType = K_shATRedoChange then
    begin
      AHistActType := K_shATChange;
      AActCode := EDAChangeHistActionType(AActCode, AHistActType);
    end;

    if CMSHist = nil then
      // CMSHist := K_RCreateByTypeName( 'TN_CMSlideEdHist', 0, [] );
      CMSHist := K_RCreateByTypeName('TN_CMSlideHist', 0, []);

    with CMSHist do
    begin
      InsertElems();
      PCMSlideEdHist := P(i + 1);
    end;
    with PCMSlideEdHist^ do
    begin
      SHistProvID := CurProvID;
      SHistLocID :=  CurLocID;
      SHistSessionID := CurSessionHistID;
      if (AHistActType <> K_shATNotChange) and (cmsfSkipChangesSave in CMSRFlags) then
        AActCode := AActCode or Integer(K_shATFSkipSaveChangesFlag); // Add Skip Chages Saving Flag to Action Code
      SHistActCode := AActCode;
      SHistActTS := EDAGetSyncTimestamp();
    end;
  end;
end; // end of TK_CMEDAccess.EDAAddHistActionToSlideBuffer

//********************************************* TK_CMEDAccess.EDAAddImportHistory ***
// Add New Import History Record
//
//     Parameters
// AImportID - new Import History Record ID
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAAddImportHistory(out AImportID: Integer)
  : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAAddImportHistory

//********************************************* TK_CMEDAccess.EDAChangeImportInfo ***
// Change Last Import History Info
//
//     Parameters
// AImportID   - Import record ID to change
// AImportInfo - new import Info string to chage
// ADumpFlag   - 0 - ordinary dump (dump 2), 1 - dump 1
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAChangeImportInfo(AImportID: Integer;
  const AImportInfo: string; ADumpFlag : Integer = 0 ): TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAChangeImportInfo

//********************************************* TK_CMEDAccess.EDAGetLastImportHistory ***
// Get Last Import History Record
//
//     Parameters
// AImportID - resulting Import Record ID
// AImportDate - resulting Import Date
// AImportInfo - resulting Import Info
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetLastImportHistory(out AImportID: Integer;
  out AImportDate: TDateTime; out AImportInfo: string): TK_CMEDResult;
begin
  AImportID := -1;
  AImportInfo := '';
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAGetLastImportHistory

//********************************************* TK_CMEDAccess.EDAChangeImportInfo1 ***
// Change Last Import History Info
//
//     Parameters
// APCMIState - pointer to Import Slides State Record
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAChangeImportInfo1(APCMIState: TK_PCMImportState)
  : TK_CMEDResult;
var
  ImpInfo: string;
  DumpState : Integer;
begin
  ImpInfo := K_CMImportBuildInfo(APCMIState);
  DumpState := 0;
  if APCMIState.CMIXMLSlidesFName = '' then
    DumpState := 1;

  Result := EDAChangeImportInfo(APCMIState.CMIDBID, ImpInfo, DumpState );
end; // end of TK_CMEDAccess.EDAChangeImportInfo1

//********************************************* TK_CMEDAccess.EDAGetLastImportHistory1 ***
// Get Last Import History Record
//
//     Parameters
// APCMIState - pointer to Import Slides State Record
// APSlidesIDArr - pointer to Imported Slides IDs Array
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAGetLastImportHistory1(APCMIState: TK_PCMImportState;
  APSlidesIDArr: TN_PIArray): TK_CMEDResult;
var
  ImpInfo: string;
begin
  Result := EDAGetLastImportHistory(APCMIState.CMIDBID, APCMIState.CMIDate,
    ImpInfo);
  if Result <> K_edOK then
  begin
    K_CMImportClear(APCMIState);
    Exit;
  end;
  K_CMImportParseInfo(ImpInfo, APCMIState, APSlidesIDArr);
end; // end of TK_CMEDAccess.EDAGetLastImportHistory1

//********************************************* TK_CMEDAccess.EDADeleteImportHistory1 ***
// Delete Import History Record given by ID
//
//     Parameters
// AImportID - import record ID to Delete
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDADeleteImportHistory(AImportID: Integer)
  : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDADeleteImportHistory

//********************************************* TK_CMEDAccess.EDAEMSetSlidesHLoc ***
// Save History Info for Slides given as SQL "WHERE" codition
//
//     Parameters
// ASQLStr - string with Slides SQL "WHERE" codition
// AHistActCode - History Action Code
//
// Result - Returns operation resulting code
//
// Save corresponding records to AllSlidesHistory Table with given Action Code
//
function TK_CMEDAccess.EDASaveSlidesHistory( const ASQLStr: string;
                                               AHistActCode: Integer ) : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDASaveSlidesHistory

//********************************************* TK_CMEDAccess.EDASaveSlidesListHistory ***
// Save History Info for Slides given as Slides List
//
//     Parameters
// APSlides - pointer to slides array start element to change Host Location
// ASlidesCount - number of slides to change Host Location
// AHistActCode - History Action Code
//
// Result - Returns operation resulting code
//
// Save corresponding records to AllSlidesHistory Table with given Action Code
//
function TK_CMEDAccess.EDASaveSlidesListHistory( APSlide: TN_PUDCMSlide;
                                                   ASlidesCount: Integer;
                                                   AHistActCode: Integer ) : TK_CMEDResult;
begin
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDASaveSlidesListHistory

//********************************************* TK_CMEDAccess.EDADataCheck ***
// Application Data Consistency Check
//
//     Parameters
// APObj - pointer to Self
// ACheckPar - check level
// Result - Returns error string
//
function TK_CMEDAccess.EDADataCheck(APObj: Pointer; ACheckPar: Integer): string;
var
  i: Integer;
  UDChild: TN_UDBase;
  CurCheckState : string;
begin

  if SlidesDIBFormat = uddfNotDef then
  begin
    Result := 'K_CMEDAccess.SlidesDIBFormat = uddfNotDef';
    Exit;
  end;

  try
    // Check CurSlidesList
    CurCheckState := 'CurSlidesList';
    for i := 0 to CurSlidesList.Count - 1 do
    begin
      UDChild := TN_UDBase(CurSlidesList[i]);
      Result := TN_UDCMSlide(UDChild).CheckConsistency(UDChild, 0);
      if Result = '' then
        Continue;
      Result := format('CurSlidesList[%d] - %s', [i, Result]);
      Exit;
    end;

    if SkipEDADataCheckInDelProc then
      Exit;

    // Check LockRes Slides
    CurCheckState := 'LockResSlides';
    for i := 0 to LockResCount - 1 do
    begin
      Result := LockResSlides[i].CheckConsistency(LockResSlides[i], 0);
      if Result = '' then
        Continue;
      Result := format('LockResSlides[%d] - %s', [i, Result]);
      Exit;
    end;

    // Check K_CMCurVisSlidesArray Slides
    CurCheckState := 'CurVisSlides';
    for i := 0 to High(K_CMCurVisSlidesArray) do
    begin
      Result := K_CMCurVisSlidesArray[i].CheckConsistency(K_CMCurVisSlidesArray[i], 0);
      if Result = '' then
        Continue;
      Result := format('K_CMCurVisSlidesArray[%d] - %s', [i, Result]);
      Exit;
    end;

  except
    on E: Exception do
    begin
      Result := ' CheckState=' + CurCheckState + ' >> ' + E.Message;
    end;
  end;

end; // end of TK_CMEDAccess.EDADataCheck

//********************************************* TK_CMEDAccess.EDASAUDTabIndByID ***
// Find Stand alone Table Index by ID
//
//     Parameters
// Result - Returns Stand alone Locations UDTable
//
function TK_CMEDAccess.EDASAUDTabIndByID( ASAUDTable : TK_UDRArray; ASID : string  ) : Integer;
begin
  with ASAUDTable do
    Result := K_IndexOfIntegerInRArray( StrToInt(ASID),
                                     @TK_PCMSALocationAttrs(PDE(0)).SALID,
                                     ALength(),
                                     PDRA.ElemSize );
  if Result >= 0 then Exit;
  ExtDataErrorString := 'Stand alone object ID =' + ASID + ' is not found';
  EDAShowErrMessage(TRUE);
end; // TK_CMEDAccess.EDASAUDTabIndByID

//********************************************* TK_CMEDAccess.EDASAGetLocalArchiveUDTab ***
// Get Stand alone Local Archive Table
//
//     Parameters
// Result - Returns Stand alone Local Archive UDTable
//
function TK_CMEDAccess.EDASAGetLocalArchiveUDTab( const AUDTabName : string ) : TK_UDRArray;
begin
  Result := TK_UDRArray(K_UDCursorGetObj( K_ArchiveCursor + 'StandAlone' + K_udpPathDelim + AUDTabName ));
  if Result = nil then
  begin
    ExtDataErrorString := AUDTabName + ' Table Object is Absent';
    EDAShowErrMessage(TRUE);
  end;
end; // TK_CMEDAccess.EDASAGetLocalArchiveUDTab

//********************************************* TK_CMEDAccess.EDASAInitDBInfo ***
// Init Providers Info in Stand alone mode
//
//     Parameters
// AInitFlags - flags to init:
//#F
//   bit0 - =1 locations init flag
//   bit1 - =2 providers init flag
//   bit4 - =4 patients init flag
//#/F
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASAInitDBInfo( AInitFlags : Integer ) : TK_CMEDResult;
var
  UDSALocations : TK_UDRArray;
  UDSAProviders : TK_UDRArray;
  UDSAPatients  : TK_UDRArray;
  UDSADelPatientsCardnums : TK_UDRArray;
  RCount : Integer;
begin
  N_Dump2Str('LA>> EDASAInitDBInfo');
  Result := K_edOK;

  with K_UDCursorForceDir(K_ArchiveCursor + 'StandAlone') do
  begin
    UDSALocations := TK_UDRArray(DirChildByObjName('Locations'));
    if UDSALocations = nil then
    begin
      RCount := 0;
      if AInitFlags and 1 <> 0 then
        RCount := 1;
      UDSALocations := TK_UDRArray(AddOneChild(K_CreateUDByRTypeName( 'TK_CMSALocationAttrs', RCount )));
      UDSALocations.ObjName := 'Locations';
      UDSALocations.ObjInfo := IntToStr(RCount);
      if RCount <> 0 then
        TK_PCMSALocationAttrs(UDSALocations.PDE(0)).SALID := -101;
    end; // if UDSALocations = nil then

    UDSAProviders := TK_UDRArray(DirChildByObjName('Providers'));
    if UDSAProviders = nil then
    begin
      RCount := 0;
      if AInitFlags and 2 <> 0 then
        RCount := 1;
      UDSAProviders := TK_UDRArray(AddOneChild(K_CreateUDByRTypeName( 'TK_CMSAProviderAttrs', RCount )));
      UDSAProviders.ObjName := 'Providers';
      UDSAProviders.ObjInfo := IntToStr(RCount);
      if RCount <> 0 then
        with TK_PCMSAProviderAttrs(UDSAProviders.PDE(0))^ do
        begin
          SAUID := 1;
          SAUTitle := 'Dr';
          SAUSurname := 'Mediasuite';
          SAUFirstname := 'Dentist';
        end; // with TK_PCMSAProviderAttrs(UDSAProviders.PDE(0))^ do
    end; // if UDSAProviders = nil then

    UDSAPatients := TK_UDRArray(DirChildByObjName('Patients'));
    if UDSAPatients = nil then
    begin
      RCount := 0;
      if AInitFlags and 4 <> 0 then
        RCount := 1;
      UDSAPatients := TK_UDRArray(AddOneChild(K_CreateUDByRTypeName( 'TK_CMSAPatientAttrs', RCount )));
      UDSAPatients.ObjName := 'Patients';
      UDSAPatients.ObjInfo := IntToStr(RCount);
      if RCount <> 0 then
        with TK_PCMSAPatientAttrs(UDSAPatients.PDE(0))^ do
        begin
          SAPID := 1;
          SAPCardNum := '1';
          SAPProvID := 1;
          SAPTitle := 'Mr';
          SAPSurname := 'SMITH';
          SAPFirstname := 'John';
        end; // with TK_PCMSAPatientAttrs(UDSAPatients.PDE(0))^ do
    end; // if UDSAPatients = nil then
    with UDSAPatients do
    begin
      UDSADelPatientsCardnums := TK_UDRArray(DirChildByObjName('DelCardNums'));
      if UDSADelPatientsCardnums = nil then
      begin
        UDSADelPatientsCardnums := TK_UDRArray(AddOneChild(K_CreateUDByRTypeCode( Ord(nptString), 0 )));
        UDSADelPatientsCardnums.ObjName := 'DelCardNums';
      end;
    end;
  end; // with K_UDCursorForceDir(K_ArchiveCursor + 'StandAlone') do
  N_Dump2Str('LA>> EDASAInitDBInfo fin');
end; // end of TK_CMEDAccess.EDASAInitDBInfo

//********************************************* TK_CMEDAccess.EDASAGetLocationsInfo ***
// Get Locations Info in Stand alone mode
//
//     Parameters
// AShowDelFlag - if =TRUE then only marked as deleted are placed to ProvidersInfo
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASAGetLocationsInfo( AShowDelFlag : Boolean ) : TK_CMEDResult;
var

  i, j, RCount: Integer;
  UDSALocations : TK_UDRArray;
begin
  N_Dump2Str('LA>> EDASAGetLocationsInfo');

  Result := K_edOK;
  UDSALocations := EDASAGetLocalArchiveUDTab( 'Locations' );

  with LocationsInfo.R do
  begin
    RCount := UDSALocations.ALength();
    ASetLength( 4, RCount + 1 );
    PString(PME(0, 0))^ := 'LocationID';
    PString(PME(1, 0))^ := 'LocationTitle';
    PString(PME(2, 0))^ := 'LocationSync';
    PString(PME(3, 0))^ := 'LocationRef#';
    j := 1;
    for i := 1 to RCount do
      with TK_PCMSALocationAttrs(UDSALocations.PDE(i-1))^ do
        if (AShowDelFlag and ((SALFlags and 1) = 1)) or
           (not AShowDelFlag and ((SALFlags and 1) = 0))
        then
        begin
          PString(PME(0, i))^ := IntToStr(SALID);
          PString(PME(1, i))^ := SALName;
//          if SALCustRefN > 0 then
//            PString(PME(3, i))^ := IntToStr(SALCustRefN);
          PString(PME(3, i))^ := SALCustRefN;
          Inc(j);
        end;
    ASetLength( 3, j );
  end;
  N_Dump2Str('LA>> EDASAGetLocationsInfo fin');
end; // end of TK_CMEDAccess.EDASAGetLocationsInfo

//********************************************* TK_CMEDAccess.EDASAGetOneLocationInfo ***
// Get givev Provider Info and Lock in Stand alone mode
//
//     Parameters
// ALocSID - Patient ID string
// APCMSALocationDBData - pointer to Location Data
// ALockOnly - Lock Only Flag
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASAGetOneLocationInfo( const ALocSID : string;
                       APCMSALocationDBData : TK_PCMSALocationDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult;
var
  UDSALocations : TK_UDRArray;
  Ind : Integer;
begin
  N_Dump2Str('LA>> EDASAGetOneLocationInfo ID=' + ALocSID );

  Result := K_edOK;
  UDSALocations := EDASAGetLocalArchiveUDTab( 'Locations' );

  Ind := EDASAUDTabIndByID( UDSALocations, ALocSID );

  with APCMSALocationDBData^, TK_PCMSALocationAttrs(UDSALocations.PDE(Ind))^ do
  begin
    ALIsLocked  := TRUE;
    ALDBFlags   := SALFlags;
    if not (K_cmsagiLockOnly in ALockFlags) then
    begin
      ALName  := SALName;
      ALCustRefN := SALCustRefN;
    end;
  end;
  N_Dump2Str('LA>> EDASAGetOneLocationInfo fin');
end; // end of TK_CMEDAccess.EDASAGetOneLocationInfo

//********************************************* TK_CMEDAccess.EDASASetOneLocationInfo ***
// Set Location Info in Stand alone mode
//
//     Parameters
// ALocSID - Location ID string
// APCMSALocationDBData - pointer to Location Data
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASetOneLocationInfo( var ALocSID : string;
                        APCMSALocationDBData : TK_PCMSALocationDBData;
                        ASkipFieldsSet : Boolean ) : TK_CMEDResult;
var
  UDSALocations : TK_UDRArray;
  Ind : Integer;
  NewID : Integer;
  FCol : Integer;
begin
  N_Dump2Str('LA>> EDASASetOneLocationInfo ID=' + ALocSID );

  Result := K_edOK;
  UDSALocations := EDASAGetLocalArchiveUDTab( 'Locations' );

  if (ALocSID <> '') and ASkipFieldsSet then Exit; // Unlock is not needed
  with UDSALocations do
  if ALocSID = '' then
  begin // Add New
    Ind := Alength();
    ASetLength( Ind + 1 );
    NewID := Max( TK_PCMSALocationAttrs(PDE(Ind - 1)).SALID + 1,
                  StrToIntDef(ObjInfo, 1) + 1 );
    ObjInfo := IntToStr( NewID );
    ALocSID := ObjInfo;
    with TK_PCMSALocationAttrs(PDE(Ind))^ do
    begin
      SALID := NewID;
      SALName := APCMSALocationDBData.ALName;
      SALCustRefN := APCMSALocationDBData.ALCustRefN;
    end;

    with LocationsInfo.R do
    begin
      Ind := ARowCount();
      ASetLength( AColCount(), Ind + 1 );
      PString(PME(0, Ind))^ := ALocSID;
    end;
  end
  else
  begin // Change Existing
    Ind := EDASAUDTabIndByID( UDSALocations, ALocSID );

    TK_PCMSALocationAttrs(PDE(Ind)).SALName := APCMSALocationDBData.ALName;
    TK_PCMSALocationAttrs(PDE(Ind)).SALCustRefN := APCMSALocationDBData.ALCustRefN;

    Ind := EDAArchUDTabIndexOf( ALocSID, LocationsInfo );
  end;

  // Set Values to LocationsInfo
  with LocationsInfo.R do
  begin
    FCol := EDAArchUDTabFieldIndex( 'LocationTitle', LocationsInfo );
    PString(PME(FCol, Ind))^ := APCMSALocationDBData.ALName;
    if APCMSALocationDBData.ALIsPMSSync then
    begin
      FCol := EDAArchUDTabFieldIndex( 'LocationSync', LocationsInfo );
      PString(PME(FCol, Ind))^ := '1';
    end;
{
    if APCMSALocationDBData.ALCustRefN <> 0 then
    begin
      FCol := EDAArchUDTabFieldIndex( 'LocationRef#', LocationsInfo );
      PString(PME(FCol, Ind))^ := IntToStr(APCMSALocationDBData.ALCustRefN);
    end;
}
    if APCMSALocationDBData.ALCustRefN <> '' then
    begin
      FCol := EDAArchUDTabFieldIndex( 'LocationRef#', LocationsInfo );
      PString(PME(FCol, Ind))^ := APCMSALocationDBData.ALCustRefN;
    end;
  end;

  N_Dump2Str('LA>> EDASASetOneLocationInfo fin');
end; // end of TK_CMEDAccess.EDASASetOneLocationInfo

//********************************************* TK_CMEDAccess.EDASASetClearMarkLocatonAsDel ***
// Set or Clear Given Locaton Marked as Deleted Flag and Unlock
//
//     Parameters
// ALocSID - Provider ID string
// AFlags - ='1' set marked as deleted flag, ='0' - clear marked as deleted flag
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASetClearMarkLocatonAsDel( const ALocSID, AFlags : string ) : TK_CMEDResult;
var
  UDSALocations : TK_UDRArray;
  Ind : Integer;
begin
  N_Dump2Str('LA>> EDASASetClearMarkLocatonAsDel ID=' + ALocSID );

  Result := K_edOK;
  UDSALocations := EDASAGetLocalArchiveUDTab( 'Locations' );

  Ind := EDASAUDTabIndByID( UDSALocations, ALocSID );

  with TK_PCMSALocationAttrs(UDSALocations.PDE(Ind))^ do
    SALFlags := (SALFlags and not 1) or (StrToInt( AFlags ) and 1);

  N_Dump2Str('LA>> EDASASetClearMarkLocatonAsDel fin');
end; // end of TK_CMEDAccess.EDASASetClearMarkLocatonAsDel

//********************************************* TK_CMEDAccess.EDASADelLocation ***
// Delete given Location
//
//     Parameters
// ALocSID - Location ID string
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASADelLocation( const ALocSID : string  ) : TK_CMEDResult;
var
  UDSALocations : TK_UDRArray;
  Ind : Integer;
begin
  N_Dump2Str('LA>> EDASADelLocation ID=' + ALocSID );

  Result := K_edOK;
  UDSALocations := EDASAGetLocalArchiveUDTab( 'Locations' );

  Ind := EDASAUDTabIndByID( UDSALocations, ALocSID );

  UDSALocations.R.DeleteElems(Ind);

  N_Dump2Str('LA>> EDASADelLocation fin');

end; // end of TK_CMEDAccess.EDASADelLocation

//********************************************* TK_CMEDAccess.EDASASyncLocationsInfo ***
// Set DB Locations by Locations Info Object
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASyncLocationsInfo: TK_CMEDResult;
begin
  Result := K_edOK;
end; // function TK_CMEDAccess.EDASASyncLocationsInfo

//********************************************* TK_CMEDAccess.EDASAGetProvidersInfo ***
// Get Providers Info in Stand alone mode
//
//     Parameters
// AShowDelFlag - if =TRUE then only marked as deleted are placed to ProvidersInfo
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASAGetProvidersInfo( AShowDelFlag : Boolean ) : TK_CMEDResult;
var
  i, j, RCount: Integer;
  UDSAProviders : TK_UDRArray;
  WSTR : string;
begin
  N_Dump2Str('LA>> EDASAGetProvidersInfo');

  Result := K_edOK;
  UDSAProviders := EDASAGetLocalArchiveUDTab( 'Providers' );

  with ProvidersInfo.R do
  begin
    RCount := UDSAProviders.ALength();
    ASetLength( 7, RCount + 1 );
    PString(PME(0, 0))^ := 'ProviderID';
    PString(PME(1, 0))^ := 'ProviderFirstName';
    PString(PME(2, 0))^ := 'ProviderSurname';
    PString(PME(3, 0))^ := 'ProviderTitle';
    PString(PME(4, 0))^ := 'ProviderFlags';
    PString(PME(5, 0))^ := 'ProviderSync';
    PString(PME(6, 0))^ := 'ProviderMiddle';
    j := 1;
    for i := 1 to RCount do
      with TK_PCMSAProviderAttrs(UDSAProviders.PDE(i-1))^ do
        if (AShowDelFlag and ((SAUFlags and 1) = 1)) or
           (not AShowDelFlag and ((SAUFlags and 1) = 0)) then
        begin
          PString(PME(0, j))^ := IntToStr(SAUID);
          PString(PME(1, j))^ := SAUSurname;
          PString(PME(2, j))^ := SAUFirstname;
          PString(PME(3, j))^ := SAUTitle;
          if SAUAuthorities = 0 then
            WSTR := '2047' // Set maximal User Authorities
          else
            WSTR := IntToStr(SAUAuthorities);
          PString(PME(4, j))^ := WSTR;
          PString(PME(6, j))^ := SAUMiddle;
          Inc(j);
        end;
    ASetLength( AColCount(), j );
  end;
  N_Dump2Str('LA>> EDASAGetProvidersInfo fin');
end; // end of TK_CMEDAccess.EDASAGetProvidersInfo

//********************************************* TK_CMEDAccess.EDASAGetOneProviderInfo ***
// Get givev Provider Info and Lock in Stand alone mode
//
//     Parameters
// AProvSID - Provider ID string
// APCMSAProviderDBData - pointer to Patient Data
// ALockOnly - Lock Only Flag
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASAGetOneProviderInfo( const AProvSID : string;
                       APCMSAProviderDBData : TK_PCMSAProviderDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult;
var
  UDSAProviders : TK_UDRArray;
  Ind : Integer;
begin

  N_Dump2Str('LA>> EDASAGetOneProviderInfo ID=' + AProvSID );

  Result := K_edOK;
  UDSAProviders := EDASAGetLocalArchiveUDTab( 'Providers' );

  Ind := EDASAUDTabIndByID( UDSAProviders, AProvSID );

  with APCMSAProviderDBData^, TK_PCMSAProviderAttrs(UDSAProviders.PDE(Ind))^ do
  begin
    AUIsLocked  := TRUE;
    AUDBFlags   := SAUFlags;
    AUPatCount  := 0;
    if not (K_cmsagiLockOnly in ALockFlags) then
    begin
      AUTitle       := SAUTitle;
      AUSurname     := SAUSurname;
      AUFirstname   := SAUFirstname;
      AUMiddle      := SAUMiddle;
      AUAuthorities := IntToStr(SAUAuthorities);
      AUEncodeLP    := SAUEncodeLP;
    end;
  end;

  N_Dump2Str('LA>> EDASAGetOneProviderInfo fin');
end; // end of TK_CMEDAccess.EDASAGetOneProviderInfo

//********************************** TK_CMEDAccess.EDASASetOneLoginPassword ***
// Set Provider Login/Password
//
//     Parameters
// AProvSID - Provider Code
// AEncLoginPassword - encoded login/password
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASetOneLoginPassword( const AProvSID : string;
                        AEncLoginPassword : string ) : TK_CMEDResult;
var
  UDSAProviders : TK_UDRArray;
  ProvID, i : Integer;
begin
  N_Dump2Str('LA>> EDASASetOneLoginPassword ID=' + AProvSID );

  Result := K_edOK;
  UDSAProviders := EDASAGetLocalArchiveUDTab( 'Providers' );
  // Nothing to do
  if (AEncLoginPassword = '') then Exit; // Save is not needed

  ProvID := StrToIntDef( AProvSID, -1 );

  // Check Login/Password Uniq
  with UDSAProviders do
    for i := 0 to AHigh() do
      with TK_PCMSAProviderAttrs(PDE(i))^ do
        if ((ProvID = -1) or (SAUID <> ProvID)) and (SAUEncodeLP = AEncLoginPassword) then
        begin
          Result := K_edFails;
          N_Dump1Str( format( 'LA>> EDASASetOneLoginPassword LP for ID=%s is used by ID=%', [AProvSID, SAUID] ) );
          break;
        end;

  if (Result <> K_edOK) or (ProvID = -1) then Exit;

  // Save new Login/Password
  i := EDASAUDTabIndByID( UDSAProviders, AProvSID );
  with TK_PCMSAProviderAttrs(UDSAProviders.PDE(i))^ do
     SAUEncodeLP := AEncLoginPassword;

  N_Dump2Str('LA>> EDASASetOneLoginPassword fin');

end; // end of TK_CMEDAccess.EDASASetOneLoginPassword

//*********************************** TK_CMEDAccess.EDASACheckLoginPassword ***
// Check Provider Login/Password
//
//     Parameters
// AProvSID - Provider Code
// AEncLoginPassword - encoded login/password
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASACheckLoginPassword( const AProvSID : string;
                        AEncLoginPassword : string ) : TK_CMEDResult;
var
  UDSAProviders : TK_UDRArray;
  ProvID, i : Integer;
begin
  N_Dump2Str('LA>> EDASACheckLoginPassword ID=' + AProvSID );

  Result := K_edOK;
  UDSAProviders := EDASAGetLocalArchiveUDTab( 'Providers' );
  // Nothing to do
  if (AEncLoginPassword = '') then Exit; // Save is not needed

  ProvID := StrToIntDef( AProvSID, -1 );

  // Check Login/Password Uniq
  with UDSAProviders do
    for i := 0 to AHigh() do
      with TK_PCMSAProviderAttrs(PDE(i))^ do
        if ((ProvID = -1) or (SAUID <> ProvID)) and (SAUEncodeLP = AEncLoginPassword) then
        begin
          Result := K_edFails;
          N_Dump1Str( format( 'LA>> EDASACheckLoginPassword LP for ID=%s is used by ID=%', [AProvSID, SAUID] ) );
          break;
        end;

  N_Dump2Str('LA>> EDASACheckLoginPassword fin');

end; // end of TK_CMEDAccess.EDASASetOneLoginPassword

//*********************************** TK_CMEDAccess.EDASASetOneProviderInfo ***
// Set Provider Info in Stand alone mode
//
//     Parameters
// AProvSID - Provider Code
// APCMSAProviderDBData - pointer to Provider Data
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASetOneProviderInfo( var AProvSID : string;
                        APCMSAProviderDBData : TK_PCMSAProviderDBData;
                        ASkipFieldsSet : Boolean ) : TK_CMEDResult;
var
  UDSAProviders : TK_UDRArray;
  Ind : Integer;
  NewID : Integer;
  PProvAttrs : TK_PCMSAProviderAttrs;

  procedure SetValues();
  begin
    with PProvAttrs^, APCMSAProviderDBData^ do
    begin
      SAUFirstname := AUFirstname;
      SAUSurname := AUSurname;
      SAUTitle := AUTitle;
      SAUMiddle := AUMiddle;
      SAUAuthorities := StrToIntDef( AUAuthorities, 2047 );
      if AUEncodeLP <> '' then
        SAUEncodeLP    := AUEncodeLP;
    end;
  end;

begin
  N_Dump2Str('LA>> EDASASetOneProviderInfo ID=' + AProvSID );

  Result := K_edOK;
  UDSAProviders := EDASAGetLocalArchiveUDTab( 'Providers' );

  if (AProvSID <> '') and ASkipFieldsSet then Exit; // Unlock is not needed
  with UDSAProviders do
  if AProvSID = '' then
  begin // Add New

    Ind := Alength();
    ASetLength( Ind + 1 );
    NewID := Max( TK_PCMSAProviderAttrs(PDE(Ind-1)).SAUID + 1,
                  StrToIntDef(ObjInfo, 1) + 1 );
    ObjInfo := IntToStr( NewID );
    AProvSID := ObjInfo;

    PProvAttrs := TK_PCMSAProviderAttrs(PDE(Ind));
    PProvAttrs.SAUID := NewID;
    SetValues();

    with ProvidersInfo.R do
    begin
      Ind := ARowCount();
      ASetLength( AColCount(), Ind + 1 );
      PString(PME(0, Ind))^ := AProvSID;
    end;

  end
  else
  begin // Change Existing

    Ind := EDASAUDTabIndByID( UDSAProviders, AProvSID );
    PProvAttrs := TK_PCMSAProviderAttrs(PDE(Ind));
    SetValues();
    Ind := EDAArchUDTabIndexOf( AProvSID, ProvidersInfo );

  end;

  // Set Values to ProvidersInfo
  with ProvidersInfo.R do
  begin
    PString(PME(1, Ind))^ := APCMSAProviderDBData.AUFirstname;
    PString(PME(2, Ind))^ := APCMSAProviderDBData.AUSurname;
    PString(PME(3, Ind))^ := APCMSAProviderDBData.AUTitle;
    PString(PME(4, Ind))^ := APCMSAProviderDBData.AUAuthorities;
    if APCMSAProviderDBData.AUIsPMSSync then
      PString(PME(5, Ind))^ := '1';
    PString(PME(6, Ind))^ := APCMSAProviderDBData.AUMiddle;
  end;

  N_Dump2Str('LA>> EDASASetOneProviderInfo fin');

end; // end of TK_CMEDAccess.EDASASetOneProviderInfo

//**************************** TK_CMEDAccess.EDASASetClearMarkProviderAsDel ***
// Set or Clear Given Provider Marked as Deleted Flag and Unlock
//
//     Parameters
// AProvSID - Provider ID string
// AFlags - ='1' set marked as deleted flag, ='0' - clear marked as deleted flag
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASetClearMarkProviderAsDel( const AProvSID, AFlags : string ) : TK_CMEDResult;
var
  UDSAProviders : TK_UDRArray;
  Ind : Integer;
begin
  N_Dump2Str('LA>> EDASASetClearMarkProviderAsDel ID=' + AProvSID );

  Result := K_edOK;
  UDSAProviders := EDASAGetLocalArchiveUDTab( 'Providers' );

  Ind := EDASAUDTabIndByID( UDSAProviders, AProvSID );

  with TK_PCMSAProviderAttrs(UDSAProviders.PDE(Ind))^ do
    SAUFlags := (SAUFlags and not 1) or (StrToInt( AFlags ) and 1);

  N_Dump2Str('LA>> EDASASetClearMarkProviderAsDel fin');

end; // end of TK_CMEDAccess.EDASASetClearMarkProviderAsDel

//****************************************** TK_CMEDAccess.EDASADelProvider ***
// Delete given Provider
//
//     Parameters
// AProvSID - Provider ID string
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASADelProvider( const AProvSID : string  ) : TK_CMEDResult;
var
  UDSAProviders : TK_UDRArray;
  Ind : Integer;
begin
  N_Dump2Str('LA>> EDASADelProvider ID=' + AProvSID );

  Result := K_edOK;
  UDSAProviders := EDASAGetLocalArchiveUDTab( 'Providers' );

  Ind := EDASAUDTabIndByID( UDSAProviders, AProvSID );

  UDSAProviders.R.DeleteElems(Ind);

  N_Dump2Str('LA>> EDASADelProvider fin');

end; // end of TK_CMEDAccess.EDASADelProvider

//************************************ TK_CMEDAccess.EDASASyncProvidersInfo ***
// Set DB Providers by Providers Info Object
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASyncProvidersInfo: TK_CMEDResult;
begin
  Result := K_edOK;
end; // function TK_CMEDAccess.EDASASyncProvidersInfo

//************************************** TK_CMEDAccess.EDASAGetPatientsInfo ***
// Get Patients Info in Stand alone mode
//
//     Parameters
// AShowDelFlag - if = TRUE then show marked as deleted flag
// AGetAll      - Get All Patients (without number restrictions)
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASAGetPatientsInfo( AShowDelFlag : Boolean; AGetAll : Boolean = FALSE ) : TK_CMEDResult;
var
  i, j, RCount: Integer;
  UDSAPatients : TK_UDRArray;
  PCMSAPatientAttrs : TK_PCMSAPatientAttrs;
begin
  N_Dump2Str('LA>> EDASAGetPatientsInfo');

  Result := K_edOK;
  UDSAPatients := EDASAGetLocalArchiveUDTab( 'Patients' );

  with PatientsInfo.R do
  begin
    RCount := UDSAPatients.ALength();
    ASetLength( 8, RCount + 1 );
    PString(PME(0, 0))^ := 'PatientID';
    PString(PME(1, 0))^ := 'PatientCardNumber';
    PString(PME(2, 0))^ := 'PatientFirstName';
    PString(PME(3, 0))^ := 'PatientSurname';
    PString(PME(4, 0))^ := 'PatientTitle';
    PString(PME(5, 0))^ := 'PatientGender';
    PString(PME(6, 0))^ := 'PatientDOB';
    PString(PME(7, 0))^ := 'PatientSync';
    j := 1;
    for i := 1 to RCount do
    begin
      PCMSAPatientAttrs := UDSAPatients.PDE(i-1);
      with PCMSAPatientAttrs^ do
        if (AShowDelFlag and ((SAPFlags and 1) = 1)) or
           (not AShowDelFlag and ((SAPFlags and 1) = 0))
        then
        begin
          PString(PME(0, j))^ := IntToStr(SAPID);
          PString(PME(1, j))^ := SAPCardNum;
          PString(PME(2, j))^ := SAPFirstname;
          PString(PME(3, j))^ := SAPSurname;
          PString(PME(4, j))^ := SAPTitle;
          PString(PME(5, j))^ := SAPGender;
          if SAPDOB = 0 then
            PString(PME(6, j))^ := ''
          else
            K_DateTimeToStr( SAPDOB, N_WinFormatSettings.ShortDateFormat );
          Inc(j);
        end;
    end;
    ASetLength( 8, j );
  end;
  N_Dump2Str('LA>> EDASAGetPatientsInfo fin');
end; // end of TK_CMEDAccess.EDASAGetPatientsInfo

//************************************ TK_CMEDAccess.EDASAGetOnePatientInfo ***
// Get Patients Info in Stand alone mode
//
//     Parameters
// APatSID - Patient ID string
// APCMSAPatientDBData - pointer to Patient Data
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASAGetOnePatientInfo( const APatSID : string;
                       APCMSAPatientDBData : TK_PCMSAPatientDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult;
var
  UDSAPatients : TK_UDRArray;
  Ind : Integer;
begin
  N_Dump2Str('LA>> EDASAGetOnePatientInfo ID=' + APatSID );

  Result := K_edOK;
  UDSAPatients := EDASAGetLocalArchiveUDTab( 'Patients' );

  Ind := EDASAUDTabIndByID( UDSAPatients, APatSID );

  with APCMSAPatientDBData^, TK_PCMSAPatientAttrs(UDSAPatients.PDE(Ind))^ do
  begin
    APIsLocked  := TRUE;
    APDBFlags   := SAPFlags and 1;
    if not (K_cmsagiLockOnly in ALockFlags) then
    begin
      APCardNum := SAPCardNum;
      APGender := SAPGender;
      APTitle := SAPTitle;
      APSurname := SAPSurname;
      APFirstname := SAPFirstname;
      APMiddle := SAPMiddle;
      APDOB := SAPDOB;
      APProvID := SAPProvID;
      APAddr1  := SAPAddr1;
      APAddr2  := SAPAddr2;
      APSuburb := SAPSuburb;
      APPostCode := SAPPostCode;
      APState   := SAPState;
      APPhone1  := SAPPhone1;
      APPhone2  := SAPPhone2;
    end;
  end;

  N_Dump2Str('LA>> EDASAGetOnePatientInfo fin');
end; // end of TK_CMEDAccess.EDASAGetOnePatientInfo

//********************************** TK_CMEDAccess.EDASACheckPatientCardNum ***
// Check Patient Card Number  in Stand alone mode
//
//     Parameters
// APatSID - Patient ID string
// AParCardNum - Patient Card Number string
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASACheckPatientCardNum( const APatSID, AParCardNum : string ) : TK_CMEDResult;

var
  UDSAPatients : TK_UDRArray;
  UDSADelPatientsCardnums: TK_UDRArray;
  Ind : Integer;
begin
  N_Dump2Str('LA>> EDASACheckPatientCardNum ID=' + APatSID );

  Result := K_edOK;
  UDSAPatients := EDASAGetLocalArchiveUDTab( 'Patients' );
  with UDSAPatients do
  begin
  // Check Patients Table
    Ind := K_IndexOfStringInRArray( AParCardNum,
                                     @TK_PCMSAPatientAttrs(PDE(0)).SAPCardNum,
                                     ALength(),
                                     PDRA.ElemSize );
    if Ind >= 0 then
    begin
      Result := K_edFails;
      if APatSID = '' then Exit;
      if TK_PCMSAPatientAttrs(PDE(Ind)).SAPID <> StrToInt( APatSID ) then Exit;
      Result := K_edOK;
    end;

  // Check Deleted Patient Card Numbers Table
    UDSADelPatientsCardnums := TK_UDRArray(DirChildByObjName('DelCardNums'));
    if UDSADelPatientsCardnums = nil then Exit;
    with UDSADelPatientsCardnums do
      Ind := K_IndexOfStringInRArray( AParCardNum,
                                      PString(PDE(0)),
                                      ALength(),
                                      PDRA.ElemSize );
    if Ind < 0 then Exit;

    Result := K_edFails;

  end;

  N_Dump2Str('LA>> EDASACheckPatientCardNum fin');

end; // end of TK_CMEDAccess.EDASACheckPatientCardNum

//********************************************* TK_CMEDAccess.EDASASetOnePatientInfo ***
// Set Patient Info in Stand alone mode
//
//     Parameters
// APatSID - Patient ID string, ='' if new patient should be added
// APCMSAPatientDBData - pointer to Patient Data
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASetOnePatientInfo( var APatSID : string;
                       APCMSAPatientDBData : TK_PCMSAPatientDBData;
                       ASkipFieldsSet : Boolean ) : TK_CMEDResult;
var
  UDSAPatients : TK_UDRArray;
  Ind : Integer;
  NewID : Integer;
  PPatAttrs : TK_PCMSAPatientAttrs;

  procedure SetValues();
  begin
    with PPatAttrs^, APCMSAPatientDBData^ do
    begin
      SAPCardNum := APCardNum;
      SAPGender := APGender;
      SAPTitle := APTitle;
      SAPSurname := APSurname;
      SAPFirstname := APFirstname;
      SAPMiddle := APMiddle;
      SAPDOB := APDOB;
      SAPProvID := APProvID;
      SAPAddr1  := APAddr1;
      SAPAddr2  := APAddr2;
      SAPSuburb := APSuburb;
      SAPPostCode := APPostCode;
      SAPState   := APState;
      SAPPhone1  := APPhone1;
      SAPPhone2  := APPhone2;
    end;
  end;

begin
  N_Dump2Str('LA>> EDASASetOnePatientInfo ID=' + APatSID );

  Result := K_edOK;
  UDSAPatients := EDASAGetLocalArchiveUDTab( 'Patients' );

  if (APatSID <> '') and ASkipFieldsSet then Exit; // Unlock is not needed
  with UDSAPatients do
  if APatSID = '' then
  begin // Add New

    Ind := Alength();
    ASetLength( Ind + 1 );
    NewID := Max( TK_PCMSAPatientAttrs(PDE(Ind-1)).SAPID + 1,
                  StrToIntDef(ObjInfo, 1) + 1 );
    ObjInfo := IntToStr( NewID );
    APatSID := ObjInfo;

    PPatAttrs := TK_PCMSAPatientAttrs(PDE(Ind));
    PPatAttrs.SAPID := NewID;
    if APCMSAPatientDBData.APCardNum = '' then
      APCMSAPatientDBData.APCardNum := APatSID;
    SetValues();

    with PatientsInfo.R do
    begin
      Ind := ARowCount();
      ASetLength( AColCount(), Ind + 1 );
      PString(PME(0, Ind))^ := APatSID;
    end;

  end
  else
  begin // Change Existing

    Ind := EDASAUDTabIndByID( UDSAPatients, APatSID );
    PPatAttrs := TK_PCMSAPatientAttrs(PDE(Ind));
    SetValues();
    Ind := EDAArchUDTabIndexOf( APatSID, PatientsInfo );

  end;
  FreeAndNil( PatientsFIOIndex );

  // Set Values to PatientsInfo
  with PatientsInfo.R do
  begin
    PString(PME(1, Ind))^ := APCMSAPatientDBData.APCardNum;
    PString(PME(2, Ind))^ := APCMSAPatientDBData.APFirstname;
    PString(PME(3, Ind))^ := APCMSAPatientDBData.APSurname;
    PString(PME(4, Ind))^ := APCMSAPatientDBData.APTitle;
    PString(PME(5, Ind))^ := APCMSAPatientDBData.APGender;
    if APCMSAPatientDBData.APDOB = 0 then
      PString(PME(6, Ind))^ := ''
    else
      PString(PME(6, Ind))^ := K_DateTimeToStr( APCMSAPatientDBData.APDOB,
                                      N_WinFormatSettings.ShortDateFormat );
    if APCMSAPatientDBData.APIsPMSSync then
      PString(PME(7, Ind))^ := '1';
  end;

  N_Dump2Str('LA>> EDASASetOnePatientInfo fin');

end; // end of TK_CMEDAccess.EDASASetOnePatientInfo

//********************************************* TK_CMEDAccess.EDASASetClearPatientDelState ***
// Set Given Patient Deleting Flag and Unlock
//
//     Parameters
// APatSID - Patient ID string
// AFlags  - Flags string: ='2' Set Deleted forever state, ='0' clear Mark as Deleted State
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASetClearPatientDelState( const APatSID, AFlags : string ) : TK_CMEDResult;
var
  UDSAPatients : TK_UDRArray;
  Ind : Integer;
begin
  N_Dump2Str('LA>> EDASASetClearMarkPatientAsDel ID=' + APatSID );

  Result := K_edOK;
  UDSAPatients := EDASAGetLocalArchiveUDTab( 'Patients' );

  Ind := EDASAUDTabIndByID( UDSAPatients, APatSID );

  with TK_PCMSAPatientAttrs(UDSAPatients.PDE(Ind))^ do
    SAPFlags := (SAPFlags and not 1) or (StrToInt( AFlags ) and 3);

  N_Dump2Str('LA>> EDASASetClearMarkPatientAsDel fin');

end; // end of TK_CMEDAccess.EDASASetClearPatientDelState

//********************************************* TK_CMEDAccess.EDASAGetPatientSlidesView ***
// Get Given Stand alone Patient Slides from Extenal Data
//
//     Parameters
// APatSID - Patient ID string
// ASlidesArray - Resulting Slides Array
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASAGetPatientSlidesView( const APatSID : string; var ASlidesArray : TN_UDCMSArray ): TK_CMEDResult;
var
  i : Integer;
  Ind : Integer;
  PatID : Integer;
begin
  N_Dump2Str('LA>> EDASAGetPatientSlidesView for patient ID=' + APatSID);
  SetLength( ASlidesArray, 0 );

  Result := K_edOK;
  if APatSID = '' then Exit;
  PatID := StrToIntDef( APatSID, -1 );
  if PatID < 0 then Exit;

  SetLength( ASlidesArray, ArchSlidesRoot.DirLength() );
  Ind := 0;
  for i := 0 to ArchSlidesRoot.DirHigh() do
  begin
    CurSlide := TN_UDCMSlide(ArchSlidesRoot.DirChild(i));

    with CurSlide.P()^ do
      if PatID <> CMSPatID then Continue;

    ASlidesArray[Ind] := CurSlide;

    Inc( Ind );
  end;
  SetLength( ASlidesArray, Ind );

  N_Dump2Str('LA>> EDASAGetPatientSlidesView fin');
end; // end of TK_CMEDAccess.EDASAGetPatientSlidesView

//********************************************* TK_CMEDAccess.EDASADelOnePatientSlides ***
// Delete Given Patient Slides and Patient if needed
//
//     Parameters
// APatSID - Patient ID string
// Result - Returns operation resulting code
//
function  TK_CMEDAccess.EDASADelOnePatientSlides( const APatSID : string ): TK_CMEDResult;
var
  i : Integer;
  SlidesArray : TN_UDCMSArray;
  PatID, Ind : Integer;
  UDSAPatients : TK_UDRArray;
  UDSADelPatientsCardnums : TK_UDRArray;
begin
  N_Dump2Str('LA>> EDASADelOnePatientSlides for patient ID=' + APatSID);

  Result := K_edOK;
  if APatSID = '' then Exit;
  PatID := StrToIntDef( APatSID, -1 );
  if PatID < 0 then Exit;

  EDASAGetPatientSlidesView( APatSID, SlidesArray );

  i := Length(SlidesArray);
  if i = 0 then Exit;

  K_CMSlidesDelete( @SlidesArray[0], i, FALSE, TRUE );

  UDSAPatients := EDASAGetLocalArchiveUDTab( 'Patients' );
  Ind := EDASAUDTabIndByID( UDSAPatients, APatSID );

  // Add Card Number of Deleted Patient to DelCardNums Table
  UDSADelPatientsCardnums := TK_UDRArray(UDSAPatients.DirChildByObjName('DelCardNums'));
  if UDSADelPatientsCardnums <> nil then
    with UDSADelPatientsCardnums.PDRA^ do
    begin
      InsertElems();
      PString(P(AHigh()))^ := TK_PCMSAPatientAttrs(UDSAPatients.PDE(Ind))^.SAPCardNum;
    end;

  UDSAPatients.R.DeleteElems(Ind);

  FreeAndNil(PatientsFIOIndex);

  N_Dump2Str('LA>> EDASADelOnePatientSlides fin');

end; // function  TK_CMEDAccess.EDASADelOnePatientSlides

//***************************** TK_CMEDAccess.EDASADelAllDelPatientSlides ***
// Delete All Deleted Patients Slides and Patients if needed
//
//     Parameters
// Result - Returns operation resulting code
//
function  TK_CMEDAccess.EDASADelAllDelPatientSlides( ): TK_CMEDResult;
var
  i : Integer;
  UDSAPatients : TK_UDRArray;
  PCMSAPatientAttrs : TK_PCMSAPatientAttrs;
begin
  N_Dump2Str('LA>> EDASADelAllDelPatientSlides' );
  Result := K_edOK;

  UDSAPatients := EDASAGetLocalArchiveUDTab( 'Patients' );
  for i := UDSAPatients.AHigh() downto 0 do
  begin
    PCMSAPatientAttrs := UDSAPatients.PDE(i);
    with PCMSAPatientAttrs^ do
      if (SAPFlags and 1) <> 0 then
        EDASADelOnePatientSlides( IntToStr(SAPID) );
  end;

  N_Dump2Str('LA>> EDASADelAllDelPatientSlides fin');
end; // function  TK_CMEDAccess.EDASADelAllDelPatientSlides

//************************************* TK_CMEDAccess.EDASASyncPatientsInfo ***
// Change Patient ID in all DB Tables
//
//     Parameters
// AOldID - Old Patient ID
// ANewID - New Patient ID
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDASASyncPatientsInfo(): TK_CMEDResult;
begin
  Result := K_edOK;
end; // function TK_CMEDAccess.EDASASyncPatientsInfo

//***************************************** TK_CMEDAccess.EDADCMCheckPatient ***
// Check if Patient with given attributes exists
//
//     Parameters
// APatSirname - patient Sirname
// APatFirstName - patient First Name
// APatCardNum  - patient card number (use if <> '')
// APatDOB      - patient DOB (use if <> 0)
// Result - Returns PatientID if patient with given attributes exists or 0
//
function TK_CMEDAccess.EDADCMCheckPatient( const APatSirname, APatFirstName, APatCardNum : string; APatDOB : TDate ) : Integer;
var
  AllPatCount, i, PatSInd, PatFInd, DInd  : Integer;
  UDSAPatients : TK_UDRArray;
  SFIO : string;
  FindPatFlag : Boolean;
  PAttrs : TK_PCMSAPatientAttrs;
begin
  N_Dump2Str( format('LA>> EDADCMCheckPatient start %s %s (%s)', [APatSirname, APatFirstName, APatCardNum] ) );
  UDSAPatients := EDASAGetLocalArchiveUDTab( 'Patients' );
  AllPatCount := UDSAPatients.ALength;
  if PatientsFIOIndex = nil then
  begin // Create Patients Index
    PatientsFIOIndex := TStringList.Create;
    for i := 0 to AllPatCount - 1 do
      with TK_PCMSAPatientAttrs(UDSAPatients.PDE(i))^ do
        PatientsFIOIndex.AddObject( SAPSurname + SAPFirstname, TObject(i) );
    PatientsFIOIndex.Sort();
  end;

  Result := 0;
  SFIO := APatSirname + APatFirstName;
  if not PatientsFIOIndex.Find( SFIO, i ) then Exit;
  N_Dump2Str('LA>> EDADCMCheckPatient FIO exists');

  PatSInd := i; // Precaution
  PatFInd := PatSInd;
  // Find FIO interval
  while (PatSInd > 0) and (PatientsFIOIndex[PatSInd-1] = SFIO) do Dec(PatSInd);
  while (PatFInd < AllPatCount - 1) and (PatientsFIOIndex[PatFInd+1] = SFIO) do Inc(PatFInd);

  // Check Card Number
  if APatCardNum <> '' then
    for i := PatSInd to PatFInd do
    begin
      DInd := Integer(PatientsFIOIndex.Objects[i]);
      PAttrs := TK_PCMSAPatientAttrs(UDSAPatients.PDE(DInd ));
      with PAttrs^ do
      begin
        if (SAPFlags and 2) <> 0 then Continue;
        FindPatFlag := SAPCardNum  = APatCardNum;
        if not FindPatFlag then Continue;
        Result := SAPID;
        Exit;
      end;
    end;
  N_Dump2Str('LA>> EDADCMCheckPatient absent CardNum');

  // Check DOB
  if APatDOB <> 0 then
    for i := PatSInd to PatFInd do
    begin
      DInd := Integer(PatientsFIOIndex.Objects[i]);
      PAttrs := TK_PCMSAPatientAttrs(UDSAPatients.PDE(DInd ));
      with PAttrs^ do
      begin
        if (SAPFlags and 2) <> 0 then Continue;
        FindPatFlag := SAPDOB = APatDOB;
        if not FindPatFlag then Continue;
        Result := SAPID;
        Exit;
      end;
    end;
  N_Dump2Str('LA>> EDADCMCheckPatient absent DOB');

end;

// function TK_CMEDAccess.EDADCMCheckPatient

{
//************************************ TK_CMEDAccess.EDAAddExtraInfoStrings ***
// Add Centaur Extra Info to given Strings
//
//     Parameters
// AMacroStrings - Resultings Strings to add
// Result - Returns operation resulting code
//
function TK_CMEDAccess.EDAAddExtraInfoStrings(AMacroStrings: TStrings) : TK_CMEDResult;
begin
  Result := K_edOK;
  AMacroStrings.Clear();
  AMacroStrings.Add( 'N=' + N_CMRegSettingsForm.CompanyName.Caption );
  AMacroStrings.Add( 'PH='+ N_CMRegSettingsForm.Phone.Caption );
  AMacroStrings.Add( 'E=' + N_CMRegSettingsForm.Email.Caption );
end; // end of TK_CMEDAccess.EDAAddExtraInfoStrings
}

//********************************** TK_CMEDAccess.EDAPrintLogoGetDIBByFile ***
// Get Print Logo DIB by image file name
//
//     Parameters
// ALogoFName - name of file with logo image
// Result - Returns nil or new print logo DIB object
//
function  TK_CMEDAccess.EDAPrintLogoGetDIBByFile( ALogoFName : string ): TN_DIBObj;
var
  VFile: TK_VFile;
  Stream: TStream;
begin

//  Get LogoDIB
  Result := nil;
  K_VFAssignByPath( VFile, ALogoFName );
  if K_VFOpen( VFile ) > 0 then
  begin
    Stream := K_VFStreamGetToRead( VFile );
    K_RIObj.RIOpenStream( Stream );
    case K_RIObj.RIGetDIB( 0, Result ) of
      rirFails:       LongWord(Result) := 2; // Method Fails
      rirOutOfMemory: LongWord(Result) := 3; // Method Fails because of memory lack
    end;
    Stream.Free;
  end
  else
    LongWord(Result) := 1;
end; // TK_CMEDAccess.EDAPrintLogoGetDIBByFile

//**************************************** TK_CMEDAccess.EDAPrintLogoGetDIB ***
// Get print templates Logo DIB
//
//     Parameters
// Result - Returns nil or print logo DIB object
//
function TK_CMEDAccess.EDAPrintLogoGetDIB: TN_DIBObj;
var
  VFName, VFNamePat: string;
begin

//  Get LogoDIB
  Result := nil;
  VFNamePat := K_ExpandFileName( '(#WrkFiles#)PrintLogo' + IntToStr(K_CMEDAccess.CurLocID) + '.*' );
  VFName := K_FindFirstFileNameByPattern( VFNamePat );
  if VFName <> '' then
  begin
    Result := EDAPrintLogoGetDIBByFile( VFName );
     if LongWord(Result) < 10 then
      N_Dump1Str( format( 'LA> Print Logo file "%s" problems %u', [VFNamePat, LongWord(Result)] ) );
  end
  else
    N_Dump2Str( format( 'LA> Print Logo file "%s" is not found', [VFNamePat] ) );
end; // TK_CMEDAccess.EDAPrintLogoGetDIB

//************************************* TK_CMEDAccess.EDAPrintLogoSetByFile ***
// Set new Logo to print templates by Logo image file
//
//     Parameters
// ALogoFName - name of file with logo image
// Result - Returns nil or new print logo DIB object
//
function TK_CMEDAccess.EDAPrintLogoSetByFile( const ALogoFName: string ) : TN_DIBObj;
var
  FNameS, FNameR : string;
begin
  Result := EDAPrintLogoGetDIBByFile( ALogoFName );
  if LongWord(Result) < 10 then
  begin
    N_Dump1Str( format( 'LA> New Print Logo file "%s" problems %u', [ALogoFName, LongWord(Result)] ) );
    Exit;
  end;
  FNameR := K_ExpandFileName( '(#WrkFiles#)' );
  FNameS := 'PrintLogo' + IntToStr(K_CMEDAccess.CurLocID) + '.*';
  K_DeleteFolderFiles( FNameR, FNameS );
  FNameR := FNameR + FNameS;
  FNameR := ChangeFileExt( FNameR, ExtractFileExt(ALogoFName) );
  K_CopyFile( ALogoFName, FNameR );
end; // function TK_CMEDAccess.EDAPrintLogoSetByFile

//************************************* TK_CMEDAccess.EDAPrintLocMemIniSave ***
// Save MemIni Location Context
//
function TK_CMEDAccess.EDAPrintLocMemIniSave : TK_CMEDResult;
begin
  K_CMGAModePrintTemplatesFName := '';
  K_CMGAModePrintTemplatesSaveFlag := FALSE;
  Result := K_edOK;
end; // end of TK_CMEDAccess.EDAPrintLocMemIniSave

//*********************************** TK_CMEDAccess.EDAPrintLocMemIniUnload ***
// Clear all Print Locations MemIni Contexts
//
function TK_CMEDAccess.EDAPrintLocMemIniUnload( const APTFName : string ) : TK_CMEDResult;
begin
  Result := K_edOK;
  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
    K_CMEDADFPLExec.DstIniFile := K_CMEDAMemIniFile;
    K_CMEDAMemIniFile.Clear;
    if K_CMEDADFPLExec.DFPLExecTFSection('LocationPrint|Save') then
    begin
      K_CMEDAccess.TmpStrings.Clear;
      K_CMEDAMemIniFile.GetStrings(K_CMEDAccess.TmpStrings);
    end;
    if not K_VFSaveText( K_CMEDAccess.TmpStrings.Text, APTFName, K_DFCreatePlain ) then
      Result := K_edFails;
  end;
end; // end of TK_CMEDAccess.EDAPrintLocMemIniUnload

//********************************* TK_CMEDAccess.EDADevicePlateUseCountGet ***
// Get Device Plate Counter
//
//     Parameters
// APlateName - Plate id string
// Result - Returns Plate Counter, if < 0 then Plates Counter is undefined
//
function TK_CMEDAccess.EDADevicePlateUseCountGet( const APlateName: string ): Integer;
begin
  Result := -1;
end; // TK_CMEDAccess.EDADevicePlateUseCountGet

//********************************* TK_CMEDAccess.EDADevicePlateUseCountGet ***
// Increment Device Plate Counter
//
//
//     Parameters
// APlateName - Plate id string
// Result - Returns resulting Plate Counter, if < 0 then Plates Counter is undefined
//
function TK_CMEDAccess.EDADevicePlateUseCountInc( const APlateName: string ): Integer;
begin
  Result := -1;
end; // TK_CMEDAccess.EDADevicePlateUseCountInc

//***************************************** TK_CMEDAccess.EDADCMSeriesStart ***
// DICOM Series start
//
procedure TK_CMEDAccess.EDADCMSeriesStart;
begin
//  K_CMDCMSeriesID := CurSlidesList.Count;  // Current DICOM Series ID
//  K_CMDCMSeriesIDTS  := Now();
//  N_Dump2Str( 'DEMO> EDADCMSeriesStart');
end; // procedure TK_CMEDAccess.EDADCMSeriesStart;

//***************************************** TK_CMEDAccess.EDADCMSeriesStart ***
// DICOM Series fin
//
procedure TK_CMEDAccess.EDADCMSeriesFin;
begin
//  K_CMDCMSeriesID := 0;   // Current DICOM Series ID
//  N_Dump2Str( 'DEMO> EDADCMSeriesFin');
end; // procedure TK_CMEDAccess.EDADCMSeriesFin;

{ *** end of TK_CMEDAccess *** }

{ *** TK_CMEDDBAccess *** }

//********************************************* TK_CMEDAccess.Create ***
// Class TK_CMEDAccess constructor
//
constructor TK_CMEDDBAccess.Create;
begin
  inherited;
{
  if (MemTextFragms.MTVFileName <> '') and
     (MemTextFragms.MTFragmsList.Count = 0) then
    raise Exception.Create
      ('File with Contexts Copy DFPL scripts is absent -> ' + MemTextFragms.MTVFileName);
}

  EDARebuildADOObjects();
{
  LANDBConnection := TADOConnection.Create(Application);
  LANDBConnection.LoginPrompt := false;
  // LANDBConnection.ConnectionString := K_CMDBGetConnectionString();
  // WANDBConnection := LANDBConnection;

  CurSlidesDSet := TADOQuery.Create(Application); // Current Slides Data Set
  CurSlidesDSet.Connection := LANDBConnection;
  CurDSet1 := TADOQuery.Create(Application); // Common SQL Query Data Set 1
  // CurDSet1.LockType := ltBatchOptimistic;

  CurDSet2 := TADOQuery.Create(Application); // Common SQL Query Data Set 2
  // CurDSet2.LockType := ltBatchOptimistic;

  CurDSet3 := TADOQuery.Create(Application); // Common SQL Query Data Set 3

  CurBlobDSet := TADOQuery.Create(Application);
  // Common SQL Blobs Query Data Set

  CurSQLCommand1 := TADOCommand.Create(Application);
  // Common SQL Command object 1
  CurSQLCommand1.CommandType := cmdText;

  CurStoredProc1  := TADOStoredProc.Create(Application);
}
  CurDataCompressPower := N_MemIniToInt('CMSDB', 'BlobsCompressPower', 1);
  ImgDBFileCompressPower := CurDataCompressPower;
  ImgFileCompressPower := CurDataCompressPower;
  // ImgDBFileCompressPower :=  N_MemIniToInt( 'CMSDB', 'ImgDBFileCompressPower', 1 );
  // ImgFileCompressPower :=  N_MemIniToInt( 'CMSDB', 'ImgFileCompressPower', 0 );  this code is used

// 2018-07-13 Close this code - don't remeber why this code appear
//  ImgDBFileCompressPower := 0;
//  ImgFileCompressPower := 0;

  SlidesCRFCopiedFilesPaths := THashedStringList.Create;
  // List of Paths to delete after copy

  SlideStudyInfoUpdateStrings := TStringList.Create;
end; // end of TK_CMEDDBAccess.Create

//********************************************* TK_CMEDAccess.destructor ***
// Class TK_CMEDAccess destructor
//
destructor TK_CMEDDBAccess.Destroy;
begin
//  N_S := IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCACreate)));
//  N_S1 := IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCACreateIAC)));

  N_Dump2Str('TK_CMEDDBAccess.Destroy >> start');

  if ATimer <> nil then
    ATimer.Enabled := FALSE;

  UDRootInstanceInfo.UDDelete();
  UDRootProviderInfo.UDDelete();
  UDRootGlobalInfo.UDDelete();
  UDRootServerInfo.UDDelete();
  UDRootLocationInfo.UDDelete();

  SlideStudyInfoUpdateStrings.Free;

  ArchSlideTIMG.Free;
  ArchSlideQTIMG.Free;


  try
    if LANDBConnection.Connected then
    begin

      if AppRTID > 0 then
      begin // Precaution for clear All Data Mode
        EDAAppDeactivate();
        N_Dump2Str('TK_CMEDDBAccess.Destroy >> after EDAAppDeactivate');
      end;

      if CurSessionHistID <> 0 then
      begin
        EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                                 Ord(K_shNCAFinishSession) ) );
        N_Dump2Str('TK_CMEDDBAccess.Destroy >> after EDASaveSlidesHistory FinishSession' );
      end;

      Sleep(30); // needed to save correct timestamp in DB
      N_Dump2Str('TK_CMEDDBAccess.Destroy >> before EDASaveSlidesHistory CMSClose' );

      if CurSessionHistID = 0 then
        CurSessionHistID := PrevSessionHistID; // Set

      EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                                 Ord(K_shNCACMSClose) ) );
      N_Dump2Str('TK_CMEDDBAccess.Destroy >> after EDASaveSlidesHistory CMSClose' );

{ // TmpBlobTable is not really used now
      with CurSQLCommand1 do
      begin
        Connection := LANDBConnection;
        CommandText :='DROP TABLE ' + K_CMENDBTmpTable + ';';
//        CurTmpTableExists := FALSE;
        Execute;
      end;
      N_Dump2Str('TK_CMEDDBAccess.Destroy >> after DROP TmpBlobTable' );
}
    end; // if LANDBConnection.Connected then
  except
    on E: Exception do
    begin
      N_Dump2Str( 'TK_CMEDDBAccess.Destroy >> ' + E.Message );
    end;
  end;

// Put Store Proc Fre to the first position because of Error
// while finishing ComServer by ComInterface freeing
  CurStoredProc1.Free;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> after CurStoredProc1.Free' );
  CurSlidesLocDSet.Free;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> after CurSlidesLocDSet.Free' );
  CurSlidesDSet.Free;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> after CurSlidesDSet.Free' );
  CurDSet1.Free;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> after CurDSet1.Free' );
  CurDSet2.Free;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> after CurDSet2.Free' );
  CurDSet3.Free;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> after CurDSet3.Free' );
  CurBlobDSet.Free;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> after CurBlobDSet.Free' );
  CurSQLCommand1.Free;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> after CurSQLCommand1.Free' );
  LANDBConnection.Free;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> after LANDBConnection.Free' );
  SlidesCRFCopiedFilesPaths.Free;

  N_Dump2Str('TK_CMEDDBAccess.Destroy >> before inherited ' );
  inherited;
  N_Dump2Str('TK_CMEDDBAccess.Destroy >> fin' );
end; // end of TK_CMEDDBAccess.Destroy

//************************************ TK_CMEDDBAccess.EDARebuildADOObjects ***
// Class TK_CMEDAccess constructor
//
procedure TK_CMEDDBAccess.EDARebuildADOObjects;
begin
  N_Dump2Str( 'EDARebuildADOObjects start');

  try
    if CurSlidesDSet  <> nil then FreeAndNil(CurSlidesDSet);
    if CurDSet1       <> nil then FreeAndNil(CurDSet1);
    if CurDSet2       <> nil then FreeAndNil(CurDSet2);
    if CurDSet3       <> nil then FreeAndNil(CurDSet3);
    if CurBlobDSet    <> nil then FreeAndNil(CurBlobDSet);
    if CurSQLCommand1 <> nil then FreeAndNil(CurSQLCommand1);
    if CurStoredProc1 <> nil then FreeAndNil(CurStoredProc1);
    if LANDBConnection <> nil then
      LANDBConnection.Free;

    if K_CMAddDBConnection <> nil then
    begin
      FreeAndNil(K_CMAddADOQuery);
      FreeAndNil(K_CMAddADOCommand);
      FreeAndNil(K_CMAddDBConnection);
    end;
  except
    on E: Exception do begin
      N_Dump1Str( 'EDARebuildADOObjects ERROR >> ' + E.Message );
    end;
  end;

  LANDBConnection := TADOConnection.Create(Application);
  LANDBConnection.LoginPrompt := false;


  // LANDBConnection.ConnectionString := K_CMDBGetConnectionString();
  // WANDBConnection := LANDBConnection;

  CurSlidesDSet := TADOQuery.Create(Application); // Current Slides Data Set
  CurSlidesDSet.Connection := LANDBConnection;

  CurDSet1 := TADOQuery.Create(Application); // Common SQL Query Data Set 1
  // CurDSet1.LockType := ltBatchOptimistic;

  CurDSet2 := TADOQuery.Create(Application); // Common SQL Query Data Set 2
  // CurDSet2.LockType := ltBatchOptimistic;

  CurDSet3 := TADOQuery.Create(Application); // Common SQL Query Data Set 3

  CurBlobDSet := TADOQuery.Create(Application);
  // Common SQL Blobs Query Data Set

  CurSQLCommand1 := TADOCommand.Create(Application);
  // Common SQL Command object 1
  CurSQLCommand1.CommandType := cmdText;

  CurStoredProc1 := TADOStoredProc.Create(Application);

  N_Dump2Str( 'EDARebuildADOObjects fin');
end; // end of TK_CMEDDBAccess.EDARebuildADOObjects

//*************************************** TK_CMEDAccess.EDAAppUnlockObjects ***
// Unlock all Locked Objects by Instance runtime ID
//
//     Parameters
// ASAppRTID - Instance runtime ID
//
procedure TK_CMEDDBAccess.EDAAppUnlockObjects( ASAppRTID: string );
var
  SQLText : string;
begin
////////////////////////////////////////////////////////////
// if something is changed in this code SQL scripts
// created within SIR #22817 should be changed consistently
////////////////////////////////////////////////////////////


  // Unlock all slides locked by current AppRTID
  N_Dump1Str( format( 'DB>> Unlock Objects for ActRTID=%s by ActRTID=%d', [ASAppRTID,AppRTID] ) );
  with CurSQLCommand1 do
  begin

    SQLText := 'DELETE FROM ' + K_CMENDBLockSlidesTable + ' WHERE ' +
                   K_CMENDBLSlidesTFActRTID + ' = ' + ASAppRTID;
    if K_CMEDDBVersion >= 19 then
    begin
      SQLText := SQLText + ';' + #10 +
        'UPDATE ' + K_CMENDBAllPatientsTable +
                       ' SET ' + K_CMENDAPActRTID + ' = 0' +
                       ' WHERE ' + K_CMENDAPActRTID + ' = ' + ASAppRTID + ';' + #10 +

        'UPDATE ' + K_CMENDBAllProvidersTable +
        ' SET ' + K_CMENDAUActRTID + ' = 0' +
        ' WHERE ' + K_CMENDAUActRTID + ' = ' + ASAppRTID + ';' + #10 +

        'UPDATE ' + K_CMENDBAllLocationsTable +
        ' SET ' + K_CMENDALActRTID + ' = 0' +
        ' WHERE ' + K_CMENDALActRTID + ' = ' + ASAppRTID;

      if K_CMEDDBVersion >= 28 then
      begin
        SQLText := SQLText + ';' + #10 +
          'UPDATE ' + K_CMENDBACMPDataTable +
          ' SET ' + K_CMENDBACMPDataTFCMPActRTID + ' = 0' +
          ' WHERE ' + K_CMENDBACMPDataTFCMPActRTID + ' = ' + ASAppRTID;

        if K_CMEDDBVersion >= 32 then
        begin
          SQLText := SQLText + ';' + #10 +
            'DELETE FROM ' + K_CMENDBActInstDevProfilesTable +
            ' WHERE ' + K_CMENDAInstRTID + ' = ' + ASAppRTID;
        end; // if K_CMEDDBVersion >= 32 then
      end; // if K_CMEDDBVersion >= 28 then
    end; // if K_CMEDDBVersion >= 19 then
    CommandText := SQLText;
    Execute;
  end; // with CurSQLCommand1 do
end; // procedure TK_CMEDDBAccess.EDAAppUnlockObjects

//************************************ TK_CMEDDBAccess.EDADumpActiveContext ***
// Dump Active Context
//
//     Parameters
// ADataSet - Data Set to Query Active Instances
// ARStrings - Strings for Dump Info
// Result - Returns operation resulting code
//
procedure TK_CMEDDBAccess.EDADumpActiveContext( ADataSet : TADOQuery; ARStrings : TStrings; ASkipSelfFlag : Boolean = FALSE );
var
  WStr : string;
begin
  try
    with ADataSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

//      WStr := 'select ' +
//        K_CMENDBAAInstsTable + '.' + K_CMENDBAAInstsTFActRTID + ',' +  {0}
//        K_CMENDBAAInstsTable + '.' + K_CMENDBAAInstsTFActTS + ',' +    {1}
//        K_CMENDBAAInstsTable + '.' + K_CMENDBAAInstsTFActTSUID + ',' + {2}
//        K_CMENDBAAInstsTable + '.' + K_CMENDBAAInstsTFGlobID + ',' +   {3}
//        K_CMENDBAAInstsTable + '.' + K_CMENDBAAInstsTFPatID + ',' +    {4}
//        K_CMENDBAAInstsTable + '.' + K_CMENDBAAInstsTFProvID + ',' +   {5}
//        K_CMENDBAAInstsTable + '.' + K_CMENDBAAInstsTFLocID + ',' +    {6}
//        K_CMENDBGAInstsTable + '.' + K_CMENDBGAInstsTFCName +          {7}
//        ' from ' + K_CMENDBAAInstsTable + ',' + K_CMENDBGAInstsTable +
//        ' where ' + K_CMENDBAAInstsTable + '.' + K_CMENDBAAInstsTFGlobID + '=' +
//                    K_CMENDBGAInstsTable + '.' + K_CMENDBAAInstsTFGlobID;

      WStr := 'select ' +
        'A.' + K_CMENDBAAInstsTFActRTID + ',' +  {0}
        'A.' + K_CMENDBAAInstsTFActTS + ',' +    {1}
        'A.' + K_CMENDBAAInstsTFActTSUID + ',' + {2}
        'A.' + K_CMENDBAAInstsTFGlobID + ',' +   {3}
        'A.' + K_CMENDBAAInstsTFPatID + ',' +    {4}
        'A.' + K_CMENDBAAInstsTFProvID + ',' +   {5}
        'A.' + K_CMENDBAAInstsTFLocID + ',' +    {6}
        'B.' + K_CMENDBGAInstsTFCName;           {7}
        if K_CMEDDBVersion >= 19 then
          WStr := WStr + ',C.' +  K_CMENDASServName; {8}

        WStr := WStr +
          ' from ' + K_CMENDBAAInstsTable + ' A, ' + K_CMENDBGAInstsTable + ' B';

        if K_CMEDDBVersion >= 19 then
          WStr := WStr + ',' +  K_CMENDBAllServersTable + ' C';

        WStr := WStr +
          ' where A.' + K_CMENDBAAInstsTFGlobID + '=B.' + K_CMENDBGAInstsTFGlobID;

        if K_CMEDDBVersion >= 19 then
          WStr := WStr + ' and A.' +  K_CMENDBAAInstsTFServID + '=C.' + K_CMENDASServID;

      SQL.Text := WStr;

      Filtered := false;
      // N_s := SQL.Text;
      Open;
      First;
      WStr := K_CMENDBAAInstsTFActRTID + Chr(9) + K_CMENDBAAInstsTFActTS + Chr
          (9) + Chr(9) + Chr(9) + K_CMENDBAAInstsTFActTSUID + Chr(9)
          + 'GlobID' + Chr(9) +
        // K_CMENDBAAInstsTFGlobID   + Chr(9) +
          K_CMENDBAAInstsTFPatID + Chr(9) + K_CMENDBAAInstsTFProvID + Chr(9)
          + K_CMENDBAAInstsTFLocID + Chr(9) + K_CMENDBGAInstsTFCName;
      if K_CMEDDBVersion >= 19 then
        WSTR := WSTR + Chr(9) + K_CMENDASServName;
      ARStrings.Add(WSTR);
      while not Eof do
      begin
        if not ASkipSelfFlag or (AppRTID <> FieldList.Fields[0].AsInteger) then
        begin
          WSTR := FieldList.Fields[0].AsString + Chr(9)
              + FieldList.Fields[1].AsString + Chr(9)
              + FieldList.Fields[2].AsString + Chr(9)
              + FieldList.Fields[3].AsString + Chr(9)
              + FieldList.Fields[4].AsString + Chr(9)
              + FieldList.Fields[5].AsString + Chr(9)
              + FieldList.Fields[6].AsString + Chr(9)
              + EDAGetStringFieldValue(FieldList.Fields[7]);
          if K_CMEDDBVersion >= 19 then
            WSTR := WSTR + Chr(9) + EDAGetStringFieldValue(FieldList.Fields[8]);
          ARStrings.Add(WSTR);
        end;
        Next;
      end;
      Close;
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDADumpActiveContext ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDADumpActiveContext

//********************************************* TK_CMEDAccess.EDASetActiveTimeStamp ***
// Regular Activity Time Stamp set handler
//
procedure TK_CMEDDBAccess.EDASetActiveTimeStamp( Sender: TObject );
var
  SAppRTID: string;
  SClientAppGlobID: string;
  UseLostActiveRecord: Boolean;
  SDBClientAppGlobID: string;
  CDTime: TDateTime;
  ErrInfo: string;
  IniResCode : Integer;
  FastTimerEvent : Boolean;
  EventStartTime : Double;
  EventTimeShift : Double;
  ScanDataPathExists : Boolean;
  ScanDataPathCheck : TK_CFPState;
  SkipReconnectFlag : Boolean;

label TimeStampError, ReconectLoop;

  function  CheckFilePath( const AScanDataPath : string; ASingleCheckFlag : Boolean ) : TK_CFPState;
  var
    PathCode : Integer;
    PrevCheckNum : Integer;
  begin
    // Set Flags
    K_CMScanDataPathCheckThread.CFPSingleCheckFlag := ASingleCheckFlag;

    // Prepare Path Code
    PathCode := K_CMScanDataPathCheckThread.CFPSetNewCheckPath( AScanDataPath );
    if K_CMScanDataPathCheckResult.CFPPathCode <> PathCode then
    begin
      K_CMScanDataPathCheckResult.CFPState := cfpsNotDef;
      K_CMScanDataPathSlowCheckCount := 0;
    end;

    // Calc Result State
    PrevCheckNum := K_CMScanDataPathPrevCheckNum;
    K_CMScanDataPathPrevCheckNum := K_CMScanDataPathCheckResult.CFPCheckNum;

    Result := K_CMScanDataPathCheckResult.CFPState;
    if Result <> cfpsOpOK then Exit;
    if K_CMScanDataPathCheckResult.CFPTime >= N_CPUFrequency * K_CMScanNetworkMaxDelay then
    begin
      if PrevCheckNum <> K_CMScanDataPathCheckResult.CFPCheckNum then
      begin
        Inc(K_CMScanDataPathSlowCheckCount);
        if K_CMScanDataPathSlowCheckCount > K_CMScanNetworkSlowMinTest then
          Result := cfpsOpSlow;
      end;
    end
    else
      K_CMScanDataPathSlowCheckCount := 0;
  end; // function CheckFilePath

  procedure PrepCurAutoDetectScanDataPath();
  begin
{} //Main Code
      if K_CMScanDataPathAutoCur = '' then
        K_CMScanDataPathAutoCur := '\\tsclient\A\CMScan\Exchange\';
      K_CMScanDataPathAutoCur[12] := Chr( Ord('C') + K_CMScanDataPathAutoSInd );
{}
{ //DEBUG Code
      if K_CMScanDataPathAutoCur = '' then
        K_CMScanDataPathAutoCur := 'D:\Delphi_prj_new\DTmp\!CMS_ScanData1\'; // Debug
      K_CMScanDataPathAutoCur[1] := Chr( Ord('C') + K_CMScanDataPathAutoSInd ); // Debug
{}
  end; // procedure PrepCurAutoDetectScanDataPath

  procedure CheckCMScanIsInstalled( const AScanDataPath : string );
  begin
    if (AScanDataPath = '') or (K_CMScanClientName = '') then Exit; // Skip all if path is empty

    K_CMScanIsInstalled := ScanDataPathExists and (AScanDataPath <> '') and
                           DirectoryExists( AScanDataPath + K_CMScanClientName + '\' );
    K_CMScanWasInstalled := not K_CMScanIsInstalled     and
                            (K_CMScanDataPathOld <> '') and
                            DirectoryExists(K_CMScanDataPathOld + K_CMScanClientName + '\');

    if not K_CMScanIsInstalled then Exit;


    if K_CMScanDataPathOnClientPC and
       (K_CMEDAccess <> nil)      and
       K_CMEDAccess.AccessReady   and
       (K_CMSAppStartContext.CMASMode < K_cmamCOMHPUI) then //to prevent exception in HRPreview
      K_CMScanRebuildCommonInfoFile(); // Needed after change path to Client Based

    if K_CMScanProcessClientTasksFlag then
    begin // Activate Process Client Tasks Action if needed
      K_CMScanProcessClientTasksFlag := FALSE;
      N_Dump1Str( '!!! Process Client Tasks >> Add to Actions Wait=' + N_B2S(K_CMD4WWaitApplyDataCount > 0) );
      N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServProcessClientTasks,
                                          K_CMD4WWaitApplyDataCount = 0 );
    end;

    N_CM_MainForm.CMMFDisableActions( nil );
  end; // procedure CheckCMScanIsInstalled

  procedure CheckScanDataPath( const AScanDataPath : string );
  var CheckState : TK_CFPState;
  begin
    if K_CMScanDataPathCheckThread = nil then Exit; // precaution

    CheckState := CheckFilePath( AScanDataPath, FALSE );
    case CheckState of
      cfpsNotDef : Exit;
      cfpsOpOK   : ScanDataPathExists := TRUE;
      cfpsOpFails,
      cfpsOpSlow : ScanDataPathExists := FALSE;
    end;

    if not ScanDataPathExists then
    begin
      if not K_CMScanDataPathLost then
      begin
      // set warning flag
        if not K_CMScanDataPathLostShowMessage then // to prenet Clear if was set early
          K_CMScanDataPathLostShowMessage := K_CMScanIsInstalled;

        K_CMScanIsInstalled := FALSE;

        // indicate that path is lost only if CMS is ready to use CMScan
        if K_CMD4WWaitApplyDataCount = 0 then
        begin
          K_CMScanDataPathLost := TRUE;
          N_CM_MainForm.CMMFDisableActions( nil );
          N_Dump1Str( format( 'DB> ScanData path access is lost State=%d SlowCount=%d',
              [Ord(CheckState), K_CMScanDataPathSlowCheckCount] ) );
          if K_CMScanDataPathLostShowMessage then
            K_CMShowMessageDlgByTimer( 'An access to destination folder ' + AScanDataPath +
                                       ' has been lost. Press OK to continue',
                                       mtWarning, N_CM_MainForm.CMMCurFMainForm <> nil );
                                //immediate timer activation if interface is ready
//                                      mtWarning, TRUE );
          K_CMScanDataPathLostShowMessage := FALSE;
        end; // if K_CMD4WWaitApplyDataCount = 0 then
      end;
    end   // if not ScanDataPathExists then
    else
    begin // if ScanDataPathExists then
      if K_CMScanDataPathLost then
      begin // Do all needed after path access is revived
        N_Dump1Str( 'DB> ScanDataPath access is revived ' + AScanDataPath );
        CheckCMScanIsInstalled( AScanDataPath );
        K_CMScanDataPathLost := FALSE;
        K_CMScanDataPathLostShowMessage := FALSE;
      end;
    end;  // if ScanDataPathExists then
  end; // procedure CheckScanDataPath

  procedure CheckCLLEvent(  );
  begin
  // Check link event

    IniResCode := K_CMSCLLContextFromIniFile( K_CMSCLLIniFName, TRUE );
    if IniResCode = 0 then
    begin
    // Apply New Context
      if K_CMSCLLAttrs.PatientAttrs.CLLPID <> -1 then
      begin
        if K_CMVUIMode and (K_CMSCLLAttrs.PatientAttrs.CLLPID = -3) then
        begin
        // Add Action to Close CMSuite by New CLL Contex
          N_Dump1Str( '!!! Close CMSuite by CLL in VUIMode >> Add to Actions Wait=' + N_B2S(K_CMD4WWaitApplyDataCount > 0) );
          K_CMCloseOnCurUICloseFlag := TRUE;
          N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServCloseCMS, K_CMD4WWaitApplyDataCount = 0 );
        end
        else
        begin
        // Add Action to Apply New CLL Contex
          N_Dump1Str( '!!! Apply New CLL Context >> Add to Actions Wait=' + N_B2S(K_CMD4WWaitApplyDataCount > 0) );
          N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServApplyCLLContext, K_CMD4WWaitApplyDataCount = 0 );
        end;
      end;
    end; // if IniResCode = 0 then

    if IniResCode < 2 then
      K_DeleteFile( K_CMSCLLIniFName );

  end; // procedure CheckCLLEvent

  procedure CheckScanCompName(  );
  begin
    K_CMVUIScanName := K_CMVUIGetScanCompNameCheckProc();
    if K_CMVUIScanName <> '' then
    begin
      EDAGlobal2MemIniToCurState;
      N_CM_MainForm.CMMFDisableActions( nil );
      K_CMVUIGetScanCompNameFinDT := 0; // set finish scan mode
    end;

    if EventStartTime < K_CMVUIGetScanCompNameFinDT then Exit;

   // Computer Name Wait is finished
    K_CMVUIGetScanCompNameFinDT := 0;
    K_CMVUIGetScanCompNameStopProc();
 end; // procedure CheckScanCompName


begin
  if not ATimer.Enabled then
  begin
    N_Dump1Str('DB>> EDASetActiveTimeStamp is Disabled!!!');
    Exit;
  end;

  ATimer.Enabled := FALSE;

  Inc(ATimerCount); // Increment Fast Timer Event Number

{ //2018-02-04 CMScan Client AutoDetect delay debug
N_Dump2Str( format( '!!!1 TCount=%d SDP=%s SDPO=%s SDPL=%s CP=%s CPA=%s'#13#10+
  'SDPA=%s SDPAC=%s SII=%s SWI=%s',
  [ATimerCount,K_CMScanDataPath,K_CMScanDataPathOld,N_B2S(K_CMScanDataPathLost),
  N_B2S(K_CMScanDataPathOnClientPC),N_B2S(K_CMScanDataPathOnClientPCAuto),
  K_CMScanDataPathAuto,K_CMScanDataPathAutoCur,
  N_B2S(K_CMScanIsInstalled),N_B2S(K_CMScanWasInstalled)] ) );
{}

//////////////////////////////////////
//  Check User Time shift
//
  EventStartTime := Now();
  if LastFastTimeStamp <> 0 then
  begin // Check if Time event is fast
  // Check User time shift
    EventTimeShift := EventStartTime - LastFastTimeStamp;
    if (EventTimeShift <= 0) or (EventTimeShift >= K_CMEDAActivateDeltaDD) then
    begin // User time shift was detected - rebuild time settings
      EventTimeShift := EventTimeShift - K_CMEDAActivateDeltaDD / 60; // Shift = Shift-1 second (in days)
      N_Dump1Str( format( '***** User TimeShift detected: %g sec',[EventTimeShift * 24 * 60 * 60] ) );
      if K_CMAutoCloseLastActTS = 0 then
      begin // Main Connection is actual - calc new time shift with DB Server
        with CurDSet1 do
        begin
          Connection := LANDBConnection;
          ExtDataErrorCode := K_eeDBSelect;

          // *** Synchronize Self Time with System Time
          SQL.Text := 'SELECT GETDATE( );';
          Filtered := false;
          Open;
          SyncTimeDelta := TDateTimeField(FieldList.Fields[0]).Value - EventStartTime;

          N_LogChannels[N_Dump1LCInd].LCTimeShift := SyncTimeDelta;
          N_Dump1Str( format( '***** TimeStamp: changed from ClientTime=%s by TimeDelta=%g sec',
                      [K_DateTimeToStr(EventStartTime, 'yyyy-mm-dd hh":"nn":"ss.zzz'),
                       SyncTimeDelta * 24 * 60 * 60] ) );
        end; // with CurDSet1 do

      end; // Calc new Time shift with DB server

      // Shift all early defind Timestamps
      if K_CMAutoCloseLastActTS <> 0 then
        K_CMAutoCloseLastActTS := K_CMAutoCloseLastActTS + EventTimeShift;
      if K_CMScanDataPathAutoSearchNextStartTS <> 0 then
        K_CMScanDataPathAutoSearchNextStartTS := K_CMScanDataPathAutoSearchNextStartTS + EventTimeShift;
      if K_CMScanDataPathAutoSearchClearTS <> 0 then
        K_CMScanDataPathAutoSearchClearTS := K_CMScanDataPathAutoSearchClearTS + EventTimeShift;
      NextActiveTimeStamp := 0; // Clear Active Time Interval control - use NextActiveTimeCount only
    end; // if (EventTimeShift <= 0) or (EventTimeShift >= K_CMEDAActivateDeltaDD) then
  end; // if FastTimerEvent then // check User Time shift
  LastFastTimeStamp := EventStartTime;
//
//  Check User Time shift
//////////////////////////////////////

//////////////////////////////////////
//  Sleeping CMS Auto Close (after 20 minutes)
//
  if K_CMAutoCloseLastActTS <> 0 then
  begin
    if EventStartTime > K_CMAutoCloseLastActTS + K_CMAutoCloseDaysDelta then
    begin
    // Close CMSuite
      N_Dump1Str( '***** AutoClose CMSuite by Timer' );
      N_CM_MainForm.Close();
    end
    else
    begin
      if (ATimerCount mod 300) = 0 then
        N_Dump1Str('DB>> EDASetActiveTimeStamp AutoClose check');
      ATimer.Enabled := TRUE;
    end;

    Exit;
  end; // if K_CMAutoCloseLastActTS <> 0 then


//////////////////////////////////////
//  DB connection auto resume
//
  if ReconnectCounter > 0 then
  begin
    if ATimerCount < ReconnectNextActiveCount then
    begin
      ATimer.Enabled := TRUE;
      Exit;
    end;

    try
      N_CM_MainForm.CMMFShowString( 'Trying to resume DB connection, please wait ...' );
      N_Dump1Str( format( 'DB>> EDASetActiveTimeStamp Reconnect Try=%d TCount=%d', [ReconnectCounter,ATimerCount] ) );
      EDARebuildADOObjects();
//      LANDBConnection.ConnectionString := K_CMDBGetConnectionString(K_CMDBGetSessionID());
      LANDBConnection.ConnectionString := K_CMDBGetConnectionString();
      N_Dump2Str('DB>> EDASetActiveTimeStamp Reconnect DB connection >= ' + LANDBConnection.ConnectionString);
      EDADBConnect( LANDBConnection );
      // Skip Fast Event condition
      NextActiveTimeStamp := 0; //
      NextActiveTimeCount := 0; //
      N_CM_MainForm.CMMFShowString( '' );
    except
      on E: Exception do
      begin
        Inc(ReconnectCounter);
        N_Dump2Str( format( 'DB>> EDASetActiveTimeStamp Rcn Except %d >> %s',
                          [ReconnectCounter, E.Message] ) );
//        if ReconnectCounter >= 178 then // try to reconnect more times
        if ReconnectCounter >= 60 then
        begin
          ExtDataErrorString := 'EDASetActiveTimeStamp >> Rcn Reconnect fails';
          EDAShowErrMessage(TRUE);
        end
        else
        begin
          ReconnectNextActiveCount := ATimerCount + 5;
          ATimer.Enabled := TRUE;
          Exit;
        end;
      end;
    end;
  end; // if ReconnectCounter > 0 then

/////////////////////////////////////////////////////////
//  Fast Timer Event Handler
//
  // Check if Time event is realy fast
  FastTimerEvent := ((NextActiveTimeStamp <> 0) or (NextActiveTimeCount <> 0))
                                                and
                    ((NextActiveTimeStamp = 0)  or (NextActiveTimeStamp > EventStartTime))
                                                and
                    ((NextActiveTimeCount = 0)  or (NextActiveTimeCount > ATimerCount));


  //  Check Link Event - if new Link (by command line) was activate
  if K_CMEDAccess.AccessReady                 and  // CMS is ready
     (K_CMSCLLAttrs.PatientAttrs.CLLPID <= 0) then // K_CMSCLLAttrs are free to use
//     (K_CMSCLLAttrs.PatientAttrs.CLLPID <= 0) and  // K_CMSCLLAttrs are free to use
//     not K_CMVUIMode then // not VirtualUI
    CheckCLLEvent();

  // Check Scan Computer Name from CMScan
  if K_CMVUIMode and (K_CMVUIGetScanCompNameFinDT > 0) then CheckScanCompName( );

  if (K_CMSAppStartContext.CMASMode < K_cmamCOMHPUI) then //to prevent exception in HRPreview
  begin

    // Fast Check if CMScan Data Path Set
    ScanDataPathExists := FALSE;
    if K_CMScanDataPath <> '' then
      CheckScanDataPath( K_CMScanDataPath )
    else
    if K_CMScanDataPathOnClientPCAuto then
    begin // Client PC Auto ScanDataPath

      // Check PathAutoNextSearch Start
      if (K_CMScanDataPathAutoSearchNextStartTS <> 0) and
         (K_CMScanDataPathAutoSearchNextStartTS <= EventStartTime) then
      begin // activate next Client ScanData Path search
        N_Dump1Str( 'DB> Client PC ScanDataPath Autodetect is activated' );
        K_CMScanDataPathAutoSInd := 0;
        K_CMScanDataPathAutoSearchNextStartTS := 0;
      end;

      if K_CMScanDataPathAuto <> '' then
      begin // Use Early Detected Path K_CMScanDataPathAuto
        CheckScanDataPath( K_CMScanDataPathAuto );
        if not ScanDataPathExists then
        begin // Early Auto Detected ScanDataPath is lost
          if K_CMScanDataPathAutoSearchClearTS = 0 then
          // Set Clear Client ScanDataPath Auto Context Timestamp = Now + 60 sec
            K_CMScanDataPathAutoSearchClearTS := EventStartTime + K_CMEDAActivateDeltaDD
          else
          if K_CMScanDataPathAutoSearchClearTS <= EventStartTime then
          begin
          // Set ScanDataPath Auto Detected mode (will be used on next Fast Time Event)
            K_CMScanDataPathAuto := '';
            K_CMScanDataPathAutoCur := '';
            K_CMScanDataPathAutoSInd := 0;
            K_CMScanDataPathAutoSearchClearTS := 0;
            // Set New Path to PathCheckThread
            PrepCurAutoDetectScanDataPath();
            CheckFilePath( K_CMScanDataPathAutoCur, TRUE );
            N_Dump1Str( 'DB> Set ScanDataPath Auto search' );
          end;
        end  // if not ScanDataPathExists then
        else // if ScanDataPathExists then Clear K_CMScanDataPathAutoSearchClearTS
        begin
          if not K_CMScanIsInstalled then
          begin
            N_Dump1Str( 'DB> Client PC Auto ScanDataPath exists but CMScan is not installed');
            CheckCMScanIsInstalled( K_CMScanDataPathAuto );
          end;
          K_CMScanDataPathAutoSearchClearTS := 0;
        end; // // if ScanDataPathExists then
      end  // if K_CMScanDataPathAuto <> '' then
      else
      if K_CMScanDataPathAutoSInd <= Ord('Z') - Ord('C') then
      begin // Continue Auto Detect Path Search (min 2 Fast Time events to one test)
        // Set PathCheckThread Path Access Events to Dump2 while Path Auto detect
        K_CMScanDataPathCheckThread.CFPDump2CheckResultFlag := TRUE;
        // clear NextSearchStartTS
        K_CMScanDataPathAutoSearchNextStartTS := 0;

        // First Time CheckFilePath set new path to PathCheckThread only,
        // next Time Events call to CheckFilePath will be continue
        // before PathCheckThread realy finish path check
        PrepCurAutoDetectScanDataPath();
        ScanDataPathCheck := CheckFilePath( K_CMScanDataPathAutoCur, TRUE ); // Check New Path PathCheckThread
        N_Dump2Str( format( 'DB> Check Client PC ScanDataPath >> %s Res=%d', [K_CMScanDataPathAutoCur,Ord(ScanDataPathCheck)] ) );

        ScanDataPathExists := ScanDataPathCheck = cfpsOpOK;
        if ScanDataPathCheck <> cfpsNotDef then
        begin // PathCheckThread Path Check is ready
          if K_CMScanDataPathAutoSInd = 0 then
            N_Dump1Str( 'DB> Client PC ScanDataPath Auto detect start >> ' + K_CMScanDataPathAutoCur );

          Inc(K_CMScanDataPathAutoSInd);
          if ScanDataPathExists then
          begin // Client Path Exists
            N_Dump1Str( 'DB> Client PC ScanDataPath is detected >> ' + K_CMScanDataPathAutoCur );
            K_CMScanDataPathLost := TRUE; //Needed To Rebuild CommonInfoFile
            K_CMScanDataPathAuto := K_CMScanDataPathAutoCur;
            CheckScanDataPath( K_CMScanDataPathAuto );
            K_CMScanDataPathAutoSearchNextStartTS := 0; // clear NextSearchStartTS
            // Return PathCheckThread path access events to Dump1 on AutoDetect Fin
            K_CMScanDataPathCheckThread.CFPDump2CheckResultFlag := FALSE;
          end
          else
          if K_CMScanDataPathAutoSInd > Ord('Z') - Ord('C') then
          begin
            N_Dump1Str( 'DB> Client PC ScanData Path Auto detect fails');
            // Set next Auto Detect Search start TS = Now() + 15 sec
            K_CMScanDataPathAutoSearchNextStartTS := EventStartTime + K_CMEDAActivateDeltaDD / 4;
            // Set PathCheckThread path access events to Dump1 on AutoDetect Fin
            K_CMScanDataPathCheckThread.CFPDump2CheckResultFlag := FALSE;
          end; // if K_CMScanDataPathAutoSInd > Ord('Z') - Ord('C') then
        end; // if ScanDataPathCheck <> cfpsNotDef then
      end // if K_CMScanDataPathAutoSInd <= Ord('Z') - Ord('C') then // Continue Auto Path Search
    end  // if K_CMScanDataPathOnClientPCAuto then
    else // ScanDataPath is not set (needed to stop thread)
      CheckScanDataPath( '' );

    // Fast Check if Client CMSCan is installed if K_CMScanDataPath is used (Server based or Client based not AutoDetect
    if K_CMScanWasInstalled then
      CheckCMScanIsInstalled( K_CMScanDataPath );


    // Check Dental Unit Action
    if Application.MainForm.Name <> 'K_FormCMSupport' then
    begin
      // Make Action Coltrols Visible if CMScan is instaled
      if K_CMScanIsInstalled and not (N_CMResForm.aCapClientScan.Visible) then
      begin
        N_Dump1Str( 'DB> CMScan is installed but Action Coltrol is invisible');
        N_CM_MainForm.CMMFDisableActions( Sender );
      end;

      K_CMCheckDentalUnitActionExec();
    end;

    // Auto Refresh Current Patient Slides View
    if not K_CMMarkAsDelShowFlag         and
       (K_CMPatSlidesAutoRefreshLag > 0) and
       ((ATimerCount mod K_CMPatSlidesAutoRefreshLag) = 0) then
    begin
      if K_GetFileAge(PatSlidesAutoRefreshFName) > PatSlidesAutoRefreshTS then
        N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aViewThumbRefresh, K_CMD4WWaitApplyDataCount = 0 );
    end;
  end; // if (K_CMSAppStartContext.CMASMode < K_cmamCOMHPUI) then

{ //2018-02-04 CMScan Client AutoDetect delay debug
N_Dump2Str( format( '!!!2 TCount=%d SDP=%s SDPO=%s SDPL=%s CP=%s CPA=%s'#13#10+
  'SDPA=%s SDPAC=%s SII=%s SWI=%s',
  [ATimerCount,K_CMScanDataPath,K_CMScanDataPathOld,N_B2S(K_CMScanDataPathLost),
  N_B2S(K_CMScanDataPathOnClientPC),N_B2S(K_CMScanDataPathOnClientPCAuto),
  K_CMScanDataPathAuto,K_CMScanDataPathAutoCur,
  N_B2S(K_CMScanIsInstalled),N_B2S(K_CMScanWasInstalled)] ) );
{}

  if FastTimerEvent then
  begin
    if (ATimerCount mod 30) = 0 then
      N_Dump2Str( format( 'DB>> EDASetActiveTimeStamp Fast Fin TCount=%d', [ATimerCount] ) );
    ATimer.Enabled := TRUE;
    Exit;
  end;
//
// end of Fast Timer Event Handler
///////////////////////////////////

//if N_i2 = 99999999 then Exit; // Debug LockSlides code

////////////////////////////////////////////////////////////
// Active Timestamp Timer Event Handler
//
  SAppRTID := IntToStr(AppRTID);
  N_Dump2Str( format( 'DB>> EDASetActiveTimeStamp Start TCount=%d ActRTID=%s AMSC=%d',
              [ATimerCount, SAppRTID, K_AMSCObj.AMSCObjsList.Count] ) );

  // Slow Check if Client CMSCan is installed - may be not needed now
  if (K_CMSAppStartContext.CMASMode < K_cmamCOMHPUI) and
     (K_CMScanClientName <> '')                      and
     not K_CMScanIsInstalled  then
    CheckCMScanIsInstalled( K_CMScanGetCurDataPath() );


  // AddPrevTrialMinutes := 0;
//  SkipReconnectFlag := FALSE; // Skip Reconnect Loop in case self raised exception 
  SkipReconnectFlag := TRUE; // Skip Reconnect Loop in any case
  try
//    N_CheckAllExec( 'Start ActiveTimeStamp' );
    K_AMSCObj.AMSCheckExec('Start ActiveTimeStamp');

{!!! Transaction and isolation_level and check Connection before transaction is opeed not needed
    with CurSQLCommand1 do
    begin // !!! Check if Connection is terminated by server -
          // to recieve exception before Connection.BeginTrans;
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      CommandText := 'select count(*) from ' + K_CMENDBGlobAttrsTable;
      Execute;
    end;

{!!! Transaction and isolation_level not needed
    LANDBConnection.BeginTrans;
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
      CommandText := EDADBIsolationLevelSet(K_tilSerializable);
      // 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end;
{}
    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBSelect;

      // *** Select Active Instances Table Record for current Instance
      SClientAppGlobID := IntToStr(ClientAppGlobID);
      SQL.Text := 'select ' +
        K_CMENDBAAInstsTFActRTID + ',' + K_CMENDBAAInstsTFActTS + ',' +
        K_CMENDBAAInstsTFGlobID + ',' +  K_CMENDBAAInstsTFActTSUID +
        ' from ' + K_CMENDBAAInstsTable +
        ' where ' + K_CMENDBAAInstsTFActRTID + '=' + SAppRTID;
      Filtered := false;
      Open;

      ExtDataErrorString := 'Active Record ActRTID=' + SAppRTID +
        ' ClientAppGlobID=' + SClientAppGlobID;
      ErrInfo := ' TSUID=' + IntToStr(TimeStampUID) + ' PatID=' + IntToStr
        (CurPatID) + ' ProvID=' + IntToStr(CurProvID) + ' LocID=' + IntToStr
        (CurLocID);
      if RecordCount > 0 then
      begin
        SDBClientAppGlobID := FieldList.Fields[2].AsString;
        if SDBClientAppGlobID <> SClientAppGlobID then
        begin
          ExtDataErrorString := ExtDataErrorString + ErrInfo +
            ' <> DB ClientAppGlobID=' + SDBClientAppGlobID;
          goto TimeStampError;
        end
        else if TimeStampUID <> TLargeintField(FieldList.Fields[3]).Value then
        begin
          ExtDataErrorString := ExtDataErrorString + ErrInfo +
            '. DB Timestamp differs from previous';
          goto TimeStampError;
        end;

        // CDTime := Now();
        CDTime := EDAGetSyncTimestamp(EventStartTime);
        UseLostActiveRecord := FALSE;
        // Check if Exceed timeout only if not user time shift detected
        if NextActiveTimeStamp <> 0 then
          UseLostActiveRecord := K_CMEDAActiveTimeOut < CDTime -
                                     TDateTimeField(FieldList.Fields[1]).Value;
        ErrInfo := FormatDateTime( '">>>>> "dd-hh":"nn":"ss.zzz" "', CDTime );
        if UseLostActiveRecord then
          N_Dump1Str( ErrInfo + 'DB>> Set Active Timestamp. Exceed timeout. ' +
                      ExtDataErrorString )
        else
          N_Dump2Str( ErrInfo + 'DB>> Set Active Timestamp. ' +
                      ExtDataErrorString );
      end
      else
      begin
        ExtDataErrorString := ExtDataErrorString + ErrInfo + ' is absent';
TimeStampError :
{!!! Transaction and isolation_level not needed
        LANDBConnection.RollbackTrans();
{}
        K_CMEDAccess.TmpStrings.Clear;
        EDADumpActiveContext( CurBlobDSet, K_CMEDAccess.TmpStrings );
        N_Dump1Str('*** Active Instances Dump ***'#13#10 + K_CMEDAccess.TmpStrings.Text);
        SkipReconnectFlag := TRUE;
        raise Exception.Create(ExtDataErrorString);
      end;

      Edit;
      TDateTimeField(FieldList.Fields[1]).Value := CDTime;
      TimeStampUID := N_CPUCounter();
      TLargeintField(FieldList.Fields[3]).Value := TimeStampUID;

      UpdateBatch;
      Close;

      // EDASaveStatInfo( [K_sifChangeTimestamp] );
{!!! Transaction and isolation_level not needed
      LANDBConnection.CommitTrans();
      with CurSQLCommand1 do
      begin
        CommandText := EDADBIsolationLevelDefault();
        Execute;
      end;
{}
      if ((SlidesCRFC.RootFolder = '') and (CurLocID <> -1)) or                // Appplication is ordinary active CMS - not Files Sync Process
         ((SlidesCRFC.RootFolder <> '') and ((ATimerCount mod 300) = 0)) then  // Refresh FilesHandlig State each 5 minutes
        EDAGetFilesHandlingDBContext();

      if (SlidesCRFC.RootFolder <> '') and       // Files Moving Mode
        (CurPatID <> -1) and                     // Application is Active or is not Files Sync Process
        (SlidesCRFC.OpProvID <> CurProvID) then  // Link Provider is not Files Moving Provider
        // Show Warning - Close CMS application
        N_CM_MainForm.CMMShowCloseApplicationWarning();
    end; // with CurDSet1 do

//  Bad if Check is already positive on application start
//    if K_CMD4WWaitApplyDataCount = 0 then
//      EDACheckMinDiskFreeSpace( ); // Check Free space if server is not buisy

    NextActiveTimeStamp := EventStartTime + K_CMEDAActivateDeltaDD;
    NextActiveTimeCount := ATimerCount + 60;
    ReconnectCounter := 0;

//    N_CheckAllExec( 'Fin ActiveTimeStamp' );
    K_AMSCObj.AMSCheckExec('Fin ActiveTimeStamp AMSC=' + IntToSTr(K_AMSCObj.AMSCObjsList.Count) );
    N_Dump2Str('DB>> EDASetActiveTimeStamp fin');
  except
    on E: Exception do
    begin
      if SkipReconnectFlag then
      begin
        ExtDataErrorString := format( 'DB>> EDASetActiveTimeStamp inside Except >> %s',
                                     [E.Message] );
        EDAShowErrMessage(TRUE);
      end
      else
      begin
        ReconnectNextActiveCount := ATimerCount + 1;
        if ReconnectCounter > 0 then
          ReconnectNextActiveCount := ATimerCount + 5;


        N_Dump2Str( format( 'DB>> EDASetActiveTimeStamp inside Except %d >> %s',
                            [ReconnectCounter, E.Message] ) );
        Inc(ReconnectCounter);
        if ReconnectCounter >= 60 then
        begin
          ExtDataErrorString := 'EDASetActiveTimeStamp >> inside Reconnect > 60';
          EDAShowErrMessage(TRUE);
        end;
      end;
    end;
  end;

  ATimer.Enabled := TRUE;

end; // end of TK_CMEDDBAccess.EDASetActiveTimeStamp

//********************************************* TK_CMEDDBAccess.EDAGetFilesHandlingDBContext ***
// Get Current Files Moving DB Context
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetFilesHandlingDBContext(): TK_CMEDResult;
begin
  Result := K_edOK;
  try

    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      //////////////////////////////////////
      // Get Image Files Moving Context
      //
      if not K_CMEnterpriseModeFlag then
        SQL.Text := 'select ' +
          K_CMENDBGTFNewFPath + ',' + K_CMENDBGTFNewFProvID + ',' +
          K_CMENDBGTFCopiedFNum + ',' + K_CMENDBGTFCopiedFSize +
          ' from ' + K_CMENDBGlobAttrsTable
      else
        // Use Context from Location Files Access Table in Enterprise Mode
        SQL.Text := 'select ' +
          K_CMENDBLFALocNewFPath + ',' + K_CMENDBLFALocNewFProvID + ',' +
          K_CMENDBLFALocNewFCopiedNum + ',' + K_CMENDBLFALocNewFCopiedSize +
          ' from ' + K_CMENDBLocsFAccessTable +
          ' where ' + K_CMENDBLFALocID + '=' + IntToStr(CurLocID);
      Filtered := false;
      Open;
      // EDAClearSlidesCRFC();
      with SlidesCRFC do
      begin
        RootFolder := EDAGetStringFieldValue(FieldList.Fields[0]);
        if RootFolder <> '' then
        begin
          ChangePathStage := 0; 
          if RootFolder[1] = '?' then
          begin
            ChangePathStage := StrToInt(RootFolder[2]);
            RootFolder := Copy(RootFolder, 3, Length(RootFolder) - 2);
          end;
          RootFDA := RootFolder[1] = '>';
          if RootFDA then
            RootFolder := Copy(RootFolder, 2, Length(RootFolder) - 1);
          MediaFCopy := RootFolder[1] = '#';
          if MediaFCopy then
          begin
            RootFolder := Copy(RootFolder, 2, Length(RootFolder) - 1);
            MediaFSplit := RootFolder[1] = '*';
            if MediaFSplit then
              RootFolder := Copy(RootFolder, 2, Length(RootFolder) - 1);
          end;

          Img3DFCopy := RootFolder[1] = ':';
          if Img3DFCopy then
            RootFolder := Copy(RootFolder, 2, Length(RootFolder) - 1);

          RootFolder := IncludeTrailingPathDelimiter(RootFolder);
          OpProvID := FieldList.Fields[1].AsInteger;
          CopiedFNum := FieldList.Fields[2].AsInteger;
          CopiedFSize := TLargeintField(FieldList.Fields[3]).AsLargeint;
        end;
      end;
      Close();

      //
      // Finish Image Files Movig Context Getting
      //////////////////////////////////////
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAGetFilesHandlingDBContext ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAGetFilesHandlingDBContext

//****************************** TK_CMEDDBAccess.EDAPrepStateAfterException ***
// Prepare Access State after Exception
//
procedure TK_CMEDDBAccess.EDAPrepStateAfterException;
begin
  {
    if K_TerminateByEDAError then begin
    end;
  }
  if ATimer <> nil then
    ATimer.Enabled := FALSE;
  if LANDBConnection = nil then
    Exit;
  if LANDBConnection.InTransaction then
    LANDBConnection.RollbackTrans;
  // if WANDBConnection.InTransaction then
  // WANDBConnection.RollbackTrans;
end; // end of TK_CMEDDBAccess.EDAPrepStateAfterException

{$IF FALSE} // Delphi >= XE5
//****************************************** TK_CMEDDBAccess.EDAAppActivate ***
// Lock Active Application Instance ID
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAAppActivate(): TK_CMEDResult;
var
  SAppRTID: string;
  CDTime: TDateTime;
  UseLostActiveRecord: Boolean;
  LogStr: string;
  CAppRTID: Integer;
  SClientAppGlobID: string;
  SCurServID: string;
{!!! not used now
  i, SFSCheckResult : Integer;
  SFSyncGIDList : TStringList;
}
//  ActiveAppTSDelta : TDateTime;
  LResult : TK_CMEDResult;
  AICount : Integer;
Label SFSyncIsActive;

  function CheckLostRecord( ): Boolean;
  begin
    Result := K_CMDBCheckAppInstanceLostRecord( CurDSet1, 1, 7, CDTime );
  end; // function CheckLostRecord

  function CheckGLobalInstance( const ASGlobID : string ) : Integer;
  begin
    with CurDSet1 do
    begin
      Filtered := FALSE;
      Filter := K_CMENDBAAInstsTFGlobID + ' = ' + ASGlobID;
      Filtered := TRUE;
      Result := 0;
      if RecordCount > 0 then
      begin
      // Check if Files Sync Process is already started
        Result := 1;
        if CheckLostRecord() then
          Result := 2;
      end;
    end;
  end; // function CheckGLobalInstance

  function CheckActiveGLobalInstance( const ASGlobID : string ) : Boolean;
  begin
    with CurDSet1 do
    begin
      Filtered := FALSE;
      Filter := K_CMENDBAAInstsTFGlobID + ' = ' + ASGlobID;
      Filtered := TRUE;
      Result := FALSE;
      if RecordCount > 0 then
      begin
        First;
        while not Eof do
        begin
          Result := not CheckLostRecord();
          if Result then Break;
          Next;
        end;
      end;
      Filtered := FALSE;
    end;
  end; // function CheckActiveGLobalInstance

begin
  // Result := K_edOK;
  N_Dump2Str('DB>> EDAAppActivate');
  with K_CMSServerClientInfo do
    N_Dump1Str( format( '!!!Client|Server Activate >> WTSSessionID=%d WTSProtocolType=%d WTSServerName=%s'#13#10 +
                        '                                                ' +
                        'WTSClientName=%s WTSClientIP=%s CMSClientName=%s WTSUserName=%s',
       [CMSSessionInfo.WTSSessionID, CMSSessionInfo.WTSClientProtocolType,
        CMSSessionInfo.WTSServerCompName, CMSSessionInfo.WTSClientName,
        CMSSessionInfo.WTSClientIPStr, CMSClientVirtualName,CMSSessionInfo.WTSUserName] ) );
  try
    {
      with CurSQLCommand1 do begin
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
      CommandText :=
      'SET TEMPORARY OPTION SUBSUME_ROW_LOCKS = OFF';
      Execute;
      end;
    }
    LANDBConnection.BeginTrans;
    with CurSQLCommand1 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBLock;
      CommandText := EDADBIsolationLevelSet(K_tilSerializable);
      // 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end;

    with CurDSet1, K_CMSServerClientInfo do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

  //////////////////////////////////
  // Get Instance Global ID
  //
      SQL.Text := 'select ' +
        K_CMENDBGAInstsTFGlobID + ',' +
        K_CMENDBGAInstsTFLocalID + ',' + K_CMENDBGAInstsTFCName +
        ' from ' + K_CMENDBGAInstsTable +
        ' order by ' + K_CMENDBGAInstsTFGlobID + ' asc';
      Filtered := false;
      Open;

      Filter := K_CMENDBGAInstsTFLocalID + '=' + IntToStr(ClientAppTypeID) +
                ' and ' +
                K_CMENDBGAInstsTFCName + '=''' + CMSClientVirtualName +  '''';
      Filtered := TRUE;

      if RecordCount > 0 then
      begin
        // Was already Registed
        ClientAppGlobID := FieldList.Fields[0].AsInteger;
        SClientAppGlobID := IntToStr(ClientAppGlobID);
        Filtered := false;
      end
      else
      begin
        // Registed New Global Application ID
        Filtered := false;
        Last();
        ClientAppGlobID := FieldList.Fields[0].AsInteger;
        Inc(ClientAppGlobID);
        SClientAppGlobID := IntToStr(ClientAppGlobID);
        N_Dump1Str
          ('DB>> Add New Client Instance ID=' + SClientAppGlobID +
            ' VName=' + CMSClientVirtualName);
        Insert;
        FieldList.Fields[0].AsInteger := ClientAppGlobID;
        FieldList.Fields[1].AsInteger := ClientAppTypeID;
        EDAPutStringFieldValue( FieldList.Fields[2], CMSClientVirtualName);
        UpdateBatch;
      end;
  //
  // end of Get Instance Global ID
  //////////////////////////////////

{!!! not used now
  //////////////////////////////////
  // Files Synchronization Process
  //
      SFSyncGIDList := nil;
      if ClientAppTypeID = K_CMFilesSyncProcClientAppTypeID then
      begin
        Filter := K_CMENDBGAInstsTFLocalID + '=' + IntToStr(ClientAppTypeID) +
                  ' and ' +
                  K_CMENDBGAInstsTFCName + '<>''' + CMSClientVirtualName +  '''';
        Filtered := TRUE;
        if RecordCount > 0 then
        begin
          SFSyncGIDList := TStringList.Create;
          while not Eof do
          begin
            SFSyncGIDList.Add( EDAGetStringFieldValue(FieldList.Fields[2]) + '=' + FieldList.Fields[0].AsString );
            Next;
          end;
        end;
      end; // if ClientAppTypeID = K_CMFilesSyncProcClientAppTypeID then
  //
  // end of Files Synchronization Process
  //////////////////////////////////
}
      Close;

  ///////////////////
  // Get Server ID
  //
      if K_CMEDDBVersion >= 19 then
      begin
        // *** Get Server ID
        SQL.Text := 'select ' +
          K_CMENDASServID + ',' + K_CMENDASServName +
          ' from ' + K_CMENDBAllServersTable +
          ' order by ' + K_CMENDASServID + ' asc';
        Filtered := false;
        Open;

//        Filter := K_CMENDASServName + '=''' + K_CMSServerName +  '''';
        Filter := K_CMENDASServName + '=''' + CMSSessionInfo.WTSServerCompName +  '''';

        Filtered := TRUE;
        if RecordCount > 0 then
        begin
          // Was already Registed
          CurServID  := FieldList.Fields[0].AsInteger;
          SCurServID := FieldList.Fields[0].AsString;
        end
        else
        begin
          // Registed New Server ID
          Filtered := false;
          Last();
          CurServID := FieldList.Fields[0].AsInteger;
          Inc(CurServID);
          SCurServID := IntToStr(CurServID);
          N_Dump1Str('DB>> Add New Server ID=' + SCurServID +
                       ' Name=' + CMSSessionInfo.WTSServerCompName);

          Insert;
          FieldList.Fields[0].AsInteger := CurServID;
          EDAPutStringFieldValue( FieldList.Fields[1],
                                  CMSSessionInfo.WTSServerCompName);
          UpdateBatch;
        end;
        Close;
      end; // if K_CMEDDBVersion >= 19 then
  //
  // end of Get Server ID
  ///////////////////

  //////////////////////////////////////////////
  // Register Instance to Active Sessions Table
  //
      SQL.Text := 'select ' +
        K_CMENDBAAInstsTFActRTID + ',' + K_CMENDBAAInstsTFActTS + ',' +     //0,1
        K_CMENDBAAInstsTFGlobID  + ',' + K_CMENDBAAInstsTFActTSUID + ',' +  //2,3
        K_CMENDBAAInstsTFPatID   + ',' + K_CMENDBAAInstsTFProvID + ',' +    //4,5
        K_CMENDBAAInstsTFLocID;                                             //6
      if K_CMEDDBVersion >= 15 then
        SQL.Text := SQL.Text + ',' + K_CMENDBAAInstsTFActFlags;             //7
      if K_CMEDDBVersion >= 19 then
        SQL.Text := SQL.Text + ',' + K_CMENDBAAInstsTFServID;               //8
      SQL.Text := SQL.Text + ' from ' +  K_CMENDBAAInstsTable +
                 ' order by ' + K_CMENDBAAInstsTFActRTID + ' asc';
      Filtered := false;
      Open;
      AICount := RecordCount;
      // *** Get Uniq Active ID
      AppRTID := 0;
      CAppRTID := 0; // to prevent warning
      UseLostActiveRecord := FALSE;
      // CDTime := Now();
      NextActiveTimeStamp := Now();
      CDTime := EDAGetSyncTimestamp( NextActiveTimeStamp );


{!!!not used now
    /////////////////////////////////////////////
    // Files Synchronization Process Special Check
    //
      if ClientAppTypeID = K_CMFilesSyncProcClientAppTypeID then
      begin
      // Check Other Computers
        if SFSyncGIDList <> nil then
          for i := 0 to SFSyncGIDList.Count - 1 do
          begin
            SFSCheckResult := CheckGLobalInstance( SFSyncGIDList.ValueFromIndex[i] );
            if SFSCheckResult = 1 then
            begin
              AResStr1 := SFSyncGIDList.Names[i];
              goto SFSyncIsActive; // Active SFSync is found
            end;
          end;

        SFSCheckResult := CheckGLobalInstance( SClientAppGlobID );
        if SFSCheckResult > 0 then
        begin
          CAppRTID := Fields[0].AsInteger;
          UseLostActiveRecord := SFSCheckResult = 2;
          if not UseLostActiveRecord then
          begin // Files Sync Process is already started - Exit
            AResStr1 := CMSClientVirtualName;
SFSyncIsActive:
            AResInt1 := Round( (CDTime - TDateTimeField(FieldList.Fields[1]).Value) * 24 * 3600 * 1000);
//            AResInt1 := Round( ActiveAppTSDelta * 24 * 3600 * 1000);
            Result := K_edEFSyncProcStarted;
            Close;
            LANDBConnection.CommitTrans();
            Exit;
          end;
        end // if SFSCheckResult > 0 then
        else
          Filtered := FALSE;
      end; // if ClientAppTypeID = K_CMFilesSyncProcClientAppTypeID then
      SFSyncGIDList.Free;
    //
    // end of Files Synchronization Process Special Check
    /////////////////////////////////////////////
}
    /////////////////////////////////////////////
    // Search for Lost Active Record
    //
      if not UseLostActiveRecord then
      begin
        if not K_CMD4WAppRunByCOMClient    and
           not K_CMStandaloneGUIMode       and
           not K_CMEDAMultipleInstanceMode and
           CheckActiveGLobalInstance( SClientAppGlobID ) then
        begin
          Result := K_edFails;

          ExtDataErrorString := format( 'DB>> Instance for ClientID=%s is active >> ActRTID=%s Time="%s" PatID=%s ProvID=%s LocID=%s',
                       [Fields[2].AsString, Fields[0].AsString, Fields[1].AsString,
                        Fields[4].AsString, Fields[5].AsString, Fields[6].AsString] );
          if K_CMEDDBVersion >= 15 then
            ExtDataErrorString := ExtDataErrorString  + ' ' + Fields[7].AsString;             //7
          if K_CMEDDBVersion >= 19 then
            ExtDataErrorString := ExtDataErrorString  + ' ServerID=' + Fields[8].AsString;             //7
          N_Dump1Str( ExtDataErrorString );
          Close;
          LANDBConnection.CommitTrans();
          Exit;
        end; // if not K_CMD4WAppRunByClient  and ...

        // Search for Lost record
        First;
        while not Eof do
        begin
          CAppRTID := FieldList.Fields[0].AsInteger;
//          UseLostActiveRecord := CheckLostRecord( K_CMEDAMultipleInstanceMode );
          UseLostActiveRecord := CheckLostRecord( );
          if UseLostActiveRecord then
            break;
          AppRTID := Max(AppRTID, CAppRTID);
          Next;
        end; // while not Eof do
      end; // if not UseLostActiveRecord then
    //
    // end of Search for Lost Active Record
    /////////////////////////////////////////////

      if not UseLostActiveRecord then
        Inc(AppRTID)
      else
      begin
        K_CMEDAccess.TmpStrings.Clear;
        EDADumpActiveContext( CurBlobDSet, K_CMEDAccess.TmpStrings );
        N_Dump1Str('DB>> EDAAppActivate LostRecord was found >> Active Instances Dump ***'#13#10 + K_CMEDAccess.TmpStrings.Text);
        AppRTID := CAppRTID;
      end;

    ///////////////////////////////////
    // Set Active Record Values
    //
      SAppRTID := IntToStr(AppRTID);
      LogStr := 'Active Instance ActRTID=' + SAppRTID +
                ' for Client ID|VName=' + SClientAppGlobID +
                '|' + CMSClientVirtualName;
//      if K_CMSClientName <> K_CMSServerClientInfo.CMSClientVirtualName then
//        LogStr := LogStr + ' Name=' + K_CMSClientName;
      if CMSSessionInfo.WTSClientName <> CMSClientVirtualName then
        LogStr := LogStr + ' Name=' + CMSSessionInfo.WTSClientName;
      if K_CMEDDBVersion >= 19 then
        LogStr := LogStr + ' and Server ID|Name=' + SCurServID +
                 '|' + CMSSessionInfo.WTSServerCompName;
      if UseLostActiveRecord then
      begin
        LogStr := 'DB>> Use existed ' + LogStr;
        ExtDataErrorCode := K_eeDBEdit;
        Edit;
      end
      else
      begin
        LogStr := 'DB>> Add New ' + LogStr;
        ExtDataErrorCode := K_eeDBIns;
        Insert;
        Inc(AICount);
      end;
      N_Dump1Str(LogStr + ' AICount=' + IntToStr(AICount) );

      // *** Set Active Record Fields
      FieldList.Fields[0].AsInteger := AppRTID;
      // TDateTimeField(FieldList.Fields[1]).Value := Now();
      // TDateTimeField(FieldList.Fields[1]).Value := EDAGetSyncTimestamp();
      TDateTimeField(FieldList.Fields[1]).Value := CDTime;

      FieldList.Fields[2].AsInteger := ClientAppGlobID;
      TimeStampUID := N_CPUCounter();
      TLargeintField(FieldList.Fields[3]).Value := TimeStampUID;
      FieldList.Fields[4].AsInteger := -1;
      FieldList.Fields[5].AsInteger := -1;
      FieldList.Fields[6].AsInteger := -1;
      if K_CMEDDBVersion >= 15 then
        FieldList.Fields[7].AsInteger := 0;
      if K_CMEDDBVersion >= 19 then
      begin
        // Set StandAlone flag if needed
        // FieldList.Fields[7].AsInteger := 128;
        FieldList.Fields[8].AsInteger := CurServID;
      end;
    //
    // end of Set Active Record Values
    ///////////////////////////////////

    //////////////////////////////////////////////////////////
    // Clear Other Lost Active Instances and Free Locked Slides
    //
      if UseLostActiveRecord then
      begin

        EDAAppUnlockObjects(SAppRTID); // Unlock Slides for Lost Active Instance
        Filtered := FALSE;
        Filter := K_CMENDBAAInstsTFActRTID + '<>' + SAppRTID;
        Filtered := TRUE;
        if RecordCount > 0 then
        begin
          First;
          while not Eof do
          begin
            if not CheckLostRecord( ) then
              Next
            else
            begin
              EDAAppUnlockObjects(FieldList.Fields[0].AsString);
              // Unlock Slides for Lost Active Instance
              Delete();
            end;
          end;
        end;
      end;
    //
    // end of Clear Other Lost Active Instances and Free Locked Slides
    //////////////////////////////////////////////////////////

      UpdateBatch;
      Close;

    // Set Next Active TimeStamp and Count
      NextActiveTimeStamp := NextActiveTimeStamp + K_CMEDAActivateDeltaDD;
      NextActiveTimeCount := ATimerCount + 60;

  //
  // end of Register Instance to Active Sessions Table
  //////////////////////////////////////////////

      {
        /////////////////////////////////////
        // Calc Running Time and Trial Period
        EDASaveStatInfo( [K_sifStartTimeCount] );
      }

      // if RecordCount = 1 then begin
      ////*** First Client Session Start
      /////////////////////////////////////
      // Check if Key Exists

      Result := EDAGAGlobalToCurState();

      LResult := EDANotGAGlobalToCurState();
      if LResult <> K_edOK then
        Result := LResult
      else
      if K_CMIURemindeInDays = -1 then
      begin
      // Save Default Values
        K_CMIURemindeTS  := Int(Now());
        K_CMIURemindeInDays := 90;
        EDANotGAGlobalToMemIni1();
      end;

//      Close;


      EDAGetFilesHandlingDBContext();

      LANDBConnection.CommitTrans();

      with CurSQLCommand1 do
      begin
        CommandText := EDADBIsolationLevelDefault();
        Execute;
      end; // with CurSQLCommand1 do

// 2013-11-15 - K_CMEDAccessInit11      ATimer := TTimer.Create(N_CM_MainForm);
//      ATimer.Interval := K_CMEDAActivateDeltaMS;

      if ATimer = nil then
        ATimer := TTimer.Create(N_CM_MainForm);
      if K_CMAutoCloseLastActTS <> 0 then
        N_Dump1Str('DB>> EDAAppActivate is waked');
      K_CMAutoCloseLastActTS := 0; // Clear AutoCLose Mode
      ATimer.Interval := K_CMEDAActivateTimerDeltaMS;
      ATimer.OnTimer := EDASetActiveTimeStamp;
      ATimer.Enabled := TRUE;

      if K_CMScanDataPathCheckThread = nil then
      begin
        K_CMScanDataPathCheckThread := TK_CFPFilePathCheckThread.Create( TRUE );
        K_CMScanDataPathCheckThread.CFPPResult := @K_CMScanDataPathCheckResult;
        N_Dump2Str('DB>> ScanDataPathCheckThread is created');
      end;

      N_Dump2Str('DB>> EDAAppActivate fin');
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAAppActivate ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAAppActivate
{$IFEND FALSE}

//****************************************** TK_CMEDDBAccess.EDAAppActivate ***
// Lock Active Application Instance ID
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAAppActivate(): TK_CMEDResult;
var
  SAppRTID: string;
  CDTime: TDateTime;
  LogStr: string;
//  CAppRTID: Integer;
  SClientAppGlobID: string;
  SCurServID: string;
//  ActiveAppTSDelta : TDateTime;
  LResult : TK_CMEDResult;
  AICount : Integer;
Label SFSyncIsActive;

//  function CheckLostRecord( AMultiInstanceMode : Boolean ): Boolean;
  function CheckLostRecord( ): Boolean;
  begin
    Result := K_CMDBCheckAppInstanceLostRecord( CurDSet1, 1, 7, CDTime );
  end; // function CheckLostRecord

  function CheckGLobalInstance( const ASGlobID : string ) : Integer;
  begin
    with CurDSet1 do
    begin
      Filtered := FALSE;
      Filter := K_CMENDBAAInstsTFGlobID + ' = ' + ASGlobID;
      Filtered := TRUE;
      Result := 0;
      if RecordCount > 0 then
      begin
      // Check if Files Sync Process is already started
        Result := 1;
        if CheckLostRecord() then
          Result := 2;
      end;
    end;
  end; // function CheckGLobalInstance

  function CheckActiveGLobalInstance( const ASGlobID : string ) : Boolean;
  begin
    with CurDSet1 do
    begin
      Filtered := FALSE;
      Filter := K_CMENDBAAInstsTFGlobID + ' = ' + ASGlobID;
      Filtered := TRUE;
      Result := FALSE;
      if RecordCount > 0 then
      begin
        First;
        while not Eof do
        begin
          Result := not CheckLostRecord();
          if Result then Break;
          Next;
        end;
      end;
      Filtered := FALSE;
    end;
  end; // function CheckActiveGLobalInstance

begin
  // Result := K_edOK;
//??  N_T1.Start;
  N_Dump2Str('DB>> EDAAppActivate');
  with K_CMSServerClientInfo do
    N_Dump1Str( format( '!!!Client|Server Activate >> WTSSessionID=%d WTSProtocolType=%d WTSServerName=%s'#13#10 +
                        '                                                ' +
                        'WTSClientName=%s WTSClientIP=%s CMSClientName=%s WTSUserName=%s',
       [CMSSessionInfo.WTSSessionID, CMSSessionInfo.WTSClientProtocolType,
        CMSSessionInfo.WTSServerCompName, CMSSessionInfo.WTSClientName,
        CMSSessionInfo.WTSClientIPStr, CMSClientVirtualName,CMSSessionInfo.WTSUserName] ) );
  try
    with CurSQLCommand1 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBLock;
      CommandText := EDADBIsolationLevelSet(K_tilSerializable);
      // 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;

      LANDBConnection.BeginTrans;

      //!!! For Lock Transaction code in exclusive mode if Isolation Level SERIALIZABLE
      //!!! needed because of new Server Code and new Client Code is generated manually - not use DB Autoincrement or Sequence
      //!!! will be not needed after Set autoincrement to Server and Client tables and deadlock processing
      CommandText := 'UPDATE ' + K_CMENDBGlobAttrsTable +
                     ' SET ' + K_CMENDBGTFDBVersion + ' = ' + K_CMENDBGTFDBVersion;
      Execute;
    end;
{}
    if K_CMEDDBVersion >= 40 then
    begin
      // Try to Rebuild AllActSessions Table
      with CurStoredProc1 do
      begin
        Connection := LANDBConnection;
        ProcedureName := 'dba.cms_RebuildAllActSessionsTable';
        Parameters.Clear;
        with Parameters.AddParameter do
        begin
          Name := '@RebuildFlag';
          Direction := pdOutput;
          DataType := ftInteger;
          ExecProc;
          AICount := Value;
        end; // with Parameters.AddParameter do

        if AICount = 1 then
          N_Dump1Str('DB>> Rebuild ID=' + K_CMENDBAAInstsTable );
      end;
    end; // if K_CMEDDBVersion >= 40 then
{}
    //////////////////////////////////
    // Get Instance Global ID
    //
    if K_CMEDDBVersion < 40 then
      with CurDSet1, K_CMSServerClientInfo do
      begin
        ExtDataErrorCode := K_eeDBSelect;
        Connection := LANDBConnection;

        SQL.Text := 'select ' +
          K_CMENDBGAInstsTFGlobID + ',' +
          K_CMENDBGAInstsTFLocalID + ',' + K_CMENDBGAInstsTFCName +
          ' from ' + K_CMENDBGAInstsTable +
          ' order by ' + K_CMENDBGAInstsTFGlobID + ' asc';
        Filtered := false;
        Open;

        Filter := K_CMENDBGAInstsTFLocalID + '=' + IntToStr(ClientAppTypeID) +
                  ' and ' +
                  K_CMENDBGAInstsTFCName + '=''' + CMSClientVirtualName +  '''';
        Filtered := TRUE;

        if RecordCount > 0 then
        begin
          // Was already Registed
          ClientAppGlobID := FieldList.Fields[0].AsInteger;
          SClientAppGlobID := IntToStr(ClientAppGlobID);
          Filtered := false;
        end
        else
        begin
          // Registed New Global Application ID
          Filtered := false;
          Last();
          ClientAppGlobID := FieldList.Fields[0].AsInteger;
          Inc(ClientAppGlobID);
          SClientAppGlobID := IntToStr(ClientAppGlobID);
          N_Dump1Str
            ('DB>> Add New Client Instance ID=' + SClientAppGlobID +
              ' VName=' + CMSClientVirtualName);
          Insert;
          FieldList.Fields[0].AsInteger := ClientAppGlobID;
          FieldList.Fields[1].AsInteger := ClientAppTypeID;
          EDAPutStringFieldValue( FieldList.Fields[2], CMSClientVirtualName);
          UpdateBatch;
        end;
        Close;
      end // with CurDSet1, K_CMSServerClientInfo do
    else // if K_CMEDDBVersion >= 40 then
      with CurStoredProc1, K_CMSServerClientInfo do
      begin
        Connection := LANDBConnection;
        ProcedureName := 'dba.cms_GetClientIDbyName';
        Parameters.Clear;
        with Parameters.AddParameter do
        begin
          Name := '@ClientName';
          Direction := pdInput;
          DataType := ftString;
          Value := CMSClientVirtualName;
        end;
        with Parameters.AddParameter do
        begin
          Name := '@ClientType';
          Direction := pdInput;
          DataType := ftInteger;
          Value := ClientAppTypeID;
        end;
        with Parameters.AddParameter do
        begin
          Name := '@ClientID';
          Direction := pdOutput;
          DataType := ftInteger;
          ExecProc;
          ClientAppGlobID := Value;
          SClientAppGlobID := IntToStr(ClientAppGlobID);
        end; // with Parameters.AddParameter do
      end; // with CurStoredProc1 do
    //
    // end of Get Instance Global ID
    //////////////////////////////////

    ///////////////////
    // Get Server ID
    //
      if K_CMEDDBVersion >= 19 then
      begin
        if K_CMEDDBVersion < 40 then
          with CurDSet1, K_CMSServerClientInfo do
          begin
            // *** Get Server ID
            SQL.Text := 'select ' +
              K_CMENDASServID + ',' + K_CMENDASServName +
              ' from ' + K_CMENDBAllServersTable +
              ' order by ' + K_CMENDASServID + ' asc';
            Filtered := false;
            Open;

    //        Filter := K_CMENDASServName + '=''' + K_CMSServerName +  '''';
            Filter := K_CMENDASServName + '=''' + CMSSessionInfo.WTSServerCompName +  '''';

            Filtered := TRUE;
            if RecordCount > 0 then
            begin
              // Was already Registed
              CurServID  := FieldList.Fields[0].AsInteger;
              SCurServID := FieldList.Fields[0].AsString;
              Filtered := false;
            end
            else
            begin
              // Registed New Server ID
              Filtered := false;
              Last();
              CurServID := FieldList.Fields[0].AsInteger;
              Inc(CurServID);
              SCurServID := IntToStr(CurServID);
              N_Dump1Str('DB>> Add New Server ID=' + SCurServID +
                           ' Name=' + CMSSessionInfo.WTSServerCompName);

              Insert;
              FieldList.Fields[0].AsInteger := CurServID;
              EDAPutStringFieldValue( FieldList.Fields[1],
                                      CMSSessionInfo.WTSServerCompName);
              UpdateBatch;
            end;
            Close;
          end // with CurDSet1, K_CMSServerClientInfo do
        else // if K_CMEDDBVersion >= 40 then
          with CurStoredProc1 do
          begin
            Connection := LANDBConnection;
            ProcedureName := 'dba.cms_GetServerIDbyName';
            Parameters.Clear;
            with Parameters.AddParameter do
            begin
              Name := '@ServerName';
              Direction := pdInput;
              DataType := ftString;
              Value := K_CMSServerClientInfo.CMSSessionInfo.WTSServerCompName;
            end;
            with Parameters.AddParameter do
            begin
              Name := '@ServerID';
              Direction := pdOutput;
              DataType := ftInteger;
              ExecProc;
              CurServID := Value;
              SCurServID := IntToStr(CurServID);
            end; // with Parameters.AddParameter do
          end; // with CurStoredProc1 do
        end; // if K_CMEDDBVersion >= 19 then
    //
    // end of Get Server ID
    ///////////////////


    //////////////////////////////////////////////
    // Register Instance to Active Sessions Table
    //
    if K_CMEDDBVersion < 40 then
    begin
      with CurDSet1, K_CMSServerClientInfo do
      begin
        SQL.Text := 'select ' +
          K_CMENDBAAInstsTFActRTID + ',' + K_CMENDBAAInstsTFActTS + ',' +     //0,1
          K_CMENDBAAInstsTFGlobID  + ',' + K_CMENDBAAInstsTFActTSUID + ',' +  //2,3
          K_CMENDBAAInstsTFPatID   + ',' + K_CMENDBAAInstsTFProvID + ',' +    //4,5
          K_CMENDBAAInstsTFLocID;                                             //6
        if K_CMEDDBVersion >= 15 then
          SQL.Text := SQL.Text + ',' + K_CMENDBAAInstsTFActFlags;             //7
        if K_CMEDDBVersion >= 19 then
          SQL.Text := SQL.Text + ',' + K_CMENDBAAInstsTFServID;               //8

        SQL.Text := SQL.Text + ' from ' + K_CMENDBAAInstsTable +
                    ' order by ' + K_CMENDBAAInstsTFActRTID + ' desc';
        Filtered := false;
        Open;
        AICount := RecordCount;

        // *** Get Uniq Active ID
        // CDTime := Now();
        NextActiveTimeStamp := Now();
        CDTime := EDAGetSyncTimestamp( NextActiveTimeStamp );

      /////////////////////////////////////////////
      // Check Multi Instance Launch
      //
        if not K_CMD4WAppRunByCOMClient    and
           not K_CMStandaloneGUIMode       and
           not K_CMEDAMultipleInstanceMode and
           CheckActiveGLobalInstance( SClientAppGlobID ) then
        begin
          Result := K_edFails;

          ExtDataErrorString := format( 'DB>> Instance for ClientID=%s is active >> ActRTID=%s Time="%s" PatID=%s ProvID=%s LocID=%s',
                       [Fields[2].AsString, Fields[0].AsString, Fields[1].AsString,
                        Fields[4].AsString, Fields[5].AsString, Fields[6].AsString] );
          if K_CMEDDBVersion >= 15 then
            ExtDataErrorString := ExtDataErrorString  + ' ' + Fields[7].AsString;             //7
          if K_CMEDDBVersion >= 19 then
            ExtDataErrorString := ExtDataErrorString  + ' ServerID=' + Fields[8].AsString;             //7
          N_Dump1Str( ExtDataErrorString );
          Close;
          LANDBConnection.CommitTrans();
          Exit;
          N_T1.SS('Multi Instance Launch Error');
        end; // if not K_CMD4WAppRunByClient  and ...
      //
      // end of Check Multi Instance Launch
      /////////////////////////////////////////////

      /////////////////////////////////////////////
      // Search for Lost Active Record
      //
        AppRTID := 0;
        if AICount > 0 then
        begin
          First;
          AppRTID := Fields[0].AsInteger;
        end;
        Inc(AppRTID);
      //
      // end of Search for Lost Active Record
      /////////////////////////////////////////////

      ///////////////////////////////////
      // Set Active Record Values
      //
        SAppRTID := IntToStr(AppRTID);
        LogStr := 'Active Instance ActRTID=' + SAppRTID +
                  ' for Client ID|VName=' + SClientAppGlobID +
                  '|' + CMSClientVirtualName;
  //      if K_CMSClientName <> K_CMSServerClientInfo.CMSClientVirtualName then
  //        LogStr := LogStr + ' Name=' + K_CMSClientName;
        if CMSSessionInfo.WTSClientName <> CMSClientVirtualName then
          LogStr := LogStr + ' Name=' + CMSSessionInfo.WTSClientName;
        if K_CMEDDBVersion >= 19 then
          LogStr := LogStr + ' and Server ID|Name=' + SCurServID +
                   '|' + CMSSessionInfo.WTSServerCompName;
        LogStr := 'DB>> Add New ' + LogStr;
        ExtDataErrorCode := K_eeDBIns;
        Insert;
        Inc(AICount);
        N_Dump1Str(LogStr + ' AICount=' + IntToStr(AICount) );

        // *** Set Active Record Fields
        FieldList.Fields[0].AsInteger := AppRTID;
        TDateTimeField(FieldList.Fields[1]).Value := CDTime;

        FieldList.Fields[2].AsInteger := ClientAppGlobID;
        TimeStampUID := N_CPUCounter();
        TLargeintField(FieldList.Fields[3]).Value := TimeStampUID;
        FieldList.Fields[4].AsInteger := -1;
        FieldList.Fields[5].AsInteger := -1;
        FieldList.Fields[6].AsInteger := -1;
        if K_CMEDDBVersion >= 15 then
          FieldList.Fields[7].AsInteger := 0;
        if K_CMEDDBVersion >= 19 then
        begin
          // Set StandAlone flag if needed
          // FieldList.Fields[7].AsInteger := 128;
          FieldList.Fields[8].AsInteger := CurServID;
        end;
      //
      // end of Set Active Record Values
      ///////////////////////////////////


        UpdateBatch;
        Close;
      end; // with CurDSet1, K_CMSServerClientInfo do
    end   // if K_CMEDDBVersion < 40 then
    else
    begin // if K_CMEDDBVersion >= 40 then
      with CurDSet1, K_CMSServerClientInfo do
      begin
        SQL.Text := 'select ' +
          K_CMENDBAAInstsTFActRTID + ',' + K_CMENDBAAInstsTFActTS + ',' +     //0,1
          K_CMENDBAAInstsTFGlobID  + ',' + K_CMENDBAAInstsTFActTSUID + ',' +  //2,3
          K_CMENDBAAInstsTFPatID   + ',' + K_CMENDBAAInstsTFProvID + ',' +    //4,5
          K_CMENDBAAInstsTFLocID;                                             //6
        if K_CMEDDBVersion >= 15 then
          SQL.Text := SQL.Text + ',' + K_CMENDBAAInstsTFActFlags;             //7
        if K_CMEDDBVersion >= 19 then
          SQL.Text := SQL.Text + ',' + K_CMENDBAAInstsTFServID;               //8

        SQL.Text := SQL.Text + ' from ' + K_CMENDBAAInstsTable +
                    ' where ' + K_CMENDBAAInstsTFGlobID + ' = ' + SClientAppGlobID;
        Filtered := false;
        Open;
        AICount := RecordCount;

        // *** Get Uniq Active ID
        // CDTime := Now();
        NextActiveTimeStamp := Now();
        CDTime := EDAGetSyncTimestamp( NextActiveTimeStamp );

      /////////////////////////////////////////////
      // Check Multi Instance Launch
      //
        if (AICount > 0)                   and
           not K_CMD4WAppRunByCOMClient    and
           not K_CMStandaloneGUIMode       and
           not K_CMEDAMultipleInstanceMode and
           CheckActiveGLobalInstance( SClientAppGlobID ) then
        begin
          Result := K_edFails;

          ExtDataErrorString := format( 'DB>> Instance for ClientID=%s is active >> ActRTID=%s Time="%s" PatID=%s ProvID=%s LocID=%s',
                       [Fields[2].AsString, Fields[0].AsString, Fields[1].AsString,
                        Fields[4].AsString, Fields[5].AsString, Fields[6].AsString] );
          if K_CMEDDBVersion >= 15 then
            ExtDataErrorString := ExtDataErrorString  + ' ' + Fields[7].AsString;             //7
          if K_CMEDDBVersion >= 19 then
            ExtDataErrorString := ExtDataErrorString  + ' ServerID=' + Fields[8].AsString;             //7
          N_Dump1Str( ExtDataErrorString );
          Close;

        /////////////////////////////////
        // Dump Active Instances Table
        //
          TmpStrings.Clear;
          EDADumpActiveContext( CurDSet1, TmpStrings );
          if TmpStrings.Count > 1 then
            N_Dump1Str('*** Active Instances ***'#13#10 + TmpStrings.Text);
        //
        // Dump Active Instances Table
        /////////////////////////////////

          LANDBConnection.CommitTrans();
          Exit;
        end; // if not K_CMD4WAppRunByClient  and ...
      //
      // end of Check Multi Instance Launch
      /////////////////////////////////////////////


      ///////////////////////////////////
      // Set Active Record Values
      //
        ExtDataErrorCode := K_eeDBIns;
        Insert;


        // *** Set Active Record Fields
        TDateTimeField(FieldList.Fields[1]).Value := CDTime;

        FieldList.Fields[2].AsInteger := ClientAppGlobID;
        TimeStampUID := N_CPUCounter();
        TLargeintField(FieldList.Fields[3]).Value := TimeStampUID;
        FieldList.Fields[4].AsInteger := -1;
        FieldList.Fields[5].AsInteger := -1;
        FieldList.Fields[6].AsInteger := -1;
        if K_CMEDDBVersion >= 15 then
          FieldList.Fields[7].AsInteger := 0;
        if K_CMEDDBVersion >= 19 then
        begin
          FieldList.Fields[8].AsInteger := CurServID;
        end;
      //
      // end of Set Active Record Values
      ///////////////////////////////////


        UpdateBatch;
        Close;

        SQL.Text := 'select @@identity';
        Filtered := false;
        CurDSet1.Open;
        AppRTID := CurDSet1.FieldList.Fields[0].AsInteger;
        CurDSet1.Close();

        SAppRTID := IntToStr(AppRTID);
        LogStr := 'Active Instance ActRTID=' + SAppRTID +
                  ' for Client ID|VName=' + SClientAppGlobID +
                  '|' + CMSClientVirtualName;
        if CMSSessionInfo.WTSClientName <> CMSClientVirtualName then
          LogStr := LogStr + ' Name=' + CMSSessionInfo.WTSClientName;
        if K_CMEDDBVersion >= 19 then
          LogStr := LogStr + ' and Server ID|Name=' + SCurServID +
                   '|' + CMSSessionInfo.WTSServerCompName;
        LogStr := 'DB>> Add New ' + LogStr;
        N_Dump1Str( LogStr );
      end; // with CurDSet1, K_CMSServerClientInfo do
    end; // if K_CMEDDBVersion >= 40 then


  // Set Next Active TimeStamp and Count
    NextActiveTimeStamp := NextActiveTimeStamp + K_CMEDAActivateDeltaDD;
    NextActiveTimeCount := ATimerCount + 60;

  //
  // end of Register Instance to Active Sessions Table
  //////////////////////////////////////////////

    {
      /////////////////////////////////////
      // Calc Running Time and Trial Period
      EDASaveStatInfo( [K_sifStartTimeCount] );
    }

    // if RecordCount = 1 then begin
    ////*** First Client Session Start
    /////////////////////////////////////
    // Check if Key Exists
    Result := EDAGAGlobalToCurState();

    LResult := EDANotGAGlobalToCurState();
    if LResult <> K_edOK then
      Result := LResult
    else
    if K_CMIURemindeInDays = -1 then
    begin
    // Save Default Values
      K_CMIURemindeTS  := Int(Now());
      K_CMIURemindeInDays := 90;
      EDANotGAGlobalToMemIni1();
    end;

//      Close;


    EDAGetFilesHandlingDBContext();

    LANDBConnection.CommitTrans();

    with CurSQLCommand1 do
    begin
      CommandText := EDADBIsolationLevelDefault();
      Execute;
    end; // with CurSQLCommand1 do

    if ATimer = nil then
      ATimer := TTimer.Create(N_CM_MainForm);
    if K_CMAutoCloseLastActTS <> 0 then
      N_Dump1Str('DB>> EDAAppActivate is waked');
    K_CMAutoCloseLastActTS := 0; // Clear AutoCLose Mode
    K_CMScanDataPathLost := TRUE; //Needed To Rebuild CommonInfoFile while CMSuite is waked

    ATimer.Interval := K_CMEDAActivateTimerDeltaMS;
    ATimer.OnTimer := EDASetActiveTimeStamp;
    ATimer.Enabled := TRUE;

    if (K_CMScanDataPathCheckThread = nil) and
       (K_FormCMDCMExe = nil) then  // Create if not cmdcm application
    begin
      K_CMScanDataPathCheckThread := TK_CFPFilePathCheckThread.Create( TRUE );
      K_CMScanDataPathCheckThread.CFPPResult := @K_CMScanDataPathCheckResult;
      N_Dump2Str('DB>> ScanDataPathCheckThread is created');
    end;

    if (K_CMDCMStoreFilesThread = nil) and
       K_CMDICOMNewFlag                and  // Create while new DICOM mode
       (K_FormCMSupport = nil)         and  // Create if not support application
       (K_FormCMDCMExe = nil) then          // Create if not cmdcm application
    begin
      K_CMDCMStoreFilesThread := TK_CMDCMStoreFilesThread.Create( FALSE );
      N_Dump2Str('DB>> DCMStoreFilesThread is created');
    end;

    N_Dump2Str('DB>> EDAAppActivate fin');

//??N_T1.SS('DB>> EDAAppActivate >>');

  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAAppActivate ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAAppActivate

//**************************************** TK_CMEDDBAccess.EDAAppDeactivate ***
// Unlock Active Application Instance ID
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAAppDeactivate(): TK_CMEDResult;
var
  SAppRTID: string;
label UnlockError;
begin
  Result := K_edOK;
  if AppRTID = 0 then Exit;
  SAppRTID := IntToStr(AppRTID);
  N_Dump2Str('DB>> EDAAppDeactivate ActRTID=' + SAppRTID);
  try
    if ATimer <> nil then
      ATimer.Enabled := FALSE;
    if LANDBConnection.Connected then
    begin
      LANDBConnection.BeginTrans;
      with CurSQLCommand1 do
      begin
        Connection := LANDBConnection;
//        ExtDataErrorCode := K_eeDBLock;
//        CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
//        Execute;

        // Delete Active Instance Record
        CommandText :=  EDADBIsolationLevelSet(K_tilSerializable);
        Execute;

        EDAAppUnlockObjects( SAppRTID );
        // EDASaveStatInfo( [K_sifChangeTimestamp] );

        ExtDataErrorCode := K_eeDBDel;
        CommandText :=  'DELETE FROM ' + K_CMENDBAAInstsTable + ' WHERE ' +
                                        K_CMENDBAAInstsTFActRTID + '=' + SAppRTID;
        Execute;


        CommandText :=  EDADBIsolationLevelDefault();
        Execute;
      end; // with CurSQLCommand1 do
      LANDBConnection.CommitTrans;
    end; // if LANDBConnection.Connected then

    if K_CMScanDataPathCheckThread <> nil then
    begin
      K_CMScanDataPathCheckThread.Terminate();
      K_CMScanDataPathCheckThread.CFPContinue;
      K_CMScanDataPathCheckThread := nil;
      N_Dump2Str('DB>> ScanDataPathCheckThread terminated');
    end;

    if K_CMDCMStoreFilesThread <> nil then
    begin
      K_CMDCMStoreFilesThread.Terminate();
      K_CMDCMStoreFilesThread := nil;
      N_Dump2Str('DB>> DCMStoreFilesThread terminated');
    end;

    AppRTID := 0;
    N_Dump2Str('DB>> EDAAppDeactivate fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAAppDeactivate ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAAppDeactivate

//*********************************** TK_CMEDDBAccess.EDAClearActiveContext ***
// Clear Active Instance Context
//
//     Parameters
// Result - Returns operation resulting code
//
// Needed to clear while Switch to HR Preview UI is done
//
function TK_CMEDDBAccess.EDAClearActiveContext(): TK_CMEDResult;
var
  SAppRTID: string;
label UnlockError;
begin
  Result := K_edOK;
  if AppRTID = 0 then Exit;
  SAppRTID := IntToStr(AppRTID);
  N_Dump2Str('DB>> EDAClearActiveContext ActRTID=' + SAppRTID);
  try
    with CurSQLCommand1 do
    begin
      CommandText := 'UPDATE ' + K_CMENDBAAInstsTable + ' SET ' +
        K_CMENDBAAInstsTFPatID  + ' = -1, ' +
        K_CMENDBAAInstsTFProvID + ' = -1, ' +
        K_CMENDBAAInstsTFLocID  + ' = -1 '  +
        ' WHERE ' +  K_CMENDBAAInstsTFActRTID + '=' + SAppRTID + ';';
      Execute;
    end;

    EDASaveContextsData( [K_cmssSkipSlides] ); // Save previous state
    CurPatID  := -1;
    CurProvID := -1;
    CurLocID  := -1;
    EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                               Ord(K_shNCAFinishSession) ) );
    CurSessionHistID := 0;
    N_Dump2Str('DB>> EDAClearActiveContext fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAClearActiveContext ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAClearActiveContext

//********************************************* TK_CMEDDBAccess.EDAGetVersionRegInfo ***
// Get CMS Version Info from DB
//
//     Parameters
// ADOQuery - ADO Data Set for calling secadm.sec_get_regversion
//
procedure TK_CMEDDBAccess.EDAGetVersionRegInfo();
var
  SVal : string;
begin
  with CurDSet1 do
  begin
    // *** Check DB Registration
    try
      SQL.Text := 'begin' + Chr($0A) + 'select secadm.sec_get_registered();' + Chr
        ($0A) + 'end';
      Filtered := false;
      Open;
      SVal := FieldList.Fields[0].AsString;
      N_Dump1Str( 'secadm.sec_get_registered=' + SVal );
//      N_LCAdd(N_CMSDump1LCInd,
//        'secadm.sec_get_registered=' + FieldList.Fields[0].AsString);
      K_CMSLiRegState := K_lrsOK;
      if SameText('trial', SVal) then
        K_CMSLiRegState := K_lrsDBTrial; // Set DB Trial Mode
      Close;
    except
      N_Dump1Str( 'secadm.sec_get_registered >> Exception' );
    end;

    { }        // Check Version Type and Build Number

//    K_CMSLiRegBuildInfo := '!?!';
    K_CMSLiRegStatus := K_lrtProfessional;
//    K_CMSLiRegStatus := K_lrtLight; // debug
//K_CMSLiRegStatus := K_lrtComplex; // debug
    K_CMSLiRegModDisable := [];
    K_CMSLiRegDevLimit := 0;
//K_CMSLiRegDevLimit := 5; // debug
//K_CMSLiRegDevLimit := 4; // debug
//K_CMSLiRegDevLimit := 1; // debug
//K_CMSLiRegDevLimit := 3; // debug
//K_CMSLiRegDevLimit := 2; // debug
    if K_CMSLiRegState = K_lrsOK then
    begin

      SQL.Text := 'begin' + Chr($0A) + 'select secadm.sec_get_regversion();' +
        Chr($0A) + 'end';
      try
        Filtered := false;
        Open;
        SVal := FieldList.Fields[0].AsString;
        N_Dump1Str('secadm.sec_get_regversion=' + SVal);
//        N_LCAdd(N_CMSDump1LCInd,
//          'secadm.sec_get_regversion=' + FieldList.Fields[0].AsString);

        if SameText('light', SVal) then
          K_CMSLiRegStatus := K_lrtLight
        else if SameText('enterprise', SVal) then
          K_CMSLiRegStatus := K_lrtEnterprise
        else if K_StrStartsWith( 'complex', SVal ) then
        begin
          K_CMSLiRegStatus := K_lrtComplex;
          // Parse COMPLEX info
          if SVal[9] <> '0' then
            K_CMSLiRegDevLimit := 2;
          if SVal[10] <> '0' then
            K_CMSLiRegDevLimit := K_CMSLiRegDevLimit + 1;
          if SVal[11] = '0' then
            K_CMSLiRegModDisable := K_CMSLiRegModDisable + [limdCosmetic];
          if SVal[12] = '0' then
            K_CMSLiRegModDisable := K_CMSLiRegModDisable + [limdDICOM];
          if SVal[13] = '0' then
            K_CMSLiRegModDisable := K_CMSLiRegModDisable + [limdCMWEB];
          if SVal[14] = '0' then
            K_CMSLiRegModDisable := K_CMSLiRegModDisable + [limdImg3D];
          if SVal[15] = '0' then
            K_CMSLiRegModDisable := K_CMSLiRegModDisable + [limdFunc3];
        end;
        Close;
      except
        N_Dump1Str( 'secadm.sec_get_regversion >> Exception' );
      end;

      SQL.Text := 'begin' + Chr($0A) + 'select secadm.sec_get_buildpayed();' +
        Chr($0A) + 'end';
      try
        Filtered := false;
        Open;
        SVal := FieldList.Fields[0].AsString;
        N_Dump1Str('secadm.sec_get_buildpayed=' + SVal);
//        N_LCAdd(N_CMSDump1LCInd,
//          'secadm.sec_get_buildpayed=' + FieldList.Fields[0].AsString);
        K_CMSLiRegBuildInfo := SVal;
        Close;
      except
        N_Dump1Str( 'secadm.sec_get_buildpayed >> Exception' );
      end;
    end; // if K_CMSLiRegState = K_lrsOK then
  end; // with CurDSet1 do
end; // end of TK_CMEDDBAccess.EDAGetVersionRegInfo


//********************************************* TK_CMEDDBAccess.EDAGetSlidesFPathContext ***
// Get Slides Files Access Context
//
//     Parameters
// ALocID - Location ID to init Path Context (really needed only for Enterprise Mode)
// Result - Returns operation resulting code
//
// ALocID is used only on CMS Application start
//
function TK_CMEDDBAccess.EDAGetSlidesFPathContext( ALocID : Integer = -1 ): TK_CMEDResult;
var
  SLocID : string;
  SQLText : string;
{
  function PrepFilesPath( var FPath: string; ADefResult: Boolean): Boolean;
  begin
    Result := ADefResult;
    if FPath <> '' then
    begin
      FPath := IncludeTrailingPathDelimiter(FPath);
      Result := FPath[1] = '!';
      if not Result then
        Result := FPath[1] = '>';
      if Result then
        FPath := Copy(FPath, 2, Length(FPath) - 1);
    end;
  end;
}

begin
  try
    Result := K_edOK;
    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBSelect;
      // *** Initialize Files Server Paths Context
      Filtered := false;
      if not K_CMEnterpriseModeFlag then
      begin  // Use Context from Global Attributes Table in Ordinary Mode
        N_Dump2Str('DB>> FilesPathsContext from ' + K_CMENDBGlobAttrsTable );
        SQLText := 'select ' +
          K_CMENDBGTFImgFPath + ',' + K_CMENDBGTFMediaFPath;
        if K_CMEDDBVersion >= 34 then
          SQLText := SQLText + ',' + K_CMENDBGTFImg3DFPath;
        SQL.Text := SQLText + ' from ' + K_CMENDBGlobAttrsTable;
        Open;
      end   // if not K_CMEnterpriseModeFlag then
      else
      begin // Use Context from Location Files Access Table in Enterprise Mode
        if ALocID = -1 then
          ALocID := CurLocID;
        SLocID := IntToStr(ALocID);
        N_Dump2Str('DB>> FilesPathsContext from ' + K_CMENDBLocsFAccessTable + ' for LocID=' + SLocID );
        SQLText := 'select ' +
          K_CMENDBLFALocImgFPath + ',' + K_CMENDBLFALocVideoFPath + ',' +
          K_CMENDBLFALocImgExtFPath + ',' + K_CMENDBLFALocVideoExtFPath + ',' +
          K_CMENDBLFALocFlags + ',' + K_CMENDBLFALocID;

        SQL.Text := SQLText + ' from ' + K_CMENDBLocsFAccessTable +
                              ' where ' + K_CMENDBLFALocID + '=' + SLocID;
        Open;

        SlidesImgRootEFolder := '';
        SlidesMediaRootEFolder := '';
        if RecordCount = 0 then
        begin
        // Add new Location Context
          Close();
          SQL.Text := SQLText;
          Open;
          CurLocEFlags := 0;
          if RecordCount = 0 then CurLocEFlags := 1; // First Location is Added
          N_Dump2Str('DB>> Add New FilesPathsContext for LocID=' + SLocID );
          Insert;
          FieldList.Fields[4].AsInteger := CurLocEFlags;
          FieldList.Fields[5].AsInteger := ALocID;
          UpdateBatch;
        end
        else
        begin
          SlidesImgRootEFolder := EDAGetStringFieldValue(FieldList.Fields[2]);
          SlidesMediaRootEFolder := EDAGetStringFieldValue(FieldList.Fields[3]);
          N_Dump1Str('DB>> ExtImgRootFolder "' + SlidesImgRootEFolder + '"');
          N_Dump1Str('DB>> ExtMediaRootFolder "' + SlidesMediaRootEFolder + '"');
          CurLocEFlags := FieldList.Fields[4].AsInteger;
        end;
      end; // if K_CMEnterpriseModeFlag then


      // 2D Img Files Root Folder Attrs
      if K_CMVUIMode then //!!!Ura 22.06.20
        SlidesImgRootFolder := '>' + K_CMVUICustomersRoot + K_CMVUICustomerID + '\Img\'
      else
        SlidesImgRootFolder := EDAGetStringFieldValue(FieldList.Fields[0]);
      N_Dump1Str('DB>> ImgRootFolder "' + SlidesImgRootFolder + '"');
      SlidesImgRootFDA := K_CMParseFilesPath(SlidesImgRootFolder);
//                          PrepFilesPath(SlidesImgRootFolder, false);


      // Media Files Root Folder Attrs
      if K_CMVUIMode then //!!!Ura 22.06.20
        SlidesMediaRootFolder := '>' + K_CMVUICustomersRoot + K_CMVUICustomerID + '\Video\'
      else
        SlidesMediaRootFolder := EDAGetStringFieldValue(FieldList.Fields[1]);
      N_Dump1Str('DB>> VideoRootFolder "' + SlidesMediaRootFolder + '"');
      SlidesMediaRootFDA := K_CMParseFilesPath( SlidesMediaRootFolder );
//                            PrepFilesPath(SlidesMediaRootFolder, false);
      if SlidesMediaRootFolder <> '' then
      begin
        SlidesMediaFSplit := SlidesMediaRootFolder[1] = '*';
        if SlidesMediaFSplit then
          SlidesMediaRootFolder := Copy(SlidesMediaRootFolder, 2,
            Length(SlidesMediaRootFolder) - 1);
      end;

      // Img3D Files Root Folder Attrs
      if (K_CMEDDBVersion >= 34) and not K_CMEnterpriseModeFlag then
      begin
        if K_CMVUIMode then //!!!Ura 22.06.20
          SlidesImg3DRootFolder := '>' + K_CMVUICustomersRoot + K_CMVUICustomerID + '\Img3D\'
        else
          SlidesImg3DRootFolder := EDAGetStringFieldValue(FieldList.Fields[2]);
        N_Dump1Str('DB>> Img3DRootFolder "' + SlidesImg3DRootFolder + '"');
        K_CMParseFilesPath( SlidesImg3DRootFolder );
      end;
      if (SlidesImg3DRootFolder = '') and (SlidesImgRootFolder <> '') then // Set Default
        SlidesImg3DRootFolder := ExtractFilePath(ExcludeTrailingPathDelimiter(SlidesImgRootFolder)) + K_Img3DFolder;

      Close();

    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAGetSlidesFPathContext ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // TK_CMEDDBAccess.EDAGetSlidesFPathContext

//******************************************** TK_CMEDDBAccess.EDADBConnect ***
// Open DB connection
//
//     Parameters
// ADBConnection - given connection
//
procedure TK_CMEDDBAccess.EDADBConnect( ADBConnection: TADOConnection );
begin
  if K_CMAddDBConnection <> nil then
  begin
    FreeAndNil(K_CMAddADOQuery);
    FreeAndNil(K_CMAddADOCommand);
    FreeAndNil(K_CMAddDBConnection);
  end;
  ADBConnection.Open();

  with CurSQLCommand1 do
  begin
{
    Connection := LANDBConnection;
CommandText :=
  'DROP PROCEDURE IF EXISTS  "DBA"."cms_TestIsoLevel";'#10 +
  'CREATE PROCEDURE "DBA"."cms_TestIsoLevel"(  )'#10 +
  'BEGIN'#10 +
  'SET TEMPORARY OPTION isolation_level = 3;'#10 +
  'END;';
Execute;

with CurDSet1 do
begin
  Connection := ADBConnection;
  SQL.Text := 'select CONNECTION_PROPERTY(''isolation_level'')';
  Open;
  N_s := Fields[0].AsString;
  Close;
end;
ADBConnection.BeginTrans;

//Connection := ADBConnection;
//CommandText := 'SET TEMPORARY OPTION isolation_level = 3;';
//Execute;

with CurDSet1 do
begin
  Connection := ADBConnection;
  SQL.Text := 'select CONNECTION_PROPERTY(''isolation_level'')';
  Open;
  N_s := Fields[0].AsString;
  Close;
end;

//CommandText := 'SET TEMPORARY OPTION isolation_level = '+ N_s + ';';
//Execute;
//with CurStoredProc1 do
//begin
//  Connection := LANDBConnection;
//  ProcedureName := 'dba.cms_TestIsoLevel';
//  Parameters.Clear;
//  ExecProc;
//end;

with CurDSet1 do
begin
  Connection := ADBConnection;
  SQL.Text := 'select CONNECTION_PROPERTY(''isolation_level'')';
  Open;
  N_s := Fields[0].AsString;
  Close;
end;

ADBConnection.CommitTrans;

with CurDSet1 do
begin
  Connection := ADBConnection;
  SQL.Text := 'select CONNECTION_PROPERTY(''isolation_level'')';
  Open;
  N_s := Fields[0].AsString;
  Close;
end;


CommandText :=
  'DROP PROCEDURE IF EXISTS  "DBA"."cms_TestIsoLevel";';
Execute;
{}

  //*** Set Sybase Blocking Timeout
    Connection := ADBConnection;
    ExtDataErrorCode := K_eeDBSetOption;
    if not K_CMEDAMSSQL then
      CommandText := 'SET OPTION BLOCKING_TIMEOUT = 0'
    else
      CommandText := 'SET LOCK_TIMEOUT -1';
    Execute;
{ // TmpBlobTable is not really used now
    with CurSQLCommand1 do
    begin

      CommandText :=
        'DROP TABLE IF EXISTS ' + K_CMENDBTmpTable  + ';';
      Execute;

      CommandText :=
        'DECLARE LOCAL TEMPORARY TABLE ' + K_CMENDBTmpTable +
      // ' ( ' + K_CMENDBTTFID + ' INT , ' + K_CMENDBTTFBlobBuf + ' LONG BINARY );';
        ' ( ' + K_CMENDBTTFID + ' INT , ' + K_CMENDBTTFBlobBuf +
        ' LONG BINARY )' + ' ON COMMIT PRESERVE ROWS;';
      Execute;

      CommandText :=
        'INSERT ' + K_CMENDBTmpTable + ' ( ' + K_CMENDBTTFID + ' ) values ( 1 );';
      Execute;
    end;
}
//    if CurTmpTableExists then Exit;

{
CommandText :=
             ' UPDATE ' + K_CMENDBGlobAttrsTable + ' SET ' + K_CMENDBGTFFixStudyDate +
               ' = DATE( DATEADD(day,-1,GETDATE()));' + #10 +
           ' IF EXISTS (SELECT 1 FROM ' + K_CMENDBSlidesTable +
                ' WHERE ' + K_CMENDBSTFSlideStudyID +' < 0 ) THEN ' + #10 +
          // Set Flag for Studies Fix Data Dlg
             ' UPDATE ' + K_CMENDBGlobAttrsTable + ' SET ' + K_CMENDBGTFFixStudyDate +
               ' = DATE( DATEADD(day,-1,GETDATE()));' + #10 +

          // Set Flag for Studies Fix Data Dlg
             ' UPDATE ' + K_CMENDBGlobAttrsTable + ' SET ' + K_CMENDBGTFFixStudyDate +
               ' = DATE( DATEADD(day,-1,GETDATE()));' + #10 +

             'END IF;';
Execute;

CommandText := 'select * into LOCAL TEMPORARY TABLE QQ1 from AllMTypes where 1=0;';
Execute;
CommandText := 'INSERT QQ1 ( MTID, MTTitle ) values ( 1, ''AA'' );';
Execute;
with CurDSet1 do
begin
  Connection := ADBConnection;
  // *** Synchronize Self Time with System Time
  SQL.Text := 'SELECT * from QQ1;';
  Filtered := false;
  Open;
  N_i := Fields[0].AsInteger;
  N_s := Fields[1].AsString;
  Close();
end;
}
//    CurTmpTableExists := TRUE;
  end;
end; // end of TK_CMEDDBAccess.EDADBConnect

//********************************************* TK_CMEDDBAccess.EDACheckDBConnection ***
// Check given DB connection state
//
//     Parameters
// ADBConnection - given connection
// AShowMessage - show error message flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDACheckDBConnection(ADBConnection: TADOConnection;
  AShowMessageFlag: Boolean = TRUE): TK_CMEDResult;
var
  DBVersion: Integer;
  SDBVer: string;
  TextPos: Integer;
  WStr, SQLText : string;
  CurTime : TDateTime;
  LogStream : TFileStream;
  EMessage : string;

Label ErrExit, LCont;


  procedure CloseConnection();
  begin
{ // TmpBlobTable is not really used now
    with CurSQLCommand1 do
    begin
      Connection := ADBConnection;
      CommandText :='DROP TABLE ' + K_CMENDBTmpTable + ';';
      Execute;
//      CurTmpTableExists := FALSE;
    end;
}
    ADBConnection.Close();
  end; // procedure CloseConnection

  function TestConnection( ADBAPSW : string ) : string;
  begin
    try
      Result := '';
      if ADBAPSW <> '' then
        N_StringToMemIni( 'CMSDB', 'ExtProperties', 'UID=dba;PWD=' + ADBAPSW + ';DSN=CMSImg' )
      else
        N_StringToMemIni( 'CMSDB', 'ExtProperties', 'UID=dba;PWD=sql;DSN=CMSImg' );
      ADBConnection.ConnectionString := K_CMDBGetConnectionString();
      EDADBConnect( ADBConnection );
    except
      on E: Exception do
      begin  // E.Message
        Result := E.Message;
      end;
    end;
  end; // function TestConnection

begin
  Result := K_edFails;
  if K_CMSLiRegState < K_lrsOK then
    Exit;

  Result := K_edOK;
  if ADBConnection.Connected then Exit;

  try

{}  // open by SIR 27085
    AShowMessageFlag := AShowMessageFlag or not PrevConnectionErr;
    PrevConnectionErr := TRUE;
    if  K_CMDBAPSW = '' then
    begin
      N_Dump2Str( 'Before TestConnection with defaul PSW' );
      N_T1.Start;
      EMessage := TestConnection( '' );
      N_T1.Stop;
      N_Dump2Str( 'After TestConnection with defaul PSW time=' + N_T1.ToStr() );
      if EMessage = '' then goto LCont;
      if 0 = Pos( 'Invalid user ID or password', EMessage ) then
        raise Exception.Create( EMessage );

      N_Dump2Str( 'Before K_CMGetDBAPSW' );
      N_T1.Start;
      K_CMGetDBAPSW();
      N_T1.Stop;
      N_Dump2Str( 'After K_CMGetDBAPSW time=' + N_T1.ToStr() );
      if K_CMDBAPSW = '' then
        raise Exception.Create( EMessage );
    end;

    N_Dump2Str( 'Before TestConnection with real PSW' );
    N_T1.Start;
    EMessage := TestConnection( K_CMDBAPSW );
    N_T1.Stop;
    N_Dump2Str( 'After TestConnection with real PSWW time=' + N_T1.ToStr() );
    if EMessage  = '' then goto LCont;
    if 0 = Pos( 'Invalid user ID or password', EMessage ) then
      raise Exception.Create( EMessage );

    WStr := K_CMDBAPSW;
    K_CMDBAPSW := '';
    repeat
      if not K_CMEnterDBAPSWDlg( ) then
        raise Exception.Create( EMessage );
      N_Dump2Str( 'Before TestConnection with new PSW' );
      EMessage := TestConnection( K_CMDBAPSW );
    until EMessage = '';

    with CurSQLCommand1 do
    begin
      Connection := ADBConnection;
      EMessage := N_AnsiToString( N_Encript1( N_StringToAnsi( K_CMDBAPSW ) ) );
      N_Dump2Str( 'Before sec_set_retcode' );
      N_T1.Start;
      CommandText := 'call "dba"."sec_set_retcode"(''dba'',''' + EMessage + ''');';
      Execute;
      N_T1.Stop;
      N_Dump2Str( 'After sec_set_retcode time=' + N_T1.ToStr() );
    end;

LCont: //*****
{}
{ // close by SIR 27085
//    ADBConnection.ConnectionString := K_CMDBGetConnectionString();
    AShowMessageFlag := AShowMessageFlag or not PrevConnectionErr;
    PrevConnectionErr := TRUE;
    EDADBConnect( ADBConnection );
//    PrevConnectionErr := TRUE;
// !!!2020-12-03 don't dump DB Connection string because of security
//    N_Dump2Str('DB>> Open DB connection >= ' + ADBConnection.ConnectionString);
{}
//      N_Dump1Str( '***** TimeStamp: Before Connection Open' ); // Deb time measuring

{ // TmpBlobTable is not really used now
    with CurSQLCommand1 do
    begin

      CommandText :=
        'DROP TABLE IF EXISTS ' + K_CMENDBTmpTable  + ';';
      Execute;

      CommandText :=
        'DECLARE LOCAL TEMPORARY TABLE ' + K_CMENDBTmpTable +
      // ' ( ' + K_CMENDBTTFID + ' INT , ' + K_CMENDBTTFBlobBuf + ' LONG BINARY );';
        ' ( ' + K_CMENDBTTFID + ' INT , ' + K_CMENDBTTFBlobBuf +
        ' LONG BINARY )' + ' ON COMMIT PRESERVE ROWS;';
      Execute;

      CommandText :=
        'INSERT ' + K_CMENDBTmpTable + ' ( ' + K_CMENDBTTFID + ' ) values ( 1 );';
      Execute;
    end;
{}
// DEBUGCODE /////////////////////////
// Check Trail expired
//      if K_CMSLiRegState <> K_lrsDBTrial then begin
//        CloseConnection();
//        raise Exception.Create( 'Trial period expired' );
//      end;
// end of Check Trail expired
////////////////////////////////////

    K_CMEDDBSetActualTablesFieldsNames();
    with CurDSet1 do
    begin
      Connection := ADBConnection;
      ExtDataErrorCode := K_eeDBSelect;

      // *** Synchronize Self Time with System Time
      SQL.Text := 'SELECT GETDATE( ),' + K_CMENDBGTFDBVersion + ' from ' + K_CMENDBGlobAttrsTable;
      Filtered := false;
      Open;
      CurTime := Now();
      SyncTimeDelta := TDateTimeField(FieldList.Fields[0]).Value - CurTime;
      NextActiveTimeStamp := 0; // Clear NextActiveTimeStamp - needed value will be set in EDAAppActivate
      NextActiveTimeCount := 0; // Clear NextActiveTimeCount - needed value will be set in EDAAppActivate

      N_LogChannels[N_Dump1LCInd].LCTimeShift := SyncTimeDelta;
      N_Dump1Str( format( '***** TimeStamp: changed from ClientTime=%s by TimeDelta=%g sec',
                  [K_DateTimeToStr(CurTime, 'yyyy-mm-dd hh":"nn":"ss.zzz'),
                   SyncTimeDelta * 24 * 60 * 60] ) );
      DBVersion := FieldList.Fields[1].AsInteger;
      Close();

      // Prepare to check DB data
//      K_CMEDDBSetActualTablesFieldsNames();
      EDAGetVersionRegInfo();
{
// For Wrong Build Testing
if TRUE then
begin
if TRUE then
{}
{}
//!!! -Error        if K_CMSLiRegState >= K_lrsOK then //!! should work if K_lrsOK or K_lrsDBTrial

      if (K_CMSLiRegState = K_lrsOK) and
         K_CMSLiRegCheckBuild        and
         not SameText(K_CMSLiRegBuildInfo, K_CMSSBuildNum) then
      begin
      // Check Auto Upgrade Info
        K_CMAUType := '';
        if DBVersion >= 29 then
        begin
          SQL.Text := 'select ' + K_CMENDUpgradeTypeID + ',' + K_CMENDUpgradeBridgeID + ' from ' + K_CMENDBUpgradeSupportTable;
          Filtered := false;
          Open;
          K_CMAUType   := FieldList.Fields[0].AsString;
          K_CMAUBridge := FieldList.Fields[1].AsString;
        end;

        EDAAddRegInfoStrings(K_CMSLiRegMacroInfo);
        CloseConnection();
//            WStr := format( 'Your Media Suite database build is %s'#13#10 +
//                            'Your Media Suite build is %s'#13#10 +
//                            'Please upgrade your Media Suite build to %s and start Media Suite again'#13#10 +
//                            '                            Click OK to continue', [K_CMSLiRegBuildInfo, K_CMSSBuildNum, K_CMSLiRegBuildInfo ] );
        WStr := format( K_CML1Form.LLLAppInit12.Caption,
//                  'Client build number (%s) does not match database build number (%s).',
                          [K_CMSSBuildNum, K_CMSLiRegBuildInfo] );
        if K_CMAUType = '1' then
          WStr := WStr + #13#10 + K_CML1Form.LLLAppInit19.Caption;
        K_CMSLiRegState := K_lrsUnregCMSBuild;
        raise Exception.Create( WStr );
      end; // if (K_CMSLiRegState = K_lrsOK) and K_CMSLiRegCheckBuild and not SameText(K_CMSLiRegBuildInfo, K_CMSSBuildNum) then

      // *** Check DB Version
//        N_BoolToMemIni( 'CMS_Main', 'OpenAllDBVer', TRUE); // skip DB Version check in DebugMode
      N_Dump2Str( format( '***** Build DB version %d real DB version %d', [K_CMEDDBVersion, DBVersion] ) );
      if  N_MemIniToBool( 'CMS_Main', 'OpenAllDBVer', false) then
      begin
        K_CMEDDBVersion := DBVersion; // If is needed to work with previous DB formats
      end
      else
      if DBVersion <> K_CMEDDBVersion then
      begin
        SDBVer := IntToStr(DBVersion);
        WStr := 'DB Version Error: Needed=' + IntToStr(K_CMEDDBVersion) +
                ' Existing=' + SDBVer;
        N_Dump1Str( WStr );
        EDAAddRegInfoStrings(K_CMSLiRegMacroInfo);
        CloseConnection();
        K_CMSLiRegState := K_lrsBadDBVersion;
        if not K_CMDesignModeFlag then
          WStr := format( K_CML1Form.LLLAppInit11.Caption,
//               'Media Suite build number (%s) does not match database version',
                          [K_CMSSBuildNum] );
        raise Exception.Create( WStr );
      end; // if DBVersion <> K_CMEDDBVersion then

      if K_CMEDDBVersion >= 16 then
      begin
        SQL.Text := 'select ' + K_CMENDBCITitle + ' from ' + K_CMENDBCustomerInfoTable;
        Filtered := false;
        Open;
        K_CMSVIPCTitle := EDAGetStringFieldValue(FieldList.Fields[0]);
        Close();
      end; // if K_CMEDDBVersion >= 16 then

      if K_CMEDDBVersion >= 10 then
      begin
        SQLText := 'select ' + K_CMENDBGTFDBFlags;

        if K_CMEDDBVersion >= 15 then
        begin
          SQLText := SQLText + ',' + K_CMENDBGTFCodePage;
          if K_CMEDDBVersion >= 19 then
            SQLText := SQLText + ',' + K_CMENDBGTFSAFlags;
          if K_CMEDDBVersion >= 27 then
            SQLText := SQLText + ',DATEDIFF(hour,GETDATE(),' + K_CMENDBGTFFixStudyDate + ')';
        end;

        SQL.Text := SQLText +  ' from ' +  K_CMENDBGlobAttrsTable;
        Filtered := false;
        Open;
        K_CMDBCurCodePage := -1;
        if (K_CMEDDBVersion >= 15) then
        begin
        ///////////////////////
        // CodePage check
        //
          K_CMDBCurCodePage := FieldList.Fields[1].AsInteger;
          if (K_CMDBCurCodePage = 0) and (K_CMD4WCurCodePage <> 0) then
          begin
            Edit;
            K_CMDBCurCodePage := K_CMD4WCurCodePage;
            FieldList.Fields[1].AsInteger := K_CMDBCurCodePage;
            UpdateBatch;
          end;


          if K_CMD4WAppRunByCOMClient                 and
            (K_CMDBCurCodePage <> K_CMD4WCurCodePage) and
            ((K_CMDBCurCodePage <> N_NeededCodePage) or (K_CMD4WCurCodePage <> 0)) then
          begin
            Close;
            K_CMSAppStartContext.CMASState := K_cmasStop;
            K_CMSLiRegState := K_lrsCodePageErr;
            K_CMSLiRegWarning := format( K_CML1Form.LLLAppInit3.Caption,
//                 'Media Suite Database code page %d does not match D4W code page %d.',
               [K_CMDBCurCodePage, K_CMD4WCurCodePage] );
            goto ErrExit;
          end
          else
          if (K_CMDBCurCodePage > 0) then
            N_NeededCodePage := K_CMDBCurCodePage;
        //
        // CodePage check
        ///////////////////////

          if K_CMEDDBVersion >= 19 then
          begin
            if K_CMEDDBVersion >= 27 then
            begin
              K_CMSFixStudyDataMode := EDACalcFixStudyDataModeByTime( FieldList.Fields[3].AsInteger );
              if K_CMSFixStudyDataMode > 0 then
                N_Dump1Str( 'DB>> Init FixStudyDataMode=' + IntToStr(K_CMSFixStudyDataMode) );
            end; // if K_CMEDDBVersion >= 27 then

            Byte(K_CMStandaloneMode) := FieldList.Fields[2].AsInteger and 3;

            if ArchMLibRoot <> nil then
            begin // Real Start - not EDAConfigGetInfo or EDAConfigSetInfo
              if Byte(K_CMStandaloneMode) = 3 then
              begin // First Start - Set Standalone Mode
                if K_CMStandaloneGUIMode then
                  K_CMStandaloneMode := K_cmsaHybrid
                else
                begin
                  K_CMStandaloneMode := K_cmsaLink;
                  // Check if DB is not empty
                  with CurBlobDSet do
                  begin
                    Connection := LANDBConnection;
                    SQL.Text := 'select ' + K_CMENDAUID + ' from ' +  K_CMENDBAllProvidersTable;
                    Filtered := false;
                    Open;
                    if RecordCount > 0 then
                      K_CMStandaloneMode := K_cmsaHybrid;
                    Close();
                  end;
                end;
                Edit;
                FieldList.Fields[2].AsInteger := Ord(K_CMStandaloneMode);
                UpdateBatch;
              end; // if Byte(K_CMStandaloneMode) = 3 then
            end; // if ArchMLibRoot <> nil then
          end; // if K_CMEDDBVersion >= 19 then
        end; // if (K_CMEDDBVersion >= 15) then

      //////////////////////////////////
      // Check Enterprise Mode
      //
        K_CMEnterpriseModeFlag := (FieldList.Fields[0].AsInteger and 1) <> 0;

        N_Dump1Str( format( 'Enterprise fields VIPTitle=%s DBFlags=%s',
                            [N_B2S(K_CMSVIPCTitle <> ''),
                             N_B2S(K_CMEnterpriseModeFlag)] ) );

        if not K_CMEnterpriseModeFlag then
        begin
          if (K_CMSLiRegStatus = K_lrtEnterprise) and (K_CMSVIPCTitle = '') then
          begin // Registered Enterprise Mode and DB Enterprise Mode is absent (error for not VIP only)
            EDAAddRegInfoStrings(K_CMSLiRegMacroInfo);
            K_CMSLiRegState := K_lrsEnterpriseErr;
            K_CMSLiRegWarning := K_CML1Form.LLLAppInit5.Caption + #13#10 + K_CML1Form.LLLAppInit4.Caption;
//                'Media Suite Database is not in Enterprise Mode.'#13#10 +
//                'Media Suite is now unusable. Click OK to continue';
          end;
        end  // if not K_CMEnterpriseModeFlag then
        else
        if (K_CMSLiRegState = K_lrsOK)           and
           (K_CMSLiRegStatus <> K_lrtEnterprise) and
           ((K_CMSLiRegStatus <> K_lrtProfessional) or (K_CMSVIPCTitle = '')) then
        begin // not Registered Enterprise Mode but DB Enterprise Mode is set
          EDAAddRegInfoStrings(K_CMSLiRegMacroInfo);
          K_CMSLiRegState := K_lrsEnterpriseUnreg;
          K_CMSLiRegWarning := K_CML1Form.LLLAppInit6.Caption + #13#10 + K_CML1Form.LLLAppInit4.Caption;
//              'Media Suite Enterprise Mode is unregistered.'#13#10 +
//              'Media Suite is now unusable. Click OK to continue';
        end
        else
        if (K_CMSLiRegState = K_lrsDBTrial) then
          K_CMSLiRegStatus := K_lrtEnterprise;
      //
      // Check Enterprise Mode
      //////////////////////////////////
      end  // if K_CMEDDBVersion >= 10 then
      else // if K_CMEDDBVersion < 10 then
      if K_CMSLiRegStatus = K_lrtEnterprise then
      begin // Precation
      // Registered Enterprise Mode and too Low DB Version
        EDAAddRegInfoStrings(K_CMSLiRegMacroInfo);
        K_CMSAppStartContext.CMASState := K_cmasStop;
        K_CMSLiRegState := K_lrsEnterpriseErr;
        K_CMSLiRegWarning := K_CML1Form.LLLAppInit2.Caption + #13#10 + K_CML1Form.LLLAppInit18.Caption;
  //        'Media Suite Database version does not match Enterprise Mode.'#13#10 +
  //        'Media Suite is now unusable. Click OK to close Media Suite';
      end;
      Close;

      if K_CMSLiRegState < K_lrsOK then
      begin
ErrExit:
        Result := K_edExDataError;
        ExtDataErrorCode := K_eeDBConnection;
        CloseConnection();
        Exit;
      end;

      ///////////////////////////
      // Check DB recovery mode
      //
      Filtered := false;
      if K_CMEDDBVersion >= 40 then
      begin // for MSSQL and high DB version
        SQL.Text := 'select ' + K_CMENDBGTFSAFlags + ' from ' + K_CMENDBGlobAttrsTable;
        Open;
        K_CMSDBRecoveryMode := (Fields[0].AsInteger and 8) <> 0;
      end
      else
      begin
        SQL.Text := 'select c.[default] from sys.syscolumn c, sys.systable t where c.table_id=t.table_id and t.table_name=''' + K_CMENDBSlidesTable +
                    ''' and c.column_name=''' + K_CMENDBSTFSlideID + '''';
        Open;
        K_CMSDBRecoveryMode := FieldList[0].IsNull;
      end;
      Close;
      N_Dump1Str( 'DB>> Recovery mode=' + N_B2S(K_CMSDBRecoveryMode) );

{ !!! 2014-02-18 DB query optimisation
     //////////////////////////////////////////////////
     //  Get Remote Client Device Profiles Saving Mode
     //
      N_Dump1Str( 'DB>> CMS TermSession=' + IntToStr(K_CMSServerClientInfo.CMSSessionInfo.WTSClientProtocolType) );

      with K_CMSServerClientInfo do
        if (K_CMEDDBVersion >= 19) and
           (CMSSessionInfo.WTSClientProtocolType = WTS_PROTOCOL_TYPE_RDP) then
        begin
          SQL.Text := 'select ' + K_CMENDBGTFDPContType +
            ' from ' + K_CMENDBGlobAttrsTable;
          Filtered := false;
          Open;
          ProfilesSaveMode := TK_CMEDDevProfilesSaveMode(FieldList.Fields[0].AsInteger);
          Close;
          if ProfilesSaveMode = K_cmdpClientIP then
            CMSClientVirtualName := CMSSessionInfo.WTSClientIPStr;
        end
        else
          ProfilesSaveMode := K_cmdpServer;

//        K_CMEDAMultipleInstanceMode := ProfilesSaveMode = K_cmdpServer;
//        K_CMEDAMultipleInstanceMode := FALSE;

      N_Dump1Str( 'DB>> CMS Remote Client Setup Device Context=' + IntToStr(Integer(ProfilesSaveMode)) );

     //////////////////////////////////////////////////
     //  Get Command Line Format
     //
      if K_CMEDDBVersion >= 21 then
      begin
        SQL.Text := 'select ' + K_CMENDBGTFLinkCLMode + ',' +
                                K_CMENDBGTFLinkCLUDFormat +
          ' from ' + K_CMENDBGlobAttrsTable;
        Filtered := false;
        Open;
        K_CMSLinkCommandLineFormatMode := TK_CMSLinkCommandLineFormatMode(FieldList.Fields[0].AsInteger);
        K_CMSLinkCommandLineUDFormat := FieldList.Fields[1].AsString;
        Close;
        N_Dump1Str( 'DB>> CMS Command line format type =' + IntToStr(Ord(K_CMSLinkCommandLineFormatMode)) );
      end;
} // !!! 2014-02-18 DB query optimisation

      ProfilesSaveMode := K_cmdpServer;
      if K_CMEDDBVersion >= 19 then
      begin
        SQLText := K_CMENDBGTFDPContType;
        if K_CMEDDBVersion >= 21 then
          SQLText := SQLText + ',' + K_CMENDBGTFLinkCLMode + ',' +
                                     K_CMENDBGTFLinkCLUDFormat;

        SQL.Text := 'select ' + SQLText + ' from ' + K_CMENDBGlobAttrsTable;
        Filtered := false;
        Open;

        //////////////////////////////////////////////////
        //  Get Remote Client Device Profiles Saving Mode
        //
        with K_CMSServerClientInfo do
          if CMSSessionInfo.WTSClientProtocolType = WTS_PROTOCOL_TYPE_RDP then
          begin
            ProfilesSaveMode := TK_CMEDDevProfilesSaveMode(FieldList.Fields[0].AsInteger);
            if ProfilesSaveMode = K_cmdpClientIP then
              CMSClientVirtualName := CMSSessionInfo.WTSClientIPStr;
          end;

        if K_CMEDDBVersion >= 21 then
        begin
        //////////////////////////////////////////////////
        //  Get Command Line Format
        //
          K_CMSLinkCommandLineFormatMode := TK_CMSLinkCommandLineFormatMode(FieldList.Fields[1].AsInteger);
          K_CMSLinkCommandLineUDFormat := FieldList.Fields[2].AsString;
          N_Dump1Str( 'DB>> CMS Command line format type =' + IntToStr(Ord(K_CMSLinkCommandLineFormatMode)) );
        end; // if K_CMEDDBVersion >= 21 then
      end; // if K_CMEDDBVersion >= 19 then
      N_Dump1Str( 'DB>> CMS Remote Client Setup Device Context=' + IntToStr(Integer(ProfilesSaveMode)) );

    end; // with CurDSet1 do


    PrevConnectionErr := false;

    K_CMStandaloneGUIMode := K_CMStandaloneGUIMode and (K_CMEDDBVersion >= 19);
    Result := EDAAppActivate();
//      if Result <> K_edOK then
    if Result = K_edFails then
    begin
      if K_CMSPrevErrLogFName <> '' then
      begin
        with N_LogChannels[N_Dump2LCInd] do
        begin
          LogStream := nil;
          try
            // Stream Open locks ErrLog file so all dump from other CMS will be buffered
            // and put to Errlog file after Stream close
            LogStream := TFileStream.Create( LCFullFName, fmOpenReadWrite  or fmShareDenyWrite );

            // Get current Errlog file to StrTextBuf
            TmpStrings.LoadFromStream( LogStream );
            StrTextBuf := TmpStrings.Text; // Text Buffer

            // Get previouse Errlog file to TmpStrings
            TmpStrings.LoadFromFile(K_CMSPrevErrLogFName);

            // Add current Errlog file to TmpStrings
            TmpStrings.Add( StrTextBuf );

            // Save All Log to current Errlog file
            TmpStrings.SaveToStream(LogStream);
            FreeAndNil(LogStream);

            // Delete previouse Errlog file
            K_DeleteFile(K_CMSPrevErrLogFName);
            N_Dump1Str( 'File ' + K_CMSPrevErrLogFName + #13#10 +
            '            is inserted at the beginning of the current CMSErrLog.txt and deleted' );
          except
            N_Dump1Str( 'Error while insertion at the beginning CMSErrLog.txt prev ' + #13#10 + '    ' + K_CMSPrevErrLogFName );
            LogStream.Free;
          end;
          K_CMSPrevErrLogFName := '';
        end; // with N_LogChannels[N_Dump2LCInd] do
      end; // if K_CMSPrevErrLogFName <> '' then

      K_CMSAppStartContext.CMASState := K_cmasStop;

      if not K_CMStandaloneGUIMode    and
         not K_CMD4WAppRunByCOMClient and
         (K_CMSLinkCommandLineFormatMode <> K_cmclfNone) then
      begin
        if K_CMSCLLContextFromCommandLine( ) then
        begin // Try to transfere Link Context to Running Instance
          if K_CMSCLLContextToIniFile( K_CMSCLLIniFName ) then Exit;
        end;
      end;
      N_Dump1Str( 'DB>> Multi Instance check StandALone=' + N_B2S(K_CMStandaloneGUIMode) +
                  ' RunByCOMClient='   + N_B2S(K_CMD4WAppRunByCOMClient) +
                  ' CLLFormat='   + IntToStr(Ord(K_CMSLinkCommandLineFormatMode)) );
      K_CMSLiRegState := K_lrsOtherErr;
      K_CMSLiRegWarning := K_CML1Form.LLLAppInit7.Caption;
//          'Media Suite instance is already running on this PC.';
      goto ErrExit;
    end; // if Result = K_edFails then
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBConnection;
      WStr := E.Message;
      ExtDataErrorString := 'EDACheckDBConnection >> ' + WStr;
      N_Dump1Str( ExtDataErrorString ); // New dump is added 22.09.2011
      if K_CMEDAMSSQL then
      begin
        TextPos := Pos( 'trigger execution', WStr );
        if TextPos > 0 then
        begin
          ADBConnection.ConnectionString := K_CMDBGetMSSQLConnectionString( 'errlog' );
//          ADBConnection.ConnectionString := K_CMDBGetMSSQLConnectionString( 'sa' );
          ADBConnection.Open();
          with CurDSet1 do
          begin
            Connection := ADBConnection;
            // *** Synchronize Self Time with System Time
            SQL.Text := 'select top 1 * from secadm.sec_log where currentuser = ''dba'' order by id desc';
            Filtered := false;
            Open;
            WStr := FieldByName('msg').AsString;
            ExtDataErrorString := 'EDACheckDBConnection MSSQL >> ' + WStr;
            Close;
            N_Dump1Str( ExtDataErrorString );
          end;
          ADBConnection.Connected := FALSE; // Close connection 
        end
        else
          EDAShowErrMessage(AShowMessageFlag);
      end; // if K_CMEDAMSSQL then

      TextPos := Pos( 'Database server not found', WStr );
      if TextPos > 0 then
      begin
        K_CMSAppStartContext.CMASState := K_cmasStop;
        K_CMSLiRegWarning := K_CML1Form.LLLAppInit8.Caption;
//          'The connection to the database server has been lost. Please restart your server and the Media Suite.';
      end
      else
      if (K_CMSLiRegState = K_lrsUnregCMSBuild) or
         (K_CMSLiRegState = K_lrsBadDBVersion) then
      begin
        K_CMSLiRegWarning := WStr;
        K_CMSAppStartContext.CMASState := K_cmasStop;
      end
      else
      begin
      // Check Exception Text for details
//        TextPos := 1;
        TextPos := Pos( 'Trial period expired', WStr );
        if TextPos > 0 then
        begin
          // Trial Period Expired Exception
          K_CMSLiRegWarning := K_CML1Form.LLLAppInit9.Caption + #13#10 + K_CML1Form.LLLAppInit4.Caption;
//            'Media Suite Database trial period is already expired.'#13#10 +
//            'Media Suite is now unusable. Click OK to continue';
          K_CMSLiRegState := K_lrsDBTrialExpired;
          K_CMSLiRegTrialExpiredInfo := WStr;
//!!!debug K_CMSAppStartContext.CMASMode := K_cmamCOMHPUI;
        end
        else
        begin
          TextPos := Pos( 'Connection limit', WStr );
          if TextPos > 0 then
          begin
            // Number of allowed connections exceeded Exception
//            K_CMSLiRegWarning :=
//              'Number of allowed connections exceeded.'#13#10 +
//              'Media Suite is now unusable. Click OK to continue';

            K_CMSAppStartContext.CMASState := K_cmasStop;
            K_CMSLiRegState := K_lrsNumConExceeded;
            K_CMSLiRegTrialExpiredInfo := WStr;
            K_CMParseLiDBTrialExpiredInfo( K_CMSLiRegMacroInfo );
            K_CMSLiRegWarning := K_StringMListReplace( K_CML1Form.LLLAppInit10.Caption,
//  'The system has detected that Centaur Media Suite is registered for (#L#) user license(s).'#13#10 +
//  'You currently have (#L#) Centaur Media Suite users. Your CIN is: (#ID#).'#13#10 +
//  'To purchase additional Centaur Media Suite  licenses please call (#N#)'#13#10 +
//  ' on (#PH#) or email to (#E#) for a registration code.',
            K_CMSLiRegMacroInfo, K_ummRemoveMacro);
          end
          else
            EDAShowErrMessage(AShowMessageFlag);
        end;
      end;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDACheckDBConnection

//********************************** TK_CMEDDBAccess.EDADBIsolationLevelSet ***
// Set DB connection isolation level
//
//     Parameters
// AILevel - isolation level name
// Returns - isolation level SQL command string
//
function TK_CMEDDBAccess.EDADBIsolationLevelSet( AILevel : TK_DBTransIsoLevel ): string;
var
  ILevel : string;
begin
  if K_CMEDAMSSQL then
  begin
    case AILevel of
    K_tilReadUncommitted : ILevel := 'READ UNCOMMITTED';
    K_tilReadCommitted   : ILevel := 'READ COMMITTED';
    K_tilRepeatableRead  : ILevel := 'REPEATABLE READ';
    K_tilSerializable    : ILevel := 'SERIALIZABLE';
    end;
     Result := 'SET TRANSACTION ISOLATION LEVEL ' + ILevel + ';';
  end
  else
  begin
    case AILevel of
    K_tilReadUncommitted : ILevel := '0';
    K_tilReadCommitted   : ILevel := '1';
    K_tilRepeatableRead  : ILevel := '2';
    K_tilSerializable    : ILevel := '3';
    end;
    Result := 'SET TEMPORARY OPTION isolation_level = ' + ILevel + ';';
  end;
end; // function TK_CMEDDBAccess.EDADBIsolationLevelSet

//****************************** TK_CMEDDBAccess.EDADBIsolationLevelDefault ***
// Set DB connection isolation level
//
//     Parameters
// Returns - default isolation level SQL command string
//
function TK_CMEDDBAccess.EDADBIsolationLevelDefault( ) : string;
begin
  Result := EDADBIsolationLevelSet( K_tilReadCommitted );
{
  if K_CMEDAMSSQL then
  begin
    Result := 'SET TRANSACTION ISOLATION LEVEL READ COMMITTED;';
  end
  else
  begin
    Result := 'SET TEMPORARY OPTION isolation_level = 1;';
  end;
}
end; // function TK_CMEDDBAccess.EDADBIsolationLevelDefault

//************************************** TK_CMEDDBAccess.EDADBDateTimeToSQL ***
// Create SQL DateTime value string for Sybase and MS SQL
//
//     Parameters
// Returns - SQL cast value string
//
function TK_CMEDDBAccess.EDADBDateTimeToSQL( ADT : TDateTime; const AFormatStr : string = '' ) : string;
var
  FStr : string;
begin
  if AFormatStr = '' then
  begin
{
    if not K_CMEDAMSSQL then
      FStr := 'yyyy-mm-dd hh:nn:ss.zzz'
    else
      FStr := 'yyyy-dd-mm hh:nn:ss.zzz';
}
    FStr := 'yyyy-mm-dd hh:nn:ss.zzz'
  end
  else FStr := AFormatStr;
  Result := K_DateTimeToStr( ADT, FStr );

  if not K_CMEDAMSSQL then
  begin
    Result := 'DATETIME('''+Result+''')';
  end
  else
  begin
    Result := 'CAST('''+Result+''' as datetime)';
  end;

end; // function TK_CMEDDBAccess.EDADBDateTimeToSQL

//****************************************** TK_CMEDDBAccess.EDADBDateToSQL ***
// Create SQL Date value string for Sybase and MS SQL
//
//     Parameters
// Returns - SQL cast value string
//
function TK_CMEDDBAccess.EDADBDateToSQL( ADT : TDateTime ) : string;
var
  FStr : string;
begin
  FStr := 'yyyy-mm-dd';
  Result := K_DateTimeToStr( ADT, FStr );

  if not K_CMEDAMSSQL then
  begin
    Result := 'DATE('''+Result+''')';
  end
  else
  begin
    Result := 'CAST('''+Result+''' as date)';
  end;

end; // function TK_CMEDDBAccess.EDADBDateToSQL

//************************************ TK_CMEDDBAccess.EDAPutBlobFieldValue ***
// Put Blob Field Data
//
//     Parameters
// ADataSet - DataSet object
// AField   - Field object
// APData - pointer to binary data first byte
// ADataSize  - on input source binary data size in bytes on output - resulting data size (after compression)
// ACurCompressPower - current compress power, if -1 then common BlobCompressPower will be used
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAPutBlobFieldValue(ADataSet: TDataSet; AField: TField;
  APData: Pointer; var ADataSize: Integer;
  ACurCompressPower: Integer = -1): TK_CMEDResult;
var
  Stream: TStream;
  // CompressedCount : Integer;
begin
  Result := K_edOK;
  if APData = nil then
    Exit;

  Result := EDACompressData(APData, ADataSize, ACurCompressPower);
  if Result <> K_edOK then
    Exit;
  Stream := nil;
  try
    if ADataSize <> 0 then
    begin
      Stream := ADataSet.CreateBlobStream(AField, bmWrite);
      Result := EDAPutDataToStream(Stream, APData, ADataSize);
      ADataSize := Stream.Size;
      Stream.Free;
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBBlobWrite;
      ExtDataErrorString := 'EDAPutBlobFieldValue ' + E.Message;
      Stream.Free;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAPutBlobFieldValue

//********************************************* TK_CMEDDBAccess.EDAGetBlobFieldValue ***
// Get Blob Field Data
//
//     Parameters
// ADataSet - DataSet object
// AField   - Field object
// APData   - pointer to resulting data array start byte
// ADataSize - resulting data size in bytes
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetBlobFieldValue(ADataSet: TDataSet; AField: TField;
  out APData: Pointer; out ADataSize: Integer): TK_CMEDResult;
var
  Stream: TStream;
begin
  ADataSize := 0;
  Stream := nil;
  try
    Stream := ADataSet.CreateBlobStream(AField, bmRead);
    ADataSize := Stream.Size;
    APData := nil;
    if ADataSize > 0 then
    begin
      if Length(BlobBuf) < ADataSize then
      begin
        BlobBuf := nil;
        SetLength(BlobBuf, ADataSize + ADataSize div 4);
      end;

      K_DFStreamOpen(Stream, ExtDFile, []);
      ADataSize := ExtDFile.DFPlainDataSize;
      K_DFReadAll(@BlobBuf[0], ExtDFile);
      APData := @BlobBuf[0];
    end;
    Result := EDAUncompressData(APData, ADataSize);
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBBlobRead;
      ExtDataErrorString := 'EDAGetBlobFieldValue ' + E.Message;
      Stream.Free;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAGetBlobFieldValue

//********************************************* TK_CMEDDBAccess.EDPutBlobFieldFromDIB ***
// Get Blob Field Data to given DIB Object
//
//     Parameters
// ADataSet - DataSet object
// AField   - Field object
// ADIBObj - source DIB
// ARIEncType  - Raster Image Encoding Type
// ARIEncAttr  - Raster Image Encoding Attribute
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDPutBlobFieldFromDIB( ADataSet: TDataSet;
            AField: TField; ADIBObj: TN_DIBObj; ARIEncType : TK_RIFileEncType;
            ARIEncAttr: Integer ): TK_CMEDResult;
var
  Stream: TStream;
//  GDW: TK_GPDIBCodecsWrapper;
  RIEncodingInfo : TK_RIFileEncInfo;

begin
  Result := K_edOK;
//  GDW := TK_GPDIBCodecsWrapper.Create;
  Stream := nil;
  try
    Stream := ADataSet.CreateBlobStream(AField, bmWrite);
{
    with GDW do
    begin
      // Save Image
      if AMimeType = K_gpiJPG then
        GPEncQuality := AGPAttr
      else if AMimeType = K_gpiTIF then
        GPEncValue := TEncoderValue(AGPAttr);
      GPSaveDIBObjToStream(ADIBObj, Stream, AMimeType);
      Free;
    end;
}
    with K_RIObj do
    begin
      RIClearFileEncInfo( @RIEncodingInfo );
      RIEncodingInfo.RIFileEncType := ARIEncType;
      RIEncodingInfo.RIFComprQuality := ARIEncAttr;
      // Save Image
      if RISaveDIBToStream( ADIBObj, Stream, @RIEncodingInfo ) = rirOK then
        N_Dump2Str('!!>> Save Data Size DIB=' + IntToStr(Stream.Size) ) // TMP DUMP DATA SIZE
      else
        raise Exception.Create( 'RISaveDIBToStream Error K_RIObj=' + ClassName );
    end;
    Stream.Free;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBBlobWrite;
      ExtDataErrorString := 'EDPutBlobFieldFromDIB ' + E.Message;
      Stream.Free;
//      GDW.Free;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDPutBlobFieldFromDIB

//********************************************* TK_CMEDDBAccess.EDGetBlobFieldToDIB ***
// Get Blob Field Data to given DIB Object
//
//     Parameters
// ADataSet - DataSet object
// AField   - Field object
// ADIBObj - resulting DIB
// ADataSize  - resulting binary data size in bytes
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDGetBlobFieldToDIB(ADataSet: TDataSet;
  AField: TField; out ADIBObj: TN_DIBObj): TK_CMEDResult;
var
  Stream: TStream;
//  GDW: TK_GPDIBCodecsWrapper;
begin
  Result := K_edOK;
//  GDW := nil;
  Stream := nil;
  ADIBObj := nil;
  try
    Stream := ADataSet.CreateBlobStream(AField, bmRead);
    if Stream.Size = 0 then
    begin
      Result := K_edFails;
      Stream.Free;
      Exit;
    end;

    if K_RIObj.RIOpenStream(Stream) = rirOK then
    begin
      if K_RIObj.RIGetDIB( 0, ADIBObj ) <> rirOK then
      begin
        FreeAndNil(ADIBObj);
        Result := K_edExDataError;
      end;
    end;
//    K_RIObj.RIClear();
    K_RIObj.RIClose();
{
    GDW := TK_GPDIBCodecsWrapper.Create;
    if GDW.GPLoadFromStream(Stream) = Ok then
    begin
      ADIBObj := TN_DIBObj.Create(1, 1, pf24bit);
      if GDW.GPGetFrameToDIBObj(ADIBObj, 0) <> Ok then
      begin
        Result := K_edExDataError;
        FreeAndNil(ADIBObj);
      end;
    end;
}
    Stream.Free;
//    GDW.Free;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBBlobRead;
      ExtDataErrorString := 'EDGetBlobFieldToDIB ' + E.Message;
      Stream.Free;
//      GDW.Free;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDGetBlobFieldToDIB

//********************************************* TK_CMEDDBAccess.EDAPutStringFieldValue ***
// Put String DB Field value
//
//     Parameters
// AField - DB Field
// AStr   - string to put
//
procedure TK_CMEDDBAccess.EDAPutStringFieldValue( AField: TField; const AStr: string );
  // CompressedCount : Integer;
begin
  if AField is TStringField then
  begin
    TStringField(AField).Value := N_StringToAnsi( AStr )
  end
  else
  if AField is TMemoField then
  begin
    TMemoField(AField).Value := N_StringToAnsi( AStr )
  end
  else
  begin
    AField.Value := N_StringToAnsi( AStr );
  end;
//    raise Exception.Create( 'EDAPutStringFieldValue - not String Field' );
end; // end of TK_CMEDDBAccess.EDAPutStringFieldValue

//********************************************* TK_CMEDDBAccess.EDAGetStringFieldValue ***
// Get String DB Field value
//
//     Parameters
// AField - DB Field
// Result - Returns string read from DB Field
//
function TK_CMEDDBAccess.EDAGetStringFieldValue( AField: TField  ): string;
begin
//    Result := N_AnsiToString( AField.AsString );
    Result := K_CMEDAGetDBStringValue(AField);
{
  if AField is TStringField then
    Result := N_AnsiToString( TStringField(AField).Value )
  else if AField is TMemoField then
    Result := N_AnsiToString( TMemoField(AField).Value )
  else
    raise Exception.Create( 'EDAGetStringFieldValue - not String Field' );
}
end; // end of TK_CMEDDBAccess.EDAGetStringFieldValue

//********************************************* TK_CMEDDBAccess.EDAPathOrFileExists ***
// Check if Path or File exists
//
//     Parameters
// AFName - File Name
// AFilesDA - Files Direct Access Flag
// APathFlag - path flag if TRUE then Path Existance check is needed
// Result -  Returns operation resulting code (K_edOK - file exists, K_edFails -
// file not exists, other - operation error)
//
// APathFlag parameter is actual only for direct access mode (AFilesDA=TRUE)
//
function TK_CMEDDBAccess.EDAPathOrFileExists( const AFName: string;
                    AFilesDA: Boolean; APathFlag: Boolean ): TK_CMEDResult;
begin
  Result := K_edOK;

  if AFilesDA then
  begin
    if APathFlag then
    begin
      if DirectoryExists(AFName) then
        Exit;
    end
    else if FileExists(AFName) then
      Exit;
    Result := K_edFails;
  end
  else
    try
      with CurBlobDSet do
      begin
        ExtDataErrorCode := K_eeDBSelect;
        Connection := LANDBConnection;
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A)
   + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(AFName, '\', '\\')) + ';' + Chr($0A)
   + 'select sf_path_exists(@ls_source);' + Chr($0A) + 'end';

        // SQL.Text := 'select sf_path_exists( ''' + AnsiReplaceText( AFName, '\', '\\' ) + ''')';
        Filtered := false;
        Open;
        if FieldList.Fields[0].AsInteger <> 0 then
          Result := K_edFails;
        Close;
      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorCode := K_eeFilesPocessing;
        ExtDataErrorString := 'EDAPathOrFileExists ' + E.Message;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end;
end; // end of TK_CMEDDBAccess.EDAPathOrFileExists

//********************************************* TK_CMEDDBAccess.EDAGetSlideImgPath ***
// Get Slide Image Files Server Base Path
//
//     Parameters
// AUDSlide - Slide
// Result - Returns Slide Image Files path
//
function TK_CMEDDBAccess.EDAGetSlideImgPath(AUDSlide: TN_UDCMBSlide): string;
begin
  Result := SlidesImgRootFolder + AUDSlide.GetFilesPathSegm;
end; // end of TK_CMEDDBAccess.EDAGetSlideImgPath

//************************************ TK_CMEDDBAccess.EDAGetSlideImg3DPath ***
// Get Slide 3D Image Files Server Base Path
//
//     Parameters
// AUDSlide - Slide
// Result - Returns Slide Image Files path
//
function TK_CMEDDBAccess.EDAGetSlideImg3DPath(AUDSlide: TN_UDCMBSlide): string;
begin
  Result := SlidesImg3DRootFolder + AUDSlide.GetFilesPathSegm;
end; // end of TK_CMEDDBAccess.EDAGetSlideImg3DPath

function TK_CMEDDBAccess.EDAGetDICOMPath(AUDSlide: TN_UDCMBSlide): string;
begin
  if not Assigned(AUDSlide) then
    Exit;


  Result := TK_CMEDDBAccess(K_CMEDAccess).EDAGetSlideImg3DPath(AUDSlide) +
            K_CMSlideGetImg3DFolderName(AUDSlide.ObjName);
end;

//********************************************* TK_CMEDDBAccess.EDAMemIniFilesMovingInfoToCurState ***
// Check Files Handling Context
//
//     Parameters
// Result  - Returns Files Handling Context State Code:
//#F
// 0 - Files Handling Context is OK
// 1 - Media Files Client Root Folder is not specified
// 2 - Media Files Server Root Folder is not specified
// 4 - Image Files Server Root Folder is not specified
// 8 - Image Files Server Root Folder is not specified
//#/F
//
// Resulting Files Handling Context Code is set of bit flags for different Root Folders
//
function TK_CMEDDBAccess.EDACheckFSSettings(): Integer;
begin
  Result := 0;
  if SlidesImg3DRootFolder = '' then
    Result := 8;
  if SlidesImgRootFolder = '' then
    Result := 4;
  if K_CMMediaFilesStoringMode <> 1 then // not only Server Media
    Result := Result + inherited EDACheckFSSettings(); // Check Client Media
  if (K_CMMediaFilesStoringMode = 0) or // Only Client Media
    (SlidesMediaRootFolder <> '') then
    Exit; // Server Media is Specified
  Result := Result + 2;
end; // end of TK_CMEDDBAccess.EDACheckFSSettings

//********************************************* TK_CMEDDBAccess.EDACheckActiveInstances ***
// Check Active Application Instance
//
//     Parameters
// AFlags - active instances flags
// Result - Returns number of proper Instance
//
function TK_CMEDDBAccess.EDACheckActiveInstances( AFlags: Integer ): Integer;
begin
  N_Dump2Str('DB>> EDACheckActiveInstances');
  Result := -1; // precation
  try
    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      SQL.Text := 'select count(*)' +
        ' from ' + K_CMENDBAAInstsTable +
        ' where ' + K_CMENDBAAInstsTFActFlags +
        ' & ' +  IntToStr( AFlags ) + ' <> 0';
      Filtered := false;
      Open;
      Result := Fields[0].AsInteger;
      Close;
    end; // with CurDSet1 do
    N_Dump2Str('DB>> EDACheckActiveInstances fin = ' + IntToStr(Result) );
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDACheckActiveInstances ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // function TK_CMEDDBAccess.EDACheckActiveInstances

//********************************************* TK_CMEDDBAccess.EDAGetSyncTimestamp ***
// Get Synchronized Timestamp
//
//     Parameters
// ATime   - Client Computer Timestamp
// Result  - Returns Timestamp Synchronized to Server
//
function TK_CMEDDBAccess.EDAGetSyncTimestamp(ATime: TDateTime = 0): TDateTime;
begin
  if ATime = 0 then
    ATime := Now();
  Result := ATime + SyncTimeDelta;
end; // end of TK_CMEDDBAccess.EDAGetSyncTimestamp

//********************************************* TK_CMEDDBAccess.EDAGetDBFilePath ***
// Get DB file path
//
//     Parameters
// ADBFilePath - DB file path
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetDBFilePath(out ADBFilePath: string)
  : TK_CMEDResult;
begin
  Result := K_edOK;
  ADBFilePath := '';
  try
    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      N_Dump2Str('DB>> EDAGetDBFilePath');
      SQL.Text := 'select DB_PROPERTY(''File'')';
      Filtered := false;
      Open;
      ADBFilePath := EDAGetStringFieldValue(FieldList.Fields[0]);
      Close;
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAGetDBFilePath ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAGetDBFilePath

//****************************** TK_CMEDDBAccess.EDAGetOneAppContextDBField ***
// Get Stored Context DB field given by Type and ID
//
//     Parameters
// ASContType - context type code as string
// ASContID   - context ID as string
// ASContID1  - additional context ID as string
// ADataSet   - DB Data set to operate
// AField     - DB Data set Field with blob Info
// Result - Returns operation resulting code
//
// Resulting data is saved in Self.BlobBuf
//
function TK_CMEDDBAccess.EDAGetOneAppContextDBField( ASContType, ASContID, ASContID1: string;
  ADataSet: TADOQuery; out AField: TField ): TK_CMEDResult;
var
  SQLText : string;
begin
  Result := K_edOK;
  try
    with ADataSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      N_Dump2Str('DB>> Get DB field for context.  ContType=' + ASContType + ' ContID=' +
          ASContID + ' ContID1=' + ASContID1);
      SQLText := 'select ' + K_CMENDBCTFBinData +
        ' from ' + K_CMENDBContextsTable +
        ' where ' + K_CMENDBCTFContID + '=' + ASContID +
        ' and ' + K_CMENDBCTFContTypeID + '=' + ASContType;
      if K_CMEDDBVersion >= 22 then
        SQLText := SQLText + ' and ' + K_CMENDBCTFContID1 + '=' + ASContID1 ;
      SQL.Text := SQLText;
      Filtered := false;
      Open;
      AField := nil;
      if RecordCount > 0 then
        AField := FieldList.Fields[0];
    end;
    N_Dump2Str('DB>> Get DB field fin' );
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAGetOneAppContextDBField ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAGetOneAppContextDBField

//********************************************* TK_CMEDDBAccess.EDAGetOneAppContext ***
// Get Stored Context given by Type and ID
//
//     Parameters
// ASContType - context type code as string
// ASContID   - context ID as string
// ASContID1  - additional context ID as string
// ADSize    - resulting data size
// Result - Returns operation resulting code
//
// Resulting data is saved in Self.BlobBuf
//
function TK_CMEDDBAccess.EDAGetOneAppContext( ASContType, ASContID, ASContID1: string;
  out APData: Pointer; out ADSize: Integer): TK_CMEDResult;
var
//  SQLText : string;
  DBField: TField;
begin
  N_Dump2Str('DB>> Get context start');
  Result := EDAGetOneAppContextDBField( ASContType, ASContID, ASContID1,
                                        CurDSet1, DBField );
  ADSize := 0;
  APData := nil;
  if (Result = K_edOK) and (DBField <> nil) then
    Result := EDAGetBlobFieldValue( CurDSet1, DBField, APData, ADSize );
  CurDSet1.Close;
  N_Dump2Str('DB>> Get context fin. Size=' + IntTostr(ADSize) );

{
  Result := K_edOK;
  try
    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      N_Dump2Str('DB>> Get context. ContType=' + ASContType + ' ContID=' +
          ASContID + ' ContID1=' + ASContID1);
      SQLText := 'select ' + K_CMENDBCTFBinData +
        ' from ' + K_CMENDBContextsTable +
        ' where ' + K_CMENDBCTFContID + '=' + ASContID +
        ' and ' + K_CMENDBCTFContTypeID + '=' + ASContType;
      if K_CMEDDBVersion >= 22 then
        SQLText := SQLText + ' and ' + K_CMENDBCTFContID1 + '=' + ASContID1 ;
      SQL.Text := SQLText;
      Filtered := false;
      Open;
      ADSize := 0;
      APData := nil;
      if RecordCount > 0 then
        Result := EDAGetBlobFieldValue(CurDSet1, FieldList.Fields[0], APData, ADSize);
      Close;
      N_Dump2Str('DB>> Get context. Size=' + IntTostr(ADSize) );
    end;
    N_Dump2Str('DB>> Get context fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAGetOneAppContext ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
}
end; // end of TK_CMEDDBAccess.EDAGetOneAppContext

//********************************************* TK_CMEDDBAccess.EDAOneAppContextToMemIni ***
// Apply Context given by Type and ID to Current MemIni
//
//     Parameters
// AContType - context type code
// AContID   - context ID
// AContID1  - additional context ID
// ADFPLName - name of DFPL library fragment to copy context strings
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAOneAppContextToMemIni( AContType, AContID, AContID1: Integer;
     ADFPLNameCopy : string = ''; ADFPLNameClear : string = '' ): TK_CMEDResult;
var
  DSize: Integer;
  PData: Pointer;
begin
  N_Dump2Str( 'DB>> EDAOneAppContextToMemIni start ' + ADFPLNameCopy );

  K_CMEDAInitDFPLExec();
  K_CMEDADFPLExec.SrcIniFile := K_CMEDAMemIniFile;
  K_CMEDADFPLExec.DstIniFile := N_CurMemIni;

  // "Clear Context State" before save (not used now!!!
  // For "Clear Context State" real use "Store Context State" before clear for future restore Context State just after save is needed
  if ADFPLNameClear <> '' then
  begin
    K_CMEDAMemIniFile.Clear;
    if not K_CMEDADFPLExec.DFPLExecTFSection(ADFPLNameClear) then
      N_Dump2Str( format( 'DB>> EDAOneAppContextToMemIni >> Clear Script "%s" is absent', [ADFPLNameClear]) )
    else
      N_Dump2Str( 'DB>> EDAOneAppContextToMemIni >> Clear Context by ' + ADFPLNameClear );
  end;

  Result := EDAGetOneAppContext( IntToStr(AContType), IntToStr(AContID),
                                 IntToStr(AContID1), PData, DSize );
  if (Result <> K_edOK) then
    Exit;

// Dump Context
  TmpStrings.Clear;
  if DSize > 0 then
  begin
    EDAAnsiTextToString(PData, DSize);
    TmpStrings.Text := PChar(PData);
  end;

// for debug needs
//K_GetFormTextEdit.EditStrings( TmpStrings );
//if AContType = Ord(K_actProvInstIni) then
//K_GetFormTextEdit.EditStrings(TmpStrings);
//if (AContType = Ord(K_actGlobIni))  or
//   (AContType = Ord(K_actGlobIni2)) or
//   (AContType = Ord(K_actLocIni))   or
//   (AContType = Ord(K_actGInstIni)) then
//K_GetFormTextEdit.EditStrings(TmpStrings, 'ContextType=' + IntToStr(AContType) );

  // Save current context before save
  K_CMEDAMemIniFile.SetStrings(TmpStrings);
  if not K_CMEDADFPLExec.DFPLExecTFSection(ADFPLNameCopy) then
  begin
    K_AddMemIni(K_CMEDAMemIniFile, N_CurMemIni);
    N_Dump2Str( format( 'DB>> EDAOneAppContextToMemIni >> Copy Script "%s" is absent, All Context is applied', [ADFPLNameCopy]) );
  end;

  if (DSize > 0) and (CMS_LogsCtrlAll or (AContType <> Ord(K_actProvInstIni))) then
  begin
    EDAHidePasswordForDump( TmpStrings, TRUE );
    N_Dump2Strings( TmpStrings, 5 );
//    N_Dump1Str( format( '***** EDAOneAppContextToMemIni Type=%d ID=%d ID1=%d',
//                [AContType, AContID, AContID1] ) );
//    N_Dump1Strings( TmpStrings, 5 );
  end;

  N_Dump2Str( 'DB>> EDAOneAppContextToMemIni fin' );
end; // end of TK_CMEDDBAccess.EDAOneAppContextToMemIni

//********************************************* TK_CMEDDBAccess.EDAAppContextToCurState ***
// Set Current Application Context
//
//     Parameters
// ANPatId  - new Patient ID
// ANProvID - new Provider ID
// ANLocID  - new Location ID
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAAppContextToCurState(ANPatId, ANProvID,
  ANLocID: Integer): TK_CMEDResult;

var
  DSize: Integer;
  PData: Pointer;

begin
  N_Dump2Str('DB>> EDAAppContextToCurState start');

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if SlidesCRFC.RootFolder <> '' then
    ANPatId := -1;

  // Set New Location
  if CurLocID <> ANLocID then
  begin
    //////////////////////////////////
    // Location Binary Context
    UDRootLocationInfo := TN_UDBase.Create;
    Result := EDAGetOneAppContext( IntToStr(Ord(K_actLocUD)),
                                   IntToStr(ANLocID), '0', PData, DSize );
    if (DSize > 0) and (Result = K_edOK) then
    begin
      EDAAnsiTextToString(PData, DSize);

      K_SerialTextBuf.LoadFromText(PChar(PData));
      K_LoadTreeFromText0(UDRootLocationInfo, K_SerialTextBuf, TRUE);
    end;
    if Result = K_edOK then
      EDALocUDTreeInit();


    EDAOneAppContextToMemIni(Ord(K_actLocIni), ANLocID, 0, 'Location|Load');
    EDALocationMemIniToCurState();

    Result := EDAOneAppContextToMemIni(Ord(K_actLocPrintIni), ANLocID, 0, 'LocationPrint|Load');
  end;
  CurLocID := ANLocID;

  // Set New Provider
  if CurProvID <> ANProvID then
  begin
    // Get Ini COntext
    Result := EDAOneAppContextToMemIni(Ord(K_actProvIni), ANProvID, 0, 'Provider|Load');
    if Result <> K_edOK then
      Exit;

      // Get Binary Context
    Result := EDAGetOneAppContext( IntToStr(Ord(K_actProvUD)),
                                   IntToStr(ANProvID), '0', PData, DSize );

    UDRootProviderInfo.ClearChilds();
    if (DSize > 0) and (Result = K_edOK) then
    begin
      // K_SerialTextBuf.LoadFromText( PChar(@BlobBuf[0]) );

      EDAAnsiTextToString(PData, DSize);

      K_SerialTextBuf.LoadFromText(PChar(PData));
  //N_S := PChar(PData);
  //K_GetFormTextEdit.EditText(N_S);
      K_LoadTreeFromText0(UDRootProviderInfo, K_SerialTextBuf, TRUE);
    end;
    if Result = K_edOK then
      Result := EDAProviderUDTreeInit();

    if Result <> K_edOK then
      Exit;

    EDAProviderMemIniToCurState();

    if K_CMEDDBVersion >= 22 then
      Result := EDAOneAppContextToMemIni( Ord(K_actProvInstIni),
                  ANProvID, ClientAppGlobID, 'ProviderInstance|Load' )
    else
      Result := EDAOneAppContextToMemIni( Ord(K_actProvInstIni),
                 (ANProvID shl 9) or ClientAppGlobID, 0, 'ProviderInstance|Load' );
    EDAProviderInstanceMemIniToCurState();
  end;
  CurProvID := ANProvID;
  if Result <> K_edOK then
    Exit;

  // Set New Patient
  if CurPatID <> ANPatId then
  begin
    Result := EDAOneAppContextToMemIni(Ord(K_actPatIni), ANPatId, 0,
      'Patient|Load');
    EDAPatientMemIniToCurState();
  end;
  CurPatID := ANPatId;
  CurSlidesSelectAttrs.SSPatID := ANPatId;
  if Result <> K_edOK then
    Exit;


  if (Result = K_edOK) and (SlidesCRFC.RootFolder <> '') then
    Result := K_edImageFilesMoving;

  if K_CMStandaloneGUIMode then
  begin // Save Stand Alone Session Context
    N_IntToMemIni('CMS_Main', 'PatientID', CurPatID);
    N_IntToMemIni('CMS_Main', 'ProviderID', CurProvID);
    N_IntToMemIni('CMS_Main', 'LocationID', CurLocID);
  end;
  N_Dump2Str('DB>> EDAAppContextToCurState fin');

end; // end of TK_CMEDDBAccess.EDAAppContextToCurState

//*********************************** TK_CMEDDBAccess.EDASaveOneAppContext0 ***
// Save Context given by Type, ID, Data Pointer and size to DB
//
//     Parameters
// ADataSet  - Data Set Object To Save Context
// AContType - context type code as string
// AContID   - context ID as string
// APData    - pointer to context data start byte
// ADSize    - saving data size
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveOneAppContext0( ADataSet: TADOQuery;
          AContType, AContID, AContID1: Integer; APData: pointer; ADSize : Integer;
          ACurCompressPower : Integer = -1 ): TK_CMEDResult;
var
  SQLText, SContID, SContID1, SContType: string;
begin
  try
    with ADataSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      SContID := IntToStr(AContID);
      SContID1:= IntToStr(AContID1);
      SContType := IntToStr(AContType);
      N_Dump2Str( format( 'DB>> Save context. ContType=%s ContID=%s ContID1=%s DSize=%d',
                  [SContType, SContID, SContID1, ADSize] ) );
//      'DB>> Save context. ContType=' + SContType +
//          ' ContID=' + SContID + ' ContID1=' + SContID1 + ' DSize=' + InToStr(ADSize) );
      SQLText := 'select ' +
        K_CMENDBCTFContID + ',' + K_CMENDBCTFContTypeID + ',' +
        K_CMENDBCTFBinData;
      if K_CMEDDBVersion >= 22 then
        SQLText := SQLText + ',' + K_CMENDBCTFContID1;
      SQLText := SQLText +
        ' from ' + K_CMENDBContextsTable +
        ' where ' + K_CMENDBCTFContID + '=' + SContID +
        ' and ' + K_CMENDBCTFContTypeID + '=' + SContType;
      if K_CMEDDBVersion >= 22 then
        SQLText := SQLText + ' and ' + K_CMENDBCTFContID1 + '=' + SContID1;

      SQL.Text := SQLText;
      Filtered := false;
      Open;
      if RecordCount > 0 then
        Edit
      else
      begin
        Insert;
        FieldList.Fields[0].AsInteger := AContID;
        FieldList.Fields[1].AsInteger := AContType;
        if K_CMEDDBVersion >= 22 then
          FieldList.Fields[3].AsInteger := AContID1;
      end;

      Result := EDAPutBlobFieldValue(ADataSet, FieldList.Fields[2], APData, ADSize, ACurCompressPower);

      if Result = K_edOK then
      begin
        UpdateBatch();
        N_Dump2Str('DB>> Save context fin DSize=' + IntToStr(ADSize) );
      end
      else
        N_Dump1Str('DB>> Save context error');

      Close;
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDASaveOneAppContext0 ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASaveOneAppContext0

//************************************ TK_CMEDDBAccess.EDASaveOneAppContext ***
// Save Context given by Type, ID, Data Pointer and size to DB
//
//     Parameters
// ADataSet  - Data Set Object To Save Context
// AContType - context type code as string
// AContID   - context ID as string
// AContObj  - context data object (TN_USBase or TStrings)
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveOneAppContext(ADataSet: TADOQuery;
          AContType, AContID, AContID1: Integer; AContObj: TObject = nil): TK_CMEDResult;
var
  DSize: Integer;
  SL: TStrings;
//  SQLText, SContID, SContID1, SContType: string;
  PData: Pointer;
  ContClass : Integer; // 1 - context is binary, 0 - context is IniFile fragment
begin
  ContClass := 0;
  if AContObj is TN_UDBase then
  begin
{
    if AContObj = nil then
      N_Dump2Str('DB>> nil')
    else if TN_UDBase(AContObj).ObjLiveMark <> N_ObjLiveMark then
      N_Dump2Str('DB>> not live');
    try
      K_SaveTreeToText(TN_UDBase(AContObj), K_SerialTextBuf, TRUE);
    except
      N_Dump2Strings( K_SerialTextBuf.TextStrings, 10 );
    end;
}
    K_SaveTreeToText(TN_UDBase(AContObj), K_SerialTextBuf, TRUE);
    SL := K_SerialTextBuf.TextStrings;
//K_GetFormTextEdit.EditStrings(SL);
    ContClass := 1;
  end
  else
    SL := TStrings(AContObj);

  DSize := EDAStringsToAnsiText(SL, PData);
  Result := EDASaveOneAppContext0( ADataSet, AContType, AContID, AContID1, PData, DSize );
  if (Result = K_edOK) and DumpSavingContext then
//  if (Result = K_edOK) then
  begin
    if ContClass = 0 then // if Ini
    begin
      EDAHidePasswordForDump( SL, TRUE );
//      N_Dump1Str( format( '***** EDASaveOneAppContextToMemIni Type=%d ID=%d ID1=%d',
//                [AContType, AContID, AContID1] ) );
//      N_Dump1Strings( SL, 5 );
    end;
    N_Dump2Strings( SL, 5 );
  end;
{
  try
    with ADataSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      SContID := IntToStr(AContID);
      SContID1:= IntToStr(AContID1);
      SContType := IntToStr(AContType);
      N_Dump2Str('DB>> Save context. ContType=' + SContType +
          ' ContID=' + SContID + ' ContID1=' + SContID1 );
      SQLText := 'select ' +
        K_CMENDBCTFContID + ',' + K_CMENDBCTFContTypeID + ',' +
        K_CMENDBCTFBinData;
      if K_CMEDDBVersion >= 22 then
        SQLText := SQLText + ',' + K_CMENDBCTFContID1;
      SQLText := SQLText +
        ' from ' + K_CMENDBContextsTable +
        ' where ' + K_CMENDBCTFContID + '=' + SContID +
        ' and ' + K_CMENDBCTFContTypeID + '=' + SContType;
      if K_CMEDDBVersion >= 22 then
        SQLText := SQLText + ' and ' + K_CMENDBCTFContID1 + '=' + SContID1;

      SQL.Text := SQLText;
      Filtered := false;
      Open;
      if RecordCount > 0 then
        Edit
      else
      begin
        Insert;
        FieldList.Fields[0].AsInteger := AContID;
        FieldList.Fields[1].AsInteger := AContType;
        if K_CMEDDBVersion >= 22 then
          FieldList.Fields[3].AsInteger := AContID1;
      end;

      ContClass := 0;
      if AContObj is TN_UDBase then
      begin

//        if AContObj = nil then
//          N_Dump2Str('DB>> nil')
//        else if TN_UDBase(AContObj).ObjLiveMark <> N_ObjLiveMark then
//          N_Dump2Str('DB>> not live');
//        try
//          K_SaveTreeToText(TN_UDBase(AContObj), K_SerialTextBuf, TRUE);
//        except
//          N_Dump2Strings( K_SerialTextBuf.TextStrings, 10 );
//        end;

        K_SaveTreeToText(TN_UDBase(AContObj), K_SerialTextBuf, TRUE);
        SL := K_SerialTextBuf.TextStrings;
        ContClass := 1;
      end
      else
        SL := TStrings(AContObj);

      DSize := EDAStringsToAnsiText(SL, PData);
      Result := EDAPutBlobFieldValue(ADataSet, FieldList.Fields[2], PData, DSize);

      if Result = K_edOK then
      begin
        UpdateBatch();
        N_Dump2Str('DB>> Save context fin DSize=' + IntToStr(DSize) );

        if DumpSavingContext then
        begin
          if ContClass = 0 then // if Ini
            EDAHidePasswordForDump( SL, TRUE );
          N_Dump2Strings( SL, 5 );
        end;

      end;
      Close;
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDASaveOneAppContext ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
}
end; // end of TK_CMEDDBAccess.EDASaveOneAppContext

//******************************* TK_CMEDDBAccess.EDAAddOneAppMemIniContext ***
// Save Context given by Type, ID and Script Name to copy MemIni Data
//
//     Parameters
// ADataSet  - Data Set Object To Save Context
// AContType - context type code as string
// AContID   - context ID as string
// AScriptName  - script name to copy MemIni Data
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAAddOneAppMemIniContext( AScriptName: string; AInitContext : Boolean ): Boolean;
begin
  if AInitContext then
    K_CMEDAMemIniFile.Clear;
  Result := K_CMEDADFPLExec.DFPLExecTFSection(AScriptName);
  if not Result then
    N_Dump2Str( format( 'DB>> EDAPrepOneAppMemIniContext >> Script %s is absent', [AScriptName] ) );

end; // function TK_CMEDDBAccess.EDAAddOneAppMemIniContext

//***************************** TK_CMEDDBAccess.EDASaveOneAppMemIniContext0 ***
// Save Context given by Type, ID and Script Name to copy MemIni Data
//
//     Parameters
// ADataSet  - Data Set Object To Save Context
// AContType - context type code as string
// AContID   - context ID as string
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveOneAppMemIniContext0( AContType, AContID, AContID1: Integer ): TK_CMEDResult;
begin
  TmpStrings.Clear;
  K_CMEDAMemIniFile.GetStrings(TmpStrings);

// debug needs
//if AContType = Ord(K_actProvInstIni) then
//K_GetFormTextEdit.EditStrings(TmpStrings);
//if (AContType = Ord(K_actGlobIni)) or
//   (AContType = Ord(K_actGlobIni2)) or
//   (AContType = Ord(K_actLocIni)) or
//   (AContType = Ord(K_actGInstIni)) then
//K_GetFormTextEdit.EditStrings(TmpStrings, 'Save ContextType=' + IntToStr(AContType) );

  Result := EDASaveOneAppContext(CurDSet1, AContType, AContID, AContID1, TmpStrings);
end; // function TK_CMEDDBAccess.EDASaveOneAppMemIniContext0

//****************************** TK_CMEDDBAccess.EDASaveOneAppMemIniContext ***
// Save Context given by Type, ID and Script Name to copy MemIni Data
//
//     Parameters
// ADataSet  - Data Set Object To Save Context
// AContType - context type code as string
// AContID   - context ID as string
// AScriptName  - script name to copy MemIni Data
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveOneAppMemIniContext( AContType, AContID, AContID1: Integer; AScriptName: string ): TK_CMEDResult;
begin
  Result := K_edOK;
  if not EDAAddOneAppMemIniContext( AScriptName, TRUE ) then Exit;
{
  K_CMEDAMemIniFile.Clear;
  if not K_CMEDADFPLExec.DFPLExecTFSection(AScriptName) then
  begin
    N_Dump2Str( format( 'DB>> EDASaveContextsData >> Script %s is absent', [AScriptName] ) );
    Exit;
  end;
}
  Result := EDASaveOneAppMemIniContext0(AContType, AContID, AContID1);
{
  TmpStrings.Clear;
  K_CMEDAMemIniFile.GetStrings(TmpStrings);

// debug needs
//if ContType = Ord(K_actProvInstIni) then
//K_GetFormTextEdit.EditStrings(TmpStrings);

  Result := EDASaveOneAppContext(CurDSet1, AContType, AContID, AContID1, TmpStrings);
}
end; // function TK_CMEDDBAccess.EDASaveOneAppMemIniContext

//********************************************* TK_CMEDDBAccess.EDASaveContextsData ***
// Save Current Application Context
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveContextsData( ASaveFlags: TK_CMEDSaveStateFlags = [] ): TK_CMEDResult;
label LExit;
begin

  Result := K_edOK;
  if stClosed in LANDBConnection.State then
    Exit; // Connection is not ready - special case when it is closed on server start

  if K_cmssSkipAllContexts in ASaveFlags then
    Exit;

  N_Dump2Str('DB>> EDASaveContextsData');
  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;


  // Save Binary Context
  try


    LANDBConnection.BeginTrans;
    CurDSet1.Connection := LANDBConnection;

    if K_CMGAModeFlag then
    begin
      if UDRootGlobalInfo <> nil then
        Result := EDASaveOneAppContext(CurDSet1, Ord(K_actGlobUD), 0, 0, UDRootGlobalInfo);
      if (Result = K_edOK) and
         (UDRootServerInfo <> nil) and
         (UDRootServerInfo.DirLength > 0) then
        Result := EDASaveOneAppContext(CurDSet1, Ord(K_actServerUD), CurServID, 0,UDRootServerInfo);
      if (Result = K_edOK) and
         (UDRootLocationInfo <> nil) and
         (UDRootLocationInfo.DirLength > 0) then
        Result := EDASaveOneAppContext(CurDSet1, Ord(K_actLocUD), CurLocID, 0, UDRootLocationInfo);
    end  // if K_CMGAModeFlag then
    else
    if ((ProfilesSaveMode = K_cmdpServer) or ((ProfilesSaveMode = K_cmdpGAServer))) and
       (UDRootServerInfo <> nil)            and
       (UDRootServerInfo.DirLength > 0) then // if not K_CMGAModeFlag then
      Result := EDASaveOneAppContext(CurDSet1, Ord(K_actServerUD), CurServID, 0, UDRootServerInfo);

    if Result <> K_edOK then
    begin
    LExit :
      LANDBConnection.RollbackTrans;
      Exit;
    end;

    if not(K_cmssSkipInstanceBinInfo in ASaveFlags) and (UDRootInstanceInfo <> nil) then
    begin
      // Set Patients|Providers|Locations Info SkipSaving Flag
      PatientsInfo.ClassFlags  := PatientsInfo.ClassFlags or K_SkipSelfSaveBit;
      ProvidersInfo.ClassFlags := PatientsInfo.ClassFlags or K_SkipSelfSaveBit;
      LocationsInfo.ClassFlags := PatientsInfo.ClassFlags or K_SkipSelfSaveBit;

      Result := EDASaveOneAppContext(CurDSet1, Ord(K_actGInstUD), ClientAppGlobID, 0,
                                     UDRootInstanceInfo);
      // Remove Patients|Providers|Locations Info SkipSaving Flag
      PatientsInfo.ClassFlags  := PatientsInfo.ClassFlags and not K_SkipSelfSaveBit;
      ProvidersInfo.ClassFlags := PatientsInfo.ClassFlags and not K_SkipSelfSaveBit;
      LocationsInfo.ClassFlags := PatientsInfo.ClassFlags and not K_SkipSelfSaveBit;
    end; // if not(K_cmssSkipInstanceBinInfo in ASaveFlags) and (UDRootInstanceInfo <> nil) then

    if Result <> K_edOK then goto LExit;

{ // previouse version
    DFPLExec.SrcIniFile := N_CurMemIni;
    DFPLExec.DstIniFile := ContMemIni;
}
    K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
    K_CMEDADFPLExec.DstIniFile := K_CMEDAMemIniFile;

    if not (K_cmssSkipGlobalInfo in ASaveFlags) then
    begin
//      if K_CMGAModeFlag or K_CMGAModePrintTemplatesSaveFlag then
      if K_CMGAModeFlag then
      begin
//      K_CMGAModePrintTemplatesSaveFlag := FALSE;
        EDAGlobalCurStateToMemIni();
//        CopyOneContextByScript( Ord(K_actGlobIni), 0,  0, 'Global|Save' );
        Result := EDASaveOneAppMemIniContext( Ord(K_actGlobIni), 0,  0, 'Global|Save' );
        if Result <> K_edOK then goto LExit;
      end;

      if K_cmssSaveGlobal2Info in ASaveFlags then
      begin
        Result := EDANotGAGlobalToMemIni();
        if Result <> K_edOK then goto LExit;
      end;
    end; // if not (K_cmssSkipGlobalInfo in ASaveFlags) then

    if not(K_cmssSkipInstanceInfo in ASaveFlags) then
    begin
      EDAInstanceCurStateToMemIni();
//      CopyOneContextByScript( Ord(K_actGInstIni), ClientAppGlobID, 0, 'Instance|Save' );
      Result := EDASaveOneAppMemIniContext( Ord(K_actGInstIni), ClientAppGlobID, 0, 'Instance|Save' );
      if Result <> K_edOK then
        goto LExit;
    end; // if not(K_cmssSkipInstanceInfo in ASaveFlags) then

    if (CurPatID <> -1) and not(K_cmssSkipPatientInfo in ASaveFlags) then
    begin
      EDAPatientCurStateToMemIni();
//      CopyOneContextByScript(Ord(K_actPatIni), CurPatID, 0, 'Patient|Save');
      Result := EDASaveOneAppMemIniContext( Ord(K_actPatIni), CurPatID, 0, 'Patient|Save' );
      if Result <> K_edOK then
        goto LExit;
    end; // if (CurPatID <> -1) and not(K_cmssSkipPatientInfo in ASaveFlags) then

    if (CurProvID <> -1) and not(K_cmssSkipProviderInfo in ASaveFlags) then
    begin
      EDAProviderCurStateToMemIni();
//      CopyOneContextByScript(Ord(K_actProvIni), CurProvID, 0, 'Provider|Save');
      Result := EDASaveOneAppMemIniContext( Ord(K_actProvIni), CurProvID, 0, 'Provider|Save' );
      if Result <> K_edOK then
        goto LExit;

      if UDRootProviderInfo <> nil then
        Result := EDASaveOneAppContext(CurDSet1, Ord(K_actProvUD), CurProvID, 0,
                                       UDRootProviderInfo);

      if not(K_cmssSkipInstanceInfo in ASaveFlags) then
      begin
        EDAProviderInstanceCurStateToMemIni();
        if K_CMEDDBVersion >= 22 then
  //       CopyOneContextByScript(Ord(K_actProvInstIni),
  //             CurProvID, ClientAppGlobID, 'ProviderInstance|Save')
          Result := EDASaveOneAppMemIniContext( Ord(K_actProvInstIni),
                                CurProvID, ClientAppGlobID, 'ProviderInstance|Save' )
        else
  //        CopyOneContextByScript(Ord(K_actProvInstIni),
  //          (CurProvID shl 9) or ClientAppGlobID, 0, 'ProviderInstance|Save');
          Result := EDASaveOneAppMemIniContext( Ord(K_actProvInstIni),
                       (CurProvID shl 9) or ClientAppGlobID, 0, 'ProviderInstance|Save' );
        if Result <> K_edOK then
          goto LExit;
      end; // if not(K_cmssSkipInstanceInfo in ASaveFlags) then
    end; // if (CurProvID <> -1) and not(K_cmssSkipProviderInfo in ASaveFlags) then

    if (CurLocID <> -1)                          and
       not(K_cmssSkipLocationInfo in ASaveFlags) and
       K_CMGAModeFlag then
    begin
      EDALocationCurStateToMemIni();
      Result := EDASaveOneAppMemIniContext( Ord(K_actLocIni), CurLocID, 0, 'Location|Save' );
      if Result <> K_edOK then
        goto LExit;
    end;

    LANDBConnection.CommitTrans;

    if not(K_cmssSkipExtIniInfo in ASaveFlags) then
      K_CMEDAMemIniToExtIniFiles();
//      EDAMemIniToExtIniFiles();

  // Save IniFile Needed to save Start Patient|Provider|Location
//    if K_CMStandaloneGUIMode then
//      K_SaveMemIniToFile(N_CurMemIni);

    N_Dump2Str('DB>> EDASaveContextsData fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDASaveContextsData ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASaveContextsData

//*********************************** TK_CMEDDBAccess.EDAGAGlobalToCurState ***
// Get GA Global Context to Current State
//
function TK_CMEDDBAccess.EDAGAGlobalToCurState : TK_CMEDResult;
begin
  Result := EDAOneAppContextToMemIni(Ord(K_actGlobIni), 0, 0, 'Global|Load');
  if Result <> K_edOK then Exit;
  EDAGlobalMemIniToCurState();
end; // end of TK_CMEDDBAccess.EDAGAGlobalToCurState

//******************************** TK_CMEDDBAccess.EDANotGAGlobalToCurState ***
// Get not GA Global Context to Current State (context separate loading)
//
function TK_CMEDDBAccess.EDANotGAGlobalToCurState : TK_CMEDResult;
begin
  Result := EDAOneAppContextToMemIni(Ord(K_actGlobIni2), 0, 0, 'Global2|Load');
  if Result <> K_edOK then Exit; //!!!Ura 22.06.20
  if K_CMVUIMode then //!!!Ura 22.06.20
  begin
    N_BoolToMemIni( 'CMS_Main', 'ScanDataPathOnClientPC', FALSE );
    N_BoolToMemIni( 'CMS_Main', 'ScanDataPathOnClientPCAuto', FALSE );
    N_StringToMemIni( 'CMS_Main', 'ScanDataPath', K_CMVUIWorkfolderRoot + K_CMVUICustomerID + '\CMS\Exchange\' );
    N_StringToMemIni( 'CMS_Main', 'ScanDataPathOld', '' );
    N_Dump2Str('ScanDataPath is substituted for: "' + N_MemIniToString( 'CMS_Main', 'ScanDataPath', '' ) + '"');
  end;
  EDAGlobal2MemIniToCurState();
end; // end of TK_CMEDDBAccess.EDANotGAGlobalToCurState

//********************************** TK_CMEDDBAccess.EDANotGAGlobalToMemIni ***
// Put not GA Global Context to MemIni  (save inside all contexts saving procedure)
//
// Saving context is set in all contexts saving procedure
//
function TK_CMEDDBAccess.EDANotGAGlobalToMemIni : TK_CMEDResult;
begin
  EDAGlobal2CurStateToMemIni();
  Result := EDASaveOneAppMemIniContext( Ord(K_actGlobIni2), 0,  0, 'Global2|Save' );
end; // end of TK_CMEDDBAccess.EDANotGAGlobalToMemIni

//********************************* TK_CMEDDBAccess.EDANotGAGlobalToMemIni1 ***
// Put not GA Global Context to MemIni (context separate saving)
//
function TK_CMEDDBAccess.EDANotGAGlobalToMemIni1 : TK_CMEDResult;
begin
  // Set saving context
  K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
  K_CMEDADFPLExec.DstIniFile := K_CMEDAMemIniFile;
  // Put not GA Global Context to MemIni
  Result := EDANotGAGlobalToMemIni();
end; // end of TK_CMEDDBAccess.EDANotGAGlobalToMemIni1

//*********************************** TK_CMEDDBAccess.EDALocationToCurState ***
// Put Location Context to CurState (context separate loading)
//
function TK_CMEDDBAccess.EDALocationToCurState: TK_CMEDResult;
begin
  Result := EDAOneAppContextToMemIni(Ord(K_actLocIni), CurLocID, 0, 'Location|Load');
  if Result = K_edOK then
    EDALocationMemIniToCurState();
end; // function TK_CMEDDBAccess.EDALocationToCurState

//************************************ TK_CMEDDBAccess.EDALocationToMemIni1 ***
// Put not GA Global Context to MemIni (context separate saving)
//
function TK_CMEDDBAccess.EDALocationToMemIni1: TK_CMEDResult;
begin
  // Set saving context
  K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
  K_CMEDADFPLExec.DstIniFile := K_CMEDAMemIniFile;
  // Put not GA Global Context to MemIni
  EDALocationCurStateToMemIni();
  Result := EDASaveOneAppMemIniContext( Ord(K_actLocIni), CurLocID, 0, 'Location|Save' );
end; // function TK_CMEDDBAccess.EDALocationToMemIni1


//************************************************* TK_CMEDDBAccess.EDAInit ***
// Init External Data Access Object when Application is Ready to Initialization
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAInit(): TK_CMEDResult;
var
  DSize,DSize1: Integer;
  PData, PData1: Pointer;
  UDRootInfo : TN_UDBase;
  ResCode : TK_CMEDResult;
  ContType, ContID : Integer;
  WStr, SSList : string;
//  SlidesCount : Integer;
  i : Integer;
  Ind, RNum : Integer;
  SaveStudySamlesToDB : Boolean;

  procedure PutStudySampleToDB( const AOpName : string );
  begin
    EDAPutBlobFieldValue( CurDSet2, CurDSet2.Fields[1], PData, DSize );
    N_Dump1Str( format( 'DB>> %s %s=%s', [AOpName,UDRootInfo.ObjName,UDRootInfo.ObjAliase] ) );
    SaveStudySamlesToDB := TRUE;
  end;

begin
  N_Dump2Str('DB>> EDAInit');
  //////////////////////////////////
  // Archive Init

  Result := EDAArchUDCompsInit();
  if Result <> K_edOK then
  begin
    Exit;
  end;

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
  begin
    N_Dump2Str('DB>> EDAInit >> EDACheckDBConnection fails');
    Exit;
  end;

  if (K_CMEDDBVersion > 36) and (K_CMSAppStartContext.CMASMode <> K_cmamDCMExe) then
  begin // Apply Ini Info

    N_Dump1Str('DB>> Check DB Init Info' );
    try
      with CurDSet2 do
      begin
        ExtDataErrorCode := K_eeDBSelect;
        Connection := LANDBConnection;
        // K_CMENDBGTFDBVersion  is needed to skip exception in future UpdateBatch();
        SQL.Text := 'select ' + K_CMENDBGTFInitInfo  + ',' + K_CMENDBGTFDBVersion  +
//        SQL.Text := 'select ' + K_CMENDBGTFInitInfo  +
          ' from ' +  K_CMENDBGlobAttrsTable;
        Filtered := false;
        Open;
        WStr := K_CMEDAGetDBStringValue( Fields[0] );
        if WStr <> '' then
        begin
        // Clear Init Info
          Edit;
          EDAPutStringFieldValue( Fields[0], '' );
          UpdateBatch();
        end;
        Close;

        if WStr <> '' then
        begin // InitInfo Exists - apply
          TmpStrings.Text :=  WStr;
          N_Dump1Str('DB>> Init Info Apply' );
          TmpStrings.Add( '' ); // for dump
          N_Dump1Strings( TmpStrings, 5 );
{ // 2020-01-08 remove "DB is Empty" check

          // Check if DB is Empty
          with CurDSet2 do
          begin
            Filtered := false;
            SQL.Text := 'select Count(*) from ' + K_CMENDBSlidesTable;
            Open;
            SlidesCount := FieldList.Fields[0].AsInteger;
            Close;
          end;

          if SlidesCount = 0 then
          begin // DB is Empty check File Storage Paths
}
            EDAClearSlidesCRFC();
            // Img Path
            WStr := TmpStrings.Values['ImgFilesFolder'];
            if WStr <> '' then
            begin
              SlidesCRFC.RootFolder := IncludeTrailingPathDelimiter( WStr );
              SlidesCRFC.RootFDA := TRUE;
              EDASetFilesPathInfo();
              N_Dump1Str('DB>> Init ImgFolder >> ' + WStr );
            end; // Img Path apply

            // Video Path
            WStr := TmpStrings.Values['VideoFilesFolder'];
            if WStr <> '' then
            begin
              SlidesCRFC.RootFolder := IncludeTrailingPathDelimiter( WStr );
              SlidesCRFC.RootFDA := TRUE;
              SlidesCRFC.MediaFCopy := TRUE;
              EDASetFilesPathInfo();
              N_Dump1Str('DB>> Init VideoFolder >> ' + WStr );
            end; // Video Path apply

            // Img3D Path
            WStr := TmpStrings.Values['Img3DFilesFolder'];
            if WStr <> '' then
            begin
              SlidesCRFC.RootFolder := IncludeTrailingPathDelimiter( WStr );
              SlidesCRFC.RootFDA := TRUE;
              SlidesCRFC.Img3DFCopy := TRUE;
              EDASetFilesPathInfo();
              N_Dump1Str('DB>> Init Img3DFolder >> ' + WStr );
            end; // Img3D Path apply
{ // 2020-01-08 remove "DB is Empty" check
          end
          else // DB is not Empty
            N_Dump1Str( format( 'DB>> Init Folders is skiped >> DB contains %d objects', [SlidesCount] ) );
}
          DSize := 0;
          WStr := UpperCase(TmpStrings.Values['ExchangeFolderMode']);
          // 'C'[LIENT]     - ExchangeFolder on Client PC
          // 'A'[UTOCLIENT] - ExchangeFolder on Client PC Auto detect
          if (WStr <> '') and ((WStr[1] = 'C') or (WStr[1] = 'A')) then
          begin
            K_CMScanDataPathOnClientPC := TRUE;
            N_BoolToMemIni( 'CMS_Main', 'ScanDataPathOnClientPC', TRUE );
            if WStr[1] = 'A' then
            begin
              K_CMScanDataPathOnClientPCAuto := TRUE;
              N_BoolToMemIni( 'CMS_Main', 'ScanDataPathOnClientPCAuto', TRUE );
            end;
            N_Dump1Str( 'DB>> Init ExchangeFolderMode >> C=T A=' + N_B2S(K_CMScanDataPathOnClientPCAuto) );
            DSize := 1;
          end; // ExchangeFolderMode apply

          if (WStr = '') or (WStr[1] <> 'A') then
          begin
            WStr := TmpStrings.Values['ExchangeFolder'];
            if WStr <> '' then
            begin
              K_CMScanDataPath := IncludeTrailingPathDelimiter( WStr );
              N_StringToMemIni( 'CMS_Main', 'ScanDataPath', K_CMScanDataPath );
              N_Dump1Str('DB>> Init ExchangeFolder >> ' + WStr );
              DSize := 1;
            end;
          end; // ExchangeFolder apply

          if DSize = 1 then
          begin // Save Not Global Data
            K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
            K_CMEDADFPLExec.DstIniFile := K_CMEDAMemIniFile;
            EDASaveOneAppMemIniContext( Ord(K_actGlobIni2), 0,  0, 'Global2|Save' );
          end;

        end; // InitInfo Exists - apply
      end; // with CurDSet1 do
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorString := 'EDAInit >> Init Info Apply >> ' + E.Message;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end;
  end; // if (K_CMEDDBVersion > 36) and (K_CMSAppStartContext.CMASMode <> K_cmamDCMExe) then

  if K_CMCheckNewVersionProcessing() then
  begin
  /////////////////////////////////////////////////
  // Process new CMS Version 1-st run Data Patches
  //
    CurDSet1.Connection := LANDBConnection; // Prepare CurDSet1 for saving
    if N_CMSVersion > K_CMSLastVersion then
    begin
      if K_CMSLastVersion = '03.059.00'   then
      begin // Run Clear Flip Flags in Duerr Profiles Patch
        try
          N_Dump1Str('DB>> Duerr Profiles Processing Start' );
          with CurDSet2 do
          begin
            ExtDataErrorCode := K_eeDBSelect;
            Connection := LANDBConnection;
            SQL.Text := 'select ' + K_CMENDBCTFBinData    + ',' +
                                    K_CMENDBCTFContID     + ',' +
                                    K_CMENDBCTFContTypeID +
              ' from ' + K_CMENDBContextsTable +
              ' where ' + K_CMENDBCTFContTypeID + '=' + IntToStr(Ord(K_actGInstUD))  +
                 ' or ' + K_CMENDBCTFContTypeID + '=' + IntToStr(Ord(K_actProvUD))   +
                 ' or ' + K_CMENDBCTFContTypeID + '=' + IntToStr(Ord(K_actGlobUD))   +
                 ' or ' + K_CMENDBCTFContTypeID + '=' + IntToStr(Ord(K_actServerUD)) +
                 ' or ' + K_CMENDBCTFContTypeID + '=' + IntToStr(Ord(K_actLocUD))    +
              ' order by ' + K_CMENDBCTFContTypeID + ' asc';

            Filtered := false;
            Open;
            while not EOF do
            begin
              DSize := 0;
              ResCode := EDAGetBlobFieldValue(CurDSet2, Fields[0], PData, DSize);
              if (DSize > 0) and (ResCode = K_edOK) then
              begin
                EDAAnsiTextToString(PData, DSize);
                K_SerialTextBuf.LoadFromText(PChar(PData));
            //N_InitWAR();
            //N_S := PChar(PData);
            //K_GetFormTextEdit.EditText(N_S);
                UDRootInfo := TN_UDBase.Create;
                K_LoadTreeFromText0(UDRootInfo, K_SerialTextBuf, TRUE);
                ContID := Fields[1].AsInteger;
                ContType := Fields[2].AsInteger;

                N_Dump1Str( format( 'DB>> Profiles from context type=%d id=%d',
                                    [ContType,ContID] ) );
                if K_CMClearFlipFlagsInOneProfilesSet( UDRootInfo ) then
                // Save Context is needed
                  EDASaveOneAppContext(CurDSet1, ContType, ContID, 0, UDRootInfo);
                UDRootInfo.UDDelete();
              end;
              Next();
            end; // while not EOF do
            Close;
          end; // with CurDSet1 do
          N_Dump1Str('DB>> Duerr Profiles Processing fin' );
        except
          on E: Exception do
          begin
            Result := K_edExDataError;
            ExtDataErrorString := 'EDAInit >> Duerr Profiles Processing >> ' + E.Message;
            EDAShowErrMessage(TRUE);
            Exit;
          end;
        end;

      end; // if K_CMSLastVersion = '03.059.00' then

      if (K_CMEDDBVersion >= 39) and (K_CMSAppStartContext.CMASMode <> K_cmamDCMExe) then
      begin // Init Study Templates Table
        try
          N_Dump1Str('DB>> Study Templates Init Start' );
          with CurDSet2 do
          begin
            ExtDataErrorCode := K_eeDBSelect;
            Connection := LANDBConnection;
            SQL.Text := 'select ' + K_CMENDASTempID    + ',' +
                                    K_CMENDASTempDescr +
              ' from ' + K_CMENDBAllStudyTemplatesTable ;

            Filtered := false;
            Open;
            SaveStudySamlesToDB := FALSE;
            if RecordCount = 0 then
            begin // StudyTemplates Table is empty - load it
              for i := 0 to ArchStudySamplesInitLibRoot.DirHigh() do
              begin
                // Get Template Description
                UDRootInfo := ArchStudySamplesInitLibRoot.DirChild(i);
                K_CMStudyTemplateUnloadDescr( UDRootInfo, TmpStrings );
                DSize := EDAStringsToAnsiText( TmpStrings, PData );

                // Add new Template Record
                Insert;
                FieldList.Fields[0].AsString := UDRootInfo.ObjName;
                PutStudySampleToDB( 'Add' );
              end; // for i := 0 to ArchStudySamplesLibRoot.DirHigh() do
            end    // if RecordCount = 0 then
            else
            begin // StudyTemplates Table is not empty - update it
              SSList := '';
              for i := 0 to ArchStudySamplesInitLibRoot.DirHigh() do
              begin
                // Get Template Description
                UDRootInfo := ArchStudySamplesInitLibRoot.DirChild(i);
                K_CMStudyTemplateUnloadDescr( UDRootInfo, TmpStrings );
                DSize := EDAStringsToAnsiText( TmpStrings, PData );

                Filter := K_CMENDASTempID + ' = ' + UDRootInfo.ObjName;
                Filtered := TRUE;
                if RecordCount = 0 then
                begin
                // Add new Template Record
                  Insert;
                  FieldList.Fields[0].AsString := UDRootInfo.ObjName;
                  PutStudySampleToDB( 'Add' );
                  SSList := SSList + ',' + UDRootInfo.ObjName;
                end   // if RecordCount = 0 then
                else
                begin // if RecordCount <> 0 then
//                  DSize := 0; // Debug
                  ResCode := EDAGetBlobFieldValue(CurDSet2, Fields[1], PData1, DSize1);
                  if (ResCode = K_edOK) and ((DSize <> DSize1) or not CompareMem(PData1,PData,DSize)) then
                  begin
                    Edit;
                    PutStudySampleToDB( 'Update' );
                  end;
                end;  // if RecordCount <> 0 then

                Filtered := FALSE;
              end; // for i := 0 to ArchStudySamplesLibRoot.DirHigh() do


              if SSList <> '' then
              begin // Set Visibility for new StudyTemplates if needed
                WStr := N_MemIniToString( 'CMS_Main', 'StudySamplesList', '' );
                if WStr <> '' then
                  N_StringToMemIni( 'CMS_Main', 'StudySamplesList', WStr + SSList );
              end;

            end; // StudyTemplates Table is not empty - update it
            if SaveStudySamlesToDB then
              UpdateBatch();
            Close;
          end; // with CurDSet2 do
          N_Dump1Str('DB>> Study Templates Init Fin' );
        except
          on E: Exception do
          begin
            Result := K_edExDataError;
            ExtDataErrorString := 'EDAInit >> Study Templates Init >> ' + E.Message;
            EDAShowErrMessage(TRUE);
            Exit;
          end;
        end;

{!!! Remove 2018-08-01: wrong code and not needed because was correctly done in cms_v39_v40.sql
//        if (K_CMEDDBVersion = 40) and K_CMEDAMSSQL then
        if K_CMEDDBVersion >= 40 then
        begin // Needed to start with not empty MSSQL DB
          with CurDSet2 do
          begin
            ExtDataErrorCode := K_eeDBSelect;
            Connection := LANDBConnection;
            SQL.Text := 'select max(' + K_CMENDBSTFSlideID + ')' +
                                    ' from ' + K_CMENDBSlidesTable;
            Filtered := FALSE;
            Open();
            WStr := FieldList.Fields[0].AsString;
            Close;
          end;

          if WStr <> '' then
            with CurSQLCommand1 do
            begin
              ExtDataErrorCode := K_eeDBUpdate;
              Connection := LANDBConnection;
              CommandText := 'ALTER SEQUENCE dba.NextSlideID RESTART WITH ' + WStr;
              Execute;
            end;
        end; // if (K_CMEDDBVersion = 40) and K_CMEDAMSSQL the
}
      end; // if (K_CMEDDBVersion >= 39) and (K_CMSAppStartContext.CMASMode <> K_cmamDCMExe) then

      if (K_CMEDDBVersion >= 46) and (K_CMSLastVersion >= '04.024.00') and (K_CMSLastVersion < '04.037.00') then
      begin
        try
          N_Dump1Str( 'DB>> Set AllSlides.DCMSerID start' );
          with CurDSet2 do
          begin
            ExtDataErrorCode := K_eeDBSelect;
            Connection := LANDBConnection;
            while TRUE do
            begin
              SQL.Text := 'select top 100 ' +
                  K_CMENDBSTFSlideID + ',' + K_CMENDBSTFSlideDCMSerID  + ',' +
                  K_CMENDBSTFSlideSysInfo +
                ' from ' + K_CMENDBSlidesTable +
                ' where ' + K_CMENDBSTFSlideDTCr + ' > ' + EDADBDateTimeToSQL( K_StrToDateTime('2020-05-21'), 'yyyy-mm-dd 00:00:00.000' )  +
                   ' and ' + K_CMENDBSTFSlideDTCr + ' < ' + EDADBDateTimeToSQL( Now() ) +
                   ' and ' + K_CMENDBSTFSlideSysInfo + ' like ''%DCMSerID=%''' +
                   ' and ' + K_CMENDBSTFSlideDCMSerID + ' is null' +
                   ' order by ' + K_CMENDBSTFSlideID;
              Filtered := false;
              Open;
              RNum := RecordCount;
              if RNum > 0 then
              begin
                while not EOF do
                begin
                  WStr := EDAGetStringFieldValue(FieldList[2]);
                  Ind := Pos( 'DCMSerID=', WStr );
                  if Ind > 0 then
                  begin
                    DSize := N_StrPos( ' ', WStr, Ind + 9 );
                    if DSize = 0 then
                      DSize := Length(WStr);
                    SSList := Copy( WStr, Ind + 9, DSize - Ind - 9 );
                    Edit;
                    FieldList[1].AsInteger := StrToInt(SSList);
                    for i := Ind to DSize - 1 do WStr[i] := ' ';
                    EDAPutStringFieldValue( FieldList[2], WStr )
                  end
                  else
                    N_Dump1Str( format( 'ObjID %d DCMSerID= was not found in "%s"',
                                [FieldList[0].AsInteger, WStr] ) );
                  Next();
                end; // while not EOF do
                UpdateBatch;
              end; // if RecordCount > 0 then
              Close;
              if RNum < 100 then Break;
            end; // while TRUE do
          end; // with CurDSet2 do
          N_Dump1Str( 'DB>> Set AllSlides.DCMSerID fin' );
        except
          on E: Exception do
          begin
            Result := K_edExDataError;
            ExtDataErrorString := 'EDAInit >> Duerr Profiles Processing >> ' + E.Message;
            EDAShowErrMessage(TRUE);
            Exit;
          end;
        end;

      end; // if (K_CMEDDBVersion >= 46) and (K_CMSLastVersion >= '04.024.00') and (K_CMSLastVersion < '04.037.00') then

      // Other Patches ...
    end; // if N_CMSVersion > K_CMSLastVersion then

  //
  // Process new CMS Version 1-st run Data Patches
  /////////////////////////////////////////////////

    // Save New Last Version info
    K_CMSLastVersion := N_CMSVersion;
    N_StringToMemIni('CMS_Main', 'LastRunVersion', N_CMSVersion );
    K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
    K_CMEDADFPLExec.DstIniFile := K_CMEDAMemIniFile;
    EDASaveOneAppMemIniContext( Ord(K_actGlobIni), 0,  0, 'Global|Save' );
    N_Dump1Str( '!!!New Version processing fin' );
  end; // if K_CMCheckNewVersionProcessing() then

  //////////////////////////////////
  // Instance Ini Context

  Result := EDAOneAppContextToMemIni( Ord(K_actGInstIni), ClientAppGlobID, 0,
                                      'Instance|Load' );
  if Result <> K_edOK then
    Exit;

  //////////////////////////////////
  // Instance Binary Context

  UDRootInstanceInfo := TN_UDBase.Create;
  Result := EDAGetOneAppContext( IntToStr(Ord(K_actGInstUD)),
                                 IntToStr(ClientAppGlobID), '0', PData, DSize );
// !!! Special code to test Karpenkov DB
//  Result := EDAGetOneAppContext( IntToStr(Ord(K_actGInstUD)),
//                                 '1', PData, DSize );
  if (DSize > 0) and (Result = K_edOK) then
  begin
    // K_SerialTextBuf.LoadFromText( PChar(@BlobBuf[0]) );

{$IF SizeOf(Char) = 2}
//////////////////////////////////////////////////////////////
// Special code to correct wrong DeviceProfile field name in SDT format
//
    AnsiTextBuf := AnsiStrings.AnsiReplaceStr( PAnsiChar(PData), 'CMÂDProductName', 'CMDPProductName' );
    PData := @AnsiTextBuf[1];
//
// end of special code to correct wrong DeviceProfile field name in SDT format
//////////////////////////////////////////////////////////////
{$IFEND}

    EDAAnsiTextToString(PData, DSize);

    K_SerialTextBuf.LoadFromText(PChar(PData));
//K_GetFormTextEdit.EditStrings( K_SerialTextBuf.TextStrings );
//N_InitWAR();
//N_S := PChar(PData);
//K_GetFormTextEdit.EditText(N_S);
    K_LoadTreeFromText0(UDRootInstanceInfo, K_SerialTextBuf, TRUE);
  end; // if (DSize > 0) and (Result = K_edOK) then

  //////////////////////////////////
  // User Binary Context

  UDRootProviderInfo := TN_UDBase.Create;

  //////////////////////////////////
  // Global Binary Context
  UDRootGlobalInfo := TN_UDBase.Create;
  Result := EDAGetOneAppContext( IntToStr(Ord(K_actGlobUD)),
                                 '0', '0', PData, DSize );
  if (DSize > 0) and (Result = K_edOK) then
  begin
    EDAAnsiTextToString(PData, DSize);

    K_SerialTextBuf.LoadFromText(PChar(PData));
//N_InitWAR();
//N_S := PChar(PData);
//K_GetFormTextEdit.EditText(N_S);
    K_LoadTreeFromText0(UDRootGlobalInfo, K_SerialTextBuf, TRUE);
  end;

  //////////////////////////////////
  // Server Binary Context
  UDRootServerInfo := TN_UDBase.Create;
  Result := EDAGetOneAppContext( IntToStr(Ord(K_actServerUD)),
                                 IntToStr(CurServID), '0', PData, DSize );
  if (DSize > 0) and (Result = K_edOK) then
  begin
    EDAAnsiTextToString(PData, DSize);

    K_SerialTextBuf.LoadFromText(PChar(PData));

//N_InitWAR();
//N_S := PChar(PData);
//K_GetFormTextEdit.EditText(N_S);
    K_LoadTreeFromText0(UDRootServerInfo, K_SerialTextBuf, TRUE);
  end;

  Result := EDAAppUDTreeInit();

  if Result = K_edOK then
  begin
    Result := EDAGlobUDTreeInit();
  end;

  if Result = K_edOK then
  begin
    Result := EDAServUDTreeInit();
  end;

  EDAStudyTemplatesPrepare();
//TestMemoryDestruction20180829();

  N_Dump2Str('DB>> EDAInit fin');

end; // end of TK_CMEDDBAccess.EDAInit

//********************************************* TK_CMEDAccess.EDASetInstanceState ***
// Set CMS Instance not active state
//
//     Parameters
// ASetActive - if TRUE set CMS Instance Active state, else not Active state
// Result - Returns operation resulting code
//
// Check Media Object File Existance and Consistancy
//
function TK_CMEDDBAccess.EDASetInstanceState( ASetActive : Boolean; AStateFlag : Integer ) : TK_CMEDResult;
var
  SSelfAppRTID: string;
  SQLText : string;

begin
  Result := K_edOK;
  SSelfAppRTID := IntToStr(AppRTID);

{
  if not ASetActive then
    SQLText := ' | ' + IntToStr( K_CMEDAInstanceNActiveStateFlag )
  else
    SQLText := ' & ' + IntToStr( 255 xor K_CMEDAInstanceNActiveStateFlag );
}
  if ASetActive then
    SQLText := ' | ' + IntToStr( AStateFlag )
  else
    SQLText := ' & ' + IntToStr( 255 xor AStateFlag );

  N_Dump2Str('DB>> EDASetInstanceState ActRTID=' + SSelfAppRTID + SQLText );
  try
    with CurSQLCommand1 do
    begin
      CommandText := 'UPDATE ' + K_CMENDBAAInstsTable + ' SET ' +
        K_CMENDBAAInstsTFActFlags + ' = ' +  K_CMENDBAAInstsTFActFlags + SQLText +
        ' WHERE ' +  K_CMENDBAAInstsTFActRTID + '=' + SSelfAppRTID + ';';
      Execute;
    end
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASetInstanceState ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASetInstanceState

//********************************************* TK_CMEDDBAccess.EDAServUDTreeInit ***
// Init Server binary context
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAServUDTreeInit(): TK_CMEDResult;
begin
  Result := K_edOK;
  if UDRootServerInfo = nil then
  begin
    Result := K_edExDataError;
    ExtDataErrorString := 'ServerInfo Root object is absent';
    EDAShowErrMessage(TRUE);
    Exit;
  end;

  if (ProfilesSaveMode <> K_cmdpGAServer) and
     (ProfilesSaveMode <> K_cmdpServer) then Exit;
  K_UDCursorGet('DI:').SetRoot(UDRootServerInfo);
  Result := EDADevProfilesUDTreeInit();

end; // end of TK_CMEDDBAccess.EDAServUDTreeInit

//********************************************* TK_CMEDDBAccess.EDALocUDTreeInit ***
// Init Location binary context
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDALocUDTreeInit(): TK_CMEDResult;
begin
  Result := K_edOK;
  if UDRootLocationInfo = nil then
  begin
    Result := K_edExDataError;
    ExtDataErrorString := 'LocationInfo Root object is absent';
    EDAShowErrMessage(TRUE);
    Exit;
  end;

  if ProfilesSaveMode <> K_cmdpGALocation then Exit;
  K_UDCursorGet('DI:').SetRoot(UDRootLocationInfo);
  Result := EDADevProfilesUDTreeInit();

end; // end of TK_CMEDDBAccess.EDALocUDTreeInit

//********************************************* TK_CMEDDBAccess.EDAGetSlideSysFieldsData ***
// Get Slide Fields List string for select statement
//
//     Parameters
// ACtrlFlags - flags to control fields list
// Result - Returns string with fields list for select statement
//
function TK_CMEDDBAccess.EDAGetSlideSelectFieldsStr(
                            ACtrlFlags : TK_CMEDASelectFieldsFlags ) : string;
var
  FPref : string;
  FInd  : Integer;
  SlideIDandPatIDField : string;
  SlideDiagnField : string;
begin

  Result := '';
  FPref := '';
  if K_sffAddFieldsPrefix in ACtrlFlags then
    FPref := 'S.';

  if not (K_sffAddStudyOnlyFields in ACtrlFlags) then
  begin
    FInd  := 19;
    if K_CMEDDBVersion >= 10 then
    begin
  {19}  Result := ',' + FPref + K_CMENDBSTFSlideFlags;
      K_CMENDBSTFSlideFlagsInd := FInd;
      Inc(Find)
    end;

    if K_CMEDDBVersion >= 41 then
    begin
      Result := Result + ',' +
  {20}    FPref + K_CMENDBSTFSlideDTArch;
      K_CMENDBSTFSlideDTArchInd := FInd;
      Inc(Find);
      if K_CMEDDBVersion >= 44 then
      begin
        Result := Result + ',' +
  {21}    FPref + K_CMENDBSTFSlideDFlags;
        K_CMENDBSTFSlideDFlagsInd := FInd;
        Inc(Find);
      end; // if K_CMEDDBVersion >= 44 then
{}
    end // if K_CMEDDBVersion >= 41 then
    else
    if K_CMEnterpriseModeFlag then
    begin
      Result := Result + ',' +
  {20}    FPref + K_CMENDBSTFSlideLocIDHost;
      K_CMENDBSTFSlideLocIDHostInd := FInd;
      Inc(Find)
{}
    end;

    if K_CMEDDBVersion >= 12 then
    begin
  {21,22} Result := Result + ',' + FPref + K_CMENDBSTFSlideCurFSize + ',' + FPref + K_CMENDBSTFSlideSrcFSize;
      K_CMENDBSTFSlideCurFSizeInd := FInd;
      Inc(Find);
      K_CMENDBSTFSlideSrcFSizeInd := FInd;
      Inc(Find);
    end;


    if K_CMEDDBVersion >= 16 then
    begin
  {23} Result := Result + ',' + FPref + K_CMENDBSTFSlideVideoFSize;
      K_CMENDBSTFSlideVideoFSizeInd := FInd;
      Inc(Find);
    end;

    if K_CMEDDBVersion >= 24 then
    begin
  {24,25} Result := Result + ',' + FPref + K_CMENDBSTFSlideStudyID + ',' + FPref + K_CMENDBSTFSlideStudyItem;
      K_CMENDBSTFSlideStudyIDInd   := FInd;
      K_CMENDBSTFSlideStudyItemInd := FInd + 1;
      if K_CMEDDBVersion >= 39 then
      begin
  {26}  Result := Result + ',' + FPref + K_CMENDBSTFSlideStudyItemPos;
        K_CMENDBSTFSlideStudyItemPosInd := FInd + 2;

        if K_CMEDDBVersion >= 46 then
        begin
          Result := Result + ',' +
  {27}    FPref + K_CMENDBSTFSlideDCMSerID;
          K_CMENDBSTFSlideDCMSerIDInd := FInd + 3;
        end; // if K_CMEDDBVersion >= 46 then
      end;
    end;

    if (K_sffAddThumbField in ACtrlFlags) or
       (K_sffAllFieldsForCopy  in ACtrlFlags) then
      Result := Result + ',' + FPref + K_CMENDBSTFSlideThumbnail;
    if (K_sffAddMapRootField in ACtrlFlags) or
       (K_sffAllFieldsForCopy  in ACtrlFlags) then
      Result := Result + ',' + FPref + K_CMENDBSTFSlideMapRoot;

    if K_sffAllFieldsForCopy  in ACtrlFlags then
      Result := Result + ',' + FPref + K_CMENDBSTFSlideSFlags;

    K_CMENDBSTFSlideIDInd        :=  0;
    K_CMENDBSTFPatIDInd          :=  1;
    K_CMENDBSTFSlideDTTakenInd   :=  2;
    K_CMENDBSTFSlideDTCrInd      :=  3;
    K_CMENDBSTFSlideDTImgInd     :=  4;
    K_CMENDBSTFSlideDTMapRootInd :=  5;
    K_CMENDBSTFSlideDTPropInd    :=  6;
    K_CMENDBSTFSlideMTypeIDInd   :=  7;
    K_CMENDBSTFSlideProvIDCrInd  :=  8;
    K_CMENDBSTFSlideProvIDModInd :=  9;
    K_CMENDBSTFSlideLocIDCrInd   := 10;
    K_CMENDBSTFSlideLocIDModInd  := 11;
    K_CMENDBSTFSlideCompCrInd    := 12;
    K_CMENDBSTFSlideCompModInd   := 13;
    K_CMENDBSTFSlideTeethRightInd:= 14;
    K_CMENDBSTFSlideTeethLeftInd := 15;
    K_CMENDBSTFSlideSrcDescrInd  := 16;
    K_CMENDBSTFSlideDiagnosesInd := 17;
    K_CMENDBSTFSlideSysInfoInd   := 18;

    SlideIDandPatIDField := FPref + K_CMENDBSTFSlideID + ',' + FPref + K_CMENDBSTFPatID + ',';
    SlideDiagnField := FPref + K_CMENDBSTFSlideDiagnoses;
    if K_sffAllFieldsForCopy  in ACtrlFlags then
    begin
      SlideIDandPatIDField := FPref + K_CMENDBSTFPatID + ',';
//      SlideIDandPatIDField := '';
      if K_CMEDDBVersion < 40 then
        SlideDiagnField := 'STRING(' + K_CMENDBSTFSlideDiagnoses + ',''<'',STR('+ K_CMENDBSTFSlideID + ',8),''>'')' +
                   ' as ' + FPref + K_CMENDBSTFSlideDiagnoses;
    end;

    Result :=
  { 0, 1} SlideIDandPatIDField +
  { 2, 3} FPref + K_CMENDBSTFSlideDTTaken    + ',' + FPref + K_CMENDBSTFSlideDTCr + ',' +
  { 4, 5} FPref + K_CMENDBSTFSlideDTImg      + ',' + FPref + K_CMENDBSTFSlideDTMapRoot + ',' +
  { 6, 7} FPref + K_CMENDBSTFSlideDTProp     + ',' + FPref + K_CMENDBMTFMTypeID + ',' +
  { 8, 9} FPref + K_CMENDBSTFSlideProvIDCr   + ',' + FPref + K_CMENDBSTFSlideProvIDMod + ',' +
  {10,11} FPref + K_CMENDBSTFSlideLocIDCr    + ',' + FPref + K_CMENDBSTFSlideLocIDMod + ',' +
  {12,13} FPref + K_CMENDBSTFSlideCompCr     + ',' + FPref + K_CMENDBSTFSlideCompMod + ',' +
  {14,15} FPref + K_CMENDBSTFSlideTeethRight + ',' + FPref + K_CMENDBSTFSlideTeethLeft + ',' +
  {16,17} FPref + K_CMENDBSTFSlideSrcDescr   + ',' + SlideDiagnField + ',' +
  {18}    FPref + K_CMENDBSTFSlideSysInfo    +
              Result;

  end   // if not (K_sffAddStudyOnlyFields in ACtrlFlags) then
  else
  begin // if K_sffAddStudyOnlyFields in ACtrlFlags then
  // Study Filelds
    K_CMENDBSTFSlideIDInd        :=  0;
    K_CMENDBSTFPatIDInd          :=  1;
    K_CMENDBSTFSlideDTTakenInd   :=  2;
    K_CMENDBSTFSlideDTCrInd      :=  3;
    K_CMENDBSTFSlideDTMapRootInd :=  4;
    K_CMENDBSTFSlideDTPropInd    :=  5;
    K_CMENDBSTFSlideMTypeIDInd   :=  6;
    K_CMENDBSTFSlideProvIDCrInd  :=  7;
    K_CMENDBSTFSlideProvIDModInd :=  8;
    K_CMENDBSTFSlideLocIDCrInd   :=  9;
    K_CMENDBSTFSlideLocIDModInd  := 10;
    K_CMENDBSTFSlideCompCrInd    := 11;
    K_CMENDBSTFSlideCompModInd   := 12;
    K_CMENDBSTFSlideSrcDescrInd  := 13;
    K_CMENDBSTFSlideDiagnosesInd := 14;
    K_CMENDBSTFSlideStudyIDInd   := 15;
    K_CMENDBSTFSlideStudyItemInd := 16;
    K_CMENDBSTFSlideFlagsInd     := 17;
    if K_CMEDDBVersion >= 39 then
      K_CMENDBSTFSlideStudyItemPosInd := 18;
    Result :=
  { 0, 1} FPref + K_CMENDBSTFSlideID         + ',' + FPref + K_CMENDBSTFPatID + ',' +
  { 2, 3} FPref + K_CMENDBSTFSlideDTTaken    + ',' + FPref + K_CMENDBSTFSlideDTCr + ',' +
  { 4 }   FPref + K_CMENDBSTFSlideDTMapRoot  + ',' +
  { 5, 6} FPref + K_CMENDBSTFSlideDTProp     + ',' + FPref + K_CMENDBMTFMTypeID + ',' +
  { 7, 8} FPref + K_CMENDBSTFSlideProvIDCr   + ',' + FPref + K_CMENDBSTFSlideProvIDMod + ',' +
  {09,10} FPref + K_CMENDBSTFSlideLocIDCr    + ',' + FPref + K_CMENDBSTFSlideLocIDMod + ',' +
  {11,12} FPref + K_CMENDBSTFSlideCompCr     + ',' + FPref + K_CMENDBSTFSlideCompMod + ',' +
  {13,14} FPref + K_CMENDBSTFSlideSrcDescr   + ',' + FPref + K_CMENDBSTFSlideDiagnoses + ',' +
  {15,16} FPref + K_CMENDBSTFSlideStudyID    + ',' + FPref + K_CMENDBSTFSlideStudyItem + ',' +
  {17}    FPref + K_CMENDBSTFSlideFlags;
    if K_CMEDDBVersion >= 39 then
      Result := Result + ',' + {18} FPref + K_CMENDBSTFSlideStudyItemPos;

    if K_sffAddThumbField in ACtrlFlags then
      Result := Result + ',' + FPref + K_CMENDBSTFSlideThumbnail;
  end; // if K_sffAddStudyOnlyFields in ACtrlFlags then
end; // end of TK_CMEDDBAccess.EDAGetSlideSelectFieldsStr

//********************************************* TK_CMEDDBAccess.EDAGetSlideSelectFromStr ***
// Get Slide FROM clause string for select statement
//
//     Parameters
// Result - Returns string with FROM clause string for select statement
//
function TK_CMEDDBAccess.EDAGetSlideSelectFromStr( ) : string;
begin
  Result := K_CMENDBSlidesTable;
//  if K_CMEnterpriseModeFlag then
//    Result := Result + ',' +
//              K_CMENDBLocFilesInfoTable;
end; // end of TK_CMEDDBAccess.EDAGetSlideSelectFromStr
{
//********************************************* TK_CMEDDBAccess.EDAGetSlideSelectWhereStr ***
// Get Slide WHERE clause string for select statement
//
//     Parameters
// ACtrlFlags - flags to control WHERE clause
// AFieldPref - field name prefix
// Result - Returns string with WHERE clause string for select statement
//
function TK_CMEDDBAccess.EDAGetSlideSelectWhereStr( ACtrlFlags : TK_CMEDASelectWhereFlags;
                                                    AFieldPref : string = '' ) : string;
begin
  Result := '';
  if K_CMEDDBVersion < 10 then Exit;
  if ACtrlFlags  = K_swfSkipFlagsCond then Exit;
  if ACtrlFlags = K_swfSkipAllDel then
    Result := ' and (' + AFieldPref + K_CMENDBSTFSlideFlags + '=0' + ' or ' + AFieldPref + K_CMENDBSTFSlideFlags + ' IS NULL)'
  else if ACtrlFlags = K_swfOnlyMarkedAsDel then
    Result := ' and ' + AFieldPref + K_CMENDBSTFSlideFlags + '= 1'
  else if ACtrlFlags = K_swfSkipDBDeleting then
    Result := ' and (' + AFieldPref + K_CMENDBSTFSlideFlags + '<> 2' + ' or ' + AFieldPref + K_CMENDBSTFSlideFlags + ' IS NULL)'
  else if ACtrlFlags = K_swfOnlyDBDeleting then
    Result := ' and ' + AFieldPref + K_CMENDBSTFSlideFlags + '= 2'

//  if K_CMEnterpriseModeFlag then
//    Result := ' and ' + K_CMENDBLFILocID + '=' + IntToStr(CurLocID) +
//              ' and ' + K_CMENDBLFILocSlideID + '=' + K_CMENDBSTFSlideID;
end; // end of TK_CMEDDBAccess.EDAGetSlideSelectWhereStr
}
//********************************************* TK_CMEDDBAccess.EDACheckSlideMedia ***
// Check Slide Media Object
//
//     Parameters
// ASlide - Slide to check
// Result - Returns operation resulting code
//
// Check Media Object File Existance and Consistancy
//
function TK_CMEDDBAccess.EDACheckSlideMedia( ASlide: TN_UDCMSlide; ASkipShowDlg : Boolean = FALSE ): TK_CMEDResult;
var
  WMes, FNAme : string;
  LoadMapRootError : Boolean;

label LExit;

begin
  Result := K_edOK;
  if TN_UDCMBSlide(ASlide) is TN_UDCMStudy then Exit;

  // Check Media File Existance - needed for proper warninig
  if ASlide.DirChild(K_CMSlideIndMapRoot) = nil then
  begin // Check Media File for not loaded slides
    with ASlide do
      FName := GetCurImgFileName( GetFilesPathSegm() );
    if EDAPathOrFileExists( SlidesImgRootFolder + FName, SlidesImgRootFDA, False ) <> K_edOK then
    begin
      WMes := format(
            K_CML1Form.LLLCheckVideoFile1.Caption,
  //          'The media object file "%s" is missing'#13#10 +
  //          'in the folder "%s"'#13#10 +
  //          'Please check your folder name and try again.',
                   [FName, SlidesImgRootFolder] );
       goto LExit;
    end; // if EDAPathOrFileExists <> K_edOK
  end; // if ASlide.DirChild(K_CMSlideIndMapRoot) = nil then

  LoadMapRootError := ASlide.GetMapRoot() = nil;

  if not LoadMapRootError then Exit;

  WMes := format(
          K_CML1Form.LLLCheckVideoFile2.Caption,
//        'The media object ID %s is corrupted and cannot be open. The corrupted file name is'#13#10+
//        '"%s"'#13#10 +
//        'Please check the file system on your Server PC.',
                [K_CMSlideGetFileIDPathSegm( ASlide.ObjName ),SlidesImgRootFolder + FName] );
LExit:
  if ASkipShowDlg then
    N_Dump1Str( WMes )
  else
    K_CMShowMessageDlg( WMes, mtError );
  Result := K_edFails;
end; // end of TK_CMEDDBAccess.EDACheckSlideMedia

//********************************************* TK_CMEDDBAccess.EDARemovePathFolders1 ***
// Remove Folders by given File Path
//
//     Parameters
// AFName - File Path at Removing Folder
// APathBase - Base Path to break removing folders loop
// ADAFlag - Direct Access Flag
// Result - Returns operation resulting code
//
//
function TK_CMEDDBAccess.EDARemovePathFolders1(AFName: string;
  const APathBase: string; ADAFlag: Boolean): TK_CMEDResult;
begin
  Result := K_edOK;
  try
    with CurBlobDSet do
    begin
      ExtDataErrorCode := K_eeFilesPocessing;
      Connection := LANDBConnection;
      Filtered := false;
      while TRUE do
      begin
        // Delete File Folders Loop
        AFName := ExtractFilePath(AFName);
        if AFName = APathBase then
          break;
        AFName := ExcludeTrailingPathDelimiter(AFName);
        N_Dump2Str('Remove Folder "' + AFName + '"');
        if ADAFlag then
        begin
          if not RemoveDir(AFName) then
            break; // Folder Remove Error
        end
        else
        begin
          SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' +
            Chr($0A) + 'set @ls_source = ' +
              QuotedStr(AnsiReplaceText(AFName, '\', '\\')) + ';' + Chr($0A) +
            'select sf_folder_delete(@ls_source);' + Chr($0A) + 'end';

          // SQL.Text := 'select sf_folder_delete( ''' + AnsiReplaceText( AFName, '\', '\\' ) + ''' )';
          Open;
          if FieldList.Fields[0].AsInteger <> 0 then
            break; // Folder Remove Error
          Close;
        end;
      end;
      Close;
    end;
    N_Dump2Str('Remove Folder fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDARemovePathFolders1 ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDARemovePathFolders1

//********************************************* TK_CMEDDBAccess.EDADelSlideImgFiles ***
// Delete Slide Image Files and Folders before Slide Deletion
//
//     Parameters
// ASlide - Slide
// Result - Returns operation resulting code
//
//
function TK_CMEDDBAccess.EDADelSlideImgFiles(ASlide: TN_UDCMBSlide)
  : TK_CMEDResult;
var
  ImgFPath: string;
  ImgFPath0: string;
  FName : string;
begin
  // N_Dump2Str( 'DB>> EDADelSlideImgFiles ActRTID=' + IntToStr(AppRTID) );
  N_Dump1Str(format('DB>> EDADelSlideImgFiles SID=%s ActRTID=%d',
      [ASlide.ObjName, AppRTID]));
  Result := K_edOK;
  ImgFPath0 := EDAGetSlideImgPath(ASlide);
  if SlidesImgRootFDA then
  begin
    if ASlide is TN_UDCMStudy then
      K_DeleteFile( TN_UDCMStudy(ASlide).GetFileName(ImgFPath0) )
    else
    begin
      FName := TN_UDCMSlide(ASlide).GetImgFilesNamePat('');
      FName[1] := '?';
      FName[Length(FName)] := '?';
      K_DeleteFolderFiles( ImgFPath0, FName, [] );
//      K_DeleteFolderFiles( ImgFPath0, TN_UDCMSlide(ASlide).GetImgFilesNamePat(''), [] );
{
      FName := K_CMSlideGetAttrsFileName(ASlide.ObjName);
      FName[Length(FName)] := '?';
      K_DeleteFolderFiles( ImgFPath0, FName, [] );
}
    end
  end
  else
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeFilesPocessing;
      Connection := LANDBConnection;
      ImgFPath := AnsiReplaceText(ImgFPath0, '\', '\\');
      if ASlide is TN_UDCMStudy then
        FName := TN_UDCMStudy(ASlide).GetFileName(ImgFPath)
      else
      begin
        FName := TN_UDCMSlide(ASlide).GetImgFilesNamePat(ImgFPath);
      end;
      { // Code OK
        CommandText :=
        'begin' + Chr($0A) +
        'declare @ls_source long varchar;' + Chr($0A) +
        'set @ls_source = ''' + ASlide.GetImgFilesNamePat( ImgFPath ) + ''';' + Chr($0A) +
        'select sf_file_delete(@ls_source);'+ Chr($0A) +
        'end';
      }
      CommandText := 'sf_file_delete(' +
        QuotedStr(FName) + ')';
      Execute;
      {
        CommandText := 'sf_file_delete(''' + ASlide.GetCurImgFileName( ImgFPath ) + ''')';
        Execute;

        CommandText := 'sf_file_delete(''' + ASlide.GetSrcImgFileName( ImgFPath ) + ''')';
        Execute;
      }
    end;

  EDAClearSlideImgFolders(ImgFPath0 + '*');

  N_Dump2Str('DB>> EDADelSlideImgFiles fin');
end; // end of TK_CMEDDBAccess.EDADelSlideImgFiles

//*********************************** TK_CMEDDBAccess.EDADelSlideMediaFiles ***
// Delete Slide Media Files and Folders before Slide Deletion
//
//     Parameters
// ASlide - Slide
// Result - Returns operation resulting code
//
//
function TK_CMEDDBAccess.EDADelSlideMediaFiles(ASlide: TN_UDCMSlide)
  : TK_CMEDResult;
var
  SPath, FName, FPref: string;

begin
  Result := K_edOK;
  with ASlide, P()^ do
  begin
    N_Dump1Str(format('DB>> EDADelSlideMediaFiles SID=%s ActRTID=%d',
        [ASlide.ObjName, AppRTID]));
    SPath := GetFilesPathSegm();
    FPref := GetMediaFileNamePref('');
    if SlidesClientMediaRootFolder <> '' then
    begin
      FName := SlidesClientMediaRootFolder + SPath + FPref + CMSDB.MediaFExt;
      K_DeleteFile(FName);
      EDARemovePathFolders0(FName, SlidesClientMediaRootFolder);
    end;
    if (SlidesMediaRootFolder <> '') and
       (K_edOK = EDAPathOrFileExists(SlidesMediaRootFolder, SlidesMediaRootFDA, TRUE)) then
    begin
      if SlidesMediaRootFDA then
      begin
        K_DeleteFolderFiles(SlidesMediaRootFolder + SPath, FPref + '*.*', [])
      end
      else
        with CurSQLCommand1 do
        begin
          ExtDataErrorCode := K_eeFilesPocessing;
          Connection := LANDBConnection;
          CommandText := 'sf_file_delete(''' + AnsiReplaceText
            (SlidesMediaRootFolder + SPath + FPref + '*.*', '\', '\\') + ''')';
          Execute;
        end;
      EDARemovePathFolders1(SlidesMediaRootFolder + SPath + '*',
        SlidesMediaRootFolder, SlidesMediaRootFDA);
    end;
  end;
  N_Dump2Str('DB>> EDADelSlideMediaFiles fin');

end; // end of TK_CMEDDBAccess.EDADelSlideMediaFiles

//*********************************** TK_CMEDDBAccess.EDADelSlideImg3DFiles ***
// Delete Slide 3D Image Files and Folders before Slide Deletion
//
//     Parameters
// ASlide - Slide
// Result - Returns operation resulting code
//
//
function TK_CMEDDBAccess.EDADelSlideImg3DFiles(ASlide: TN_UDCMSlide) : TK_CMEDResult;
var
  FName: string;

begin
  Result := K_edOK;
  with ASlide, P()^ do
  begin
    N_Dump1Str(format('DB>> EDADelSlideImg3DFiles SID=%s ActRTID=%d',
        [ASlide.ObjName, AppRTID]));
    if SlidesImg3DRootFolder <> '' then
    begin
      if CMSDB.MediaFExt <> '' then // Delete temporary 3D files if exists
        K_DeleteFolderFiles( CMSDB.MediaFExt );
      // Delete main 3D files
      FName := EDAGetSlideImg3DPath(ASlide) + K_CMSlideGetImg3DFolderName( ObjName );
      K_DeleteFolderFiles( FName );
      EDARemovePathFolders0(FName + '1', SlidesImg3DRootFolder);
    end;
  end;
  N_Dump2Str('DB>> EDADelSlideImg3DFiles fin');

end; // end of TK_CMEDDBAccess.EDADelSlideImg3DFiles

//********************************************* TK_CMEDDBAccess.EDAClearSlideImgFolders ***
// Clear Slide Image File Folders after Image File Deletion
//
//     Parameters
// ASlideImgFName - Slide Image File Name
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAClearSlideImgFolders(ASlideImgFName: string) : TK_CMEDResult;
//var
//  InTransMode: Boolean;
begin
  N_Dump2Str('DB>> EDAClearSlideImgFolders ActRTID=' + IntToStr
      (AppRTID));
  Result := K_edOK;
  try
{
    InTransMode := LANDBConnection.InTransaction;
    if not InTransMode then
      LANDBConnection.BeginTrans;

    with CurSQLCommand1 do
    begin
      // Lock Active Instance Table in exclusive mode
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
      CommandText := 'LOCK TABLE ' + K_CMENDBLockSlidesTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end;
}
    EDARemovePathFolders1(ASlideImgFName, SlidesImgRootFolder, SlidesImgRootFDA);
//    if not InTransMode then
//      LANDBConnection.CommitTrans;
    N_Dump2Str('DB>> EDAClearSlideImgFolders fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAClearSlideImgFolders ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAClearSlideImgFolders

//********************************************* TK_CMEDDBAccess.EDAAddSessionHistRecord ***
// Add Current Context Session Record
//
//     Parameters
// ANPatID  - new patient ID, if =-1 then Current Patient will be used
// ANProvID - new provider ID, if =-1 then Current Provider will be used
// ANLocID  - new location ID, if =-1 then Current Location will be used
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAAddSessionHistRecord( ANPatID : Integer = -1;
                                                  ANProvID : Integer = -1;
                                                  ANLocID  : Integer = -1 ) : TK_CMEDResult;
var
  PatText,PatCN,ProvText,LocText : string;
  SQLText : string;
  ParInd : Integer;
begin
  Result := K_edOK;
  N_Dump2Str('DB>> EDAAddSessionHistRecord');
  try
    if ANPatID  = -1 then ANPatID := CurPatID;
    if ANProvID = -1 then ANProvID := CurProvID;
    if ANLocID  = -1 then ANLocID := CurLocID;
    if K_CMEDDBVersion >= 12 then // Save Sessions History Text Contexs
    begin

      PatText := K_CMGetPatientDetails(ANPatID);
      if (Trim(PatText) = '') or K_StrStartsWith( 'Px. ID=', PatText ) then
        PatText := '@'
      else
        PatText := Copy( Trim(PatText), 1, 49 );

      PatCN := K_CMGetPatientDetails(ANPatID, K_CMENPTDICOMPatientDetails2 );

      if (PatCN = '') or K_StrStartsWith( 'Px. ID=', PatCN ) then PatCN := IntToStr( ANPatID );

      ProvText := K_CMGetProviderDetails(ANProvID);
      if (ProvText = '') or K_StrStartsWith( 'Dr. ID=', ProvText ) then
        ProvText := '@'
      else
        ProvText := Copy( Trim(ProvText), 1, 49 );

      LocText := K_CMGetLocationDetails(ANLocID);
      if (LocText = '') or K_StrStartsWith( 'LocID=', LocText ) then
        LocText := '@'
      else
        LocText := Copy( Trim(LocText), 1, 49 );


      if K_CMEDDBVersion >= 18 then
      begin
      // New cms_SetHistSessionTextInfo version - use @SessionID out parameter
      // correct MultiLanguage AnsiStrings transmision to DB StoredProcedure by TADOStoredProc.Parameters
        N_Dump2Str( 'DB>> cms_SetHistSessionTextInfo ' );

        with CurStoredProc1 do
        begin
          Connection := LANDBConnection;
          ProcedureName := 'dba.cms_SetHistSessionTextInfo';
          Parameters.Clear;
          with Parameters.AddParameter do
          begin // 0
            Name := '@PatientID';
            Direction := pdInput;
            DataType := ftInteger;
            Value := ANPatID;
          end;
          with Parameters.AddParameter do
          begin  // 1
            Name := '@PatientText';
            Direction := pdInput;
            DataType := ftString;
            Value := N_StringToAnsi( PatText );
          end;
          with Parameters.AddParameter do
          begin  // 2
            Name := '@PatientCN';
            Direction := pdInput;
            DataType := ftString;
            Value := N_StringToAnsi(PatCN);
          end;
          with Parameters.AddParameter do
          begin  // 3
            Name := '@UserID';
            Direction := pdInput;
            DataType := ftInteger;
            Value := ANProvID;
          end;
          with Parameters.AddParameter do
          begin  // 4
            Name := '@UserText';
            Direction := pdInput;
            DataType := ftString;
            Value := N_StringToAnsi( ProvText );
          end;
          with Parameters.AddParameter do
          begin  // 5
            Name := '@LocationID';
            Direction := pdInput;
            DataType := ftInteger;
            Value := ANLocID;
          end;
          with Parameters.AddParameter do
          begin  // 6
            Name := '@LocationText';
            Direction := pdInput;
            DataType := ftString;
            Value := N_StringToAnsi( LocText );
          end;

          ParInd := 8;
          if K_CMEDDBVersion >= 19 then
          begin
            with Parameters.AddParameter do
            begin  // 7
              Name := '@ClientID';
              Direction := pdInput;
              DataType := ftInteger;
              Value := ClientAppGlobID;
            end;
            with Parameters.AddParameter do
            begin  // 8
              Name := '@ServID';
              Direction := pdInput;
              DataType := ftInteger;
              Value := CurServID;
            end;
            ParInd := 9;
            if K_CMEDDBVersion >= 44 then
            begin
              with Parameters.AddParameter do
              begin  // 9
                Name := '@DCMSTUID';
                Direction := pdInput;
                DataType := ftString;
                if K_CMDCMD4WStudyUID <> '' then
                  Value := N_StringToAnsi( K_CMDCMD4WStudyUID )
                else
                  Value := '@';
              end;
              ParInd := 10;
            end
          end
          else
            with Parameters.AddParameter do
            begin  // 7
              Name := '@CompID';
              Direction := pdInput;
              DataType := ftInteger;
              Value := ClientAppGlobID;
            end;

          with Parameters.AddParameter do
          begin  // 8 or 9 or 10
            Name := '@SessionID';
            Direction := pdOutput;
            DataType := ftInteger;
            Value := ClientAppGlobID;
          end;
          ExecProc;
          CurSessionHistID := Parameters[ParInd].Value;
        end;
      end   // if K_CMEDDBVersion >= 18 then
      else
      begin // if K_CMEDDBVersion < 18 then
      // Errors in MultiLaguage AnsiStrings transmision to DB StoredProcedure
        SQLText := format( 'begin' + Chr($0A) +
               'declare @PatText long varchar;' + Chr($0A) +
               'declare @PatCN long varchar;' + Chr($0A) +
               'declare @ProvText long varchar;' + Chr($0A) +
               'declare @LocText long varchar;' + Chr($0A) +
               'set @PatText = %s;' + Chr($0A) +
               'set @PatCN = %s;' + Chr($0A) +
               'set @ProvText = %s;' + Chr($0A) +
               'set @LocText = %s;' + Chr($0A) +
               'select cms_SetHistSessionTextInfo( %d, @PatText, @PatCN, %d, @ProvText, %d, @LocText, %d);' + Chr($0A) +
               'end', [QuotedStr(PatText),QuotedStr(PatCN),QuotedStr(ProvText),QuotedStr(LocText),
                       ANPatID,ANProvID,ANLocID,ClientAppGlobID] );
        if K_CMEDDBVersion >= 13 then
        begin
        // New CMS Statistics - use Sessions History Table
          with CurDSet1 do
          begin
            SQL.Text := SQLText;
            Filtered := false;
            Open;
            CurSessionHistID := FieldList.Fields[0].AsInteger;
            Close;
          end;
        end // if K_CMEDDBVersion >= 13 then
        else
        // Old CMS Statistics - not use Sessions History Table
          with CurSQLCommand1 do
          begin
            ExtDataErrorCode := K_eeDBSelect;
            CommandText := SQLText;
            Execute;
          end;
      end; // // if K_CMEDDBVersion < 18 then
    end;
   PrevSessionHistID := CurSessionHistID;
    N_Dump2Str('DB>> EDAAddSessionHistRecord fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAAddSessionHistRecord ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAAddSessionHistRecord
{
//************************************ TK_CMEDDBAccess.EDALockActiveContext ***
// Lock Current Patient, Provider, Location context for Application Active
// Instance
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDALockActiveContext() : TK_CMEDResult;
var
  SAppRTID: string;
  SAPatID: string;
  PatID: Integer;
  PatientChanged: Boolean;
//  PatText,PatCN,ProvText,LocText : string;
//  SQLText : string;
begin
//  Result := K_edOK;
  N_Dump2Str('DB>> EDALockActiveContext');
  try
    LANDBConnection.BeginTrans;
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
      CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end; // with CurSQLCommand1 do

    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      SAppRTID := IntToStr(AppRTID);
      SQL.Text := 'select ' +
        K_CMENDBAAInstsTFActRTID + ',' + K_CMENDBAAInstsTFPatID + ',' +
        K_CMENDBAAInstsTFProvID + ',' +  K_CMENDBAAInstsTFLocID +
        ' from ' + K_CMENDBAAInstsTable +
        ' where ' + K_CMENDBAAInstsTFActRTID + '=' + SAppRTID;
      Filtered := false;
      Open;
      PatID := CurPatID;
      SAPatID := IntToStr(PatID);
      if RecordCount > 0 then
      begin
        N_Dump2Str( 'DB>> Active Instance. Set Current Context ActRTID=' +
            SAppRTID + ' PatID=' + SAPatID + ' ProvID=' + IntToStr(CurProvID)
            + ' LocID=' + IntToStr(CurLocID) );

        PatientChanged := FieldList.Fields[1].AsInteger <> PatID;
        ExtDataErrorCode := K_eeDBDel;
        if PatientChanged then
        begin


          // Unlock all slides locked by previous AppRTID Patient
          N_Dump2Str( 'DB>> Active Instance. Delete Locked Slides ActRTID=' + SAppRTID );
          with CurSQLCommand1 do
          begin
            CommandText := 'DELETE FROM ' + K_CMENDBLockSlidesTable +
              ' WHERE ' + K_CMENDBLSlidesTFActRTID + ' = ' + SAppRTID;
            Execute;
          end;
        end;

        ExtDataErrorCode := K_eeDBEdit;
        Edit;
        FieldList.Fields[1].AsInteger := PatID;
        FieldList.Fields[2].AsInteger := CurProvID;
        FieldList.Fields[3].AsInteger := CurLocID;

        UpdateBatch;
        Close;
        LANDBConnection.CommitTrans();
      end
      else
      begin
        ExtDataErrorString := 'Active Instance is absent. ActRTID=' + SAppRTID;
        Close;
        LANDBConnection.RollbackTrans();
        raise Exception.Create(ExtDataErrorString);
      end;
    end; // with CurDSet1 do
    Result := EDAAddSessionHistRecord();
    N_Dump2Str( 'DB>> EDALockActiveContext fin' );
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDALockActiveContext ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDALockActiveContext

//************************************ TK_CMEDDBAccess.EDALockActiveContext ***
// Lock Current Patient, Provider, Location context for Application Active
// Instance
//
//     Parameters
// Result - Returns operation resulting code
//
// Result = K_edFails means that current patient is locked by
// some CopyMove procedure;
//
function TK_CMEDDBAccess.EDALockActiveContext( ) : TK_CMEDResult;
var
  SAppRTID: string;
  SAPatID: string;
  PatID: Integer;
  DBPatID : Integer;
  PatientChanged: Boolean;
  CDTime: TDateTime;
//  PatText,PatCN,ProvText,LocText : string;
//  SQLText : string;
  CMPProcID : Integer;
begin
//  Result := K_edOK;
  N_Dump2Str('DB>> EDALockActiveContext');
  try
    LANDBConnection.BeginTrans;
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
      CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end; // with CurSQLCommand1 do

    with CurDSet1 do
    begin

      /////////////////////////////////////
      // Set New Context to Active Instance
      //
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      SAppRTID := IntToStr(AppRTID);
      SQL.Text := 'select ' +
        K_CMENDBAAInstsTFActRTID + ',' + K_CMENDBAAInstsTFPatID + ',' +
        K_CMENDBAAInstsTFProvID  + ',' + K_CMENDBAAInstsTFLocID + ',' +
        K_CMENDBAAInstsTFActTS +
        ' from ' + K_CMENDBAAInstsTable;
//        ' from ' + K_CMENDBAAInstsTable +
//        ' where ' + K_CMENDBAAInstsTFActRTID + '=' + SAppRTID;
      Filtered := false;
      Open;
      Filter := K_CMENDBAAInstsTFActRTID + '=' + SAppRTID;
      Filtered := TRUE;

      PatID := CurPatID;
      SAPatID := IntToStr(PatID);
      if RecordCount > 0 then
      begin
        N_Dump2Str( 'DB>> Active Instance. Set Current Context ActRTID=' +
            SAppRTID + ' PatID=' + SAPatID + ' ProvID=' + IntToStr(CurProvID)
            + ' LocID=' + IntToStr(CurLocID) );

        DBPatID := FieldList.Fields[1].AsInteger;
        PatientChanged := DBPatID <> PatID;

        ////////////////////////////////////////////////////////
        // Try to Free Active Instance Lost Records and Objects
        //
        if (DBPatID <> -1) and PatientChanged then
        begin //  Switch Patient Inside Session (not session 1-st LockActiveContext)
          Filtered := FALSE;
          Filter := K_CMENDBAAInstsTFActRTID + '<>' + SAppRTID;
          Filtered := TRUE;
          if RecordCount > 0 then
          begin
            CDTime := EDAGetSyncTimestamp();
            First;
            while not Eof do
            begin
              if not EDAAppInstanceLostRecord( CurDSet1, 4, 1, CDTime ) then
                Next
              else
              begin
                EDAAppUnlockObjects(FieldList.Fields[0].AsString);
                // Unlock Slides for Lost Active Instance
                Delete();
              end;
            end;
          end; // if RecordCount > 0 then
          Filtered := FALSE;
          Filter := K_CMENDBAAInstsTFActRTID + '=' + SAppRTID;
          Filtered := TRUE;
        end; // if (DBPatID <> -1) and PatientChanged then
        //
        // Try to Free Active Instance Lost Records and Objects
        ///////////////////////////////////////////////////////

        EDAPatObjCopyMoveProcGet( CMPProcID, CurPatID, 2 );
        if CMPProcID <> 0 then
        begin
          Result := K_edFails;
          Close;
          LANDBConnection.CommitTrans();
          Exit;
        end;

        ExtDataErrorCode := K_eeDBDel;
        //////////////////////////////////////////////
        // Free to Free Previous Patient Locked Slides
        //
        if PatientChanged then
        begin
          // Unlock all slides locked by previous AppRTID Patient
          N_Dump2Str( 'DB>> Active Instance. Delete Locked Slides ActRTID=' + SAppRTID );
          with CurSQLCommand1 do
          begin
            CommandText := 'DELETE FROM ' + K_CMENDBLockSlidesTable +
              ' WHERE ' + K_CMENDBLSlidesTFActRTID + ' = ' + SAppRTID;
            Execute;
          end;
        end;

        //////////////////////////////
        // Save new session context
        //
        ExtDataErrorCode := K_eeDBEdit;
        Edit;
        FieldList.Fields[1].AsInteger := PatID;
        FieldList.Fields[2].AsInteger := CurProvID;
        FieldList.Fields[3].AsInteger := CurLocID;

        UpdateBatch;
        Close;
      end   // if RecordCount > 0 then Active Instance Record exists
      else
      begin // if RecordCount = 0 then Active Instance Record is absent
        ExtDataErrorString := 'Active Instance is absent. ActRTID=' + SAppRTID;
        Close;
        LANDBConnection.CommitTrans();
        raise Exception.Create(ExtDataErrorString);
      end; // if RecordCount = 0
      //
      // Set New Context to Active Instance
      /////////////////////////////////////

      LANDBConnection.CommitTrans();
    end; // with CurDSet1 do
    Result := EDAAddSessionHistRecord();
    N_Dump2Str( 'DB>> EDALockActiveContext fin' );
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDALockActiveContext ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDALockActiveContext
}
//*********************************** TK_CMEDDBAccess.EDALockActiveContext1 ***
// Lock Current Patient, Provider, Location context for Application Active
// Instance
//
//     Parameters
// ANPatID  - new patient ID
// ANProvID - new provider ID
// ANLocID  - new location ID
// Result - Returns operation resulting code
//
// Result = K_edFails means that current patient is locked by
// some CopyMove procedure;
//
function TK_CMEDDBAccess.EDALockActiveContext1( ANPatID, ANProvID, ANLocID : Integer ) : TK_CMEDResult;
var
  SAppRTID: string;
  SAPatID: string;
  PatID: Integer;
  DBPatID : Integer;
  PatientChanged: Boolean;
//  CDTime: TDateTime;
//  PatText,PatCN,ProvText,LocText : string;
//  SQLText : string;
  CMPProcID : Integer;
//  DumpActiveInstancesFlag : Boolean;
begin
//  Result := K_edOK;
  N_Dump2Str('DB>> EDALockActiveContext1');
  try
    LANDBConnection.BeginTrans;
{debug
with CurDSet1 do
begin
  Connection := LANDBConnection;
      SQL.Text := 'select ' + K_CMENDBLSlidesTFActRTID +
        ' from ' + K_CMENDBLockSlidesTable;
  Open;
  Close;
end;
}

    with CurSQLCommand1 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBLock;
      CommandText := EDADBIsolationLevelSet(K_tilSerializable);
      // 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end; // with CurSQLCommand1 do
//K_CMShowMessageDlg( '3',  mtInformation ); // debug

    with CurDSet1 do
    begin

      /////////////////////////////////////
      // Set New Context to Active Instance
      //
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      SAppRTID := IntToStr(AppRTID);
      SQL.Text := 'select ' +
        K_CMENDBAAInstsTFActRTID + ',' + K_CMENDBAAInstsTFPatID + ',' +
        K_CMENDBAAInstsTFProvID  + ',' + K_CMENDBAAInstsTFLocID + ',' +
        K_CMENDBAAInstsTFActTS +
        ' from ' + K_CMENDBAAInstsTable;
//        ' from ' + K_CMENDBAAInstsTable +
//        ' where ' + K_CMENDBAAInstsTFActRTID + '=' + SAppRTID;
      Filtered := false;
      Open;
      Filter := K_CMENDBAAInstsTFActRTID + '=' + SAppRTID;
      Filtered := TRUE;

      PatID := ANPatID;
      SAPatID := IntToStr(PatID);
      if RecordCount > 0 then
      begin
        N_Dump2Str( 'DB>> Active Instance. Set Current Context ActRTID=' +
            SAppRTID + ' PatID=' + SAPatID + ' ProvID=' + IntToStr(ANProvID)
            + ' LocID=' + IntToStr(ANLocID) );

        DBPatID := FieldList.Fields[1].AsInteger;
        PatientChanged := DBPatID <> PatID;

        ////////////////////////////////////////////////////////
        // Try to Free Active Instance Lost Records and Objects
        //
        N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServClearInstLostRecords, TRUE );

//        if (DBPatID <> -1) and PatientChanged then
//        begin //  Switch Patient Inside Session (not session 1-st LockActiveContext)
//          Filtered := FALSE;
//          Filter := K_CMENDBAAInstsTFActRTID + '<>' + SAppRTID;
//          Filtered := TRUE;
//          if RecordCount > 0 then
//          begin
//            //CDTime := EDAGetSyncTimestamp();
//            First;
//            //DumpActiveInstancesFlag := FALSE;
//            while not Eof do
//            begin
//              if not K_CMDBCheckAppInstanceLostRecord( CurDSet1, 4, 1, CDTime ) then
//                Next
//              else
//              begin
//                if not DumpActiveInstancesFlag then
//                begin
//                  DumpActiveInstancesFlag := TRUE;
//                  K_CMEDAccess.TmpStrings.Clear;
//                  EDADumpActiveContext( CurBlobDSet, K_CMEDAccess.TmpStrings );
//                  N_Dump1Str('DB>> EDALockActiveContext1 LostRecord was found >> Active Instances Dump ***'#13#10 + K_CMEDAccess.TmpStrings.Text);
//    // To prevent 'Deadlock detected' error
////                CommandText := 'LOCK TABLE ' + K_CMENDBLockSlidesTable + ' IN EXCLUSIVE MODE;';
////                Execute;
//                end;
//                EDAAppUnlockObjects(FieldList.Fields[0].AsString);
//                // Unlock Slides for Lost Active Instance
//                Delete();
//              end;
//            end; // while not Eof do
//          end; // if RecordCount > 0 then
//          Filtered := FALSE;
//          Filter := K_CMENDBAAInstsTFActRTID + '=' + SAppRTID;
//          Filtered := TRUE;
//        end; // if (DBPatID <> -1) and PatientChanged then

        //
        // Try to Free Active Instance Lost Records and Objects
        ///////////////////////////////////////////////////////

        ///////////////////////////////////////////
        // Check if Patient is Locked by CopyMove
        //  ANPatID = 0 special context to skip current patient - for LargeResample and CopyMove
        //
        if (ANPatID <> 0) and PatientChanged and (K_CMEDDBVersion >= 28) then
        begin
          EDAPatObjCopyMoveProcGet( CMPProcID, ANPatID, 2 );
          if CMPProcID <> 0 then
          begin
            Result := K_edFails;
            Close;
            LANDBConnection.CommitTrans();
            N_Dump1Str( 'DB>> Paient data is locked by CopyMove PatID=' + SAPatID );
            Exit;
          end;
        end;
        //
        // Check if Patient is Locked by CopyMove
        ///////////////////////////////////////////

        ExtDataErrorCode := K_eeDBDel;
        //////////////////////////////////////////////
        // Free to Free Previous Patient Locked Slides
        //
        if PatientChanged then
        begin
          // Unlock all slides locked by previous AppRTID Patient
          N_Dump2Str( 'DB>> Active Instance. Delete Locked Slides ActRTID=' + SAppRTID );
//K_CMShowMessageDlg( '4',  mtInformation ); // debug
          with CurSQLCommand1 do
          begin
//!!! To prevent 'Deadlock detected' error
//            CommandText := 'LOCK TABLE ' + K_CMENDBLockSlidesTable + ' IN EXCLUSIVE MODE;';
//            Execute;
            CommandText := 'DELETE FROM ' + K_CMENDBLockSlidesTable +
              ' WHERE ' + K_CMENDBLSlidesTFActRTID + ' = ' + SAppRTID;
            Execute;
          end;
        end;

        //////////////////////////////
        // Save new session context
        //
        ExtDataErrorCode := K_eeDBEdit;
        Edit;
        FieldList.Fields[1].AsInteger := ANPatID;
        FieldList.Fields[2].AsInteger := ANProvID;
        FieldList.Fields[3].AsInteger := ANLocID;

        UpdateBatch;
        Close;
      end   // if RecordCount > 0 then Active Instance Record exists
      else
      begin // if RecordCount = 0 then Active Instance Record is absent
        ExtDataErrorString := 'Active Instance is absent. ActRTID=' + SAppRTID;
        Close;
        LANDBConnection.CommitTrans();
        raise Exception.Create(ExtDataErrorString);
      end; // if RecordCount = 0
      //
      // Set New Context to Active Instance
      /////////////////////////////////////

      LANDBConnection.CommitTrans();
    end; // with CurDSet1 do

    with CurSQLCommand1 do
    begin
      CommandText := EDADBIsolationLevelDefault();
      Execute;
    end; // with CurSQLCommand1 do

    if CurSessionHistID <> 0 then
      EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                               Ord(K_shNCAFinishSession) ) );
    Result := EDAAddSessionHistRecord( ANPatID, ANProvID, ANLocID );
    N_Dump2Str( 'DB>> EDALockActiveContext1 fin' );
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDALockActiveContext1 ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDALockActiveContext1

//*************************************** TK_CMEDDBAccess.EDALockSlideForRW ***
// Lock given slide file for Read/Write operation
//
//     Parameters
// ASlideID - given Slide ID to lock
// ALockFileMode - lock slide file mode
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDALockSlideForRW( const ASlideID: string;
  ALockFileMode: TK_CMEDLockFileMode): TK_CMEDResult;

var
  SSelfAppRTID: string;
  SLockMode: string;

begin

  Result := K_edOK;
  if (ALockFileMode = K_cmlfFree) and not ChngLockedSlideFlag  then
    Exit; // Unlock is not needed
  SSelfAppRTID := IntToStr(AppRTID);
  SLockMode := IntToStr(Ord(ALockFileMode));
  N_Dump2Str('DB>> EDALockSlideForRW SlideID=' + ASlideID +
      ' ActRTID=' + SSelfAppRTID + ' LockMode=' + SLockMode);

  try
    if ALockFileMode = K_cmlfFree then
      with CurSQLCommand1 do
      begin
        CommandText := 'UPDATE ' + K_CMENDBLockSlidesTable + ' SET ' +
          K_CMENDBLSlidesTFFLockFlag + ' = 0' + ' WHERE ' +
          K_CMENDBLSlidesTFSlideID + ' = ' + ASlideID + ' AND ' +
          K_CMENDBLSlidesTFActRTID + '=' + SSelfAppRTID + ';';
        Execute;
        ChngLockedSlideFlag := FALSE; // Clear Slide Lock Flag
      end
    else
    begin //  if ALockFileMode <> K_cmlfFree then
//      if (K_CMEDDBVersion < 39) and not K_CMEDDBUseSQLProcs then
      if K_CMEDDBVersion < 39  then
        with CurDSet1 do
        begin
          // Select all records from Locked Slides Table
          ExtDataErrorCode := K_eeDBSelect;
          Connection := LANDBConnection;
          SQL.Text := 'select cms_LockSlideChange( ' + ASlideID + ', ' +
                                          SSelfAppRTID + ', ' + SLockMode + ' );';
          Filtered := false;
          Open;
          if FieldList.Fields[0].AsInteger = 0 then
            Result := K_edFails
          else
            ChngLockedSlideFlag := TRUE; // Set Slide Locked Flag

          Close;
        end
//      else // if (K_CMEDDBVersion >= 39) or K_CMEDDBUseSQLProcs then
      else // if K_CMEDDBVersion >= 39 then
        with CurStoredProc1 do
        begin
          Connection := LANDBConnection;
          ProcedureName := 'dba.cms_LockSlideChange';
          Parameters.Clear;
          with Parameters.AddParameter do
          begin
            Name := '@SlideID';
            Direction := pdInput;
            DataType := ftInteger;
            Value := StrToInt( ASlideID );
          end;
          with Parameters.AddParameter do
          begin
            Name := '@AppRTID';
            Direction := pdInput;
            DataType := ftInteger;
            Value := AppRTID;
          end;
          with Parameters.AddParameter do
          begin
            Name := '@LockMode';
            Direction := pdInput;
            DataType := ftInteger;
            Value := Ord(ALockFileMode);
          end;
          with Parameters.AddParameter do
          begin
            Name := '@RET';
            Direction := pdOutput;
            DataType := ftInteger;
            ExecProc;
            if Value = 0 then
              Result := K_edFails
            else
              ChngLockedSlideFlag := TRUE; // Set Slide Locked Flag
          end; // with Parameters.AddParameter do
        end; // with CurStoredProc1 do

    end; // if ALockFileMode <> K_cmlfFree then
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDALockSlideForRW ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDALockSlideForRW
{
function TK_CMEDDBAccess.EDALockSlideForRW(ASlide: TN_UDCMSlide;
  ALockFileMode: TK_CMEDLockFileMode): TK_CMEDResult;

var
  SSelfAppRTID: string;
  SLockMode: string;

begin

  Result := K_edOK;
  if (ALockFileMode = K_cmlfFree) and (ChngLockedSlide = nil) then
    Exit; // Unlock is not needed
  SSelfAppRTID := IntToStr(AppRTID);
  SLockMode := IntToStr(Ord(ALockFileMode));
  N_Dump2Str('DB>> EDALockSlideForRW SlideID=' + ASlide.ObjName +
      ' ActRTID=' + SSelfAppRTID + ' LockMode=' + IntToStr(Ord(ALockFileMode)));

  try
    if ALockFileMode = K_cmlfFree then
      with CurSQLCommand1 do
      begin
        CommandText := 'UPDATE ' + K_CMENDBLockSlidesTable + ' SET ' +
          K_CMENDBLSlidesTFFLockFlag + ' = 0' + ' WHERE ' +
          K_CMENDBLSlidesTFSlideID + ' = ' + ASlide.ObjName + ' AND ' +
          K_CMENDBLSlidesTFActRTID + '=' + SSelfAppRTID + ';';
        Execute;
        ChngLockedSlide := nil; // Clear Slide Lock Flag
      end
      else
      begin
//          with CurSQLCommand1 do begin
//          CommandText :=  'BEGIN TRANSACTION;';
//          Execute;
//          end;

        // LANDBConnection.BeginTrans;
        with CurDSet1 do
        begin
          // Select all records from Locked Slides Table
          ExtDataErrorCode := K_eeDBSelect;
          Connection := LANDBConnection;
          SQL.Text := 'select cms_LockSlideChange( ' + ASlide.ObjName + ', ' +
            SSelfAppRTID + ', ' + SLockMode + ');';
          Filtered := false;
          Open;
          if FieldList.Fields[0].AsInteger = 0 then
            Result := K_edFails
          else
            ChngLockedSlide := ASlide; // Set Slide Locked Flag

          Close;
        end;
//          if Result = K_edOK then
//          LANDBConnection.CommitTrans()
//          else
//          LANDBConnection.RollbackTrans();

//          with CurSQLCommand1 do begin
//          if Result <> K_edOK then
//          CommandText := 'ROLLBACK TRANSACTION;'
//          else
//          CommandText := 'COMMIT TRANSACTION;';
//          Execute;
//          end;
      end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDALockSlideForRW ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDALockSlideForRW
}
//******************************** TK_CMEDDBAccess.EDAWaitForCurSlideRWLock ***
// Lock given slide file for Read/Write operation
//
//     Parameters
// ASlideID - given Slide ID to lock
// ALockFileMode - lock slide file mode
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAWaitForCurSlideRWLock( const ASlideID : string;
  ALockFileMode: TK_CMEDLockFileMode): TK_CMEDResult;
var
  i: Integer;
  SavedCursor: TCursor;
begin
  i := 0;
  SavedCursor := Screen.Cursor;
  while (EDALockSlideForRW( ASlideID, ALockFileMode) <> K_edOK) do
  begin
    if i = 0 then
    begin
      Screen.Cursor := crHourglass;

      // Disable CMS UI
      N_CM_MainForm.CMMSetUIEnabled( FALSE );
    end;
    N_CM_MainForm.CMMFShowString( K_CML1Form.LLLSave2.Caption
//              ' Image is busy. Wait please ...'
                                 );
    sleep(500);
    Inc(i);
    if i > 30 * 60 * 2 then
    begin
      raise Exception.Create('Waiting for Image save timeout elapsed');
    end;
    // ??    Application.ProcessMessages();
  end; // while (EDALockSlideForRW( ASlideID, ALockFileMode) <> K_edOK) do

  if i > 0 then
  begin
    // Enable CMS UI
    N_CM_MainForm.CMMSetUIEnabled( TRUE );
    Screen.Cursor := SavedCursor;
    N_CM_MainForm.CMMFShowString('');
  end;

  Result := K_edOK;
end; // end of TK_CMEDDBAccess.EDAWaitForCurSlideRWLock

//******************************************* TK_CMEDDBAccess.EDALockSlides ***
// Lock given slides for edit
//
//     Parameters
// APSlide - pointer to slides array start element to lock
// ASlidesCount - number of slides to lock
// ALockResultMode - specified SkipDeleted or SkipExtLocked mode
// APatID - Patient ID (if APatID <> - 1 then only given Patiient Slides should be Locked)
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDALockSlides( APSlide: TN_PUDCMSlide;
                  ASlidesCount: Integer; ALockResultMode: TK_CMEDLockResultMode;
                  APatID: Integer = -1 ): TK_CMEDResult;
var
  {SAppRTID,} SSelfAppRTID: string;
  CDTime: TDateTime;
  i: Integer;
  SPatID, SlideID: string;
  FLockedCount: Integer;
  PCMSlideFields: TN_PCMSlide;
  USlide: TN_UDCMSlide;
  SQLStr, SQLStr0: string;
  FViewAttrs  : TN_CMSViewAttrs;
//  SlideVewAttrsBuf: array [0 .. K_SlideViewAttsSize - 1] of Byte;
  WPSlide: TN_PUDCMSlide;
  ILockState: TK_CMEDLockState;
  LockState: TK_CMEDLockState;
  CurLockState : TK_CMEDLockState;
  LockResultMode: TK_CMEDLockResultMode;
  FLockResUpdate: TN_UDCMSArray; // Slides to Update Array
  FLockResUpdateState: TK_CMEDBUSFArray; // Update Slide States Array

  DeadlockCount : Integer;
  LockOKFlag    : Boolean;
//  LockSlidesTableFlag : Boolean; // LockSlidesTable is Locked Flag

label LoopCont, DeadlockLoop;

  function IfSlideActiveLockRecordExists(ALockState: Integer): Boolean;
  begin
    with CurDSet1 do
    begin
      Filtered := FALSE;
      Filter := K_CMENDBLSlidesTFSlideID + ' = ' + SlideID + ' and ' +
        K_CMENDBLSlidesTFActRTID + ' <> ' + SSelfAppRTID;
      Filtered := TRUE;
      Result := FALSE;
      if RecordCount > 0 then
      begin
        First();
        while not Eof do
        begin
//          if (K_CMEDAActiveTimeOut >= CDTime - TDateTimeField(FieldList.Fields[3]).Value) and
          if not K_CMDBCheckAppInstanceLostRecord( CurDSet1, 3, 8, CDTime ) and
             ((ALockState = -1) or (FieldList.Fields[2].AsInteger = ALockState)) then
          begin
            // Slide Locked by Active Instatnce and given LockState is found
            Result := TRUE;
            LockResState[LockResCount - 1].LSProvIDLock := FieldList.Fields[5].AsInteger;
            LockResState[LockResCount - 1].LSLocIDLock  := FieldList.Fields[6].AsInteger;
            LockResState[LockResCount - 1].LSCompIDLock := EDAGetStringFieldValue(FieldList.Fields[7]);
            Exit;
          end;
          Next();
        end;
      end;
    end;
  end; // function IfSlideActiveLockRecordExists

  function SelectItemLocRecord(): Boolean;
  begin
    with CurDSet1 do
    begin
      Filtered := false;
      Filter := K_CMENDBLSlidesTFSlideID + ' = ' + SlideID + ' and ' +
                K_CMENDBLSlidesTFActRTID + ' = ' + SSelfAppRTID;
      Filtered := TRUE;
      Result := RecordCount > 0;
    end;
  end; // function IfSlideActiveLockRecordExists

  procedure SetLockRecordFields();
  begin
    with CurDSet1 do
    begin
      // Set Lock Slide Record Fields
      FieldList.Fields[0].AsInteger := StrToInt(SlideID);
      FieldList.Fields[1].AsInteger := AppRTID;
      FieldList.Fields[2].AsInteger := Ord(LockState);
      Inc(FLockedCount);
    end;
  end; // procedure SetLockRecordFields

  procedure AddNewLockRecord();
  begin
    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBIns;
      N_Dump2Str( format('DB>> Add new Lock Record LockState=%d SID=%s SEdState=%d ActRTID=%s',
                        [(Ord(LockState)), SlideID, Ord(APSlide^.CMSlideEdState), SSelfAppRTID]) );
      Insert;
      SetLockRecordFields();
    end;
  end; // procedure AddNewLockRecord

  procedure EditExistingLockRecord();
  begin
    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBEdit;
      N_Dump2Str( format('DB>> Use existing Lock Record LockState=%d SID=%s SEdState=%d ActRTID=%s',
                        [(Ord(LockState)), SlideID, Ord(APSlide^.CMSlideEdState), SSelfAppRTID]) );
      Edit;
      SetLockRecordFields();
    end;
  end; // procedure EditExistingLockRecord

  procedure SlideLockRecordPrep();
  begin
    with CurDSet1 do
    begin
      Filtered := false;
      Filter := K_CMENDBLSlidesTFSlideID + ' = ' + SlideID;
      Filtered := TRUE;
      if RecordCount > 0 then
      begin
        First();
        while not Eof do
        begin
//          if (K_CMEDAActiveTimeOut < CDTime - TDateTimeField(FieldList.Fields[3]).Value) then
          if K_CMDBCheckAppInstanceLostRecord( CurDSet1, 3, 8, CDTime ) then
          begin
            // Not Active Lock Record is Found - use it for Current Slide Locking
            EditExistingLockRecord(); // Use Existed Lock Record
            Exit;
          end;
          Next();
        end;
      end;
      AddNewLockRecord(); // Add new Lock Record
    end;
  end; // procedure SlideLockRecordPrep

  procedure AddSlideToDeletedList();
  begin
    LockResDelSlides[LockResDelCount] := APSlide^;
    Inc(LockResDelCount);
    if LockResultMode = K_cmlrmDeleteLock then
      Exit;
    Dec(LockResCount); // Remove Slide From Resulting List
    N_Dump2Str('DB>> Slide was deleted ID=' + SlideID);
  end; // procedure AddSlideToDeletedList

  procedure AddSlideToMarkAsDeletedList();
  begin
    LockResMarkAsDelSlides[LockResMarkAsDelCount] := APSlide^;
    Inc(LockResMarkAsDelCount);
    Dec(LockResCount); // Remove Slide From Resulting List
    N_Dump2Str('DB>> Slide was marked as deleted ID=' + SlideID);
  end; // procedure AddSlideToMarkAsDeletedList

  procedure AddSlideToSkipOpenList();
  begin
    LockResSkipOpenSlides[LockResSkipOpenCount] := APSlide^;
    Inc(LockResSkipOpenCount);
    Dec(LockResCount); // Remove Slide From Resulting List
    N_Dump2Str('DB>> Slide is SkipOpen ID=' + SlideID);
  end; // procedure AddSlideToSkipOpenList

  procedure CheckSLideUpdates();
  var
//    DT: TDateTime;
    DMax: TDateTime;
  begin


    with CurDSet3, PCMSlideFields^ do
    begin
      if not (cmsfIsLocked in CMSRFlags) then
        FLockResUpdateState[LockResUpdateCount] := EDACheckSLideUpdates( PCMSlideFields, DMax, CurDSet3, 2, 4, 3 )
      else
      begin
        FLockResUpdateState[LockResUpdateCount] := [];
// Why DB TS value is used - may be it is enough to use Slide Runtime Values
//        DMax := FieldList.Fields[3].AsDateTime; // Use Image change TimeStamp
        DMax := Max(CMSDTImgMod, Max(CMSDTPropMod,CMSDTMapRootMod)); // Max of 3 Slide TimeStamps
      end;
      LockResState[LockResCount - 1].LSUpdate := FLockResUpdateState[LockResUpdateCount];
      LockResState[LockResCount - 1].LSDTMod := DMax;
      LockResState[LockResCount - 1].LSProvIDMod := FieldList.Fields[5].AsInteger;
      LockResState[LockResCount - 1].LSLocIDMod := FieldList.Fields[6].AsInteger;
      LockResState[LockResCount - 1].LSCompIDMod := EDAGetStringFieldValue(FieldList.Fields[7]);

      // LockResultUpdateState[LockResCount - 1] := FLockResUpdateState[LockResUpdateCount];
      if [K_dbusOldProps,K_dbusNewProps,
          K_dbusOldMapRoot,K_dbusNewMapRoot,
          K_dbusOldCurImg,K_dbusNewCurImg] *  FLockResUpdateState[LockResUpdateCount] <> [] then
      begin
        FLockResUpdate[LockResUpdateCount] := APSlide^;
        Inc(LockResUpdateCount);
      end;
    end;
  end; // procedure CheckSLideUpdates

  function IsDeletedSlideUsed( ALockState: Integer ): Boolean;
  begin
    Result := (APSlide.CMSlideEdState <> K_edsFullAccess) and
              not K_CMGAModeFlag;
//              not K_CMEnterpriseGAModeFlag;
//    Result := APSlide.CMSlideEdState <> K_edsFullAccess;
    if not Result then
    begin
      Result := IfSlideActiveLockRecordExists(ALockState);
      if not Result then
        Exit;
      with CurDSet1 do
        N_Dump2Str('DB>> Slide ID=' + SlideID +
            ' to delete is used by ProvID=' + FieldList.Fields[5].AsString +
            ' LocID=' + FieldList.Fields[6].AsString +
            ' Comp=' +  EDAGetStringFieldValue(FieldList.Fields[7]) +
            ' ClientAppGlobID=' + FieldList.Fields[4].AsString);
      Inc(LockResDelUsedByOtherCount); // Slide which is used by other user during deletion
    end
    else
    begin
      with APSlide.P^ do
        N_Dump2Str('DB>> Slide ID=' + SlideID +
                     ' to delete on Loc=' + IntToStr(CurLocID) +
                     ' is from another HLoc=' + IntToStr(CMSLocIDHost) );
      Inc(LockResDelNotHostLoc); // Slide from anoter Location
    end;
    Dec(LockResCount); // Remove Slide From Resulting List
  end; // function IsDeletedSlideUsed

begin
  // !!! for skip real lock
  // Result := inherited EDALockSlides( APSlide, ALockResultMode, ASlidesCount );
  // Exit;
  SSelfAppRTID := IntToStr(AppRTID);
  N_Dump2Str('DB>> EDALockSlides ActRTID=' + SSelfAppRTID);
  DeadlockCount := 0;
  with CurSQLCommand1 do
  begin
    // Lock Active Instance Table in exclusive mode
    Connection := LANDBConnection;
    CommandText := EDADBIsolationLevelSet(K_tilSerializable);
    Execute;
  end;

DeadlockLoop: //******
  LockOKFlag := FALSE;
  Result := K_edOK;

  try
    LANDBConnection.BeginTrans;

{
    if not LockSlidesTableFlag then
    with CurSQLCommand1 do
    begin
      // Lock Active Instance Table in exclusive mode
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
      // 'LOCK TABLE ' + K_CMENDBLockSlidesTable + ' IN EXCLUSIVE MODE;';
      // 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
      LockSlidesTableFlag := TRUE;
    end;
}


// K_CMShowMessageDlg( '1',  mtInformation ); // debug
    with CurDSet1 do
    begin
      // Select all records from Locked Slides Table
      Connection := LANDBConnection;

      SQLStr := 'select ' +
  'B.' + K_CMENDBLSlidesTFSlideID + ',' +  // 0
  'B.' + K_CMENDBLSlidesTFActRTID + ',' +  // 1
  'B.' + K_CMENDBLSlidesTFLockFlag + ',' + // 2
  'I.' + K_CMENDBAAInstsTFActTS + ',' +    // 3
  'I.' + K_CMENDBAAInstsTFGlobID + ',' +   // 4
  'I.' + K_CMENDBAAInstsTFProvID + ',' +   // 5
  'I.' + K_CMENDBAAInstsTFLocID + ',' +    // 6
  'G.' + K_CMENDBGAInstsTFCName;           // 7
      if K_CMEDDBVersion >= 15 then
        SQLStr := SQLStr + ',I.' + K_CMENDBAAInstsTFActFlags; // 8
      SQL.Text := SQLStr +
    ' from ' +  K_CMENDBLockSlidesTable + ' B,' + K_CMENDBAAInstsTable + ' I,' + K_CMENDBGAInstsTable + ' G' +
    ' where ' + 'B.' + K_CMENDBLSlidesTFActRTID + '='
              + 'I.' + K_CMENDBAAInstsTFActRTID +
              ' and '
              + 'I.' + K_CMENDBAAInstsTFGlobID + '=' +
                'G.' + K_CMENDBGAInstsTFGlobID;
      // N_S := SQL.Text;
      Filtered := false;
      Open;
    end; // with CurDSet1 do

//K_CMShowMessageDlg( '2',  mtInformation ); // debug

    with CurDSet3 do
    begin // Use CurDSet3 because CurSlidesDSet is used inside K_CMGetMediaFileName
      // Select records for Slides of Current Patient from All SLides Table
      SPatID := IntToStr(CurSlidesSelectAttrs.SSPatID);
      Connection := LANDBConnection;
      WPSlide := APSlide;

      //  Build AllSlides Table Subquery SQL
      SQLStr0 := 'select ' +
  K_CMENDBSTFSlideID        + ',' + K_CMENDBSTFPatID          + ',' + // 0,1
  K_CMENDBSTFSlideDTProp    + ',' + K_CMENDBSTFSlideDTImg     + ',' + // 2,3
  K_CMENDBSTFSlideDTMapRoot + ',' +                                   // 4
  K_CMENDBSTFSlideProvIDMod + ',' + K_CMENDBSTFSlideLocIDMod  + ',' + // 5,6
  K_CMENDBSTFSlideCompMod   + ',';                                    // 7

      if K_CMEnterpriseModeFlag then
        SQLStr0 :=  SQLStr0 + K_CMENDBSTFSlideLocIDHost + ','  // 8
      else
      if K_CMEDDBVersion >= 41 then
        SQLStr0 :=  SQLStr0 + K_CMENDBSTFSlideDTArch + ','       // 8
      else
        SQLStr0 :=  SQLStr0 + '0,';                            // 8

      if K_CMEDDBVersion >= 10 then
        SQLStr0 := SQLStr0 + K_CMENDBSTFSlideFlags                   // 9
      else
        SQLStr0 :=  SQLStr0 + '0';                                   // 9

      SQLStr0 :=  SQLStr0 +  ' from ' + K_CMENDBSlidesTable + ' where ';

      if APatID <> -1 then
      begin
        SQLStr := ' and ';
        SQLStr0 := SQLStr0 + K_CMENDBSTFPatID + ' = ' + IntToStr(APatID) +
                   K_CMEDAGetSlideSelectWhereStr( K_swfSkipDBDeleting )
      end
      else
        SQLStr := ' ';

      SQLStr0 := SQLStr0 + SQLStr;

      //  Build Slides List Select Condition
      EDABuildSelectSQLBySlidesList( WPSlide, ASlidesCount, @SQLStr, nil );

      //  Build Resulting SQL
      if not K_CMEnterpriseModeFlag then
        SQL.Text := SQLStr0 + '( ' + SQLStr + ' )'
      else
      ////////////////////
      // Enterprise Mode
      if K_CMEDDBVersion < 41 then
        SQL.Text := 'select ' +
  'S.'+K_CMENDBSTFSlideID        + ',' + 'S.'+K_CMENDBSTFPatID          + ',' + // 0,1
  'S.'+K_CMENDBSTFSlideDTProp    + ',' + 'S.'+K_CMENDBSTFSlideDTImg     + ',' + // 2,3
  'S.'+K_CMENDBSTFSlideDTMapRoot + ',' +                                        // 4
  'S.'+K_CMENDBSTFSlideProvIDMod + ',' + 'S.'+K_CMENDBSTFSlideLocIDMod  + ',' + // 5,6
  'S.'+K_CMENDBSTFSlideCompMod  +  ',' + 'S.'+K_CMENDBSTFSlideLocIDHost + ',' + // 7,8
  'S.'+K_CMENDBSTFSlideFlags    +  ',' + 'Q.' + K_CMENDBLFILocSlideTS  +        // 9,10
  ' from (' + SQLStr0 + '( ' + SQLStr + ' ) ) S ' +
  ' left outer join ' +
        '( select '  + K_CMENDBLFILocSlideID + ', ' + K_CMENDBLFILocSlideTS +
           ' from '  + K_CMENDBLocFilesInfoTable +
           ' where ' + K_CMENDBLFILocID + ' = ' + IntToStr(CurLocID) +
           ' ) Q ' +
//           ' and ( ' + SQLStr + ' ) ) Q ' +
  ' on S.' + K_CMENDBSTFSlideID + ' = Q.' + K_CMENDBLFILocSlideID;
      // Enterprise Mode
      ////////////////////

//  N_s := SQL.Text;
      Filtered := false;
      Open;
//   N_i := RecordCount;
    end; // with CurDSet3 do

    // CDTime := Now();
    CDTime := EDAGetSyncTimestamp();
    FLockedCount := 0;
    if Length(LockResSlides) < ASlidesCount then
    begin
      SetLength(LockResSlides, ASlidesCount);
      SetLength(LockResState, ASlidesCount);
      // SetLength( LockResultUpdateState, ASlidesCount );
      // SetLength( LockResultSrcInds, ASlidesCount );
    end;
    LockResCount := 0;

    if Length(LockResDelSlides) < ASlidesCount then
      SetLength(LockResDelSlides, ASlidesCount);
    LockResDelCount := 0;

    if Length(LockResMarkAsDelSlides) < ASlidesCount then
      SetLength(LockResMarkAsDelSlides, ASlidesCount);
    LockResMarkAsDelCount := 0;

    if Length(LockResSkipOpenSlides) < ASlidesCount then
      SetLength(LockResSkipOpenSlides, ASlidesCount);
    LockResSkipOpenCount := 0;

    if Length(FLockResUpdate) < ASlidesCount then
    begin
      SetLength(FLockResUpdate, ASlidesCount);
      SetLength(FLockResUpdateState, ASlidesCount);
    end;

    LockResUpdateCount := 0;
    LockResUpdateThumbCount := 0;
    LockResUpdateOpenImgCount := 0;
    LockResUpdateStudyCount := 0;
    LockResDelUsedByOtherCount := 0;
    LockResDelNotHostLoc := 0;
    LockResMediaCreatedOnOtherCount := 0;

    case ALockResultMode of
      // K_cmlrmExclusive,
      K_cmlrmDeleteLock:
        ILockState := K_cmlsLockedExclusive;
      K_cmlrmMarkAsDelLock,
      K_cmlrmEditAllLock,
      K_cmlrmEditImgLock,
      K_cmlrmEditPropLock,
      K_cmlrmDBRecoveryLock,
      K_cmlrmEditStudyLock:
        ILockState := K_cmlsLocked;
    else
      ILockState := K_cmlsUsed;
    end;

    //////////////////////////////////
    // SLides Lock Loop
    //
    for i := 1 to ASlidesCount do
    begin
      SlideID := APSlide.ObjName;
      PCMSlideFields := APSlide.P();

      LockResSlides[LockResCount] := APSlide^;
      LockResState[LockResCount].LSUpdate := [];
      LockResState[LockResCount].LSSrcInd := i - 1;
      LockResState[LockResCount].LSDTMod := 0;
      LockResState[LockResCount].LSProvIDMod := -1;
      LockResState[LockResCount].LSLocIDMod := -1;
      LockResState[LockResCount].LSCompIDMod := '';
      LockResState[LockResCount].LSProvIDLock := -1;
      LockResState[LockResCount].LSLocIDLock := -1;
      LockResState[LockResCount].LSCompIDLock := '';
      LockResState[LockResCount].LSCMSRFlags  := PCMSlideFields.CMSRFlags;

      // LockResultUpdateState[LockResCount] := [];
      // LockResultSrcInds[LockResCount] := i - 1;
      Inc(LockResCount);

      LockResultMode := ALockResultMode;
      LockState := ILockState;

      if cmsfIsLocked in PCMSlideFields.CMSRFlags then
      begin
        // Locked Slide - has Self Lock Record
        if (LockResultMode = K_cmlrmMarkAsDelLock) or
           ( (LockResultMode = K_cmlrmDeleteLock) and
             not IsDeletedSlideUsed( -1 ) ) then
        begin
          SelectItemLocRecord();
          EditExistingLockRecord();
        end;
        goto LoopCont;
      end;

      with CurDSet3 do
      begin
        // Check if Slide existed
        Filtered := false;
        Filter := K_CMENDBSTFSlideID + ' = ' + SlideID;
        Filtered := TRUE;
        if RecordCount = 0 then
        begin
          // Slide was deleted by other Application
          AddSlideToDeletedList();
          goto LoopCont;
        end   // if RecordCount = 0 then
        else
        begin // if RecordCount <> 0 then

          APSlide.CMSDBStateFlags := TN_CMSlideDBFlags(Byte(FieldList.Fields[9].AsInteger));

          if K_CMEnterpriseModeFlag then
          begin
          // Refresh Slide State
             // if Slide Image changed DT > LocSlideTS then Slide EdState = K_edsSkipOpen
             APSlide.CMSlideEdState := K_edsSkipOpen;
             if FieldList.Fields[3].AsDateTime = FieldList.Fields[10].AsDateTime then
             begin
               APSlide.CMSlideEdState := K_edsSkipChanges;
               if FieldList.Fields[8].AsInteger = CurLocID then
                 APSlide.CMSlideEdState := K_edsFullAccess; // Slide Host Location = Current Location
             end;
          end;
        end; // if RecordCount <> 0 then

      end; // with CurDSet3 do

      // Process not Locked existing Slides
      if IfSlideActiveLockRecordExists(Ord(K_cmlsLockedExclusive)) then
      begin
        // Slide is Exclusivly locked for deletion by other Application
        AddSlideToDeletedList();
        goto LoopCont;
      end;

      // Process not Locked existing Slides (without Exclusivly Locked)
      with PCMSlideFields^ do
        if cmsfIsMediaObj in CMSDB.SFlags then
        begin
          // Media Slide Processing
          if LockResultMode = K_cmlrmEditAllLock then
            LockResultMode := K_cmlrmEditPropLock
          else
          if LockResultMode = K_cmlrmEditImgLock then
            LockResultMode := K_cmlrmOpenLock;
        end; // if cmsfIsMediaObj in CMSDB.SFlags then

      if LockResultMode = K_cmlrmEditAllLock then
        LockResultMode := K_cmlrmEditImgLock; // For Image Slides

      // Process not Locked existing Slides (without Exclusivly Locked and Slides without MediaFiles)
      if not K_CMMarkAsDelShowFlag and
         (LockResultMode <> K_cmlrmDeleteLock) and
         (cmsdbfMarkedAsDel in APSlide.CMSDBStateFlags) then
      begin
      // Skip Marked as deleted
        AddSlideToMarkAsDeletedList();
      end
      else
      if LockResultMode = K_cmlrmDeleteLock then
      begin
        if not IsDeletedSlideUsed(-1) then
        begin
          if (cmsfIsOpened in PCMSlideFields.CMSRFlags) or
             (cmsfIsUsed in PCMSlideFields.CMSRFlags) then
          begin
            // Process Slides, which have Self Lock Record
            SelectItemLocRecord();
            EditExistingLockRecord();
          end
          else
          begin
            // Select some not self Lock Record
            // CurDSet1 is now filtered by =SlideID and <>SSelfAppRTID
            // So it contains 0 new records or some old records
            if CurDSet1.RecordCount = 0 then // No records used Slide - add new
              AddNewLockRecord()
            else
            begin // Old Records with this slide exist - use first
              CurDSet1.First();
              EditExistingLockRecord();
            end;
          end;
          Include(PCMSlideFields.CMSRFlags, cmsfIsLocked);
        end;
      end // if LockResultMode = K_cmlrmDeleteLock then
      else
      if (LockResultMode = K_cmlrmMarkAsDelLock) then
      begin
        CurLockState := K_cmlsLocked;
        if TN_UDCMBSlide(APSlide^) is TN_UDCMStudy then
          CurLockState := K_cmlsUsed;
        if not IsDeletedSlideUsed( Ord(CurLockState) ) then
        begin
          // Lock SLide Records are not found - Lock it
          SlideLockRecordPrep();
          Include(PCMSlideFields.CMSRFlags, cmsfIsLocked);
        end;
      end // if (LockResultMode = K_cmlrmMarkAsDelLock) then
      else
      if (LockResultMode = K_cmlrmUnDelLock) then
      begin
        // Do anything only for not opened slides
        if (APSlide.CMSlideEdState = K_edsFullAccess) or
           K_CMGAModeFlag then
//           K_CMEnterpriseGAModeFlag then
        begin
          if not (cmsfIsOpened in PCMSlideFields.CMSRFlags) then
          begin
            // Not Opened SLide has no Loñk Record
            SlideLockRecordPrep();
            Include(PCMSlideFields.CMSRFlags, cmsfIsUsed);
          end
        end
        else
          Dec(LockResCount);
      end // if (LockResultMode = K_cmlrmUnDelLock) then
      else
      if (LockResultMode = K_cmlrmOpenLock) then
      begin
        // Do anything only for not opened slides
        if not(cmsfIsOpened in PCMSlideFields.CMSRFlags) then
        begin
          if APSlide.CMSlideEdState = K_edsSkipOpen then
          begin
            AddSlideToSkipOpenList();
            goto LoopCont;
          end;

          // Add Update Info
          CheckSLideUpdates();
          // Not Opened SLide has no Loñk Record
          SlideLockRecordPrep();
          Include(PCMSlideFields.CMSRFlags, cmsfIsUsed);
        end;
      end // if (LockResultMode = K_cmlrmOpenLock) then
      else
      if (LockResultMode = K_cmlrmCheckFilesLock) then
      begin // No Slides are open in Maitenance Mode
        SlideLockRecordPrep();
        Include(PCMSlideFields.CMSRFlags, cmsfIsUsed);
      end // if (LockResultMode = K_cmlrmCheckFilesLock) then
      else
      if (LockResultMode = K_cmlrmDBRecoveryLock) then
      begin  // No Slides are open in Maitenance Mode
        if not IfSlideActiveLockRecordExists(Ord(K_cmlsLocked)) then
        begin
          SelectItemLocRecord();
          EditExistingLockRecord();
          Include(PCMSlideFields.CMSRFlags, cmsfIsLocked);
        end
        else
          Dec(LockResCount);
      end // if (LockResultMode = K_cmlrmDBRecoveryLock) then
      else
      if LockResultMode = K_cmlrmEditImgLock then
      begin
        // Do anything only for not opened slides - Skip Lock and Update for Opened
        if not(cmsfIsOpened in PCMSlideFields.CMSRFlags) then
        begin
          if APSlide.CMSlideEdState = K_edsSkipOpen then
          begin
            AddSlideToSkipOpenList();
            goto LoopCont;
          end;
          // Check ExtLocked State
          if (APSlide.CMSlideEdState <> K_edsFullAccess)      or
             IfSlideActiveLockRecordExists(Ord(K_cmlsLocked)) or
             (cmsdbfMarkedAsDel in APSlide.CMSDBStateFlags) then
            LockState := K_cmlsUsed;

          // Add Update Info
          CheckSLideUpdates();

          // Not Opened SLide has no Loñk Record
          SlideLockRecordPrep();

          if LockState = K_cmlsUsed then
            Include(PCMSlideFields.CMSRFlags, cmsfIsUsed)
          else
            Include(PCMSlideFields.CMSRFlags, cmsfIsLocked);
        end;
      end // if LockResultMode = K_cmlrmEditImgLock then
      else
      if LockResultMode = K_cmlrmEditPropLock then
      begin
        // Check ExtLocked State
        if IfSlideActiveLockRecordExists(Ord(K_cmlsLocked)) then
          LockState := K_cmlsUsed
        else
          // Add Update Info
          CheckSLideUpdates();

         // Skip Edit Properties Lock if not K_edsFullAccess in Enterprise mode
        if (APSlide.CMSlideEdState <> K_edsFullAccess)   or
           (cmsdbfMarkedAsDel in APSlide.CMSDBStateFlags) then
          LockState := K_cmlsUsed;

        if (cmsfIsOpened in PCMSlideFields.CMSRFlags) then
        begin
          // Process Slides, which have Self Lock Record
          if LockState = K_cmlsLocked then
          begin
            // Set new LockState to Existing Record
            SelectItemLocRecord();
            EditExistingLockRecord();
          end
        end
        else
        begin
          // Not Opened SLide
          SlideLockRecordPrep();
        end;
        if LockState = K_cmlsUsed then
          Include(PCMSlideFields.CMSRFlags, cmsfIsUsed)
        else
          Include(PCMSlideFields.CMSRFlags, cmsfIsLocked);
      end  // if LockResultMode = K_cmlrmEditPropLock then
      else
      if LockResultMode = K_cmlrmEditStudyLock then
      begin
        // Check if already Locked
        CheckSLideUpdates();
        if not (cmsfIsLocked in PCMSlideFields.CMSRFlags) then
        begin
          // Check if is locked be other Instance
          if IfSlideActiveLockRecordExists(Ord(K_cmlsLocked)) then
            LockState := K_cmlsUsed;

          // Set new LockState
          if (LockState <> K_cmlsUsed) or                       // Set Locked is Needed
             not (cmsfIsUsed in PCMSlideFields.CMSRFlags) then  // Set Used is Needed
          begin
            SelectItemLocRecord();
            EditExistingLockRecord();
            if LockState = K_cmlsUsed then
            // Used state was set
              Include(PCMSlideFields.CMSRFlags, cmsfIsUsed)
            else
            begin
            // Locked state was set
              Include(PCMSlideFields.CMSRFlags, cmsfIsLocked);
              Exclude(PCMSlideFields.CMSRFlags, cmsfIsUsed)
            end;
          end;
        end;

      end; // if LockResultMode = K_cmlrmEditStudyLock then

    LoopCont :
      Inc(APSlide);

    end;
    //
    // end of SLides Lock Loop
    //////////////////////////////////
//??N_i2 := 99999999;
//??K_CMShowMessageDlg( 'Test Isolation Level AppRTID=' + SSelfAppRTID, mtInformation, [], FALSE, '' );
//??N_Dump1Str('DB>> EDALockSlides slide  AppRTID=' + SSelfAppRTID);


    if FLockedCount > 0 then
    begin
      CurDSet1.UpdateBatch; // Some Slide are Locked - Update DB
      N_Dump2Str('DB>> EDALockSlides Save to DB Count=' + IntToStr(FLockedCount));
    end;
    CurDSet1.Close;
    CurDSet3.Close();
//??K_CMShowMessageDlg( 'Test Isolation Level 999 AppRTID=' + SSelfAppRTID, mtInformation, [], FALSE, '' );
//??N_Dump1Str('DB>> EDALockSlides  AppRTID=' + SSelfAppRTID);

    //////////////////////////////////
    // SLides Update
    //
    if (ALockResultMode <> K_cmlrmDeleteLock)    and // Lock for deletion
       (ALockResultMode <> K_cmlrmEditAllLock)   and // Lock for ECache needs
       (ALockResultMode <> K_cmlrmUnDelLock)     and // Lock for undeletion
       (ALockResultMode <> K_cmlrmCheckFilesLock)and // Lock for Files Check
       (LockResUpdateCount > 0) then
    begin

      // Prepare SLides to Update
      SQLStr := 'select ' +
        EDAGetSlideSelectFieldsStr( [K_sffAddThumbField] ) +
        ' from ' + EDAGetSlideSelectFromStr( ) +
        ' where (' + K_CMENDBSTFSlideID + ' = ' + FLockResUpdate[0].ObjName;

      for i := 1 to LockResUpdateCount - 1 do
        SQLStr := SQLStr + ' or ' + K_CMENDBSTFSlideID + ' = ' + FLockResUpdate[i].ObjName;

      if K_CMEnterpriseModeFlag then
        EDALocFilesInfoQuery( );

      with CurSlidesDSet do
      begin
        SQL.Text := SQLStr + ')' + K_CMEDAGetSlideSelectWhereStr( K_swfSkipFlagsCond );
//        EDAGetSlideSelectWhereStr( K_swfSkipFlagsCond );
        Filtered := false;
        Open;

        // SetLength( SlideVewAttrsBuf, K_SlideViewAttsSize );

        //////////////////////////////////
        // SLides Update Loop
        //
        for i := 0 to LockResUpdateCount - 1 do
        begin
          USlide := FLockResUpdate[i];

          // Get New Field Values and Save View Attrs
          with USlide, P^ do
          begin
            // Update Attributes

            // Slide was not saved to DB (change flags means saving fails)
            if CMSRFlags * [cmsfIsNew,cmsfCurImgChanged,cmsfMapRootChanged,
                            cmsfAttribsChanged,cmsfThumbChanged] <> [] then
              Continue; // Skip Slide Update

            Filtered := false;
            Filter := K_CMENDBSTFSlideID + ' = ' + USlide.ObjName;
            Filtered := TRUE;

            FViewAttrs := CMSDB.ViewAttrs; // Save Current View Attributes
//            Move(CMSDB.ColPalInd, SlideVewAttrsBuf[0], K_SlideViewAttsSize);
            if TN_UDCMBSlide(USlide) is TN_UDCMStudy then
            begin
            // Study
              EDAStudyGetFields( TN_UDCMStudy(USlide ));
              if [K_dbusOldMapRoot,K_dbusNewMapRoot] * FLockResUpdateState[i] <> [] then
              begin
                // Update Thumbnail
                EDAGetSlideThumbnail(USlide);
                Inc(LockResUpdateThumbCount);
                Inc(LockResUpdateStudyCount);
                CMSViewUpdateFlag := TRUE;
                if cmsfIsOpened in CMSRFlags then
                begin
                  Inc(LockResUpdateOpenImgCount);
                  CMSViewRefreshFlag := TRUE;
                end;
              end
              else
              if [K_dbusOldProps,K_dbusNewProps] * FLockResUpdateState[i] <> [] then
              begin
                Inc(LockResUpdateStudyCount);
                Inc(LockResUpdateOpenImgCount);
                CMSViewUpdateFlag := TRUE;
              end
            end    // if TN_UDCMBSlide(USlide) is TN_UDCMStudy then
            else
            begin  // if TN_UDCMBSlide(USlide) is TN_UDCMSlide then
            // Slide
              EDAGetSlideFields(USlide, FALSE);
              EDAGetSlideLocFields(USlide);
              CMSDB.ViewAttrs := FViewAttrs; // Restore Current View Attributes
//              Move(SlideVewAttrsBuf[0], CMSDB.ColPalInd, K_SlideViewAttsSize);

              if [K_dbusOldMapRoot,K_dbusNewMapRoot,K_dbusOldCurImg,K_dbusNewCurImg] * FLockResUpdateState[i] <> [] then
              begin
                // Update Thumbnail
                EDAGetSlideThumbnail(USlide);
                CMSViewUpdateFlag := TRUE;
                Inc(LockResUpdateThumbCount);
                // Clear Image Data
                if [K_dbusOldCurImg,K_dbusNewCurImg] * FLockResUpdateState[i] <> [] then
                  USlide.PutDirChildSafe(K_CMSlideIndCurImg, nil);
                if [K_dbusOldMapRoot,K_dbusNewMapRoot] * FLockResUpdateState[i] <> [] then
                  USlide.PutDirChildSafe(K_CMSlideIndMapRoot, nil);
                if cmsfIsOpened in CMSRFlags then
                begin
                  Inc(LockResUpdateOpenImgCount);
                  CMSViewRefreshFlag := TRUE;
                end;
              end; // End of Update
              Include( CMSRFlags, cmsfInitUndoBuf );
            end; // if TN_UDCMBSlide(USlide) is TN_UDCMStudy then
          end; // with USlide, P^ do
        end; // for i := 0 to LockResUpdateCount - 1 do
        //
        // end of SLides Update Loop
        //////////////////////////////////
        CurSlidesDSet.Close();
      end;
      if K_CMEnterpriseModeFlag then
        CurSlidesLocDSet.Close();
    end;
    //
    // end of SLides Update
    //////////////////////////////////
    LANDBConnection.CommitTrans(); // Suggested by Lopatin always use CommitTrans instead of Rollback
//    LockSlidesTableFlag := false;

    with CurSQLCommand1 do
    begin
      CommandText := EDADBIsolationLevelDefault();
      Execute;
    end;
//K_CMShowMessageDlg( 'Test Isolation Level 000 AppRTID=' + SSelfAppRTID, mtInformation, [], FALSE, '' );

    N_Dump2Str('DB>> EDALockSlides fin');
    LockOKFlag := TRUE;
  except
    on E: Exception do
    begin
      ExtDataErrorString := E.Message;
      if (Pos( 'eadlock', E.Message ) = 0) or (DeadlockCount > 100) then
      begin
        ExtDataErrorString := 'EDALockSlides ' + ExtDataErrorString;
        Result := K_edExDataError;
        EDAShowErrMessage(TRUE);
      end
      else
        Inc(DeadlockCount);
    end;

  end; // Try/Except

//  if not LANDBConnection.InTransaction then Exit;
  if LockOKFlag then Exit; //
  N_Dump1Str( format( 'DB>> EDALockSlides E.Count=%d >> %s',
                      [DeadlockCount,ExtDataErrorString] ) );

  LANDBConnection.RollbackTrans;
//??K_CMShowMessageDlg( 'Test Isolation Level 111 AppRTID=' + SSelfAppRTID, mtInformation, [], FALSE, ''  );
//??N_i2 := 0;

  for i := 0 to LockResCount - 1 do
  begin
    // Restore Initial Slide Runtime Flags
    LockResSlides[i].P()^.CMSRFlags := LockResState[i].LSCMSRFlags;
    // Restore Initial Pointer to source Slides array
    Dec(APSlide);
  end;
  sleep(100);
  goto DeadlockLoop;
end; // end of TK_CMEDDBAccess.EDALockSlides

//********************************************* TK_CMEDDBAccess.EDAUnlockSlides ***
// Unlock given slides after edit
//
//     Parameters
// APSlide - pointer to slides array start element to lock
// ASlidesCount - number of slides to lock
// ALockResultMode - Unlock Mode
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAUnlockSlides( APSlide: TN_PUDCMSlide;
                                          ASlidesCount: Integer;
                                          ALockResultMode: TK_CMEDLockResultMode ) : TK_CMEDResult;
var
  SAppRTID: string;
  i, LockedCount: Integer;
  SlideID: string;
  RemoveLockRecord: Boolean;
  PCMSlide : TN_PCMSlide;
  ChangeLockState: Boolean;

label LoopCont;
begin
  // !!! for skip real unlock
  // Result := inherited EDAUnlockSlides( APSlide, ASlidesCount );
  // Exit;

  Result := K_edOK;

  SAppRTID := IntToStr(AppRTID);
  N_Dump2Str('DB>> EDAUnlockSlides ActRTID=' + SAppRTID);
  try
{!!! Transaction and isolation_level not needed
    LANDBConnection.BeginTrans;

    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
      CommandText := EDADBIsolationLevelSet(K_tilSerializable);
      // 'LOCK TABLE ' + K_CMENDBLockSlidesTable + ' IN EXCLUSIVE MODE;';
      // 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end;
{}
    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SQL.Text := 'select ' +
        K_CMENDBLSlidesTFSlideID + ',' +  // 0
        K_CMENDBLSlidesTFActRTID + ',' +  // 1
        K_CMENDBLSlidesTFLockFlag +       // 2
        ' from ' + K_CMENDBLockSlidesTable +
        ' where ' + K_CMENDBLSlidesTFActRTID + '=' + SAppRTID;
      Filtered := false;
      Open;

      LockedCount := 0;
      for i := 1 to ASlidesCount do
      begin
        SlideID := APSlide.ObjName;
        PCMSlide := APSlide.P();
        with PCMSlide^ do
        begin
        ///////////////////////////////
        //  Analize Unlock possibility
        //
          RemoveLockRecord := FALSE;
          ChangeLockState := ALockResultMode = K_cmlrmSaveOpenLock;
          if ChangeLockState then
          begin
            Exclude(CMSRFlags, cmsfIsLocked);
            Include(CMSRFlags, cmsfIsUsed);
          end
          else
          begin // not ChangeLockState
            if (cmsfIsOpened in CMSRFlags) then
              goto LoopCont; // unlock is not available
            RemoveLockRecord := cmsfIsUsed in CMSRFlags;
            Exclude(CMSRFlags, cmsfIsUsed);
            if ALockResultMode = K_cmlrmOpenLock then
            begin
              if not RemoveLockRecord then
                goto LoopCont; // Slide is already unlocked
            end // if ALockResultMode = K_cmlrmOpenLock
            else
            begin // if ALockResultMode <> K_cmlrmOpenLock
              if (cmsfIsLocked in CMSRFlags) and
                 not(cmsfSkipUnlock in CMSRFlags) then
              begin
                RemoveLockRecord := TRUE;
                Exclude(CMSRFlags, cmsfIsLocked);
              end;
            end; // if ALockResultMode <> K_cmlrmOpenLock
          end;
        end; // with PCMSlide^ do

        if not RemoveLockRecord and not ChangeLockState then
          goto LoopCont;
        //
        //  Analize Unlock possibility
        ///////////////////////////////

        //////////////////////////////////////////
        // Delete from or Change Lock State in DB
        //
        Filtered := FALSE;
        Filter := K_CMENDBLSlidesTFSlideID + ' = ' + SlideID;
        Filtered := TRUE;
        if RecordCount = 0 then
        begin
          // Try to unlock not locked SLide
          ExtDataErrorString :=
            'Unlock Slide. Unlock not locked slide ID=' + SlideID +
            ' by ActRTID=' + SAppRTID;
          Close;
          raise Exception.Create(ExtDataErrorString);
        end;
        N_Dump2Str('DB>> Unlock Slide. ID=' + SlideID + ' by ActRTID=' +
            SAppRTID);

        if ChangeLockState then
        begin
          ExtDataErrorCode := K_eeDBEdit;
          Edit();
          Fields[2].AsInteger := Ord(K_cmlsUsed);
        end
        else
        begin
          ExtDataErrorCode := K_eeDBDel;
          Delete();
        end;
        Inc(LockedCount);
        //
        // end of Delete from or Change Lock State in DB
        //////////////////////////////////////////

LoopCont:
        Inc(APSlide);
      end; // end of Slides Loop for i := 1 to ASlidesCount do

      if LockedCount > 0 then
        UpdateBatch;
      Close;
    end; // with CurDSet1 do

{!!! Transaction and isolation_level not needed
   LANDBConnection.CommitTrans(); // Suggested by Lopatin always use CommitTrans instead of Rollback)

   with CurSQLCommand1 do
    begin
      CommandText := EDADBIsolationLevelDefault();
      Execute;
    end;
{}
    N_Dump2Str('DB>> EDAUnlockSlides fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAUnlockSlides ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAUnlockSlides

//********************************************* TK_CMEDDBAccess.EDAClearDeletedSlides ***
// Clear Deleted  Slides from External Data
//
//     Parameters
// AMarkAsDelFlag - if = TRUE then only mark as deleted is needed
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAClearDeletedSlides( AMarkAsDelFlag : Boolean ): TK_CMEDResult;
var
  i: Integer;
  UDSlide: TN_UDCMSlide;
  SavedCursor: TCursor;
  SQLStr, LastSQL, StartSQL: string;
  FileName: string;
  LogStr, AddLog: string;
  DelHistAddCode, DelHistCode : Integer;
  DelTS : TDateTime;
  SlideIDs : TN_SArray;
  PCMSlide : TN_PCMSlide;
  UFL : TStringList;


  procedure ClearDelSlide(Ind: Integer);

  begin
    UDSlide := TN_UDCMSlide(DelSlidesList[Ind]);
    PCMSlide := UDSlide.P;
    with PCMSlide^ do
      if (cmsfIsLocked in CMSRFlags) and not AMarkAsDelFlag then
      begin
        if cmsfIsMediaObj in CMSDB.SFlags then
          EDADelSlideMediaFiles(UDSlide)
          // K_CMDeleteClientMediaFile( UDSlide )
        else
        if cmsfIsImg3DObj in CMSDB.SFlags then
        begin
// 2020-07-28 add Capt3DDevObjName <> '' if CMSDB.Capt3DDevObjName = '' then
// 2020-09-25 add new condition for Dev3D objs
          if (CMSDB.Capt3DDevObjName = '') or (CMSDB.MediaFExt = '') then
            EDADelSlideImg3DFiles(UDSlide)
        end
        else
        if K_CMEDDBVersion >= 3 then
        begin
          // Delete SLide ImageFiles
          EDADelSlideImgFiles(UDSlide);
        end;
{
        if SQLStr <> '' then
        begin
          SQLStr := SQLStr + ' or ';
          LogStr := LogStr + ','
        end;
        with UDSlide do
        begin
          LogStr := LogStr + ObjName;
          SQLStr := SQLStr + K_CMENDBSTFSlideID + ' = ' + ObjName;
        end;
}
      end;
    EDASaveSlideHistBuffer( UDSlide, DelHistCode );
    EDAClearSlideECache(UDSlide);

    SlideIDs[i] := UDSlide.ObjName;

    if not AMarkAsDelFlag or not K_CMMarkAsDelShowFlag then
      UDSlide.UDDelete() // Delete Slide which is not saved in archive
    else
    begin
      Include( UDSlide.CMSDBStateFlags, cmsdbfMarkedAsDel );
      UDSlide.P.CMSRFlags := UDSlide.P.CMSRFlags - [cmsfIsLocked,cmsfIsUsed];
    end;
    DelSlidesList.Delete(Ind);
  end;

begin
  Result := K_edOK;
  if UndeletedFileNames <> nil then
  begin
    with UndeletedFileNames do
      for i := SL.Count - 1 downto 0 do
      begin
        FileName := SL[i];
        if not FileExists(FileName) or DeleteFile(FileName) then
        begin
          SL.Delete(i);
          if K_StrStartsWith(SlidesClientMediaRootFolder, FileName) then
            EDARemovePathFolders0(FileName, SlidesClientMediaRootFolder);
        end;
      end;
  end;

  if DelSlidesList.Count = 0 then
    Exit;
  SavedCursor := Screen.Cursor;
  Screen.Cursor := crHourglass;
  try
    UFL := TStringList.Create;
    K_UnDeletedFileNames := UFL;

//    K_UnDeletedFileNames := UndeletedFileNames.SL;
//    SQLStr := '';
//    LogStr := 'Slides IDs=';

    EDABuildSelectSQLBySlidesList( TN_PUDCMSlide(@DelSlidesList.List[0]),
                                   DelSlidesList.Count, @SQLStr, @LogStr );

    DelHistAddCode := 0;
    if K_CMSCreateDeleteMode = 0 then
    begin
      DelHistCode := Ord(K_shCADelete);
      if AMarkAsDelFlag then
        DelHistCode := Ord(K_shCADelMark);
    end
    else if K_CMSCreateDeleteMode = 1 then
      DelHistCode := Ord(K_shCADeleteIAC)
    else // Delete during DB Integrity Check
    begin
      DelHistCode := Ord(K_shCADBRecovery);
      DelHistAddCode := Ord(K_shRDBDelete);
    end;
    DelHistCode := EDABuildHistActionCode( K_shATChange, DelHistCode, DelHistAddCode );


    SetLength( SlideIDs, DelSlidesList.Count );
    for i := DelSlidesList.Count - 1 downto 0 do
    begin
      if not GUISilentFlag then
        N_CM_MainForm.CMMFShowString( format( K_CML1Form.LLLSlidesDel4.Caption,
//            ' %d media object(s) to delete is needed ... Please wait',
            [i + 1] ) );
      ClearDelSlide(i);
    end;
    AddLog := ' Delete for ever';
    if AMarkAsDelFlag then
      AddLog := ' Mark as deleted';
    if K_CMEnterpriseModeFlag then
      AddLog := AddLog + ' in Enterprise Mode';
    N_Dump1Str('DB>> EDAClearDeletedSlides ' + LogStr + AddLog );

    if UFL.Count > 0 then
    begin
      N_Dump1Str('DB>> !!!Undeleted files:'#13#10 + UFL.Text );
      UndeletedFileNames.SL.AddStrings(UFL);
    end;

    UFL.Free;
    K_UnDeletedFileNames := nil;

    if SQLStr <> '' then
    begin // Nothing to do if SQLStr = ''

//      StartSQL := 'LOCK TABLE ' + K_CMENDBLockSlidesTable + ' IN EXCLUSIVE MODE;' + Chr($0A);
      StartSQL := EDADBIsolationLevelSet(K_tilSerializable) + Chr($0A);
      LastSQL := '';
      if AMarkAsDelFlag then
      // Mark as Deleted
        StartSQL := StartSQL + 'UPDATE ' + K_CMENDBSlidesTable +
          ' SET ' + K_CMENDBSTFSlideFlags + ' = 1 WHERE ' +  SQLStr + ';' + Chr($0A)
      else
      begin
      // Delete forever
        LastSQL := 'DELETE FROM ' + K_CMENDBDelMarkedSlidesTable +
                   ' WHERE ' + SQLStr + ';' + Chr($0A);

        if not K_CMEnterpriseModeFlag then
        begin
          StartSQL := StartSQL + 'DELETE FROM ' + K_CMENDBSlidesTable + ' WHERE ' +  SQLStr + ';' + Chr($0A)
        end
        else
        begin // Enterprise Mode
          StartSQL := StartSQL +
          'UPDATE ' + K_CMENDBSlidesTable + ' SET ' + K_CMENDBSTFSlideFlags + ' = 2 WHERE ' +  SQLStr+ ';' + Chr($0A) +
          'DELETE FROM ' + K_CMENDBLocFilesInfoTable +
          ' WHERE ' + K_CMENDBLFILocID + '=' + IntToStr(CurLocID) +
          ' and (' +  SQLStr + ');';

          LastSQL := LastSQL + 'DELETE FROM ' + K_CMENDBSlidesTable +
           ' WHERE NOT EXISTS( SELECT 1 ' + ' FROM ' + K_CMENDBLocFilesInfoTable +
                  ' WHERE ' + K_CMENDBLocFilesInfoTable +'.'+ K_CMENDBLFILocSlideID + '=' +
                              K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideID + ');' + Chr($0A);
        end;

      end;

      LastSQL := LastSQL +
       'DELETE FROM ' + K_CMENDBLockSlidesTable +
       ' WHERE ' + K_CMENDBLSlidesTFActRTID + '=' + IntToStr(AppRTID) +
       ' and  ( ' + SQLStr + ' );';

      LANDBConnection.BeginTrans;
      with CurSQLCommand1 do
      begin
        if not AMarkAsDelFlag then
        begin
        // Delete forever
          CommandText := 'BEGIN' + Chr($0A) +
                         StartSQL + Chr($0A) +
                         LastSQL + Chr($0A) + 'END';
          Execute;
        end
        else
        begin
        // Mark as Deleted
          CommandText := 'BEGIN' + Chr($0A) + StartSQL + Chr($0A) + 'END';
          Execute;
          DelTS := EDAGetSyncTimestamp();
          with CurDSet3 do
          begin
            ExtDataErrorCode := K_eeDBSelect;
            SQL.Text := 'select ' + K_CMENDMSlideID + ',' + K_CMENDMTS +
            ' from ' + K_CMENDBDelMarkedSlidesTable +
            ' where ' + K_CMENDMSlideID + '=-1';
            Filtered := FALSE;
            Open;
            ExtDataErrorCode := K_eeDBIns;
            for i := 0 to High(SlideIDs) do
            begin
              Insert;
              FieldList.Fields[0].AsString := SlideIDs[i];
              FieldList.Fields[1].AsDateTime := DelTS;
            end;
            UpdateBatch();
            Close;
          end;
          CommandText := 'BEGIN' + Chr($0A) +
                            LastSQL + Chr($0A) +
                            EDADBIsolationLevelDefault() + Chr($0A) +
                         'END';
          Execute;
        end;
      end;
      LANDBConnection.CommitTrans;
    end;
    Screen.Cursor := SavedCursor;
    N_Dump2Str('DB>> EDAClearDeletedSlides fin');
  except
    on E: Exception do
    begin
      Screen.Cursor := SavedCursor;
      ExtDataErrorString := 'EDAClearDeletedSlides ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAClearDeletedSlides

//********************************************* TK_CMEDDBAccess.EDAUnDeleteSlides ***
// Remove Deletion Mark from given slides
//
//     Parameters
// APSlides   - slides array start element to undelete
// APSlidesCount - slides to email counter
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAUnDeleteSlides( APSlides: TN_PUDCMSlide; ASlidesCount: Integer ): TK_CMEDResult;
var
  SQLStr: string;
  LogStr: string;
  SavedCursor: TCursor;
  i : Integer;
  WPSlides: TN_PUDCMSlide;
begin
  Result := K_edOK;
  EDABuildSelectSQLBySlidesList( APSlides, ASlidesCount, @SQLStr, @LogStr );
  N_Dump2Str('DB>> EDAUnDeleteSlides ' + LogStr);
  if ASlidesCount = 0 then Exit;

  WPSlides := APSlides;
  for i := 0 to ASlidesCount - 1 do
  begin
    Exclude( APSlides^.CMSDBStateFlags, cmsdbfMarkedAsDel );
    Inc(APSlides);
  end;

  SQLStr := ' WHERE ' + SQLStr + ';' + Chr($0A);

  SavedCursor := Screen.Cursor;
  Screen.Cursor := crHourglass;
  try
    LANDBConnection.BeginTrans; //!!! May be not needed for one SQL command
    with CurSQLCommand1 do
    begin
      CommandText :=
  'BEGIN' + Chr($0A) +
//  'LOCK TABLE ' + K_CMENDBLockSlidesTable + ' IN EXCLUSIVE MODE;' + Chr($0A) +
  'UPDATE ' + K_CMENDBSlidesTable + ' SET ' + K_CMENDBSTFSlideFlags + ' = 0' + SQLStr +
  'DELETE FROM ' + K_CMENDBDelMarkedSlidesTable + SQLStr +
  'END';
      Execute;
    end;
    LANDBConnection.CommitTrans; //!!! May be not needed for one SQL command

    EDASaveSlidesListHistory( WPSlides, ASlidesCount,
         EDABuildHistActionCode(K_shATChange, Ord(K_shCADelUnMark)) );

    Screen.Cursor := SavedCursor;
  except
    on E: Exception do
    begin
      Screen.Cursor := SavedCursor;
      ExtDataErrorString := 'EDAUnDeleteSlides ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAUnDeleteSlides

//********************************************* TK_CMEDDBAccess.EDAClearLocDelSlides ***
// Remove Deleted Slides Records and Files in Current Location
//
//     Parameters
// AClearNum - number of slides to clear
// Result - Returns operation resulting code
//
//  !!! Not Used now
function TK_CMEDDBAccess.EDAClearLocDelSlides( AClearNum : Integer ): TK_CMEDResult;
var
  i: Integer;
  SavedCursor: TCursor;
  SQLStr: string;
  FileName: string;
  LogStr: string;

begin
  Result := K_edOK;
  N_Dump2Str('DB>> EDAClearLocDeletedSlides start' );

  if UndeletedFileNames <> nil then
  begin
    with UndeletedFileNames do
      for i := SL.Count - 1 downto 0 do
      begin
        FileName := SL[i];
        if not FileExists(FileName) or DeleteFile(FileName) then
        begin
          SL.Delete(i);
          if K_StrStartsWith(SlidesClientMediaRootFolder, FileName) then
            EDARemovePathFolders0(FileName, SlidesClientMediaRootFolder);
        end;
      end;
  end;

  SavedCursor := Screen.Cursor;
  Screen.Cursor := crHourglass;
  try

  // Get Deleted Slides with Undeleted Files in Current Location
    with CurDSet2 do
    begin
      Connection := LANDBConnection;
//      SQL.Text := 'select ' +
      SQL.Text := 'select top ' + IntToStr(AClearNum) + ' ' +
  K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideID + ',' +
  K_CMENDBSlidesTable +'.'+ K_CMENDBSTFPatID + ',' +
  K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideDTCr + ',' +
  K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideSysInfo +
        ' from ' + K_CMENDBSlidesTable + ',' + K_CMENDBLocFilesInfoTable +
        ' where ' + K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideFlags + '=2' +
        ' and ' + K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideID + '=' + K_CMENDBLocFilesInfoTable +'.'+ K_CMENDBLFILocSlideID +
        ' and ' + K_CMENDBLocFilesInfoTable +'.'+ K_CMENDBLFILocID + '=' + IntToStr(CurLocID);
      Filtered := false;
//      N_s := SQL.Text;
      Open;
      SQLStr := '';
      LogStr := '';
      while not Eof do
      begin
        CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1,
            N_UDCMSlideCI));
        with CurSlide, P^ do
        begin
          ObjName := FieldList[0].AsString;
          CMSPatID := FieldList[1].AsInteger;
          CMSDTCreated := TDateTimeField(FieldList[2]).Value;
          K_CMEDAGetSlideSysFieldsData(EDAGetStringFieldValue(FieldList[3]), @CMSDB);
          if cmsfIsMediaObj in CMSDB.SFlags then
            EDADelSlideMediaFiles(CurSlide)
          else
          if cmsfIsImg3DObj in CMSDB.SFlags then
          begin
// 2020-07-28 add Capt3DDevObjName <> '' if CMSDB.Capt3DDevObjName = '' then
// 2020-09-25 add new condition for Dev3D objs
            if (CMSDB.Capt3DDevObjName = '') or (CMSDB.MediaFExt = '') then
              EDADelSlideImg3DFiles(CurSlide)
          end
          else
          begin
            // Delete SLide ImageFiles
            EDADelSlideImgFiles(CurSlide);
          end;
          if SQLStr <> '' then
          begin
            SQLStr := SQLStr + ' or ';
            LogStr := LogStr + ','
          end;
          LogStr := LogStr + ObjName;
          SQLStr := SQLStr + K_CMENDBSTFSlideID + '=' + ObjName;
          UDDelete();
        end; // with CurSlide, P^ do
        Next;
      end; // while not Eof do
      Close();
      CurSlide := nil;
    end; // with CurDSet2 do

    K_UnDeletedFileNames := UndeletedFileNames.SL;
    N_Dump2Str('DB>> EDAClearLocDeletedSlides ' + LogStr);
    if SQLStr <> '' then
    begin
      K_UnDeletedFileNames := nil;
      SQLStr := 'DELETE FROM ' + K_CMENDBLocFilesInfoTable +
                       ' WHERE ' + K_CMENDBLFILocID + '=' + IntToStr(CurLocID) +
                       ' and (' +  SQLStr + ');' + Chr($0A);
    end;

    with CurSQLCommand1 do
    begin
      CommandText := 'BEGIN' + Chr($0A) + SQLStr +
         'DELETE FROM ' + K_CMENDBSlidesTable +
         ' WHERE NOT EXISTS( SELECT 1 FROM ' + K_CMENDBLocFilesInfoTable +
              ' WHERE ' + K_CMENDBLocFilesInfoTable +'.'+ K_CMENDBLFILocSlideID + '=' +
                          K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideID + ');' + Chr($0A) +
          'END';
      Execute;
    end;

    Screen.Cursor := SavedCursor;
    N_Dump2Str('DB>> EDAClearLocDeletedSlides fin');
  except
    on E: Exception do
    begin
      Screen.Cursor := SavedCursor;
      ExtDataErrorString := 'EDAClearLocDeletedSlides ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAClearLocDelSlides

//********************************************* TK_CMEDDBAccess.EDAClearMarkAsDelSlides ***
// Remove Marked as Deleted Slides Records and Files in Current Location after time delta
//
//     Parameters
// AClearNum - number of slides to clear
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAClearMarkAsDelSlides( AClearNum : Integer ): TK_CMEDResult;
var
  i: Integer;
  SavedCursor: TCursor;
  SQLStr: string;
  Slides : TN_UDCMSArray;
  SaveGAMode : Boolean;

begin
  Result := K_edOK;
  N_Dump2Str('DB>> EDAClearMarkAsDelSlides start' );

  SavedCursor := Screen.Cursor;
  Screen.Cursor := crHourglass;
  try

    i := N_MemIniToInt( 'CMS_Main', 'DelObjsKeepMonths', 6 );
    if i > 0 then
    begin // try to delete  marked as deleted slides
      // Search for "old" marked as deleted slides that should be removed from DB
      SQLStr :=  EDADBDateTimeToSQL( DateOf( IncMonth( EDAGetSyncTimestamp(), -i ) ) );
//      SQLStr :=  'DATETIME(''' +
//                       K_DateTimeToStr( DateOf( IncMonth( EDAGetSyncTimestamp(), -i )), 'yyyy-mm-dd hh:nn:ss.zzz' ) + ''')';
{ // for testing Slides deletion
      SQLStr :=  EDADBDateTimeToSQL( EDAGetSyncTimestamp() );
//      SQLStr :=  'DATETIME(''' +
//                       K_DateTimeToStr( EDAGetSyncTimestamp(), 'yyyy-mm-dd hh:nn:ss.zzz' ) + ''')';
{}
      with CurDSet2 do begin
        Connection := LANDBConnection;
  //      SQL.Text := 'select ' +
        SQL.Text := 'select top ' + IntToStr(AClearNum) + ' ' +
    K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideID + ',' +
    K_CMENDBSlidesTable +'.'+ K_CMENDBSTFPatID + ',' +
    K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideDTCr + ',' +
    K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideSysInfo +
          ' from ' + K_CMENDBSlidesTable + ',' + K_CMENDBDelMarkedSlidesTable +
          ' where ' + K_CMENDBDelMarkedSlidesTable +'.'+ K_CMENDMTS + ' < ' + SQLStr +
          ' and ' + K_CMENDBSlidesTable +'.'+ K_CMENDBSTFSlideID + '=' +
           K_CMENDBDelMarkedSlidesTable +'.'+ K_CMENDMSlideID;
        Filtered := false;
  //      N_s := SQL.Text;
        Open;
        i := RecordCount;
        if i > 0 then
        begin
          SetLength( Slides, i );
          First();
          i := 0;
          while not Eof do
          begin
            Slides[i] := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1,
                N_UDCMSlideCI));
            with Slides[i], P^ do
            begin
              ObjName := FieldList[0].AsString;
              CMSPatID := FieldList[1].AsInteger;
              CMSDTCreated := TDateTimeField(FieldList[2]).Value;
              K_CMEDAGetSlideSysFieldsData( EDAGetStringFieldValue(FieldList[3]), @CMSDB);
            end;
            Next;
            Inc(i);
          end;
        end;
        Close();
      end;

      // Delete found marked as deleted slides
      if i > 0 then
      begin
        SaveGAMode := K_CMGAModeFlag;
        K_CMGAModeFlag := TRUE;
        GUISilentFlag := TRUE;
        K_CMSlidesDelete( @Slides[0], Length(Slides), FALSE, TRUE );
        GUISilentFlag := FALSE;
        K_CMGAModeFlag := SaveGAMode;
        LockResCount := 0;
      end;
    end;
    Screen.Cursor := SavedCursor;
    N_Dump2Str('DB>> EDAClearMarkAsDelSlides fin');
  except
    on E: Exception do
    begin
      Screen.Cursor := SavedCursor;
      ExtDataErrorString := 'EDAClearMarkAsDelSlides ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAClearMarkAsDelSlides

//********************************************* TK_CMEDDBAccess.EDAGetNewSlidesStartID ***
// Get Start ID for new Slides
//
//     Parameters
// ANCount - number of new Slides
// Result - Returns strat ID or -1 if error detected
//
function TK_CMEDDBAccess.EDAGetNewSlidesStartID(ANCount: Integer): Integer;
begin
  Result := 1;
end; // end of TK_CMEDDBAccess.EDAGetNewSlidesStartID

//********************************************* TK_CMEDDBAccess.EDAStoreSlideNewMediaData ***
// Rename new Media Slide TMP MediaFile to Permanent MediaFile Name
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAStoreSlideNewMediaData(ASlide: TN_UDCMSlide)
  : TK_CMEDResult;
var
  FName: string;
begin
  if (K_CMMediaFilesStoringMode <> 1) or // has Client Location
    not SlidesMediaRootFDA or // has no Direct Access to Server
    SlidesMediaFSplit then    // file should be splited
  begin // Not Server only or Nor Direc Access or
  // Store Splited Media File
    if K_CMMediaFilesStoringMode = 1 then
    begin
      // Only Server Mode
      FName := ASlide.GetMediaFileNamePref(
            K_ExpandFileName('(#TmpFiles#)') + ASlide.GetFilesPathSegm() );
      Result := EDARenameSlideNewMediaFile(ASlide, FName);
      FName := FName + ASlide.P.CMSDB.MediaFExt;
    end
    else
    begin
      // Save to Client Only or to Client + Server
      Result := inherited EDAStoreSlideNewMediaData(ASlide);
      FName := ASlide.GetMediaFileClientName();
    end;

    if (Result <> K_edOK) or (K_CMMediaFilesStoringMode = 0) then
      Exit; // Only Client
    //
    Result := EDACopyMediaFileToServer(ASlide, FName);
  end
  else
  begin
    // TMP File is already on server - OnlyServer + DirectAccess + not Splited
    Result := EDARenameSlideNewMediaFile(ASlide,
      ASlide.GetMediaFileNamePref
        (SlidesMediaRootFolder + ASlide.GetFilesPathSegm()));
  end;
end; // end of TK_CMEDDBAccess.EDAStoreSlideNewMediaData

//********************************************* TK_CMEDDBAccess.EDASetCurSlide ***
// Set given Slide as current
//
//     Parameters
// ASlide - given Slide
// AUpdateMode - if =TRUE then SLides DataSet will be prepared for Load Slide Data
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASetCurSlide( ASlide: TN_UDCMSlide; AUpdateMode: Boolean = false ): TK_CMEDResult;
var
  IsNewSlide: Boolean;
  SlideID: string;
  LogStr: string;
  LockFileMode: TK_CMEDLockFileMode;

begin
  try
    with CurSlidesDSet, ASlide, P()^ do
    begin
      Connection := LANDBConnection;

      Result := EDACheckDBConnection(Connection);
      if Result <> K_edOK then
        Exit;

      IsNewSlide := cmsfIsNew in CMSRFlags;

      if IsNewSlide then
        SlideID := '-1'
      else
        SlideID := ObjName;

      if AUpdateMode then
        LockFileMode := K_cmlfRead
      else
        LockFileMode := K_cmlfWrite;

      // if not IsNewSlide then
//      if not IsNewSlide then // Return this code 2012-08-29
      EDAWaitForCurSlideRWLock(ASlide.ObjName, LockFileMode);

      if not AUpdateMode and not Connection.InTransaction then
        Connection.BeginTrans;

      ExtDataErrorCode := K_eeDBSelect;
      SQL.Text := 'select ' +
        EDAGetSlideSelectFieldsStr( [K_sffAddThumbField,K_sffAddMapRootField] ) +
        ' from ' + EDAGetSlideSelectFromStr( ) +
        ' where ' +  K_CMENDBSTFSlideID + ' = ' + SlideID +
                     K_CMEDAGetSlideSelectWhereStr( K_swfSkipFlagsCond );
//        EDAGetSlideSelectWhereStr( K_swfSkipFlagsCond );
      Filtered := false;
      Open;

      if AUpdateMode then
      begin
        ExtDataErrorCode := K_eeDBIns;
        if not IsNewSlide then
          Exit;
        raise Exception.Create('Update SLide and Save New conflict');
      end;

      if IsNewSlide then
      begin
        ExtDataErrorCode := K_eeDBIns;
        Insert;
        FieldList.Fields[1].AsInteger := CMSPatId;

        CurDSet1.Connection := Connection;
        if K_CMEDDBVersion >= 40 then
        begin // Get New Slide ID
          if not K_CMEDAMSSQL then
            CurDSet1.SQL.Text := 'SELECT dba.NextSlideID.NEXTVAL'
          else
            CurDSet1.SQL.Text := 'SELECT NEXT VALUE FOR dba.NextSlideID';
          CurDSet1.Filtered := false;
          CurDSet1.Open;
          SlideID := CurDSet1.FieldList.Fields[0].AsString;
          FieldList.Fields[0].AsString := SlideID;
        end;
        UpdateBatch();
        CurDSet1.Close();
        if K_CMEDDBVersion < 40 then
        begin // Get New Slide ID
          CurDSet2.SQL.Text := 'select @@identity';
          CurDSet2.Filtered := false;
          CurDSet2.Open;
          SlideID := CurDSet2.FieldList.Fields[0].AsString;
          CurDSet2.Close();
        end;
        ObjName := SlideID;
        LogStr := 'DB>> Add new slide record ID=';
        // !!2010-03-17 - this flags are already set for new image
        CMSRFlags := CMSRFlags + [cmsfAttribsChanged, cmsfCurImgChanged, cmsfMapRootChanged];
        if cmsfSkipNewFile in CMSRFlags then
          CMSRFlags := CMSRFlags - [cmsfCurImgChanged];
      end
      else
        LogStr := 'DB>> Edit existing slide record ID=';

      Edit;
      N_Dump2Str(LogStr + ObjName);

      // if IsNewSlide then // for protocol logic
      // EDAWaitForCurSlideRWLock( ASlide, LockFileMode );

      CurSlide := ASlide;
      if (cmsfIsNew in CMSRFlags) then
      begin
        if (cmsfIsMediaObj in CMSDB.SFlags) and
           not(cmsfSkipNewFile in CMSRFlags) then
        // Store Media File
          Result := EDAStoreSlideNewMediaData(CurSlide)
        else
        if (cmsfIsImg3DObj in CMSDB.SFlags) and
// 2020-07-28 add Capt3DDevObjName <> ''  (CMSDB.Capt3DDevObjName = '')    and
// 2020-09-25 return condition for Dev3D Objs
           (CMSDB.Capt3DDevObjName = '') and
           (CMSDB.MediaFExt <> '') then
        begin // Store 3D Image Files (not use for Dev3D Obj
//          Result := EDARenameFileOnServer( ExcludeTrailingPathDelimiter(CMSDB.MediaFExt),
//                               ExcludeTrailingPathDelimiter(ExtractFilePath(ExcludeTrailingPathDelimiter(CMSDB.MediaFExt)) +
//                               K_CMSlideGetImg3DFolderName( SlideID )), TRUE );
          Result := EDARenameFileOnServer( CMSDB.MediaFExt,
                               ExtractFilePath(ExcludeTrailingPathDelimiter(CMSDB.MediaFExt)) +
                               K_CMSlideGetImg3DFolderName( SlideID ), TRUE );
          CMSDB.MediaFExt := '';
        end;
      end;

      if Result <> K_edOK then
        raise Exception.Create(ExtDataErrorString);
      // Exclude( CMSRFlags, cmsfIsNew );
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASetCurSlide ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASetCurSlide

//********************************************* TK_CMEDDBAccess.EDASaveSlideHistBuffer ***
// Save given Slide History
//
//     Parameters
// ASlide - given Slide
// AHistCode - additional hist code (creation or deletion)
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveSlideHistBuffer( ASlide : TN_UDCMSlide; AHistCode : Integer ): TK_CMEDResult;
var
  i : Integer;
  PCMSlideEdHist: TN_PCMSlideHist;
  SQLStr : string;
  SessionHistID : Integer;

  procedure InsHistRecord( AProvID, AActCode : Integer; ATS : TDateTime );
  begin
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBIns;
      Connection := LANDBConnection;
      CommandText := 'INSERT INTO ' + K_CMENDBSlidesHistTable + ' (' +
        K_CMENDBSlidesHTFSlideID + ',' + K_CMENDBSlidesHTFProvID + ',' +
        K_CMENDBSlidesHTFActID + ',' + K_CMENDBSlidesHTFActTS +
        ' ) ' +
        'VALUES ( ' + ASlide.ObjName + ',' +
              IntToStr( AProvID ) + ',' +
              IntToStr( AActCode ) + ',''' +
              K_DateTimeToStr( ATS, 'yyyy"/"mm"/"dd"/" hh":"nn":"ss.zzz' ) + '''' +
        ' )';
      Execute;
    end;
  end;

begin
  // *** Save Slide History
  Result := K_edOK;
  with ASlide, P()^ do
  begin
    if (AHistCode = -1) and (CMSHist.ALength = 0) then Exit; // Skip Internal Wrk Action Code
    try
      if K_CMEDDBVersion < 13 then
      begin
      // Old Statistics
        if CMSHist.ALength > 0 then
        begin
          for i := 0 to CMSHist.AHigh do
          begin
            PCMSlideEdHist := CMSHist.P(i);
            InsHistRecord( PCMSlideEdHist.SHistProvID,
                           (PCMSlideEdHist.SHistActCode and not K_shATFSkipSaveChangesFlag),
                            PCMSlideEdHist.SHistActTS )
          end;
          CMSHist.DeleteElems(0, -1);
        end;

        if AHistCode <> -1 then
        begin // Add Special History
          InsHistRecord( CurProvID, AHistCode, EDAGetSyncTimestamp() )
        end;
      end
      else
      begin
      // New Statistics
        TmpStrings.Clear;
        SQLStr := '<record ActCode="%d" ActTS="%s" />';
//        SQLStr := '<record ActCode=%d ActTS="%s" />';
        SessionHistID := CurSessionHistID;
        if CMSHist.ALength > 0 then
        begin
          for i := 0 to CMSHist.AHigh do
          begin
            PCMSlideEdHist := CMSHist.P(i);
            SessionHistID := PCMSlideEdHist.SHistSessionID;
            TmpStrings.Add( format( SQLStr, [PCMSlideEdHist.SHistActCode,
                K_DateTimeToStr( PCMSlideEdHist.SHistActTS, 'yyyy-mm-dd hh":"nn":"ss.zzz' )] ) );
//                K_DateTimeToStr( PCMSlideEdHist.SHistActTS, 'yyyy"/"mm"/"dd"/" hh":"nn":"ss.zzz' )] ) );
          end;
          CMSHist.DeleteElems(0, -1);
        end;
        if AHistCode <> -1 then
        begin // Add Special History
          TmpStrings.Add( format( SQLStr, [AHistCode,
          K_DateTimeToStr( EDAGetSyncTimestamp(), 'yyyy-mm-dd hh":"nn":"ss.zzz' )] ) );
//          K_DateTimeToStr( EDAGetSyncTimestamp(), 'yyyy"/"mm"/"dd"/" hh":"nn":"ss.zzz' )] ) );
        end;
        if TmpStrings.Count = 0 then Exit;

        SQLStr := '<root>' +
          Copy( StrTextBuf, 1, K_GetStringsToBuf( StrTextBuf, TmpStrings, 0, TmpStrings.Count, TRUE, Chr($0A) ) )
            +'</root>';
        // Exec Stored Procedure to Add Query Lements

        N_Dump2Str( format( 'DB>> cms_AddSlideHistActs: Slide=%s Session=%d', [ASlide.ObjName,SessionHistID]) );
        N_Dump2Strings(TmpStrings, 5);
        with CurStoredProc1 do
        begin
          Connection := LANDBConnection;
          ProcedureName := 'dba.cms_AddSlideHistActs';
          Parameters.Clear;
          with Parameters.AddParameter do begin
            Name := '@SlideID';
            Direction := pdInput;
            DataType := ftInteger;
            Value := StrToInt(ASlide.ObjName);
          end;
          with Parameters.AddParameter do begin
            Name := '@SessionID';
            Direction := pdInput;
            DataType := ftInteger;
            Value := SessionHistID;
          end;
          with Parameters.AddParameter do begin
            Name := '@xml_list';
            Direction := pdInput;
            DataType := ftString;
            Value := SQLStr;
          end;
          ExecProc;
        end;
      end;
    // *** Fin Slide History Save
    except
      on E: Exception do
      begin
        ExtDataErrorString := 'EDASaveSlideHistBuffer ' + E.Message;
        EDAShowErrMessage(TRUE);
        Result := K_edExDataError;
        Exit;
      end;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASaveSlideHistBuffer

{
//********************************************* TK_CMEDDBAccess.EDASaveSlideFields ***
// Save given Slide fields
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveSlideFields(): TK_CMEDResult;

var
  CField: TField;
  // WInt : Integer;
  // WCMSlideFlags : TN_CMSlideFlags;
  PCMSlide: TN_PCMSlide;
begin
  Result := K_edOK;
  try
    PCMSlide := CurSlide.P();
    with CurSlidesDSet, CurSlide, PCMSlide^ do
    begin

      { !! 14.11.2009 not needed now
        CField := FieldList.Find( K_CMENDBSTFSlideID );
        if CField <> nil then  // Slide ID
        ObjName := CField.AsString;
        //        CField.AsString := ObjName;
      }
{
      if cmsfIsNew in CMSRFlags then
      begin
        // New Slide Fields!!!
        CField := FieldList.Find(K_CMENDBSTFPatID);
        if CField <> nil then // Patient ID
          CField.AsInteger := CMSPatId;

        CField := FieldList.Find(K_CMENDBSTFSlideDTTaken);
        if CField <> nil then // DT Taken
          TDateTimeField(CField).Value := CMSDTTaken;

        CField := FieldList.Find(K_CMENDBSTFSlideDTCr);
        if CField <> nil then // DT Created
          TDateTimeField(CField).Value := CMSDTCreated;

        CField := FieldList.Find(K_CMENDBSTFSlideProvIDCr);
        if CField <> nil then // Provider ID
          CField.AsInteger := CMSProvIDCreated;

        CField := FieldList.Find(K_CMENDBSTFSlideLocIDCr);
        if CField <> nil then // Location ID
          CField.AsInteger := CMSLocIDCreated;

        CField := FieldList.Find(K_CMENDBSTFSlideCompCr);
        if CField <> nil then // Computer Name
          CField.AsString := CMSCompIDCreated;

        CField := FieldList.Find(K_CMENDBSTFSlideSrcDescr);
        if CField <> nil then // Source Description
          CField.AsString := CMSSourceDescr;
        // End of New Slide Fields
      end;

      CField := FieldList.Find(K_CMENDBSTFSlideDTImg);
      if CField <> nil then // DT Img Modified
        TDateTimeField(CField).Value := CMSDTImgMod;

      CField := FieldList.Find(K_CMENDBSTFSlideDTMapRoot);
      if CField <> nil then
      begin // DT MapRoot Modified
        TDateTimeField(CField).Value := CMSDTMapRootMod;
      end;

      CField := FieldList.Find(K_CMENDBSTFSlideDTProp);
      if CField <> nil then // DT Prop Modified
        TDateTimeField(CField).Value := CMSDTPropMod;

      CField := FieldList.Find(K_CMENDBSTFSlideMTypeID);
      if CField <> nil then // MediaType ID
        CField.AsInteger := CMSMediaType;

      CField := FieldList.Find(K_CMENDBSTFSlideProvIDMod);
      if CField <> nil then // Provider ID
        CField.AsInteger := CMSProvIDModified;

      CField := FieldList.Find(K_CMENDBSTFSlideLocIDMod);
      if CField <> nil then // Location ID
        CField.AsInteger := CMSLocIDModified;

      CField := FieldList.Find(K_CMENDBSTFSlideCompMod);
      if CField <> nil then // Computer Name
        CField.AsString := CMSCompIDModified;

      CField := FieldList.Find(K_CMENDBSTFSlideTeethRight);
      if CField <> nil then // Right Flags
        CField.AsInteger := TK_Int64TeethFlags(CMSTeethFlags).IRight;

      CField := FieldList.Find(K_CMENDBSTFSlideTeethLeft);
      if CField <> nil then // Left Flags
        CField.AsInteger := TK_Int64TeethFlags(CMSTeethFlags).ILeft;

      CField := FieldList.Find(K_CMENDBSTFSlideDiagnoses);
      // N_s := CField.Classname;
      if CField <> nil then // Diagnoses
        CField.Value := CMSDiagn;

      // SysInfo
      CField := FieldList.Find(K_CMENDBSTFSlideSysInfo);
      // N_s := CField.Classname;
      if CField <> nil then
      begin // SysInfo
        if K_CMEDDBSysInfoSPLDTC.DTCode = 0 then
          K_CMEDDBSysInfoSPLDTC := K_GetExecTypeCodeSafe('TN_CMSlideSDBF¸');
        CField.AsString := K_SaveSPLDataToText(CMSDB,
          K_CMEDDBSysInfoSPLDTC.All);
        // CField.AsString := K_SPLValueToString( CMSDB, K_CMEDDBSysInfoSPLDTC, []);
      end;

    end;

  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASaveSlideFields ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASaveSlideFields
}

//********************************************* TK_CMEDDBAccess.EDASaveSlideFields ***
// Save given Slide fields
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveSlideFields(): TK_CMEDResult;

var
  PCMSlide: TN_PCMSlide;
  SSysInfo : string;
begin
  Result := K_edOK;
  try
    PCMSlide := CurSlide.P();
    with CurSlidesDSet, CurSlide, PCMSlide^ do
    begin
      if cmsfIsNew in CMSRFlags then
      begin
        // New Slide Fields!!!
//        FieldList[K_CMENDBSTFPatIDInd].AsInteger := CMSPatId;  // Not Needed because value was set while recored was created

        TDateTimeField(FieldList[K_CMENDBSTFSlideDTCrInd]).Value := CMSDTCreated;
        if K_CMEDDBVersion >= 41 then
          TDateTimeField(FieldList[K_CMENDBSTFSlideDTArchInd]).Value := CMSDTCreated;

        FieldList[K_CMENDBSTFSlideProvIDCrInd].AsInteger := CMSProvIDCreated;

        FieldList[K_CMENDBSTFSlideLocIDCrInd].AsInteger := CMSLocIDCreated;

        EDAPutStringFieldValue( FieldList[K_CMENDBSTFSlideCompCrInd], CMSCompIDCreated );

        EDAPutStringFieldValue( FieldList[K_CMENDBSTFSlideSrcDescrInd], CMSSourceDescr );
        // End of New Slide Fields
{ Not needed - Study Mount Info should be saved in single transaction while Study is saving
        if (K_CMEDDBVersion >= 24) and (CMSStudyID > 0)  then
        begin
          FieldList[K_CMENDBSTFSlideStudyIDInd].AsInteger := CMSStudyID; // Study ID
          FieldList[K_CMENDBSTFSlideStudyItemInd].AsInteger := CMSStudyItemID; // Study Item ID
        end;
}
      end;

      TDateTimeField(FieldList[K_CMENDBSTFSlideDTTakenInd]).Value := CMSDTTaken;

      TDateTimeField(FieldList[K_CMENDBSTFSlideDTImgInd]).Value := CMSDTImgMod;

      TDateTimeField(FieldList[K_CMENDBSTFSlideDTMapRootInd]).Value := CMSDTMapRootMod;

      TDateTimeField(FieldList[K_CMENDBSTFSlideDTPropInd]).Value := CMSDTPropMod;

      FieldList[K_CMENDBSTFSlideMTypeIDInd].AsInteger := CMSMediaType;

      FieldList[K_CMENDBSTFSlideProvIDModInd].AsInteger := CMSProvIDModified;

      FieldList[K_CMENDBSTFSlideLocIDModInd].AsInteger := CMSLocIDModified;

      EDAPutStringFieldValue( FieldList[K_CMENDBSTFSlideCompModInd], CMSCompIDModified );

      FieldList[K_CMENDBSTFSlideTeethRightInd].AsInteger := TK_Int64TeethFlags(CMSTeethFlags).IRight;

      FieldList[K_CMENDBSTFSlideTeethLeftInd].AsInteger := TK_Int64TeethFlags(CMSTeethFlags).ILeft;

      EDAPutStringFieldValue( FieldList[K_CMENDBSTFSlideDiagnosesInd], CMSDiagn );

      if K_CMEDDBVersion >= 46 then
        FieldList[K_CMENDBSTFSlideDCMSerIDInd].AsInteger := CMDCMSerID;

      if K_CMEDDBSysInfoSPLDTC.DTCode = 0 then
        K_CMEDDBSysInfoSPLDTC := K_GetExecTypeCodeSafe('TN_CMSlideSDBF');

      SSysInfo := K_SaveSPLDataToText( CMSDB, K_CMEDDBSysInfoSPLDTC.All );
      N_Dump2Str('!!>> Save Data Size SysInfo=' + IntToStr( Length(SSysInfo) + 1 ) ); // TMP DUMP DATA SIZE
      EDAPutStringFieldValue( FieldList[K_CMENDBSTFSlideSysInfoInd], SSysInfo );
      N_Dump2Str( '!!>> After Save SysInfo' ); // TMP DUMP DATA SIZE

      if K_CMEnterpriseModeFlag then
      begin
        with FieldList[K_CMENDBSTFSlideLocIDHostInd] do
          if IsNull then // to Set HostLoc for New Object Only
            AsInteger := CMSLocIDHost;
      end;

      if K_CMEDDBVersion >= 12 then
      begin
        with FieldList[K_CMENDBSTFSlideCurFSizeInd] do
          if (CMSCurImgFSize <> 0) and
             (AsInteger <> CMSCurImgFSize) then
          begin
            AsInteger := CMSCurImgFSize;
            N_Dump2Str( '!!>> After Save Cur Image Size' ); // TMP DUMP DATA SIZE
          end;
        with FieldList[K_CMENDBSTFSlideSrcFSizeInd] do
          if (CMSSrcImgFSize <> 0) and
             (AsInteger <> CMSSrcImgFSize) then
          begin
            AsInteger := CMSSrcImgFSize;
            N_Dump2Str( '!!>> After Save Src Image Size' ); // TMP DUMP DATA SIZE
          end;
      end; // if K_CMEDDBVersion >= 12 then

{!!! 23-02-2016 Range check Error Exception while AsInteger := CMSDB.BytesSize
      with FieldList[K_CMENDBSTFSlideVideoFSizeInd] do
        if (K_CMEDDBVersion >= 16)          and
           (cmsfIsMediaObj in CMSDB.SFlags) and
           (AsInteger <> CMSDB.BytesSize) then
        begin
        // Video File Size is needed to set
          AsInteger := CMSDB.BytesSize;
          N_Dump2Str( '!!>> After Save Video size' ); // TMP DUMP DATA SIZE
        end;
}
      with FieldList[K_CMENDBSTFSlideVideoFSizeInd] do
        if (K_CMEDDBVersion >= 16)                                 and
           (cmsfIsMediaObj in CMSDB.SFlags) and
           (Round(AsFloat) <> CMSDB.BytesSize) then
        begin
        // Video File Size is needed to set
          AsFloat := CMSDB.BytesSize;
          N_Dump2Str( '!!>> After Save Video size' ); // TMP DUMP DATA SIZE
        end;

    end;

  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASaveSlideFields ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASaveSlideFields

//********************************************* TK_CMEDDBAccess.EDASaveSlideLocFields ***
// Get given Slide fields from LocFilesInfo table
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveSlideLocFields( ): TK_CMEDResult;
var
  PCMSlide: TN_PCMSlide;
  AddRecordFlag : Boolean;
  WInt : Integer;
begin
  Result := K_edOK;
  if not K_CMEnterpriseModeFlag then Exit;
  N_Dump2Str('DB>> EDASaveSlideLocFields');
  try
    PCMSlide := CurSlide.P();
    with CurSlidesLocDSet, CurSlide, PCMSlide^ do
    begin
      AddRecordFlag := cmsfIsNew in CMSRFlags;
      if not AddRecordFlag then
      begin
        Filter := K_CMENDBLFILocSlideID + '=' + ObjName;
        Filtered := TRUE;
        AddRecordFlag := RecordCount = 0;
      end;

      if AddRecordFlag then
        Insert
      else
        Edit;

      TDateTimeField(FieldList[0]).Value := CMSDTImgMod; // LocSlideTS
      WInt := 0;
      if cmsfHasSrcImg in CMSDB.SFlags then
        WInt := 1;
      FieldList[1].AsInteger := WInt; // LocSlideFlags

      if AddRecordFlag then
      begin
         FieldList[2].AsString := ObjName;   // LocSlideID
         FieldList[3].AsInteger := CurLocID; // LocID
      end;

      CurSlidesLocDSet.UpdateBatch();
      CurSlidesLocDSet.Close;
    end;

    N_Dump2Str('DB>> EDASaveSlideLocFields fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASaveSlideLocFields ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASaveSlideLocFields

//********************************************* TK_CMEDDBAccess.EDASaveSlideThumbnail ***
// Save Current Slide Thumbnail
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveSlideThumbnail(): TK_CMEDResult;
var
  CField: TField;
  DSize: Integer;
  Thumb: TN_UDDIB;
begin
  Result := K_edOK;
  if CurSlide.CMSArchived then Exit;
  
  CField := CurSlidesDSet.FieldList.Find(K_CMENDBSTFSlideThumbnail);
  if CField = nil then
    Exit;

  if K_CMEDDBVersion >= 2 then
  begin
    // Save JPG
    Thumb := CurSlide.GetThumbnail();
    Result := EDPutBlobFieldFromDIB( CurSlidesDSet, CField, Thumb.DIBObj,
                                     rietJPG, K_CMSlideThumbQuality );
  end
  else
  begin
    // Save BMP
    CurSlide.GetThumbnailBMP(BlobBuf, DSize);
    if DSize > 0 then
      Result := EDAPutBlobFieldValue(CurSlidesDSet, CField, @BlobBuf[0], DSize, 0);
  end;

end; // end of TK_CMEDDBAccess.EDASaveSlideThumbnail

//********************************************* TK_CMEDDBAccess.EDASaveSlideMapRoot ***
// Save Current Slide Thumbnail
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveSlideMapRoot(): TK_CMEDResult;
var
  CField: TField;
  DSize: Integer;
  PData : Pointer;
  UDMapRoot: TN_UDBase;

begin
  Result := K_edOK;

//  UDMapRoot := CurSlide.GetMapRoot(false, TRUE);
  K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapImgBuild];
  UDMapRoot := CurSlide.GetMapRoot();
  K_UDCMSlideGetMapRootFlags := [];
  // Clear Slide ROI Refs
  CurSlide.PrepROIView([K_roiClearRefs]);

//  K_TextModeFlags := K_TextModeFlags + [K_txtCompactArray,K_txtSkipTypesInfo];
  K_SaveTreeToText(UDMapRoot, K_SerialTextBuf);
//  K_TextModeFlags := K_TextModeFlags - [K_txtCompactArray,K_txtSkipTypesInfo];

// Deb Code
//K_GetFormTextEdit.EditStrings(K_SerialTextBuf.TextStrings);

  // Restore Slide ROI Refs
  CurSlide.PrepROIView([K_roiRestoreIfImage]);

  DSize := EDAStringsToAnsiText(K_SerialTextBuf.TextStrings, PData);

  N_Dump2Str('DB>> Save slide MapRoot');
  CField := CurSlidesDSet.FieldList.Find(K_CMENDBSTFSlideMapRoot);
  if CField <> nil then
    Result := EDAPutBlobFieldValue(CurSlidesDSet, CField, PData, DSize);
  N_Dump2Str('!!>> Save Data Size MapRoot=' + IntToStr(DSize) ); // TMP DUMP DATA SIZE

end; // end of TK_CMEDDBAccess.EDASaveSlideMapRoot

//********************************* TK_CMEDDBAccess.EDASaveSlideAttrsToFile ***
// Save Current Slide Attrs to file
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveSlideAttrsToFile( ASaveToArchiveFlag : Boolean ): TK_CMEDResult;
var
  CPath : string;
begin
  Result := K_edOK;
  if not SaveSlidesAttrsFiles and not ASaveToArchiveFlag then Exit;
  N_Dump2Str('DB>> EDASaveSlideAttrsToFile start ID=' + CurSlide.ObjName );
  if cmsfIsMediaObj in CurSlide.P^.CMSDB.SFlags then
    CPath := SlidesMediaRootFolder
  else
  if cmsfIsImg3DObj in CurSlide.P^.CMSDB.SFlags then
    CPath := SlidesImg3DRootFolder
  else
    CPath := SlidesImgRootFolder;
  with CurSlide do
    SaveAttrsToFile( GetAttrsFileName(CPath + GetFilesPathSegm() ), ASaveToArchiveFlag );
  N_Dump2Str('DB>> EDASaveSlideAttrsToFile fin' );
end; // end of TK_CMEDDBAccess.EDASaveSlideAttrsToFile

//********************************************* TK_CMEDDBAccess.EDAPutSlideBlobFieldValue ***
// Save given Slide data to Blob Field given by Name
//
//     Parameters
// ASlideID - given Slide ID
// AFieldName - Blob Field Name
// APData - pointer to binary data first byte
// ADataSize  - binary data size in bytes
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAPutSlideBlobFieldValue(const ASlideID: string;
  AFieldName: string; APData: Pointer; ADataSize: Integer): TK_CMEDResult;
begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  try
    ExtDataErrorCode := K_eeDBSelect;
    with CurBlobDSet do
    begin
      Connection := LANDBConnection;
      SQL.Text := 'select ' + AFieldName + ', ' + K_CMENDBSTFSlideID +
        ' from ' + K_CMENDBSlidesTable +
        ' where ' + K_CMENDBSTFSlideID + '=' + ASlideID;

      Filtered := false;
      Open;
      Edit;
      Result := EDAPutBlobFieldValue(CurBlobDSet, FieldList.Fields[0], APData,
                                     ADataSize);
      if Result = K_edOK then
        UpdateBatch();
      Close;
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASaveSlideFields ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAPutSlideBlobFieldValue

//********************************************* TK_CMEDDBAccess.EDASlideDataToFile ***
// Save given Data to file given by name
//
//     Parameters
// APData - pointer to binary data first byte
// ADataSize  - on input source binary data size in bytes, on output - resulting data size (in file)
// AImgFName - Image File Name
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASlideDataToFile(APData: Pointer;
  var ADataSize: Integer; const AImgFName: string): TK_CMEDResult;
begin
  if SlidesImgRootFDA then
  begin
    Result := inherited EDASlideDataToFile(APData, ADataSize, AImgFName);
  end   // if SlidesImgRootFDA then
  else
  begin // if not SlidesImgRootFDA then
    with CurBlobDSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      Result := EDACheckDBConnection(LANDBConnection);
      if Result <> K_edOK then
        Exit;

      SQL.Text := 'select ' + K_CMENDBTTFBlobBuf + ', ' + K_CMENDBTTFID +
        ' from ' + K_CMENDBTmpTable;
      Filtered := false;
      Open;
      Edit;
      Result := EDAPutBlobFieldValue(CurBlobDSet, FieldList.Fields[0], APData,
        ADataSize, ImgDBFileCompressPower);
      if Result = K_edOK then
      begin
        UpdateBatch;
        Close;
        ExtDataErrorCode := K_eeDBSelect;

        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A)
        + 'set @ls_source = ' + QuotedStr(AImgFName) + ';' + Chr($0A)
        + 'select xp_write_file( @ls_source, ' + K_CMENDBTTFBlobBuf +
        ' ) from ' + K_CMENDBTmpTable + ';' + Chr($0A) + 'end';
        N_Dump2Str('New Image DB File "' + AImgFName + '" is saved');
        Open;
        if FieldList.Fields[0].AsInteger <> 0 then
          Result := K_edFails;
        Close;
      end; // if Result = K_edOK then
    end; // with CurBlobDSet do
  end; // if not SlidesImgRootFDA then
end; // end of TK_CMEDDBAccess.EDASlideDataToFile

//********************************************* TK_CMEDDBAccess.EDASplitMediaFileIsNeeded ***
// Check if Media File should be splited
//
//     Parameters
// AMediaSize - media file size
// Result -  Returns TRUE if Media File should be splited
//
function TK_CMEDDBAccess.EDASplitMediaFileIsNeeded(AMediaSize: Int64): Boolean;
begin
  Result := AMediaSize > (K_CMMediaFilesSplitSize + K_CMMediaFilesMinSize);
end; // end of TK_CMEDDBAccess.EDASplitMediaFileIsNeeded

//********************************************* TK_CMEDDBAccess.EDAFileDelete ***
// Delete given File
//
//     Parameters
// AFName - File Name
// AFilesDA - Files Direct Access Flag
// Result -  Returns operation resulting code (K_edOK - file exists, K_edFails -
// file not exists, other - operation error)
//
function TK_CMEDDBAccess.EDAFileDelete(const AFName: string;
  AFilesDA: Boolean): TK_CMEDResult;
begin
  Result := K_edOK;
  if AFilesDA then
  begin
    if not K_DeleteFile(AFName) then
      Result := K_edFails;
  end
  else
    try
      with CurBlobDSet do
      begin
        ExtDataErrorCode := K_eeFilesPocessing;
        Connection := LANDBConnection;
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A)
         + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(AFName, '\', '\\')) + ';' + Chr($0A)
         + 'select sf_file_delete(@ls_source);' + Chr($0A) + 'end';

        // SQL.Text := 'select sf_file_delete( ''' + AnsiReplaceText( CurFName, '\', '\\' ) + ''' )';
        Filtered := false;
        Open;
        if FieldList.Fields[0].AsInteger <> 0 then
          Result := K_edFails;
        Close;
      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorCode := K_eeFilesPocessing;
        ExtDataErrorString := 'EDAFileDelete ' + E.Message;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end;
end; // end of TK_CMEDDBAccess.EDAFileDelete

//********************************************* TK_CMEDDBAccess.EDAForceFilePath ***
// Force Files Server Path
//
//     Parameters
// AFPath - Server Files Base Path
// AFilesDA - Files Direct Access
// ARaiseExcept - raise exception if path creation error
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAForceFilePath(const AFPath: string;
  AFilesDA: Boolean; ARaiseExcept: Boolean): TK_CMEDResult;
var
  SL: TStringList;
  FPath, FPath0: string;
  i: Integer;
//  ForceSuccess : Boolean;

  procedure CreationError;
  begin
    ExtDataErrorString := FPath0;
    if ExtDataErrorCode = K_eePathExists then
      FPath := 'Path "' + FPath0 + '" doesn''t exist'
    else
      FPath := 'Can''t create path "' + FPath0 + '"';
    if ARaiseExcept then
    begin
      if CurBlobDSet.Active then
        CurBlobDSet.Close;
      raise Exception.Create(FPath);
    end
    else
    begin
      Result := K_edFails;
      N_Dump1Str( 'DB> EDAForceFilePath >> ' + FPath);
    end;
  end;

begin
  if not K_IfExpandedFileName(AFPath) then
  begin
    ExtDataErrorCode := K_eePathExists;
    CreationError();
    Exit;
  end;

  Result := K_edOK;
  FPath0 := AFPath;
  if AFilesDA then
  begin
    if not EDAForceDirPath( FPath0 ) then
      CreationError();

{
    if not DirectoryExists(FPath0) then
    begin
      ExtDataErrorCode := K_eePathCreate;
      for i := 1 to 20 do
      begin
        ForceSuccess := K_ForceDirPath(FPath0);
        if ForceSuccess then Break;
        N_Dump1Str( 'DB >> EDAForceFilePath fails ' + IntToStr(i) );
        sleep( 1000 );
      end;
      if not ForceSuccess then
        CreationError();
    // raise Exception.Create( 'Can''t create path "' + FPath0 + '"' );
    end;
}
  end
  else
  begin
    SL := nil;
    with CurBlobDSet do
    begin
      ExtDataErrorCode := K_eePathExists;
      Connection := LANDBConnection;
      Filtered := false;
      while TRUE do
      begin
        // Search existing Path
        FPath := ExcludeTrailingPathDelimiter(FPath0);

        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A)
         + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(FPath, '\', '\\')) + ';' + Chr($0A)
         + 'select sf_path_exists(@ls_source);' + Chr($0A)  + 'end';

        // SQL.Text := 'select sf_path_exists( ''' + AnsiReplaceText( FPath, '\', '\\' ) + ''' )';
        Filtered := false;
        Open;
        if FieldList.Fields[0].AsInteger = 0 then
          break; // Existing Path is Found

        if SL = nil then
          SL := TStringList.Create;

        SL.Add(FPath);
        FPath0 := ExtractFilePath(FPath);
        if FPath0 = FPath then
        begin
          if SL.Count > 1 then
            FPath0 := SL[SL.Count - 2];
          CreationError();
        end;
        if Result <> K_edOK then
          break;
        // raise Exception.Create( 'Can''t create path"' + AFPath + '"' );
      end;

      if (SL <> nil) and (Result = K_edOK) then
      begin
        // Create Absent Folders
        ExtDataErrorCode := K_eePathCreate;
        for i := SL.Count - 1 downto 0 do
        begin
          SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A)
           + 'set @ls_source = ' +   QuotedStr(AnsiReplaceText(SL[i], '\', '\\')) + ';' + Chr($0A)
           + 'select sf_folder_create(@ls_source);' + Chr($0A) + 'end';

          // SQL.Text := 'select sf_folder_create( ''' + AnsiReplaceText( SL[i], '\', '\\' ) + ''' )';
          Open;
          FPath0 := SL[i];
          if FieldList.Fields[0].AsInteger <> 0 then
            CreationError();
          if Result <> K_edOK then
            break;
          // raise Exception.Create( 'Can''t create path"' + SL[i] + '"' );
        end;
      end;
      Close;
    end;
    SL.Free;
  end;
end; // end of TK_CMEDDBAccess.EDAForceFilePath

//********************************************* TK_CMEDDBAccess.EDARenameFileOnServer ***
// Rename source file to destination file on server
//
//     Parameters
// ASFName - source file name
// ADFName - destination file name
// AFDA -  (Server) files Direct Access Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDARenameFileOnServer( const ASFName, ADFName: string;
                                                AFDA: Boolean ): TK_CMEDResult;
begin
  Result := K_edOK;
  if AFDA then
  begin
    if not RenameFile( ASFName, ADFName ) then
      Result := K_edFails;
  end
  else
    try
      EDAForceFilePath(ExtractFilePath(ADFName), false, TRUE);
      with CurBlobDSet do
      begin
        ExtDataErrorCode := K_eeFilesPocessing;
        Connection := LANDBConnection;
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' +
          Chr($0A) + 'declare @ls_destination long varchar;' + Chr($0A)
          + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(ASFName, '\', '\\')) + ';' + Chr($0A)
          + 'set @ls_destination = ' + QuotedStr(AnsiReplaceText(ADFName, '\', '\\')) + ';' + Chr($0A) +
          'select sf_file_move(@ls_source,@ls_destination);' + Chr($0A) + 'end';
        Filtered := false;
        Open;
        if FieldList.Fields[0].AsInteger <> 0 then
          Result := K_edFails;
        Close;
      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorCode := K_eeFilesPocessing;
        ExtDataErrorString := 'EDARenameFileOnServer ' + E.Message;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end;
end; // end of TK_CMEDDBAccess.EDARenameFileOnServer

//********************************************* TK_CMEDDBAccess.EDACopyFileOnServer ***
// Copy source file to destination file on server
//
//     Parameters
// ASFName - source file name
// ADFName - destination file name
// AFDA -  (Server) files Direct Access Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDACopyFileOnServer(const ASFName, ADFName: string;
  AFDA: Boolean): TK_CMEDResult;
begin
  Result := K_edOK;
  if AFDA then
  begin
    if 0 <> K_CopyFile(ASFName, ADFName, [K_cffOverwriteNewer]) then
      Result := K_edFails;
  end
  else
    try
      EDAForceFilePath(ExtractFilePath(ADFName), false, TRUE);
      with CurBlobDSet do
      begin
        ExtDataErrorCode := K_eeFilesPocessing;
        Connection := LANDBConnection;
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' +
          Chr($0A) + 'declare @ls_destination long varchar;' + Chr($0A)
  + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(ASFName, '\', '\\')) + ';' + Chr($0A)
  + 'set @ls_destination = ' + QuotedStr(AnsiReplaceText(ADFName, '\', '\\')) + ';' + Chr($0A) +
          'select sf_file_copy(@ls_source,@ls_destination);' + Chr($0A) + 'end';
        Filtered := false;
        Open;
        if FieldList.Fields[0].AsInteger <> 0 then
          Result := K_edFails;
        Close;
      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorCode := K_eeFilesPocessing;
        ExtDataErrorString := 'EDACopyFileOnServer ' + E.Message;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end;
end; // end of TK_CMEDDBAccess.EDACopyFileOnServer

//********************************************* TK_CMEDDBAccess.EDACopyFilesOnServer ***
// Copy source file to destination file on server
//
//     Parameters
// ASFPath - source file name
// ADFPath - destination file name
// AFilesPat - files name pattern
// AFDA -  (Server) files Direct Access Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDACopyFilesOnServer( const ASFPath, ADFPath,
                          AFilesPat: string; AFDA: Boolean ): TK_CMEDResult;
begin
  Result := EDAPathOrFileExists(ASFPath, AFDA, TRUE);
  if Result <> K_edOK then
  begin
    Result := K_edImageFilesMoving;
    Exit;
  end;
  if AFDA then
  begin
    if not K_CopyFolderFiles(ASFPath, IncludeTrailingPathDelimiter(ADFPath),
      AFilesPat, [K_cffOverwriteNewer]) then
      Result := K_edFails;
  end
  else
    try
      EDAForceFilePath(ExtractFilePath(ADFPath), false, TRUE);
      with CurBlobDSet do
      begin
        ExtDataErrorCode := K_eeFilesPocessing;
        Connection := LANDBConnection;
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' +
          Chr($0A) + 'declare @ls_destination long varchar;' + Chr($0A)
  + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(ASFPath + AFilesPat, '\', '\\'))+ ';' + Chr($0A)
  + 'set @ls_destination = ' + QuotedStr(AnsiReplaceText(ADFPath, '\', '\\')) + ';' + Chr($0A) +
          'select sf_file_xcopy(@ls_source,@ls_destination);' + Chr($0A) + 'end';

        Filtered := false;
        Open;
        if FieldList.Fields[0].AsInteger <> 0 then
          Result := K_edFails;
        Close;

      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorCode := K_eeFilesPocessing;
        ExtDataErrorString := 'EDACopyFilesOnServer ' + E.Message;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end;
end; // end of TK_CMEDDBAccess.EDACopyFilesOnServer

//********************************************* TK_CMEDDBAccess.EDACopyFileToServer ***
// Copy given file to server
//
//     Parameters
// ASFName - source file name
// ADFName - destination file name
// ADestFDA - destination (Server) files Direct Access Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDACopyFileToServer( const ASFName, ADFName: string;
                                              ADestFDA: Boolean ): TK_CMEDResult;
var
  DFStream: TStream;
  SFStream: TFileStream;
begin
  Result := K_edOK;
  SFStream := nil;
  DFStream := nil;
  if ADestFDA then
  begin
    if 0 <> K_CopyFile(ASFName, ADFName, [K_cffOverwriteNewer]) then
      Result := K_edFails;
  end
  else
    try
      if not FileExists(ASFName) then
      begin
        Result := K_edFails;
        Exit;
      end;
      EDAForceFilePath(ExtractFilePath(ADFName), false, TRUE);
      with CurBlobDSet do
      begin
        ExtDataErrorCode := K_eeFilesPocessing;
        Connection := LANDBConnection;

        SQL.Text := 'select ' + K_CMENDBTTFBlobBuf + ', ' + K_CMENDBTTFID +
          ' from ' + K_CMENDBTmpTable;
        Filtered := false;
        Open;
        Edit;
        SFStream := TFileStream.Create(ASFName, fmOpenRead);
        DFStream := CreateBlobStream(FieldList.Fields[0], bmWrite);
        DFStream.CopyFrom(SFStream, 0);
        DFStream.Free;
        SFStream.Free;
        UpdateBatch;
        Close;
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A)
         + 'set @ls_source = ' + QuotedStr(ADFName) + ';' + Chr($0A)
         + 'select  xp_write_file( @ls_source, ' + K_CMENDBTTFBlobBuf +
          ' ) from ' + K_CMENDBTmpTable + ';' + Chr($0A) + 'end';
        Open;
        if FieldList.Fields[0].AsInteger <> 0 then
          Result := K_edFails;
        Close;
      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorCode := K_eeDBBlobWrite;
        ExtDataErrorString := 'EDACopyFileToServer ' + E.Message;
        SFStream.Free;
        DFStream.Free;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end;
end; // end of TK_CMEDDBAccess.EDACopyFileToServer

//********************************************* TK_CMEDDBAccess.EDACopyFileFromServer ***
// Copy given file from server
//
//     Parameters
// ASFName - source server file name
// ADFName - destination local file name
// ASrcFDA - source (Server) files Direct Access Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDACopyFileFromServer(const ASFName, ADFName: string;
  ASrcFDA: Boolean): TK_CMEDResult;
var
  SFStream: TStream;
  DFStream: TFileStream;
begin
  Result := K_edOK;
  SFStream := nil;
  DFStream := nil;
  if ASrcFDA then
  begin
    if 0 <> K_CopyFile(ASFName, ADFName, [K_cffOverwriteNewer]) then
      Result := K_edFails;
  end
  else
    try
      EDAForceFilePath(ExtractFilePath(ADFName), false, TRUE);
      with CurBlobDSet do
      begin
        ExtDataErrorCode := K_eeFilesPocessing;
        Connection := LANDBConnection;
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' +
          Chr($0A) + 'set @ls_source = ' + QuotedStr(ASFName) + ';' + Chr($0A)
          + 'select xp_read_file(@ls_source);' + Chr($0A) + 'end';

        // SQL.Text := 'select xp_read_file( ''' + ASFName + ''' )';
        Filtered := false;
        Open;
        SFStream := CreateBlobStream(FieldList.Fields[0], bmRead);
        DFStream := TFileStream.Create(ADFName, fmCreate);
        if SFStream.Size > 0 then
          DFStream.CopyFrom(SFStream, 0)
        else
          Result := K_edFails;
        Close;
        DFStream.Free;
        SFStream.Free;
      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorCode := K_eeDBBlobWrite;
        ExtDataErrorString := 'EDACopyFileFromServer ' + E.Message;
        SFStream.Free;
        DFStream.Free;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end;
end; // end of TK_CMEDDBAccess.EDACopyFileFromServer

//********************************************* TK_CMEDDBAccess.EDACopyMediaFileToServer ***
// Check if File exists
//
//     Parameters
// AFName - File Name
// AFilesDA - Files Direct Access Flag
// Result -  Returns operation resulting code (K_edOK - file exists, K_edFails -
// file not exists, other - operation error)
//
function TK_CMEDDBAccess.EDACopyMediaFileToServer(ASlide: TN_UDCMSlide;
  const AFName: string): TK_CMEDResult;
var
  FPath: string;
  FNamePref: string;
  MFStream: TStream;
begin
  with ASlide, P()^ do
  begin
    FPath := SlidesMediaRootFolder + GetFilesPathSegm();
    FNamePref := GetMediaFileNamePref(FPath);
    N_Dump2Str
      ('New Media File "' + FNamePref + '..." is saved to Server');
    if SlidesMediaFSplit and EDASplitMediaFileIsNeeded(CMSDB.BytesSize) then
    begin
      EDAForceFilePath(ExcludeTrailingPathDelimiter(FPath), SlidesMediaRootFDA,
        TRUE);
      MFStream := TFileStream.Create(AFName, fmOpenRead);
      Result := EDASplitMediaStreamToFiles(MFStream, FNamePref,
        SlidesMediaRootFDA);
      MFStream.Free;
    end
    else
      Result := EDACopyFileToServer(AFName, FNamePref + CMSDB.MediaFExt,
        SlidesMediaRootFDA);
  end;
end; // end of TK_CMEDDBAccess.EDACopyMediaFileToServer

//********************************************* TK_CMEDDBAccess.EDASplitMediaStreamToFiles ***
// Split given Media Stream to files
//
//     Parameters
// AMFStream - MediaData stream
// AMFNamePref - Media Part Files prefix
// ADestRootFDA - destination Files Root Direct Access Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASplitMediaStreamToFiles(AMFStream: TStream;
  const AMFNamePref: string; ADestRootFDA: Boolean): TK_CMEDResult;
var
  FStream: TStream;
  SplitCount: Integer;
  FSize: Int64;
  SplitMod: Integer;
  CurFName: string;
  i: Integer;

  procedure CopyStreamToFile(PartSize: Integer);
  begin
    if ADestRootFDA then
    begin
      FStream := TFileStream.Create(CurFName, fmCreate);
      FStream.CopyFrom(AMFStream, PartSize);
      FStream.Free;
    end
    else
      with CurBlobDSet do
      begin
        SQL.Text := 'select ' + K_CMENDBTTFBlobBuf + ', ' + K_CMENDBTTFID +
          ' from ' + K_CMENDBTmpTable;
        Filtered := false;
        Open;
        Edit;
        FStream := CreateBlobStream(FieldList.Fields[0], bmWrite);
        FStream.CopyFrom(AMFStream, PartSize);
        FStream.Free;
        UpdateBatch;
        Close;

        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' +
          Chr($0A) + 'set @ls_source = ' + QuotedStr(CurFName) + ';' + Chr($0A) +
          'select  xp_write_file( @ls_source, ' + K_CMENDBTTFBlobBuf +
          ' ) from ' + K_CMENDBTmpTable + ';' + Chr($0A) + 'end';
        Open;
        if FieldList.Fields[0].AsInteger <> 0 then
          Result := K_edFails;
        Close;
      end;

  end;

begin
  FSize := AMFStream.Size;
  SplitCount := Round(Int(FSize / K_CMMediaFilesSplitSize));
  SplitMod := FSize - (K_CMMediaFilesSplitSize * SplitCount);
  if (SplitMod <= K_CMMediaFilesMinSize) and (SplitMod > 0) then
    Dec(SplitCount);

  Result := K_edOK;
  try
    with CurBlobDSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      Filtered := false;
    end;

    for i := 0 to SplitCount - 1 do
    begin
      CurFName := AMFNamePref + '_' + IntToStr(i) + '.mfp';
      CopyStreamToFile(K_CMMediaFilesSplitSize);
      if Result <> K_edOK then
        break;
    end;

    if SplitMod <> 0 then
    begin
      CurFName := AMFNamePref + '_' + IntToStr(SplitCount) + '.mfp';
      CopyStreamToFile(FSize - AMFStream.Position);
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBBlobWrite;
      ExtDataErrorString := 'EDASplitMediaStreamToFiles ' + E.Message;
      FStream.Free;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASplitMediaStreamToFiles

//********************************************* TK_CMEDDBAccess.EDAJoinFilesToMediaStream ***
// Join Files to given Media Stream
//
//     Parameters
// AMFStream - MediaData stream
// AMFNamePref - Media Part Files Name prefix
// ASrcRootFDA - source Files Root Direct Access Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAJoinFilesToMediaStream(AMFStream: TStream;
  const AMFNamePref: string; ASrcRootFDA: Boolean): TK_CMEDResult;
var
  FStream: TStream;
  CurFName: string;
  i: Integer;

  function CopyFileToStream(): Boolean;
  begin
    if ASrcRootFDA then
    begin
      Result := FileExists(CurFName);
      if not Result then
        Exit;
      FStream := TFileStream.Create(CurFName, fmOpenRead);
      AMFStream.CopyFrom(FStream, 0);
      FStream.Free;
    end
    else

      with CurBlobDSet do
      begin
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' +
          Chr($0A) + 'set @ls_source = ' + QuotedStr(CurFName) + ';' + Chr($0A)
          + 'select xp_read_file(@ls_source);' + Chr($0A) + 'end';
        // SQL.Text := 'select xp_read_file( ''' + CurFName + ''')';
        Filtered := false;
        Open;
        FStream := CreateBlobStream(FieldList.Fields[0], bmRead);
        Result := FStream.Size > 0;
        if Result then
          AMFStream.CopyFrom(FStream, 0);
        FStream.Free;
        Close;
      end;

  end;

begin
  Result := K_edOK;
  try
    with CurBlobDSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      Filtered := false;
    end;

    i := 0;
    repeat
      CurFName := AMFNamePref + '_' + IntToStr(i) + '.mfp';
      Inc(i);
    until not CopyFileToStream();

  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBBlobWrite;
      ExtDataErrorString := 'EDAJoinFilesToMediaStream ' + E.Message;
      FStream.Free;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAJoinFilesToMediaStream
{
//********************************************* TK_CMEDDBAccess.EDAGetSlideSysFieldsData ***
// Get Slide Sys Fields Data
//
//     Parameters
// ASysInfo - SysInfo string Data
// APCMSlideSDBF - pointer to Slide Sys Fields Data
//
procedure TK_CMEDDBAccess.EDAGetSlideSysFieldsData(const ASysInfo: string;
  APCMSlideSDBF: TN_PCMSlideSDBF);
begin
  if ASysInfo <> '' then
  begin
    if K_CMEDDBSysInfoSPLDTC.DTCode = 0 then
      K_CMEDDBSysInfoSPLDTC := K_GetExecTypeCodeSafe('TN_CMSlideSDBF');
    if ASysInfo[1] = '<' then
      // new format
      K_LoadSPLDataFromText(APCMSlideSDBF^, K_CMEDDBSysInfoSPLDTC.All, ASysInfo)
    else
    begin
      // old format
      ExtDataErrorString := K_SPLValueFromString(APCMSlideSDBF^,
        K_CMEDDBSysInfoSPLDTC.All, ASysInfo);
      if ExtDataErrorString <> '' then
        raise Exception.Create(ExtDataErrorString);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAGetSlideSysFieldsData
}
//********************************************* TK_CMEDDBAccess.EDALocFilesInfoQuery ***
// Get Slide WHERE clause string for select statement
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDALocFilesInfoQuery( const ASlideID : string = '' ) : TK_CMEDResult;
var
  SQLStr : string;
begin
  Result := K_edOK;
  try
    if CurSlidesLocDSet = nil then
    begin
      CurSlidesLocDSet := TADOQuery.Create(Application); // Current Slides Data Set for request to LocFilesInfo Table
      CurSlidesLocDSet.Connection := LANDBConnection;
    end;
    SQLStr := '';
    if ASlideID <> '' then
       SQLStr := ' and ' + K_CMENDBLFILocSlideID + '=' + ASlideID;
    CurSlidesLocDSet.SQL.Text := 'select ' +
      K_CMENDBLFILocSlideTS + ',' + K_CMENDBLFILocSlideFlags + ',' +
      K_CMENDBLFILocSlideID + ',' + K_CMENDBLFILocID +
      ' from ' + K_CMENDBLocFilesInfoTable +
      ' where ' +  K_CMENDBLFILocID + '=' + IntToStr(CurLocID) + SQLStr;

    CurSlidesLocDSet.Filtered := false;
    CurSlidesLocDSet.Open;
    CurSlidesLocDSet.First;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDALocFilesInfoQuery ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSelect;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDALocFilesInfoQuery

//********************************************* TK_CMEDDBAccess.EDACheckSLideUpdates ***
// Get Slide WHERE clause string for select statement
//
//     Parameters
// APCMSlideFields - pointer to Slide Fields
// ASlidesDSet - data set with selected Slide
// APropTSFInd - Slide Properties Change Timestamp Field Index
// AMapRootTSFInd - Slide MapRoot Change Timestamp Field Index
// AImgTSFInd - Slide Current Image Change Timestamp Field Index
// Result - Returns Slide Updates flags set
//
function TK_CMEDDBAccess.EDACheckSLideUpdates( APCMSlideFields: TN_PCMSlide; var ASlideChageTS : TDateTime;
                             ASlidesDSet : TADOQuery;
                             APropTSFInd, AMapRootTSFInd, AImgTSFInd : Integer ) : TK_CMEDBUStateFlags;
var
  DT: TDateTime;
begin
  with ASlidesDSet, APCMSlideFields^ do
  begin
    Result := [];

    DT := FieldList.Fields[APropTSFInd].AsDateTime;
    ASlideChageTS := DT;
    if Abs(DT - CMSDTPropMod) > K_CMEDATimeThreshold then
    begin
      if DT > CMSDTPropMod then
        Result := [K_dbusNewProps]
      else
        Result := [K_dbusOldProps];
    end;

    DT := FieldList.Fields[AImgTSFInd].AsDateTime;
    ASlideChageTS := Max(ASlideChageTS, DT);
    if Abs(DT - CMSDTImgMod) > K_CMEDATimeThreshold then
    begin
      if DT > CMSDTImgMod then
        Result := Result + [K_dbusNewCurImg]
      else
        Result := Result + [K_dbusOldCurImg];
    end;

    DT := FieldList.Fields[AMapRootTSFInd].AsDateTime;
    ASlideChageTS := Max(ASlideChageTS, DT);
    if Abs(DT - CMSDTMapRootMod) > K_CMEDATimeThreshold then
    begin
      if DT > CMSDTMapRootMod then
        Result := Result + [K_dbusNewMapRoot]
      else
        Result := Result + [K_dbusOldMapRoot];
    end;
  end;
end; // TK_CMEDDBAccess.EDACheckSLideUpdates
{
  //******************************************** TK_CMEDDBAccess.EDASaveStatInfo ***
  // Save Statistic Info in DB
  //
  //   Parameters
  // AStatInfoFlags - Sata Info operating flags
  // Result - Returns operation resulting code
  //
  function TK_CMEDDBAccess.EDASaveStatInfo( AStatInfoFlags : TK_CMDBStatInfoFlags ): TK_CMEDResult;
  var
  PStatInfo: TK_PCMDBStatInfo;
  DataSize : Integer;
  DBStatInfo : TK_CMDBStatInfo; // DB Running Statistic Info
  FirstRunningFlag : Boolean;

  begin
  try
  with CurBlobDSet do begin
  ExtDataErrorCode := K_eeDBSelect;
  Connection := LANDBConnection;
  SQL.Text := 'select ' +  K_CMENDBGAInstsTFStat + ',' + K_CMENDBGAInstsTFGlobID +
  ' from ' + K_CMENDBGAInstsTable +
  ' where ' + K_CMENDBGAInstsTFGlobID + '=' + IntToStr(ClientAppGlobID);
  Filtered := FALSE;
  Open;
  BlobEncParams.DFEncryptionType := K_dfeEncr1; // Set Encryption Flag
  Result := EDAGetBlobFieldValue( CurBlobDSet, FieldList.Fields[0], Pointer(PStatInfo), DataSize );
  if Result = K_edOK then begin

  if DataSize = 0 then
  FillChar( DBStatInfo, SizeOf(TK_CMDBStatInfo), 0 )
  else
  DBStatInfo := PStatInfo^;

  with DBStatInfo do begin
  FirstRunningFlag := CurSTS = 0; // First CMS Running
  if (K_sifChangeTimestamp in AStatInfoFlags) or
  FirstRunningFlag then begin
  //            CurFTS := Now(); // Change Final Timestamp
  CurFTS := EDAGetSyncTimestamp(); // Change Final Timestamp
  if FirstRunningFlag then
  CurSTS := CurFTS;
  end;

  FullMinutes := FullMinutes + Round( (CurFTS - CurSTS) * 24 * 60 );

  if K_sifStartTimeCount in AStatInfoFlags then
  CurFTS := EDAGetSyncTimestamp(); // Change Final Timestamp - New Time Start

  CurSTS := CurFTS;

  if (K_CMSLiRegState <> K_lrsVerTrial) and
  (K_CMSLiRegState <> K_lrsVerTrialExpired) then
  TrialMinutes := FullMinutes;
  Edit;
  Result := EDAPutBlobFieldValue( CurBlobDSet, FieldList.Fields[0], @DBStatInfo, SizeOf(TK_CMDBStatInfo), 0 );
  UpdateBatch;

  // Check if Trial Period Expire
  K_CMSLiVerTrialMinutes := FullMinutes - TrialMinutes;
  if (K_CMSLiRegState = K_lrsVerTrial) and
  (K_CMSLiVerTrialMinutes >= K_CMEDATrialRunningPeriod) then
  K_CMSLiRegState := K_lrsVerTrialExpired; // Set Trial Period is Expired Flag
  K_CMSLiVerTrialMinutes := K_CMEDATrialRunningPeriod - K_CMSLiVerTrialMinutes;

  end;
  end;
  Close;
  BlobEncParams.DFEncryptionType := K_dfePlain; // Clear Ecnryption Flag
  end;
  except
  on E: Exception do begin
  Result := K_edExDataError;
  ExtDataErrorString := E.Message;
  EDAShowErrMessage( true );
  Exit;
  end;
  end;
  end; // end of TK_CMEDDBAccess.EDASaveStatInfo
}

//********************************************* TK_CMEDDBAccess.EDASaveSlide ***
// Save given Slide
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveSlide(ASlide: TN_UDCMSlide): TK_CMEDResult;
var
  // SSlideID : string;
  // CurDSet : TADOQuery;
  PData: Pointer;
  DSize: Integer;
  PSlideFields: TN_PCMSlide;
  CImg: TN_UDDIB;
  FilesPath: string;
  ImgBufNamePath: string;
//  CField: TField;
//  UDMapRoot: TN_UDBase;
  AHistCode : Integer;
  BHistCode : Byte;
  MediaOrImg3D : Boolean;
  SaveToFileStorageError: Integer; // Save to File Storage Error code 1 -Original, 2 - Current, 0 - not file storage Error
  SaveToFileStorageErrorFName: string; // Save to File Storage Error File Name
  SlideStartRFlags: TN_CMSlideRFlags; // Slide Runtime Flags
  SlideStartSFlags: TN_CMSlideSFlags; // Slide Saved Flags
  SlideStartID: string; // Slide Saved Start ID for new slide
  ErrMes : string;                                 //
  InTrans : Boolean;
  DCMAttrsFSize: Integer;
  DCMAutoStore1, DCMAutoStore2, DCMAutoStore3 : Integer;

//  i: Integer;
//  PCMSlideEdHist: TN_PCMSlideHist;
  // OnlyHistorySave : Boolean;
label Rollback, LExit;

  procedure GetImgFilesPath();
  begin
    Result := K_edOK;
    if FilesPath <> '' then
      Exit;
    FilesPath := EDAGetSlideImgPath(ASlide);
    Result := EDAForceFilePath(FilesPath, SlidesImgRootFDA, FALSE);
  end;

begin
  Result := K_edOK;
  CurSlide := nil;
  InTrans := LANDBConnection.InTransaction;
  try
    SaveToFileStorageError := 0;
    PData := nil;
    FilesPath := '';
    PSlideFields := ASlide.P();
    with ASlide, PSlideFields^ do
    begin
      N_Dump2Str( format('DB>> EDASaveSlide SaveFlags==$%x',[Short(CMSRFlags)]) );
      ASlide.CMSUndoBuf.UBSlidePrepForSaving();
      ImgBufNamePath := '';
      SlideStartRFlags := CMSRFlags; // Store Slide Start Runtime Flags
      SlideStartSFlags := CMSDB.SFlags; // Store Slide State Saved Flags
      SlideStartID := ASlide.ObjName;

      /////////////////////////////////////////////////////////
      // Copy CurImg to special file to minimizing Slide Lock for Data Write Operation
      // is needed in Not Direct Access Mode only
      //
      if not SlidesImgRootFDA             and // Not Direct Access
         (cmsfCurImgChanged in CMSRFlags) and // CurImg ñhanged
         not(cmsfIsNew in CMSRFlags) then
      begin // Not New Image  and not direct access mode
        //
        N_Dump2Str('DB>> Save Current Image to buffer file');
        CImg := ASlide.GetCurrentImage(FALSE,TRUE);
        if CImg <> nil then
        begin
          GetImgFilesPath();
          if Result <> K_edOK then
            Exit;
          // Save Current Image to Buffer File
          ASlide.GetCurrentImageSData( PData, DSize );
          ImgBufNamePath := ASlide.GetCurImgFileName(FilesPath);
          ImgBufNamePath[Length(ImgBufNamePath)] := 'b';
          // LANDBConnection.BeginTrans;
          Result := EDASlideDataToFile( PData, DSize, ImgBufNamePath );
          CMSCurImgFSize := DSize;  // Store Slide Current Image Size
          if Result <> K_edOK then // File Operation Fails
            ImgBufNamePath := '';
        end;
      end; // if not SlidesImgRootFDA and ...
      //
      /////////////////////////////////////////////////////////

      // *** Save Slide Original Image
      if (cmsfHasSrcImg  in CMSDB.SFlags) and
         (cmsfSaveSrcImg in CMSDB.SFlags) then
      begin
        Result := EDASetCurSlide(ASlide);
        if Result <> K_edOK then
          goto Rollback;

        N_Dump2Str('DB>> Save original image');
        SaveToFileStorageError := 1;
        GetImgFilesPath();
        SaveToFileStorageErrorFName := GetSrcImgFileName( FilesPath );
        if Result <> K_edOK then
          goto Rollback;

        // Try Copy ECacheFile
        CMSSrcImgFSize := CurSlide.ECacheToSrcImageFile( '', SaveToFileStorageErrorFName );

        if CMSSrcImgFSize <= 0 then
        begin
          if CMSSrcImgFSize = -2 then
          begin
            Result := K_edFails;
            N_Dump2Str('DB>> CopyMove original from ECache Error');
            goto Rollback;
          end
          else
          begin
          // Try Copy Existed Current after change
            Result := EDACopyFileOnServer(
                      CurSlide.GetCurImgFileName(FilesPath),
                      CurSlide.GetSrcImgFileName(FilesPath),
                      SlidesImgRootFDA );
            if Result = K_edFails then
            begin
              // Save From Memory
              CImg := CurSlide.GetSourceImage(FALSE,TRUE);
              if CImg <> nil then
              begin
                // Save Original Image to File
                // File with current image is absent Save Origial
                CurSlide.GetSourceImageSData( PData, DSize );
                try
                  Result := EDASlideDataToFile( PData, DSize,
                                  CurSlide.GetSrcImgFileName(FilesPath) );
                except
                  Result := K_edExDataError;
                  N_Dump1Str('DB>> Copy original from DIB error');
                end;
                if Result <> K_edOK then
                  goto Rollback;

                CMSSrcImgFSize := DSize;  // Store Slide Original Image Size
                N_Dump2Str('DB>> Copy original from DIB');
              end
            end
            else
            begin
              N_Dump2Str('DB>> Copy original from current');
              CMSSrcImgFSize := CMSCurImgFSize;  // Store Slide Original Image Size
            end;
          end;
        end // if CMSSrcImgFSize <= 0 then
        else
          N_Dump2Str('DB>> CopyMove original from ECache');

        if Result <> K_edOK then
        begin
Rollback : //***********
          N_Dump1Str( format('DB>> SaveSlide  Rollback ID=%s Res=%d',[ASlide.ObjName,Ord(Result)]) );
          CMSRFlags := SlideStartRFlags; // Restore Slide Runtime Flags
          CMSDB.SFlags := SlideStartSFlags; // Restore Slide Saved Flags
          CurSlide.ObjName := SlideStartID;
          CMSUndoBuf.UBSlideRestoreSavingContext();
          LANDBConnection.RollbackTrans;
          CurSlide := nil;

          if SaveToFileStorageError >= 1 then
          begin
            if cmsfIsNew in CMSRFlags then
              ErrMes := K_CML1Form.LLLCheckVideoFile4.Caption
//        'New object cannot be saved. You will see this object in the not saved objects list at the next Media Suite start. Press OK to continue.',
           else
              ErrMes := format( K_CML1Form.LLLCheckVideoFile3.Caption,
//        'Access to "%s" is denied.'#13#10+
//        'Any changes to the object cannot be saved. Press OK to continue.',
                [SaveToFileStorageErrorFName] );
            K_CMShowMessageDlg( ErrMes, mtError );

          end;

          goto LExit;
        end;
        Include(CMSRFlags, cmsfAttribsChanged);
        Exclude(CMSDB.SFlags, cmsfSaveSrcImg);
        if K_CMEnterpriseModeFlag then
          Include( CMSlideLocFlags, K_slfSrcImgFileExists );
        SaveToFileStorageError := 0;
      end; // if (cmsfHasSrcImg  in CMSDB.SFlags) and ...
      // *** Fin Slide Original Image Save

      // *** Save Slide Thumbnail
      if (cmsfThumbChanged in CMSRFlags)  or
         (cmsfCurImgChanged in CMSRFlags) or
         (cmsfMapRootChanged in CMSRFlags) then
      begin
        if CurSlide = nil then
        begin
          Result := EDASetCurSlide(ASlide);
          if Result <> K_edOK then
            goto Rollback;
        end;

        N_Dump2Str('DB>> Save Slide Thumbnail');
        Result := EDASaveSlideThumbnail();
        if Result <> K_edOK then
          goto Rollback;
        Exclude(CMSRFlags, cmsfThumbChanged);
      end; // if (cmsfThumbChanged in CMSRFlags)  or ...
      // *** Fin Slide Thumbnail Save

      { !!
        // Save All SLide Fields Except Blobs - MapRoot and CurImage
        // Needed for correct work EDAPutSlideBlobFieldValue if New Slide is saving
        if CurSlide <> nil then
        CurSlidesDSet.UpdateBatch();
        !! }

      MediaOrImg3D := (cmsfIsMediaObj in CMSDB.SFlags) or
                      (cmsfIsImg3DObj in CMSDB.SFlags);
      // *** Save Slide MapRoot
      if (cmsfMapRootChanged in CMSRFlags) and // Save MapRoot SubTree
         not MediaOrImg3D then
//         (CMSDB.MediaFExt = '') then
      begin // Skip MapRoot Saving if New Media Format
        Result := EDASaveSlideMapRoot();
        if Result <> K_edOK then
          goto Rollback;
      end; // if (cmsfMapRootChanged in CMSRFlags) and ...
      Exclude(CMSRFlags, cmsfMapRootChanged);
      // *** Fin Save Slide MapRoot

      // *** Save Slide CurImage
//      ASlide.CMSCurImgFSize := DSize; //??? not needed 04-03-2011
      if (cmsfCurImgChanged in CMSRFlags) and
         not MediaOrImg3D then
      begin
        SaveToFileStorageError := 2;
        if ImgBufNamePath <> '' then
        begin
          // Buffer File is Ready - Move it to Cur Img File if not Direct Access - SlidesImgRootFDA = FALSE
          FilesPath := ImgBufNamePath;
          FilesPath[Length(FilesPath)] := 'i';
          Result := EDARenameFileOnServer( ImgBufNamePath, FilesPath, SlidesImgRootFDA );
        end   // if ImgBufNamePath <> '' then
        else
        begin // if ImgBufNamePath = '' then
          GetImgFilesPath();

          SaveToFileStorageErrorFName := CurSlide.GetDCMFileName( FilesPath );
          DCMAttrsFSize := CurSlide.ECacheToDCMAttrsFile('', SaveToFileStorageErrorFName);
          N_Dump2Str('DB>> CopyMove DCMAttrs from ECache size ' + IntTostr(DCMAttrsFSize) );

          SaveToFileStorageErrorFName := CurSlide.GetCurImgFileName( FilesPath );
          if Result <> K_edOK then
            goto Rollback;

          CMSCurImgFSize := CurSlide.ECacheToCurImageFile( '', SaveToFileStorageErrorFName );
          if CMSCurImgFSize <= 0 then
          begin
            Result := K_edFails;
            if CMSCurImgFSize = -2 then
            begin
              N_Dump1Str('DB>> CopyMove current from ECache Error');
              goto Rollback;
            end
            else
            begin
              CImg := CurSlide.GetCurrentImage(FALSE,TRUE);
              if CImg <> nil then
              begin
                // Write CurImg File in DA Mode
                // Save Current Image to File
                CurSlide.GetCurrentImageSData( PData, DSize );
                try
                  Result := EDASlideDataToFile( PData, DSize,
                                   CurSlide.GetCurImgFileName(FilesPath) );
                except
                  Result := K_edExDataError;
                  N_Dump1Str('DB>> Copy current from DIB error');
                end;
                if Result <> K_edOK then
                  goto Rollback;

                CMSCurImgFSize := DSize;  // Store Slide Current Image Size
                N_Dump2Str('DB>> Copy current from DIB');
              end; // if CImg <> nil then
            end;
          end // if CMSCurImgFSize <= 0 then
          else
            N_Dump2Str('DB>> CopyMove current from ECache');

        end; // if ImgBufNamePath = '' then

        if Result <> K_edOK then
          goto Rollback;

//        if K_CMEnterpriseModeFlag and
//           ((CImg <> nil) or (cmsfIsMediaObj in ASlide.P.CMSDB.SFlags)) then
        if K_CMEnterpriseModeFlag then
        begin // Save Slide State to LocFilesInfo
          EDALocFilesInfoQuery( CurSlide.ObjName );
          EDASaveSlideLocFields ();
        end;

        Exclude(CMSRFlags, cmsfCurImgChanged);
        SaveToFileStorageError := 0;
      end; // if (cmsfCurImgChanged in CMSRFlags) then
      // *** Fin Slide CurImage Save

      // *** Save Slide Attributes
      if cmsfAttribsChanged in CMSRFlags then
      begin
        if CurSlide = nil then
        begin
          Result := EDASetCurSlide(ASlide);
          if Result <> K_edOK then
            goto Rollback;
        end;

        with CurSlide, P()^ do
          if CMSDB.PixWidth = 0 then
            SetAttrsByCurImgParams(FALSE);

        N_Dump2Str('DB>> Save Slide Fields');
        Result := EDASaveSlideFields();
        if Result <> K_edOK then
          goto Rollback;
        Exclude(CMSRFlags, cmsfAttribsChanged);
        EDASaveSlideAttrsToFile( FALSE );
      end; // if cmsfAttribsChanged in CMSRFlags then
      // *** Fin Slide Attributes Save

      // if LANDBConnection.InTransaction then begin
      // *** Save Slide History
      AHistCode := -1;
      if cmsfIsNew in CMSRFlags then
      begin
        if K_CMSCreateDeleteMode = 0 then
          BHistCode := Ord(K_shCACreate)
        else
          BHistCode := Ord(K_shCACreateIAC);
        AHistCode := EDABuildHistActionCode(K_shATChange, BHistCode);
      end;
      Result := EDASaveSlideHistBuffer( ASlide, AHistCode );
      if Result <> K_edOK then
        goto Rollback;
     // *** Fin Slide History Save

      if CurSlide <> nil then
      begin
        CurSlidesDSet.UpdateBatch();
        CurSlidesDSet.Close;
        if not InTrans and LANDBConnection.InTransaction then
          LANDBConnection.CommitTrans;
        EDAClearSlideECache(CurSlide);

        if K_CMDCMStoreAutoFlag         and
           not K_CMDCMStoreAutoSkipFlag and
           not MediaOrImg3D         and
           (cmsfIsNew in CMSRFlags) and
           (K_CMSCreateDeleteMode = 0) and
           (1 <> K_DCMStoreExport( @CurSlide, 1, '', DCMAutoStore1, DCMAutoStore2, DCMAutoStore3 )) then
          N_Dump1Str( format( 'DB>> DCMAutoStore errors OutOfMem=%d Err=%d Exists=%d',
                              [DCMAutoStore2, DCMAutoStore3, DCMAutoStore1] ) );
      end; // if CurSlide <> nil


      Exclude(CMSRFlags, cmsfIsNew); // cmsfIsNew flag should be droped only in the End of Save procedure

LExit : //***********
      // Close Lock Mode and Error Exit
      if CurSlidesDSet.Active then
        CurSlidesDSet.Close;
      EDALockSlideForRW(ASlide.ObjName, K_cmlfFree);
//!!! all ECache Context should be saved if error
//      FreeAndNil(CMSlideECFStream); // Close Stream if EDAClearSlideECache was not called (may be it is unreal situation)
    end; // with ASlide, PSlideFields^ do
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASaveSlide ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASaveSlide

//********************************************* TK_CMEDDBAccess.EDASlideDataFromFile ***
// Get given DIBObj from file given by name
//
//     Parameters
// APData - pointer to buffer for data
// ADSize - resulting data size
// AImgFName - Image File Name
// AFSize - file size in bytes
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASlideDataFromFile(out APData: Pointer;
  out ADSize: Integer; const AImgFName: string; out AFSize : Integer ): TK_CMEDResult;
begin
  if SlidesImgRootFDA then
  begin
    Result := inherited EDASlideDataFromFile( APData, ADSize, AImgFName, AFSize );
  end
  else
    with CurBlobDSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr
        ($0A) + 'set @ls_source = ''' + AImgFName + ''';' + Chr($0A)
        + 'select xp_read_file(@ls_source);' + Chr($0A) + 'end';

      // SQL.Text := 'select xp_read_file( ''' + AImgFName + ''' )';
      Filtered := false;
      Open;
      Result := EDAGetBlobFieldValue(CurBlobDSet, FieldList.Fields[0], APData,
        ADSize);
      Close;
      if Result <> K_edOK then
        Exit;
      if ADSize = 0 then
      begin  // Text shoud be started by "Image file" and be finished by "not found"
        raise Exception.Create( format( 'Image file "%s" on DB Server not found', [AImgFName] ) );
//        raise Exception.Create( format('Image file not found on DB Server "%s"', [AImgFName] ) );
//          ('Image file not found on DB Server "' + AImgFName + '"' );
        // N_Dump2Str( 'Image file not found ' + AImgFName );
        // K_CMShowMessageDlg( 'Image file not found '#13#10 +
        // AImgFName,  mtError );
      end;
    end;
end; // end of TK_CMEDDBAccess.EDASlideDataFromFile

{
//********************************************* TK_CMEDDBAccess.EDAGetSlideFields ***
// Save given Slide fields
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlideFields(ASlide: TN_UDCMSlide): TK_CMEDResult;
var
  CField: TField;
  // i, WInt : Integer;
  // CName : string;
  WI64: Int64;
  // CSysInfo : string;

begin
  Result := K_edOK;
  N_Dump2Str('DB>> EDAGetSlideFields');
  try
    with CurSlidesDSet, ASlide, P()^ do
    begin

      CField := FieldList.Find(K_CMENDBSTFSlideID);
      if CField <> nil then // Slide ID
        ObjName := CField.AsString;
      // CMSSelfId := CField.AsInteger;
      N_Dump2Str('DB>> Get Fields SlideID=' + ObjName);

      CField := FieldList.Find(K_CMENDBSTFPatID);
      if CField <> nil then // Patient ID
        CMSPatId := CField.AsInteger;

      CField := FieldList.Find(K_CMENDBSTFSlideDTTaken);
      if CField <> nil then // DT Taken
        CMSDTTaken := TDateTimeField(CField).Value;

      CField := FieldList.Find(K_CMENDBSTFSlideDTCr);
      if CField <> nil then // DT Created
        CMSDTCreated := TDateTimeField(CField).Value;

      CField := FieldList.Find(K_CMENDBSTFSlideDTImg);
      if CField <> nil then // DT Img Modified
        CMSDTImgMod := TDateTimeField(CField).Value;

      CField := FieldList.Find(K_CMENDBSTFSlideDTMapRoot);
      if CField <> nil then // DT MapRoot Modified
        CMSDTMapRootMod := TDateTimeField(CField).Value;
      if CMSDTMapRootMod = 0 then // Set DT MapRoot for the first time
        CMSDTMapRootMod := CMSDTImgMod;

      CField := FieldList.Find(K_CMENDBSTFSlideDTProp);
      if CField <> nil then // DT Prop Modified
        CMSDTPropMod := TDateTimeField(CField).Value;

      CField := FieldList.Find(K_CMENDBSTFSlideMTypeID);
      if CField <> nil then // MediaType ID
        CMSMediaType := CField.AsInteger;

      CField := FieldList.Find(K_CMENDBSTFSlideProvIDCr);
      if CField <> nil then // Provider ID
        CMSProvIDCreated := CField.AsInteger;

      CField := FieldList.Find(K_CMENDBSTFSlideProvIDMod);
      if CField <> nil then // Provider ID
        CMSProvIDModified := CField.AsInteger;

      CField := FieldList.Find(K_CMENDBSTFSlideLocIDCr);
      if CField <> nil then // Location ID
        CMSLocIDCreated := CField.AsInteger;

      CField := FieldList.Find(K_CMENDBSTFSlideLocIDMod);
      if CField <> nil then // Location ID
        CMSLocIDModified := CField.AsInteger;

      CField := FieldList.Find(K_CMENDBSTFSlideCompCr);
      if CField <> nil then // Computer Name
        CMSCompIDCreated := CField.AsString;

      CField := FieldList.Find(K_CMENDBSTFSlideCompMod);
      if CField <> nil then // Computer Name
        CMSCompIDModified := CField.AsString;

      CField := FieldList.Find(K_CMENDBSTFSlideTeethRight);
      if CField <> nil then // Right Flags
        CMSTeethFlags := CField.AsInteger;

      CField := FieldList.Find(K_CMENDBSTFSlideTeethLeft);
      if CField <> nil then
      begin // Left Flags
        WI64 := CField.AsInteger;
        CMSTeethFlags := (WI64 shl 32) or CMSTeethFlags;
      end;

      CField := FieldList.Find(K_CMENDBSTFSlideDiagnoses);
      if CField <> nil then // Diagn
        CMSDiagn := String(TMemoField(CField).Value);

      CField := FieldList.Find(K_CMENDBSTFSlideSrcDescr);
      if CField <> nil then // Source
        CMSSourceDescr := CField.AsString;

      // SysInfo
      CField := FieldList.Find(K_CMENDBSTFSlideSysInfo);
      if CField <> nil then
      begin // SysInfo
        EDAGetSlideSysFieldsData(CField.AsString, @CMSDB);
      end;

    end;
    EDAInitSlideViewAttrs(ASlide);

    N_Dump2Str('DB>> EDAGetSlideFields fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetSlideFields ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAGetSlideFields
}

//********************************************* TK_CMEDDBAccess.EDAGetSlideFields ***
// Get given Slide fields from AllSlides table
//
//     Parameters
// ASlide - given Slide
// AGetStudyLinkInfo - Get Slide Study Link info from DB
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlideFields(ASlide: TN_UDCMSlide; AGetStudyLinkInfo : Boolean = FALSE; ADataSet : TObject = nil): TK_CMEDResult;
var
  // i, WInt : Integer;
  // CName : string;
  WI64: Int64;
  // CSysInfo : string;
  WByte : Byte;

begin
  Result := K_edOK;
  N_Dump2Str('DB>> EDAGetSlideFields start' );
  try
    if ADataSet = nil then ADataSet := CurSlidesDSet;
    with TADOQuery(ADataSet), ASlide, P()^ do
    begin
      ObjName := FieldList[K_CMENDBSTFSlideIDInd].AsString;// Slide ID
      N_Dump2Str('DB>> Get Fields SlideID=' + ObjName);

      CMSPatId := FieldList[K_CMENDBSTFPatIDInd].AsInteger; // Patient ID

      CMSDTTaken := TDateTimeField(FieldList[K_CMENDBSTFSlideDTTakenInd]).Value; // DT Taken

      CMSDTCreated := TDateTimeField(FieldList[K_CMENDBSTFSlideDTCrInd]).Value; // DT Created

      CMSDTImgMod := TDateTimeField(FieldList[K_CMENDBSTFSlideDTImgInd]).Value; // DT Img Modified

      CMSDTMapRootMod := TDateTimeField(FieldList[K_CMENDBSTFSlideDTMapRootInd]).Value; // DT MapRoot Modified

      if CMSDTMapRootMod = 0 then // Set DT MapRoot for the first time
        CMSDTMapRootMod := CMSDTImgMod;

      CMSDTPropMod := TDateTimeField(FieldList[K_CMENDBSTFSlideDTPropInd]).Value; // DT Properties Modified

      CMSMediaType := FieldList[K_CMENDBSTFSlideMTypeIDInd].AsInteger; // MediaType ID

      CMSProvIDCreated := FieldList[K_CMENDBSTFSlideProvIDCrInd].AsInteger; // Created Provider ID

      CMSProvIDModified := FieldList[K_CMENDBSTFSlideProvIDModInd].AsInteger; // Modified Provider ID

      CMSLocIDCreated := FieldList[K_CMENDBSTFSlideLocIDCrInd].AsInteger; // Created Location ID
      CMSLocIDHost := CMSLocIDCreated; // HostLoc Init (it will be set to real value if K_CMEDDBVersion >= 10)

      CMSLocIDModified := FieldList[K_CMENDBSTFSlideLocIDModInd].AsInteger; // Modified  Location ID

      CMSCompIDCreated := EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideCompCrInd]); // Created Computer Name

      CMSCompIDModified := EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideCompModInd]); // Modified Computer Name

      CMSTeethFlags := FieldList[K_CMENDBSTFSlideTeethRightInd].AsInteger; // Right Teeth Flags

      WI64 := FieldList[K_CMENDBSTFSlideTeethLeftInd].AsInteger; // Left Teeth Flags
      CMSTeethFlags := (WI64 shl 32) or CMSTeethFlags;

      CMSSourceDescr := EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideSrcDescrInd]); // Source

      CMSDiagn := EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideDiagnosesInd]); // Diagn

//      EDAGetSlideSysFieldsData(
      K_CMEDAGetSlideSysFieldsData( EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideSysInfoInd]), @CMSDB); // SysInfo

      if K_CMEDDBVersion >= 10 then
      begin
        WByte := FieldList[K_CMENDBSTFSlideFlagsInd].AsInteger; // Slide DB Flags
        CMSDBStateFlags := TN_CMSlideDBFlags(WByte);
      end;

      CMSlideEdState := K_edsFullAccess;
      CMSArchDate := 0;
      if K_CMEDDBVersion < 41 then
      begin
        if K_CMEnterpriseModeFlag then
          with FieldList[K_CMENDBSTFSlideLocIDHostInd] do
            if not IsNull then // for DB Switched to Enterprise
              CMSLocIDHost := AsInteger; // Host Location
      end
      else
      begin // if K_CMEDDBVersion >= 41 then
        with FieldList[K_CMENDBSTFSlideDTArchInd] do
          if not IsNull then //
            CMSArchDate := TDateTimeField(FieldList[K_CMENDBSTFSlideDTArchInd]).Value;

        if K_CMEDDBVersion >= 44 then
        begin
          with FieldList[K_CMENDBSTFSlideDFlagsInd] do
            if not IsNull then //
              Byte(CMSDCMFSet) := Byte(FieldList[K_CMENDBSTFSlideDFlagsInd].AsInteger);

          if K_CMEDDBVersion >= 46 then
            CMDCMSerID := FieldList[K_CMENDBSTFSlideDCMSerIDInd].AsInteger; // DICOM Series ID
        end; // if K_CMEDDBVersion >= 44 then
      end; // if K_CMEDDBVersion >= 41 then

      if K_CMEDDBVersion >= 12 then
      begin
        CMSCurImgFSize := FieldList[K_CMENDBSTFSlideCurFSizeInd].AsInteger; // Slide Current Image File Size
        CMSSrcImgFSize := FieldList[K_CMENDBSTFSlideSrcFSizeInd].AsInteger; ; // Slide Original Image File Size
      end;

{  // VideoFile Size is not needed because VideoFile Size stored in CMSDB.BytesSize field needed for Calculating Data Size Utility}

      if (K_CMEDDBVersion >= 24) and AGetStudyLinkInfo then
      begin
        CMSStudyID := FieldList[K_CMENDBSTFSlideStudyIDInd].AsInteger; // Study ID
        CMSStudyItemID := FieldList[K_CMENDBSTFSlideStudyItemInd].AsInteger; // Study Item ID
        if K_CMEDDBVersion >= 39 then
          CMSStudyItemPos := FieldList[K_CMENDBSTFSlideStudyItemPosInd].AsInteger; // Study Item Pos

      end;

    end;
    EDAInitSlideViewAttrs(ASlide);

    N_Dump2Str('DB>> EDAGetSlideFields fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetSlideFields ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAGetSlideFields

//********************************************* TK_CMEDDBAccess.EDAGetSlideLocFields ***
// Get given Slide fields from LocFilesInfo table (used if EnterpriseMode only)
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlideLocFields( ASlide: TN_UDCMSlide;
                                ASlideDTImgMod : TDateTime = 0 ): TK_CMEDResult;
var
  CField: TField;
  WByte : Byte;
  WTS : TDateTime;
  PCMSlideFields: TN_PCMSlide;

begin
  Result := K_edOK;
  if not K_CMEnterpriseModeFlag then Exit;
  N_Dump2Str('DB>> EDAGetSlideLocFields ID=' + ASlide.ObjName );
  try
    PCMSlideFields := ASlide.P();
    with CurSlidesLocDSet, ASlide, PCMSlideFields^ do
    begin
//      if CMSLocIDHost <> CurLocID then
//      begin
      CMSlideEdState := K_edsSkipChanges;

      CMSlideLocFlags := [];
      Filter := K_CMENDBLFILocSlideID + '=' + ObjName;
      Filtered := TRUE;

      CMSlideEdState := K_edsSkipOpen;
      if RecordCount > 0 then
      begin
        CField := FieldList[0]; // LocFiles Slide TS
        Assert( CField.FieldName = K_CMENDBLFILocSlideTS, 'FieldList[0].Name='+CField.FieldName + ' <> ' + K_CMENDBLFILocSlideTS );
        WTS := TDateTimeField(CField).Value;
        if ASlideDTImgMod = 0 then
          ASlideDTImgMod := CMSDTImgMod;
        if WTS = ASlideDTImgMod then
        begin
          CMSlideEdState := K_edsSkipChanges;
          if CMSLocIDHost = CurLocID then
            CMSlideEdState := K_edsFullAccess;
        end;
      end;
      Filtered := FALSE;
//      end;
      CField := FieldList[1]; // LocFiles Slide File Flags
      Assert( CField.FieldName = K_CMENDBLFILocSlideFlags, 'FieldList[1].Name='+CField.FieldName + ' <> ' + K_CMENDBLFILocSlideFlags );
      WByte := CField.AsInteger;
      CMSlideLocFlags := TK_CMSlideLocFlags(WByte);
    end;

    N_Dump2Str('DB>> EDAGetSlideLocFields fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetSlideLocFields ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAGetSlideLocFields

//********************************************* TK_CMEDDBAccess.EDAGetSlideThumbnail ***
// Get given Slide Thumbnail
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlideThumbnail(ASlide: TN_UDCMBSlide)
  : TK_CMEDResult;
var
  DSize: Integer;
  PData: Pointer;
  CField: TField;
  Stream: TStream;
//  GDW: TK_GPDIBCodecsWrapper;
  DIBObj: TN_DIBObj;

const
  JPGSignature = 'JFIF';

label GetBMP;

  function LoadDIB( const MemIniName : string ) : TN_DIBObj;
  var
    FName : string;
{
    VFile: TK_VFile;
    Stream: TStream;
    FileSize : Integer;
}
    RetCode : Integer;
    ErrStr : string;
  begin
    FName := N_MemIniToString( 'CMS_Main', MemIniName, '' );
    RetCode := K_LoadDIBFromVFileByRI( K_RIObj, FName, Result );
    if RetCode = 0 then Exit;
    case RetCode of
    1: ErrStr := 'is absent';
    2: ErrStr := 'has not proper format';
    end;
    N_Dump1Str( format( 'DB>> EDAGetSlideThumbnail >> Archived Slide Thumbnail file %s >> %s', [FName, ErrStr] ) );

{
    Result := nil;
    FName := N_MemIniToString( 'CMS_Main', MemIniName, '' );
    if FName <> '' then
    begin
      K_VFAssignByPath( VFile, K_ExpandFileName(FName) );
      FileSize := K_VFOpen( VFile );
      if FileSize > 0 then
      begin
        Stream := K_VFStreamGetToRead( VFile );
        K_RIObj.RIOpenStream(Stream);
        FileSize := Ord(K_RIObj.RIGetDIB( 0, Result ));
        if FileSize <>  Ord(rirOK) then
          Result := nil;
        K_RIObj.RIClose();
        K_VFStreamFree(VFile);
      end;
      if FileSize < 10 then
        N_Dump1Str( format( 'DB>> EDAGetSlideThumbnail >> Archived Slide Thumbnail File error =%d', [FileSize] ) );
    end;

    if Result = nil then
      N_Dump1Str( format( 'DB>> EDAGetSlideThumbnail >> Archived Slide Thumbnail File %s is absent or has wrong format', [FName] ) );
}
  end; // function LoadDIB

begin
  Result := K_edOK;
  N_Dump2Str('DB>> EDAGetSlideThumbnail ID=' + ASlide.ObjName );
  CField := CurSlidesDSet.FieldList.Find(K_CMENDBSTFSlideThumbnail);
  if CField = nil then
    Exit;
  if K_CMEDDBVersion >= 3 then
  begin
    // Get JPG
    Result := EDGetBlobFieldToDIB(CurSlidesDSet, CField, DIBObj);
    ASlide.CMSArchived := FALSE;
    if Result <> K_edOK then
    begin

      if (Result = K_edFails) and (K_CMEDDBVersion >= 41) and
         (ASlide is TN_UDCMSlide) then
      begin // Used DIBObj for archived Slides
        ASlide.CMSArchived := TRUE;
        if ASlide.CMSArchDate = 0 then
        begin
          if ArchSlideTIMG = nil then
            ArchSlideTIMG := LoadDIB( 'ArchSlideTIMGFName' );
          if ArchSlideTIMG <> nil then
            DIBObj := TN_DIBObj.Create(ArchSlideTIMG);   // archived and not in queue to restore
        end
        else
        begin
          if ArchSlideQTIMG = nil then
            ArchSlideQTIMG := LoadDIB( 'ArchSlideQTIMGFName' );
          if ArchSlideQTIMG <> nil then
            DIBObj := TN_DIBObj.Create(ArchSlideQTIMG); // archived and in queue to restore
        end;
      end;

      if DIBObj = nil then
        DIBObj := TN_DIBObj.Create(K_CMSlideThumbSize, K_CMSlideThumbSize, pf24bit); // default DIBObj
    end;
    ASlide.SetThumbnailByDIB(DIBObj);
    Result := K_edOK;
  end   // if K_CMEDDBVersion >= 3 then
  else
  begin // if K_CMEDDBVersion < 3 then
//    GDW := nil;
    Stream := nil;
    try
      // Get BMP or JPG
      Stream := CurSlidesDSet.CreateBlobStream(CField, bmRead);
      DSize := Stream.Size;
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBBlobRead;
      if DSize > 10 then
      begin
        if Length(BlobBuf) < DSize then
        begin
          BlobBuf := nil;
          SetLength(BlobBuf, DSize + DSize div 4);
        end;
        Stream.Read(BlobBuf[0], 10);
        if PInteger(@BlobBuf[6])^ = PInteger(@JPGSignature[1])^ then
        begin
          // Read JPG
          Stream.Seek(0, soFromBeginning);
{
          GDW := TK_GPDIBCodecsWrapper.Create;
          if GDW.GPLoadFromStream(Stream) = Ok then
          begin
            DIBObj := TN_DIBObj.Create(1, 1, pf24bit);
            if GDW.GPGetFrameToDIBObj(DIBObj, 0) = Ok then
            begin
              ASlide.SetThumbnailByDIB(DIBObj);
              Result := K_edOK;
            end
            else
              DIBObj.Free;
          end;
          Stream.Free;
          GDW.Free;
}
          if K_RIObj.RIOpenStream(Stream) = rirOK then
          begin
            DIBObj := nil;
            if K_RIObj.RIGetDIB( 0, DIBObj ) = rirOK then
            begin
              ASlide.SetThumbnailByDIB(DIBObj);
              Result := K_edOK;
            end
            else
              DIBObj.Free;
          end;
//          K_RIObj.RIClear();
          K_RIObj.RIClose();
          FreeAndNil(Stream);
        end   // if PInteger(@BlobBuf[6])^ = PInteger(@JPGSignature[1])^ then
        else
        begin // if PInteger(@BlobBuf[6])^ <> PInteger(@JPGSignature[1])^ then
          // Get BMP
          FreeAndNil(Stream);
          Result := EDAGetBlobFieldValue(CurSlidesDSet, CField, PData, DSize);
          ASlide.SetThumbnailByBMP(PData);
        end;
      end; // if DSize > 10 then
      Stream.Free;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorCode := K_eeDBBlobRead;
        ExtDataErrorString := 'EDAGetSlideThumbnail ' + E.Message;
        Stream.Free;
//        GDW.Free;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end; // try
  end; // end if K_CMEDDBVersion < 3 then
  N_Dump2Str('DB>> EDAGetSlideThumbnail fin');
end; // end of TK_CMEDDBAccess.EDAGetSlideThumbnail

//********************************************* TK_CMEDDBAccess.EDACalcBySlidesSelectAttrs ***
// Calculate Slides number by Current Slides Select Attributes
//
//     Parameters
// ASlidesCount - resulkting slides counter
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDACalcBySlidesSelectAttrs(out ASlidesCount: Integer)
  : TK_CMEDResult;
var
  SelAttrs: string;
begin
  ASlidesCount := 0;
  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  try

    ExtDataErrorCode := K_eeDBSelect;
    CurDSet1.Connection := LANDBConnection;
    SelAttrs := IntToStr(CurSlidesSelectAttrs.SSPatID);
    N_Dump2Str('DB>> EDACalcBySlidesSelectAttrs PatID=' + SelAttrs);
    with CurDSet1 do
    begin
      SQL.Text := 'select count(*) ' + ' from ' + K_CMENDBSlidesTable +
        ' where ' + K_CMENDBSTFPatID + '=' + SelAttrs;

      Filtered := false;
      Open;

      ASlidesCount := FieldList.Fields[0].AsInteger;
      Close;
    end;
    N_Dump2Str('DB>> EDACalcBySlidesSelectAttrs fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDACalcBySlidesSelectAttrs ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
  Result := K_edOK;
end; // end of TK_CMEDDBAccess.EDACalcBySlidesSelectAttrs

//********************************************* TK_CMEDDBAccess.EDARefreshCurSlidesSet ***
// Refresh Current Slides Set from External Data
//
//     Parameters
// ANewSlidesCount - number of Slides added to Current Slides Set
// ADelSlidesCount - number of Slides deleted from Current Slides Set
// AUpdateSlidesCount - number of Updated Slides
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDARefreshCurSlidesSet( out ANewSlidesCount,
            ADelSlidesCount, AUpdateSlidesCount: Integer ): TK_CMEDResult;
var
  SPatID: string;
  SCInd, SInd : Integer;
  SSlideID, SQLText: string;
  NewSlideFlag : Boolean;
  StudyFlag : Boolean;
  LockedSlideFlag, SkipThumbnailUpdate : Boolean;
  SlideActualDTImgMod : TDateTime;
  UpdateAttrs, UpdateCurImg, UpdateMapRoot,
  ChngMarkedAsDel, UpdateCommon : Boolean;
  WByte : Byte;
  FViewAttrs  : TN_CMSViewAttrs;

//  SlideVewAttrsBuf: array [0 .. K_SlideViewAttsSize - 1] of Byte;
  PCMSlideFields: TN_PCMSlide;
  DBUStateFlags : TK_CMEDBUStateFlags;
  SelectWhereFlags : TK_CMEDASelectWhereFlags;
  StudiesList : TStringList;
  StudyItem : TN_UDBase;
  Study : TN_UDCMStudy;
{
  NewSlidesArray : TN_UDCMSArray;
  i : Integer;
}

label DeleteSlide;

begin
  // !!## Temporary code
  N_Dump2Str('DB>> EDARefreshCurSlidesSet start');
  if K_CMEDDBVersion < 9 then
  begin
    Result := inherited EDARefreshCurSlidesSet( ANewSlidesCount,
      ADelSlidesCount, AUpdateSlidesCount );
    Exit;
  end;

  Result := EDACheckDBConnection(CurSlidesDSet.Connection);
  if Result <> K_edOK then
    Exit;

  try
    SPatID := IntToStr(CurSlidesSelectAttrs.SSPatID);
    N_Dump2Str('DB>> Refresh slides for patient ID=' + SPatID);

    EDAGetPatientSlidesUpdateTS(); // Get Update Slides TS before Refresh

    SelectWhereFlags := K_swfSkipAllDel;
    if K_CMMarkAsDelShowFlag then
      SelectWhereFlags := K_swfOnlyMarkedAsDel;
//      SelectWhereFlags := K_swfSkipDBDeleting;
    SQLText := 'select ' +
      EDAGetSlideSelectFieldsStr( [K_sffAddThumbField] ) +
      ' from ' + EDAGetSlideSelectFromStr( ) +
      ' where ' +  K_CMENDBSTFPatID + '=' + SPatID +
                   K_CMEDAGetSlideSelectWhereStr( SelectWhereFlags ) +
//                   EDAGetSlideSelectWhereStr( SelectWhereFlags ) +
      ' order by ' + K_CMENDBSTFSlideDTCr + ' asc';

    CurSlidesDSet.SQL.Text := SQLText;
    CurSlidesDSet.Filtered := false;
    CurSlidesDSet.Open;

    if K_CMEnterpriseModeFlag then
      EDALocFilesInfoQuery( );

    SCInd := 0;
    ANewSlidesCount := 0;
    AUpdateSlidesCount := 0;
    TmpStrings.Clear;
    TmpStrings.Sorted := FALSE;
    EDACurSlidesToStrings(TmpStrings);


    CurSlidesDSet.First;
    StudiesList := TStringList.Create;


  ///////////////////////////////
  //  DB Select Slides Loop
  //
    while not CurSlidesDSet.Eof do
    begin
      SSlideID := CurSlidesDSet.FieldList.Fields[0].AsString;
      CurSlide := nil;
      if SCInd < CurSlidesList.Count then
        CurSlide := TN_UDCMSlide(CurSlidesList[SCInd]);
      NewSlideFlag := FALSE;
      StudyFlag := FALSE;
      LockedSlideFlag := FALSE;
      SkipThumbnailUpdate := FALSE;
      if (CurSlide = nil) or (CurSlide.ObjName <> SSlideID) then
      begin
        SInd := TmpStrings.IndexOf(SSlideID);

        NewSlideFlag := SInd < 0;
        if not NewSlideFlag then
        begin
        // Use Existing Slide Object
          CurSlide := TN_UDCMSlide(CurSlidesList[SInd]);
          SCInd := SInd; // Set SCInd
        end  // if not NewSlideFlag then
        else
        begin // if NewSlideFlag then
          // Create new Slide Object
          StudyFlag := (K_CMEDDBVersion >= 24) and (CurSlidesDSet.Fields[K_CMENDBSTFSlideStudyIDInd].AsInteger < 0);
          if not StudyFlag then
          begin
            CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMSlideCI));
            EDAGetSlideFields( CurSlide, TRUE );
            N_Dump2Str('DB>> Refresh >> New Slide ID=' + CurSlide.ObjName);
          end // if not StudyFlag then
          else
          begin // if StudyFlag then
            CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMStudyCI));
            EDAStudyGetFields( TN_UDCMStudy(CurSlide) );
            StudiesList.AddObject( CurSlide.ObjName, CurSlide );
            N_Dump2Str('DB>> Refresh >> New Study ID=' + CurSlide.ObjName);
          end;  // if StudyFlag then

          EDAGetSlideThumbnail(CurSlide);
          CurSlidesList.Insert(SCInd, CurSlide);
          TmpStrings.InsertObject(SCInd, CurSlide.ObjName, CurSlide);
          // Correct Strings to synchronize with CurSlidesList
          Inc(ANewSlidesCount);
        end; // if NewSlideFlag then
      end; // if (CurSlide = nil) or (CurSlide.ObjName <> SSlideID) then

      if not NewSlideFlag then
      begin
        StudyFlag := TN_UDCMBSLide(CurSlide) is TN_UDCMStudy;
        if StudyFlag then
          StudiesList.AddObject( CurSlide.ObjName, CurSlide );
      end; // if not NewSlideFlag then


      SlideActualDTImgMod := 0;
      ChngMarkedAsDel := FALSE;
      UpdateCommon := FALSE;
      UpdateCurImg := FALSE;
      UpdateMapRoot := FALSE;
      UpdateAttrs := FALSE;
      PCMSlideFields := CurSlide.P();
      with CurSlide, PCMSlideFields^ do
      begin
        if not NewSlideFlag then
        begin
        // Update Image Date and Host Location
        ///////////////////////
        // Check Slide Updates
        //
          DBUStateFlags := [];
          LockedSlideFlag := cmsfIsLocked in CMSRFlags;
          if // Slide is not opended in VE mode - Skip Update opened Slide
             not LockedSlideFlag and
             // Slide was saved to DB (change flags means saving fails) - Skip Update not saved Slide
             (CMSRFlags * [cmsfIsNew,cmsfCurImgChanged,cmsfMapRootChanged,
                          cmsfAttribsChanged,cmsfThumbChanged] = []) then
            DBUStateFlags := EDACheckSLideUpdates( PCMSlideFields, SlideActualDTImgMod, CurSlidesDSet,
                                                   K_CMENDBSTFSlideDTPropInd,
                                                   K_CMENDBSTFSlideDTMapRootInd,
                                                   K_CMENDBSTFSlideDTImgInd );
          SlideActualDTImgMod := CurSlidesDSet.FieldList[K_CMENDBSTFSlideDTImgInd].AsDateTime;
          UpdateMapRoot := [K_dbusOldMapRoot,K_dbusNewMapRoot] * DBUStateFlags <> [];
          UpdateAttrs := [K_dbusOldProps,K_dbusNewProps] * DBUStateFlags <> [];
          if not StudyFlag then
          begin
            UpdateCurImg := [K_dbusOldCurImg,K_dbusNewCurImg] * DBUStateFlags <> [];

            if UpdateCurImg then
              PutDirChildSafe(K_CMSlideIndCurImg, nil);

            if UpdateMapRoot then
              PutDirChildSafe(K_CMSlideIndMapRoot, nil);
          end
          else
          begin
            UpdateCurImg := FALSE;
          end;
        ///////////////////////


        //////////////////////////////
        // Prep Slide State by Updates
        //
          if UpdateCurImg or UpdateMapRoot then
          begin
            EDAGetSlideThumbnail(CurSlide);
            SkipThumbnailUpdate := TRUE;
            CurSlide.CMSViewUpdateFlag := TRUE;
            Inc(AUpdateSlidesCount);
          end;
          with CurSlidesDSet do
          begin
            if K_CMEDDBVersion >= 10 then
            begin
              WByte := FieldList[K_CMENDBSTFSlideFlagsInd].AsInteger;
              ChngMarkedAsDel := (CMSDBStateFlags * [cmsdbfMarkedAsDel]) <> (TN_CMSlideDBFlags(WByte) * [cmsdbfMarkedAsDel]);
              CMSDBStateFlags := TN_CMSlideDBFlags(WByte);
            end;

            if K_CMEDDBVersion >= 41 then
            begin
              CMSArchDate := TDateTimeField(FieldList[K_CMENDBSTFSlideDTArchInd]).Value;
              if K_CMEDDBVersion >= 44 then
              begin
                with FieldList[K_CMENDBSTFSlideDFlagsInd] do
                  if not IsNull then //
                    Byte(CMSDCMFSet) := Byte(AsInteger);
              end; // if K_CMEDDBVersion >= 44 then
            end // if K_CMEDDBVersion >= 41 then
            else
            if K_CMEnterpriseModeFlag then
              CMSLocIDHost := CurSlidesDSet.FieldList[K_CMENDBSTFSlideLocIDHostInd].AsInteger;
          end;

          UpdateCommon := UpdateAttrs or UpdateCurImg or UpdateMapRoot;
        end; // if not NewSlideFlag then

        if not StudyFlag then
        begin
        // Update Slide
          if UpdateCommon then
          begin
          // Update Slide Fields
            Include( CMSRFlags, cmsfInitUndoBuf );

            if UpdateCurImg or UpdateMapRoot then
              FViewAttrs := CMSDB.ViewAttrs;
//              Move(CMSDB.ColPalInd, SlideVewAttrsBuf[0], K_SlideViewAttsSize);

            EDAGetSlideFields( CurSlide, TRUE );

            if UpdateCurImg or UpdateMapRoot then
              CMSDB.ViewAttrs := FViewAttrs;
//              Move(SlideVewAttrsBuf[0], CMSDB.ColPalInd, K_SlideViewAttsSize);

          end
          else
          begin
            if K_CMEDDBVersion >= 24 then
            begin
              CMSStudyID := CurSlidesDSet.FieldList[K_CMENDBSTFSlideStudyIDInd].AsInteger; // Study Sample ID
              CMSStudyItemID := CurSlidesDSet.FieldList[K_CMENDBSTFSlideStudyItemInd].AsInteger; // Study Sample Items Count
              if K_CMEDDBVersion >= 39 then
                CMSStudyItemPos := CurSlidesDSet.FieldList[K_CMENDBSTFSlideStudyItemPosInd].AsInteger; // Study Item Pos
            end;
          end;

          // Update Slide Location Fields (Enterprise)
          EDAGetSlideLocFields( CurSlide, SlideActualDTImgMod );

          if not NewSlideFlag        and
             not LockedSlideFlag     and
             not SkipThumbnailUpdate and
             (K_CMEDDBVersion >= 41) then // actual for archiving by other user
            EDAGetSlideThumbnail(CurSlide);

        end  // if not StudyFlag then
        else // if StudyFlag then
        if UpdateMapRoot or UpdateAttrs then
          EDAStudyGetFields( TN_UDCMStudy(CurSlide) );

        if cmsfIsOpened in CMSRFlags then
        begin
          if ChngMarkedAsDel then // MarkAsDel state was changed - Close if Needed
            Include( CMSRFlags, cmsfCloseOpened );
        end;
      end; // with CurSlide, PCMSlideFields^ do

      CurSlide.Marker := 1; // Mark Slide that is needed after refresh
      Inc(SCInd);
      CurSlidesDSet.Next;
    end; // while not CurSlidesDSet.Eof do
  //
  //  end of DB Select Slides Loop
  ///////////////////////////////

    TmpStrings.Clear;
    CurSlidesDSet.Close();

    if K_CMEnterpriseModeFlag then
      CurSlidesLocDSet.Close();

  /////////////////////////////////////
  // Remove Not used Slides and Studies
  //   and 3D Objects if 3D functionality is not available
    ADelSlidesCount := 0;
    for SCInd := CurSlidesList.Count - 1 downto 0 do
    begin
      CurSlide := TN_UDCMSlide(CurSlidesList[SCInd]);
      if CurSlide.Marker <> 0 then
      begin // Slide is needed - Clear Marker and Continue
        CurSlide.Marker := 0;
{!!! do 3D objects always visible
        if not K_CMDesignModeFlag                      and
           (TN_UDCMBSLide(CurSlide) is TN_UDCMSlide)   and
           (cmsfIsImg3DObj in CurSlide.P.CMSDB.SFlags) and
           ((K_CMSLiRegStatus <> K_lrtComplex) or
            (limdImg3D in K_CMSLiRegModDisable)) then
        begin
          N_Dump2Str('DB>> Refresh >> Clear 3D Slide ID=' + CurSlide.ObjName);
          CurSlidesList.Delete(SCInd);
          goto  DeleteSlide;
        end
        else
}
          Continue;
      end;

      if cmsfIsNew in CurSlide.P.CMSRFlags then Continue; // New Slide - deletion is not needed

      // Delete Slide and Links to Study Item
      N_Dump2Str('DB>> Refresh >> Del Slide ID=' + CurSlide.ObjName);
      CurSlidesList.Delete(SCInd);
      if cmsfIsOpened in CurSlide.P.CMSRFlags then
        with N_CM_MainForm.CMMFFindEdFrame(CurSlide) do
          EdFreeObjects( [cmrfefSkipSave] );

      if TN_UDCMBSLide(CurSlide) is TN_UDCMSlide then
      begin
        if CurSlide.CMSStudyID > 0 then
        begin
        // Slide was Removed - Remove Current Runtime Study Link
           StudyItem := CurSlide.DirChild(K_CMSlideIndStudyItem);
           if StudyItem <> nil then
           begin
             Study := TN_UDCMStudy(StudyItem.Owner.Owner);
             if Study <> nil then // Study was not removed earlier - dismount
               EDAStudyDismountOneSlideFromItem( StudyItem, CurSlide, Study, TRUE );
           end; // if StudyItem <> nil then
        end; // if CurSlide.CMSStudyID > 0 then
      end; // if TN_UDCMBSLide(CurSlide) is TN_UDCMSlide then
      Inc(ADelSlidesCount); // Number of Deleted Slides

DeleteSlide: //******
      CurSlide.UDDelete();
    end; // for SCInd := CurSlidesList.Count - 1 downto 0 do
{}

  //
  // end of Remove Not used Slides and Studies
  ////////////////////////////////////////////
    CurSlide := nil;

    EDARestoreAllMountedSlidesLinks(StudiesList);

    StudiesList.Free;

    if not K_CMMarkAsDelShowFlag then
    begin
      CurSlidesDSet.SQL.Text := 'select count(*) ' +
        ' from ' + EDAGetSlideSelectFromStr( ) +
        ' where ' +  K_CMENDBSTFPatID + '=' + SPatID +
                     K_CMEDAGetSlideSelectWhereStr( K_swfOnlyMarkedAsDel );
      CurSlidesDSet.Filtered := false;
      CurSlidesDSet.Open;
      K_CMMarkedAsDeletedCount := CurSlidesDSet.FieldList[0].AsInteger;
      CurSlidesDSet.Close;
    end;

{
  ///////////////////////////////
  //  Restore New Slides Loop
    for i := High(NewSlidesArray) downto 0 do
      CurSlidesList.Add( NewSlidesArray[i] );
  //
  ///////////////////////////////
}
    N_Dump2Str('DB>> Refresh slides fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDARefreshCurSlidesSet ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSelect;
      Exit;
    end;
  end;
  N_Dump2Str('DB>> EDARefreshCurSlidesSet fin');
end; // end of TK_CMEDDBAccess.EDARefreshCurSlidesSet

//********************************************* TK_CMEDDBAccess.EDAGetCurSlidesSet ***
// Get Current Slides Set from Extenal Data
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetCurSlidesSet(): TK_CMEDResult;
var
  SPatID: string;
  // SCount, i : Integer;
  SelectWhereFlags : TK_CMEDASelectWhereFlags;
  StudiesList : TStringList;
{
}

label NextSlideFromBD;
begin
  EDAClearCurSlidesSet();
  Result := EDACheckDBConnection(CurSlidesDSet.Connection);
  if Result <> K_edOK then
    Exit;
  try
    SPatID := IntToStr(CurSlidesSelectAttrs.SSPatID);
    N_Dump2Str('DB>> Select slides for patient ID=' + SPatID);

    EDAGetPatientSlidesUpdateTS(); // Get Update Slides TS before Build CurSlides Set

    SelectWhereFlags := K_swfSkipAllDel;
    if K_CMMarkAsDelShowFlag then
      SelectWhereFlags := K_swfOnlyMarkedAsDel;
//      SelectWhereFlags := K_swfSkipDBDeleting;
    CurSlidesDSet.SQL.Text := 'select ' +
      EDAGetSlideSelectFieldsStr( [K_sffAddThumbField] ) +
      ' from ' + EDAGetSlideSelectFromStr( ) +
      ' where ' +  K_CMENDBSTFPatID + '=' + SPatID +
                   K_CMEDAGetSlideSelectWhereStr( SelectWhereFlags ) +
//                   EDAGetSlideSelectWhereStr( SelectWhereFlags ) +
//         EDAGetSlideSelectWhereStr( [] ) +
      ' order by ' + K_CMENDBSTFSlideDTCr + ' asc';
    CurSlidesDSet.Filtered := false;
    CurSlidesDSet.Open;
    CurSlidesDSet.First;

    if K_CMEnterpriseModeFlag then
      EDALocFilesInfoQuery( );

    StudiesList := TStringList.Create;
    while not CurSlidesDSet.Eof do
    begin
      // Create new Slide Object
      if (K_CMEDDBVersion < 24) or
         (CurSlidesDSet.Fields[K_CMENDBSTFSlideStudyIDInd].AsInteger >= 0) then
      begin // Slide
        CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMSlideCI));
        EDAGetSlideFields( CurSlide, TRUE );
{!!! do 3D objects always visible
        if not K_CMDesignModeFlag                      and
           (cmsfIsImg3DObj in CurSlide.P.CMSDB.SFlags) and
           ((K_CMSLiRegStatus <> K_lrtComplex) or
            (limdImg3D in K_CMSLiRegModDisable)) then
        begin // Remove 3D Objects if 3D functionality is not available
          N_Dump2Str('DB>> Select >> Clear 3D Slide ID=' + CurSlide.ObjName);
          CurSlide.UDDelete();
          goto NextSlideFromBD;
        end;
}
        EDAGetSlideLocFields( CurSlide );
      end
      else
      begin // Study
        CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMStudyCI));
        EDAStudyGetFields( TN_UDCMStudy(CurSlide) );
        StudiesList.AddObject( CurSlide.ObjName, CurSlide );
      end;
      EDAGetSlideThumbnail(CurSlide);
      CurSlidesList.Add(CurSlide);

NextSlideFromBD: //***********
      CurSlidesDSet.Next;
    end; //  while not CurSlidesDSet.Eof do


    CurSlidesDSet.Close();

    if K_CMEnterpriseModeFlag then
      CurSlidesLocDSet.Close();

    EDARestoreAllMountedSlidesLinks(StudiesList);
    StudiesList.Free;

    if not K_CMMarkAsDelShowFlag then
    begin
      CurSlidesDSet.SQL.Text := 'select count(*) ' +
        ' from ' + EDAGetSlideSelectFromStr( ) +
        ' where ' +  K_CMENDBSTFPatID + '=' + SPatID +
                     K_CMEDAGetSlideSelectWhereStr( K_swfOnlyMarkedAsDel );
      CurSlidesDSet.Filtered := false;
      CurSlidesDSet.Open;
      K_CMMarkedAsDeletedCount := CurSlidesDSet.FieldList[0].AsInteger;
      CurSlidesDSet.Close;
    end;

    N_Dump2Str('DB>> Select slides fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetCurSlidesSet ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSelect;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAGetCurSlidesSet

//************************************ TK_CMEDDBAccess.EDAGetUDCMSlidesByID0 ***
// Get Slides from Extenal Data by given IDs
//
//     Parameters
// APSlideIDs - pointer to first slide ID
// ACount - number of slides ID
// ASlides - resulting array of slides
// Result - Returns operation resulting code
//
// Resulting array ASlides length may be less than number of slides ID ACount if
// some Slides with given IDs are not found
//
function TK_CMEDDBAccess.EDAGetUDCMSlidesByID0( APSlideIDs: PInteger; ACount: Integer;
                                var ASLides: TN_UDCMSArray ): TK_CMEDResult;
var
  Ind, i, SInd: Integer;
  SQLStr: string;
  SPatID: string;
  SSlideID: string;
begin
  N_Dump2Str('DB>> Get slides by given IDs start');
  Result := EDACheckDBConnection(CurSlidesDSet.Connection);
  if Result <> K_edOK then
    Exit;
  try
    SPatID := IntToStr(CurSlidesSelectAttrs.SSPatID);
    SQLStr := K_CMENDBSTFSlideID + ' = ' + IntToStr(APSlideIDs^);
    for i := 1 to ACount - 1 do
    begin
      Inc(APSlideIDs);
      SQLStr := SQLStr + ' or ' + K_CMENDBSTFSlideID + ' = ' + IntToStr(APSlideIDs^);
    end;
    CurSlidesDSet.SQL.Text := 'select ' +
      EDAGetSlideSelectFieldsStr( [] ) +
      ' from ' + EDAGetSlideSelectFromStr( ) +
      ' where (' +  SQLStr + ')' +
              K_CMEDAGetSlideSelectWhereStr( K_swfSkipFlagsCond ) +
//              EDAGetSlideSelectWhereStr( K_swfSkipFlagsCond ) +
      ' order by ' +  K_CMENDBSTFSlideDTCr + ' asc';

    CurSlidesDSet.Filtered := false;
    CurSlidesDSet.Open;
    SetLength(ASLides, ACount);
    Ind := 0;
    CurSlidesDSet.First;
    TmpStrings.Clear;
    TmpStrings.Sorted := FALSE;
    EDACurSlidesToStrings(TmpStrings);
    TmpStrings.Sort();

    while not CurSlidesDSet.Eof do
    begin
      CurSlide := nil;
      if (SPatID = CurSlidesDSet.FieldList.Fields[1].AsString) then
      begin
        // Search for Existing Slide
        SSlideID := CurSlidesDSet.FieldList.Fields[0].AsString;
        if TmpStrings.Find( SSlideID, SInd ) then
          // Use Existing Slide Oblect
          CurSlide := TN_UDCMSlide(TmpStrings.Objects[SInd]);
      end;
      if CurSlide = nil then
      begin
        if (K_CMEDDBVersion >= 24) and
           (CurSlidesDSet.Fields[K_CMENDBSTFSlideStudyIDInd].AsInteger < 0) then
        begin
          // Create New Study Oblect
          CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMStudyCI));
          EDAStudyGetFields( TN_UDCMStudy(CurSlide), CurSlidesDSet );
        end
        else
        begin
          // Create New Slide Oblect
          CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1,
              N_UDCMSlideCI));
          EDAGetSlideFields( CurSlide, FALSE, CurSlidesDSet );
        end;
        CurSlide.Marker := 1;
      end;
      ASLides[Ind] := CurSlide;
      CurSlidesDSet.Next();
      Inc(Ind);
    end;
    SetLength(ASLides, Ind);
    CurSlidesDSet.Close();
    TmpStrings.Sorted := FALSE;
    N_Dump2Str(format('DB>> Get %d slides by given IDs', [Ind]));
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetUDCMSlidesByID0 ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSelect;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAGetUDCMSlidesByID0

//************************************ TK_CMEDDBAccess.EDAGetUDCMSlidesByID ***
// Get Slides from Extenal Data by given IDs
//
//     Parameters
// APSlideIDs - pointer to first slide ID
// ACount - number of slides ID
// ASlides - resulting array of slides
// Result - Returns operation resulting code
//
// Resulting array ASlides length may be less than number of slides ID ACount if
// some Slides with given IDs are not found
//
function TK_CMEDDBAccess.EDAGetUDCMSlidesByID( APSlideIDs: PInteger; ACount: Integer;
  var ASLides: TN_UDCMSArray): TK_CMEDResult;
var
  i : Integer;
{
  Ind, SInd: Integer;
  SQLStr: string;
  SPatID: string;
  SSlideID: string;
}
begin
  N_Dump2Str('DB>> Get slides by given IDs');
  Result := EDAGetUDCMSlidesByID0( APSlideIDs, ACount, ASLides);
// Clear marker field just in case because new func EDAGetUDCMSlidesByID0 set Marker for self created slides
  for i := 0 to High(ASLides) do
    ASLides[i].Marker := 0;

{
  try
    SPatID := IntToStr(CurSlidesSelectAttrs.SSPatID);
    SQLStr := K_CMENDBSTFSlideID + ' = ' + IntToStr(APSlideIDs^);
    for i := 1 to ACount - 1 do
    begin
      Inc(APSlideIDs);
      SQLStr := SQLStr + ' or ' + K_CMENDBSTFSlideID + ' = ' + IntToStr(APSlideIDs^);
    end;
    CurSlidesDSet.SQL.Text := 'select ' +
      EDAGetSlideSelectFieldsStr( [] ) +
      ' from ' + EDAGetSlideSelectFromStr( ) +
      ' where (' +  SQLStr + ')' +
              K_CMEDAGetSlideSelectWhereStr( K_swfSkipFlagsCond ) +
//              EDAGetSlideSelectWhereStr( K_swfSkipFlagsCond ) +
      ' order by ' +  K_CMENDBSTFSlideDTCr + ' asc';

    CurSlidesDSet.Filtered := false;
    CurSlidesDSet.Open;
    SetLength(ASLides, ACount);
    Ind := 0;
    CurSlidesDSet.First;
    TmpStrings.Clear;
    TmpStrings.Sorted := FALSE;
    EDACurSlidesToStrings(TmpStrings);
    TmpStrings.Sort();

    while not CurSlidesDSet.Eof do
    begin
      CurSlide := nil;
      if (SPatID = CurSlidesDSet.FieldList.Fields[1].AsString) then
      begin
        // Search for Existing Slide
        SSlideID := CurSlidesDSet.FieldList.Fields[0].AsString;
        if TmpStrings.Find( SSlideID, SInd ) then
          // Use Existing Slide Oblect
          CurSlide := TN_UDCMSlide(TmpStrings.Objects[SInd]);
      end;
      if CurSlide = nil then
      begin
        // Create New Slide Oblect
        CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1,
            N_UDCMSlideCI));
        EDAGetSlideFields(CurSlide, FALSE);
      end;
      ASLides[Ind] := CurSlide;
      CurSlidesDSet.Next();
      Inc(Ind);
    end;
    SetLength(ASLides, Ind);
    CurSlidesDSet.Close();
    TmpStrings.Sorted := FALSE;
    N_Dump2Str(format('DB>> Get %d slides by given IDs', [Ind]));
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetUDCMSlidesByID ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSelect;
      Exit;
    end;
  end;
}
end; // end of TK_CMEDDBAccess.EDAGetUDCMSlidesByID

//********************************************* TK_CMEDDBAccess.EDAUpdateSlide ***
// Udate given SLide from DB
//
//     Parameters
// ASlide - slide to update
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAUpdateSlide(ASlide: TN_UDCMSlide;
  ASkipCurImgLoad: Boolean = false): TK_CMEDResult;
var
//  CField: TField;
//  DSize: Integer;
//  PData: Pointer;
  // InTrans : Boolean;
  // SlideVewAttrsBuf : array [0..K_SlideViewAttsSize-1] of byte;
  CMSlide: TN_CMSlide;
  CMSlideDB: TN_CMSlide;
  PCMSlide : TN_PCMSlide;
  { // Save as *.TIF
    CurImg : TN_UDDIB;
    DIBObj : TN_DIBObj;
  }
begin
  try
    with CurSlidesDSet, ASlide do
    begin
      N_Dump2Str('DB>> Update slide ID=' + ObjName);
      Result := EDACheckDBConnection(Connection);
      if Result <> K_edOK then
        Exit;

      Result := EDASetCurSlide(ASlide, TRUE);
      if Result <> K_edOK then
        Exit;
      // Update Attributes
      PCMSlide := ASlide.P();
      CMSlide := PCMSlide^; // Save Slide Current State to CMSlide
      Result := EDAGetSlideFields(ASlide, FALSE);
      if Result <> K_edOK then
      begin
        ASlide.P^ := CMSlide;
        N_Dump1Str( 'DB>> Update slide GetFields error ID=' + ObjName );
        Exit;
      end;
      CMSlideDB := PCMSlide^;

      if K_CMEnterpriseModeFlag then
      begin
        EDALocFilesInfoQuery( ASlide.ObjName );
        EDAGetSlideLocFields(ASlide);
        CurSlidesLocDSet.Close;
      end; // if K_CMEnterpriseModeFlag then

{!!! 2018-11-13 error while add never used slide to study - when CurImage is not loaded
      with ASlide.P^ do
      begin
        if CMSlide.CMSDTPropMod > CMSDTPropMod then
        begin
          // Restore User Attributes
          CMSDTPropMod := CMSlide.CMSDTPropMod;
          CMSMediaType := CMSlide.CMSMediaType;
          CMSTeethFlags := CMSlide.CMSTeethFlags;
          CMSDiagn := CMSlide.CMSDiagn;
        end;
        // Restore Self View Attributes
//        Move(CMSlide.CMSDB.ColPalInd, CMSDB.ColPalInd, K_SlideViewAttsSize);
        Move(CMSlide.CMSDB.ViewAttrs, CMSDB.ViewAttrs, SizeOf(TN_CMSViewAttrs) );
      end;

      if Result <> K_edOK then
        Exit;

      Result := EDAGetSlideThumbnail(ASlide);
      if Result <> K_edOK then
        Exit;

      Result := EDAGetSlideMapRoot0(ASlide);

      if not(cmsfIsMediaObj in CMSDB.SFlags) and not ASkipCurImgLoad then
      begin
        Result := EDAGetSlideCurImage0(ASlide);
      end;
}
///////////////////////////
// !!! New code 2018-11-13
      if (CMSlide.CMSDTPropMod >= CMSlideDB.CMSDTPropMod) or
         (cmsfAttribsChanged in CMSlide.CMSRFlags) then
        PCMSlide^ := CMSlide // return Slide Fields
      else
        Move(CMSlide.CMSDB.ViewAttrs, PCMSlide^.CMSDB.ViewAttrs, SizeOf(TN_CMSViewAttrs) );

      with CMSlide do
      if not (cmsfThumbChanged in CMSRFlags)  and
         not (cmsfCurImgChanged in CMSRFlags) and
         not (cmsfMapRootChanged in CMSRFlags) then
      begin
        Result := EDAGetSlideThumbnail(ASlide);
        if Result <> K_edOK then
        begin
          N_Dump1Str( 'DB>> Update slide GetThumbnail error ID=' + ObjName );
          Exit;
        end;
      end;

      if not (cmsfMapRootChanged in CMSlide.CMSRFlags) then
      begin
        Result := EDAGetSlideMapRoot0(ASlide);
        if Result <> K_edOK then
        begin
          N_Dump1Str( 'DB>> Update slide GetMapRoot error ID=' + ObjName );
          Exit;
        end;
      end; // if not (cmsfMapRootChanged in CMSlide.CMSRFlags) then

      if not(cmsfIsMediaObj in CMSlide.CMSDB.SFlags) and
         not(cmsfIsImg3DObj in CMSlide.CMSDB.SFlags) and
         not ASkipCurImgLoad then
      begin
        Result := EDAGetSlideCurImage0(ASlide);
      end;
// !!! New code 2018-11-13
///////////////////////////

      CurSlidesDSet.Close;
      EDALockSlideForRW(ASlide.ObjName, K_cmlfFree);

    end;
    N_Dump2Str('DB>> Update slide fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAUpdateSlide ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAUpdateSlide

//********************************************* TK_CMEDDBAccess.EDAGetSlideMapRoot0 ***
// Get given SLide MapRoot from DB
//
//     Parameters
// ASlide - slide to update
// Result - Returns operation resulting code
//
// Low level procedure - only get MapRoot Blob from DB
//
function TK_CMEDDBAccess.EDAGetSlideMapRoot0(ASlide: TN_UDCMSlide ) : TK_CMEDResult;
var
  CField: TField;
  DSize: Integer;
  PData: Pointer;
begin
  with CurSlidesDSet, ASlide, P()^ do
  begin
    N_Dump2Str('DB>> EDAGetSlideMapRoot0 start');
    Result := K_edAbsentData;
    CField := CurSlidesDSet.FieldList.Find(K_CMENDBSTFSlideMapRoot);
    if CField <> nil then
    begin
      N_Dump2Str('DB>> Get MapRoot SlideID=' + ObjName);
      Result := EDAGetBlobFieldValue(CurSlidesDSet, CField, PData, DSize);
      if (Result = K_edOK) and (DSize > 0) then
      begin
        DSize := EDAAnsiTextToString(PData, DSize);
{ // Deb Code 
TmpStrings.Text := PCHAR(PData);
K_GetFormTextEdit.EditStrings(TmpStrings);
N_S := TmpStrings.Text;
PData := @N_S[1];
DSize := Length(N_S);
{}
        ASlide.PutDirChildSafe(K_CMSlideIndMapRoot, N_LoadUObjFromMem(PData, DSize));
        if K_LoadUDTreeErrorMessage <> '' then
        begin
          N_Dump1Str('MapRoot Load Error SLide ID=' + ObjName);
          N_Dump1Str( PChar(PData) );
          N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServCloseCMS, TRUE );
        end;
      end;
    end;
    N_Dump2Str('DB>> EDAGetSlideMapRoot0 fin');
  end;
end; // TK_CMEDDBAccess.EDAGetSlideMapRoot0

//********************************************* TK_CMEDDBAccess.EDAGetSlideBlobFieldValue ***
// Get Slide Blob Field given by Name to Blob Buffer
//
//     Parameters
// ASlide - given Slide
// AFieldName - Blob Field Name
// ADsize - resulting data size in bytes
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlideBlobFieldValue(const ASlideID: string;
  AFieldName: string; out APData: Pointer;
  out ADSize: Integer): TK_CMEDResult;
begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  try
    ExtDataErrorCode := K_eeDBSelect;
    with CurBlobDSet do
    begin
      Connection := LANDBConnection;
      SQL.Text := 'select ' + AFieldName +
        ' from ' + K_CMENDBSlidesTable +
        ' where ' + K_CMENDBSTFSlideID + '=' + ASlideID;
      Filtered := false;
      Open;
      Result := EDAGetBlobFieldValue(CurBlobDSet, FieldList.Fields[0], APData,
        ADSize);
      Close;
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAGetSlideBlobFieldValue ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAGetSlideBlobFieldValue

//********************************************* TK_CMEDDBAccess.EDAGetSlideMapRoot ***
// Get given Slide Graphic
//
//     Parameters
// ASlide - given Slide
// ASkipLoadFlag - if =TRUE then slide content shoud not be loaded
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlideMapRoot( ASlide: TN_UDCMSlide;
        ASkipLoad: Boolean = false; ASkipCurImgLoad: Boolean = false ): TK_CMEDResult;
// var
// DSize : Integer;
begin
  Result := K_edOK;
  if ASlide.DirChild(K_CMSlideIndMapRoot) <> nil then
    Exit;

  if ASkipLoad then
  begin
    Result := K_edAbsentData;
    Exit;
  end;

  N_Dump2Str('DB>> Update Slide by MapRoot ID=' + ASlide.ObjName);
  Result := EDAUpdateSlide(ASlide, ASkipCurImgLoad);
  {
    N_Dump2Str( 'DB>> Get Slide MapRoot ID=' + ASlide.ObjName );
    Result := EDAGetSlideBlobFieldValue( ASlide, K_CMENDBSTFSlideMapRoot, DSize );
    if (Result <> K_edOK) or (DSize <= 0) then Exit;
    ASlide.PutDirChildSafe( K_CMSlideIndMapRoot, N_LoadUObjFromMem( @BlobBuf[0], DSize ) );
  }
end; // end of TK_CMEDDBAccess.EDAGetSlideMapRoot

//********************************************* TK_CMEDDBAccess.EDACheckSlideImageData ***
// Check Slide Image Data by given file name
//
//     Parameters
// AFName - slide image file name
// APData - pointer to files data buffer
// ADSize - files data buffer size
// AFSize - on out image file size
// ACheckLevel - file check level: 0 - only data file check, 1 - deserialization check,
//   2 - DIB loading check
// Result - Returns resulting 0 - OK, 1 - File is absent, 2 - File is Corrupted,
//          3 - Deserialization error, 4 - DIB format Error
//
function TK_CMEDDBAccess.EDACheckSlideImageData( const AFName : string;
                     out APData : Pointer; out ADSize : Integer;
                     out AFSize : Integer;
                     ACheckLevel : Integer ) : Integer;
var
  UDDIB: TN_UDDIB;
  OpRes : TK_CMEDResult;

begin
  // Get Current Image from DB File
  Result := 0;
  N_Dump2Str( 'DB>> EDACheckSlideImageData FName=' + AFName );
  try
    OpRes := EDASlideDataFromFile( APData, ADSize, AFName, AFSize );
  except
    on E: Exception do begin
      N_Dump1Str( 'DB >> Image File Error >> ' + E.Message );
      OpRes := K_edFails;
    end;
  end;
  if (OpRes  <> K_edOK) then
  begin
    if ExtDataErrorCode = K_eeFileExists then
      Result := 1
    else
      Result := 2;
    Exit;
  end;

  if ACheckLevel < 1 then Exit;

  UDDIB := K_CMCreateUDDIBBySData( APData, ADSize, EDAFreeBuffer );
  if UDDIB = nil then
  begin
    Result := 3;
    Exit;
  end;

  if ACheckLevel >= 2 then
    try
      UDDIB.LoadDIBObj();
    except
      on E: Exception do begin
        N_Dump1Str( 'DB >> EDACheckSlideImageData Error >> ' + E.Message );
        Result := 4;
      end;
    end;

  UDDIB.Free;

end; // end of TK_CMEDDBAccess.EDACheckSlideImageData

//********************************************* TK_CMEDDBAccess.EDAGetSlideCurImage0 ***
// Get given Slide Current Image only
//
//     Parameters
// ASlide - given Slide
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlideCurImage0(ASlide: TN_UDCMSlide) : TK_CMEDResult;
var
  DSize: Integer;
  PData: Pointer;
  FName : string;

begin
  Result := K_edOK;
  if (ASlide.DirChild(K_CMSlideIndCurImg) <> nil) then
    Exit;

  FName := '';
  if ASlide.CMSlideECFName <> '' then
  begin
  // Try ECache
    FName := ASlide.CMSlideECFName;
    FName[Length(FName) - 4] := 'R';
    if not FileExists( FName ) then
      FName := '' // EChache File is absent try DB File
  end; // if ASlide.CMSlideECFStream <> nil then

  if FName = '' then // Get Current Image from DB File
    FName := ASlide.GetCurImgFileName( EDAGetSlideImgPath(ASlide) );

  N_Dump2Str( 'DB>> EDAGetSlideCurImage0 FName=' + FName );
  try
    Result := EDASlideDataFromFile( PData, DSize, FName, ASlide.CMSCurImgFSize );
  except
    on E: Exception do
    begin
      N_Dump1Str( 'DB>> Current Image File Error >> ' + E.Message );
      Result := K_edFails;
    end;
  end; // except

  if (Result <> K_edOK) or (DSize = 0) then Exit;

  if not ASlide.SetCurrentImageBySData( PData, DSize, EDAFreeBuffer ) then
  begin
    N_Dump1Str( 'DB>> Current Image File Error >> File data is corrupted.' );
    Result := K_edFails;
  end;

end; // end of TK_CMEDDBAccess.EDAGetSlideCurImage0

//********************************************* TK_CMEDDBAccess.EDAGetSlideCurImage ***
// Get given Slide Graphic
//
//     Parameters
// ASlide - given Slide
// ASkipLoadFlag - if =TRUE then slide content shoud not be loaded
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlideCurImage( ASlide: TN_UDCMSlide;
                           ASkipLoad: Boolean = false ): TK_CMEDResult;
var
// DSize : Integer;
  PCMSlide : TN_PCMSlide;
begin
  Result := K_edOK;
  PCMSlide := ASlide.P();
  if (cmsfIsMediaObj in PCMSlide.CMSDB.SFlags) or
     (cmsfIsImg3DObj in PCMSlide.CMSDB.SFlags) or
     (ASlide.DirChild(K_CMSlideIndCurImg) <> nil) then
    Exit;
  if ASkipLoad then
  begin
    Result := K_edAbsentData;
    Exit;
  end;
  N_Dump2Str('DB>> Update Slide by Current Image ID=' + ASlide.ObjName);
  if not ASlide.CMSSkipMemFree4CurImage then
     K_CMSCheckMemConstraints(ASlide);

  if (cmsfIsNew in PCMSlide.CMSRFlags) or
     (cmsfCurImgChanged in PCMSlide.CMSRFlags) then
  // To prevent Slide Data Update from DB if CurImage object was removed by MemoryConstraints
  // only restore Current Image from ECahe file
    Result := EDAGetSlideCurImage0(ASlide)
  else
    Result := EDAUpdateSlide(ASlide);

  ASlide.CMSSkipMemFree4CurImage := FALSE;

  {
    N_Dump2Str( 'DB>> Get Slide Current Image ID=' + ASlide.ObjName );
    Result := EDAGetSlideBlobFieldValue( ASlide, K_CMENDBSTFSlideCurImg, DSize );
    if (Result = K_edOK) and (DSize > 0) then
    ASlide.SetCurrentImageBySData( @BlobBuf[0], DSize );
  }
end; // end of TK_CMEDDBAccess.EDAGetSlideCurImage

//********************************************* TK_CMEDDBAccess.EDAGetSlideSrcImage ***
// Get given Slide Original Image
//
//     Parameters
// ASlide - given Slide
// ASkipLoadFlag - if =TRUE then slide source image shoud not be loaded
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlideSrcImage( ASlide: TN_UDCMSlide;
                              ASkipLoadFlag: Boolean = false ): TK_CMEDResult;
var
  DSize: Integer;
  PData: Pointer;
  SrcImg: TN_UDDIB;
  FName : string;
  // DIBObj : TN_DIBObj;
begin
  Result := K_edOK;
  SrcImg := TN_UDDIB(ASlide.DirChild(K_CMSlideIndSrcImg));
  if SrcImg <> nil then
    Exit;
  Result := K_edAbsentData;
  if ASkipLoadFlag or not(cmsfHasSrcImg in ASlide.P.CMSDB.SFlags) then
    Exit;

  N_Dump2Str('DB>> Get Slide Original Image ID=' + ASlide.ObjName);
  K_CMSCheckMemConstraints(ASlide);


  if K_CMEDDBVersion >= 3 then
  begin
    FName := '';
    if ASlide.CMSlideECFName <> '' then
    begin
    // Try ECache
      FName := ASlide.CMSlideECFName;
      FName[Length(FName) - 4] := 'S';
      if not FileExists( FName ) then
        FName := '' // EChache File is absent try DB File
    end; // if ASlide.CMSlideECFStream <> nil then

    if FName = '' then
      FName := ASlide.GetSrcImgFileName(EDAGetSlideImgPath(ASlide));

    // Get Current Image from File
    try
      Result := EDASlideDataFromFile(PData, DSize, FName, ASlide.CMSSrcImgFSize );
    except
      on E: Exception do begin
        N_Dump1Str( 'DB >> Original Image File Error >> ' + E.Message );
        Result := K_edFails;
      end;
    end;
  end
  else
  begin
    // Get Original Image from BLOB
    Result := EDAGetSlideBlobFieldValue(ASlide.ObjName, K_CMENDBSTFSlideSrcImg,
      PData, DSize);
  end;

  if (Result = K_edOK) and (DSize > 0) then
  begin
    if not ASlide.SetSourceImageBySData(PData, DSize, EDAFreeBuffer) then
    begin
      N_Dump1Str( 'DB >> Original Image File Error >> File data is corrupted.' );
      Result := K_edFails;
    end;
  end;
  N_Dump2Str('DB>> Get Slide Original Image fin');
end; // end of TK_CMEDDBAccess.EDAGetSlideSrcImage

//***************************** TK_CMEDDBAccess.EDASetSlideMediaFileTMPName ***
// Set given slide Media File Temporary name using file name extension
//
//     Parameters
// ASlide - given Slide
// AMediaFExt - file name extension
//
procedure TK_CMEDDBAccess.EDASetSlideMediaFileTMPName( ASlide: TN_UDCMSlide;
                                                      const AMediaFExt: string );
var
  FileInd: Integer;
  TMPPath: string;
//  FilesStoringModes: Integer;
  LocFName: string;
  PCMSlide : TN_PCMSlide;
begin
  if K_CMMediaFilesStoringMode <> 1 then
  // Only CLient or both Server+Client Local Path is Used
    Inherited
  else
  begin
  // Only Server Mode
    PCMSlide := ASlide.P();
    with PCMSlide^ do
    begin
      if AMediaFExt <> '' then
        CMSDB.MediaFExt := AMediaFExt;

      TMPPath := ASlide.GetFilesPathSegm();
      if SlidesMediaRootFDA and not SlidesMediaFSplit then
        // Pure Direct Access (+ DA - Split)
        TMPPath := SlidesMediaRootFolder + TMPPath
      else // (#CMECacheFiles#)
//        TMPPath := K_ExpandFileName( '(#CMECacheFiles#)' );
        TMPPath := K_CMGetECacheFilesPath();

      K_ForceDirPath( TMPPath );

      LocFName := K_DateTimeToStr( CMSDTCreated, 'hhnnsszzz' );
      FileInd := 0;
      CMSDB.MediaFExt := N_CreateUniqueFileName( TMPPath + 'MF_' + LocFName,
                                                 FileInd, CMSDB.MediaFExt );
      N_Dump1Str('TMP Media File name "' + CMSDB.MediaFExt + '"');
    end; // with PCMSlide^ do
  end; // if K_CMMediaFilesStoringMode = 1 then
end; // procedure TK_CMEDDBAccess.EDASetSlideMediaFileTMPName

//*************************** TK_CMEDDBAccess.EDASetPatientSlidesUpdateFlag ***
// Set Patient Slides Update Flag
//
procedure TK_CMEDDBAccess.EDASetPatientSlidesUpdateFlag();
begin
  try
    with TFileStream.Create( PatSlidesAutoRefreshFName, fmCreate ) do
    begin
      Free();
      PatSlidesAutoRefreshTS := K_GetFileAge(PatSlidesAutoRefreshFName);
    end;
  except
  // Call Auto Refresh if Update Flag File Conflict
    N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aViewThumbRefresh, K_CMD4WWaitApplyDataCount = 0 );
  end;

end; // procedure TK_CMEDDBAccess.EDASetPatientSlidesUpdateFlag

//***************************** TK_CMEDDBAccess.EDAGetPatientSlidesUpdateTS ***
// Set Patient Slides Update Flag
//
procedure TK_CMEDDBAccess.EDAGetPatientSlidesUpdateTS();
var
  CurTS : TDateTime;
begin
  if (CurPatID > -100) and (CurPatID <= 0) then Exit; // precaution
  PatSlidesAutoRefreshFName := SlidesImgRootFolder + K_CMSlideGetPatientFilesPathSegm(CurPatID) + '!';
  CurTS := K_GetFileAge(PatSlidesAutoRefreshFName);
  if CurTS <> 0 then
    PatSlidesAutoRefreshTS := CurTS
  else
    K_ForceFilePath( PatSlidesAutoRefreshFName );
end; // procedure TK_CMEDDBAccess.EDAGetPatientSlidesUpdateTS

//********************************** TK_CMEDDBAccess.EDACheckSlideImg3DData ***
// Check Slide 3D Image Data by given files path
//
//     Parameters
// AFPath - slide image file name
// ACheckLevel - file check level:
//#F
// 0 - only folder existance,
// 1 - check ResFiles\Info.txt and ResFiles\Thumbnail.png existance
// 2 - check all files consistency
//#/F
// Result - Returns:
//#F
// 0 - OK,
// 1 - folder is absent,
// 2 - one of needed files is absent
// 3 - one of needed files is corrupted
//
function TK_CMEDDBAccess.EDACheckSlideImg3DData( const AFPath : string;
                                                 ACheckLevel : Integer;
                                                 var AErrFileRPath : string ) : Integer;
begin
  Result := 1;
  if not DirectoryExists( AFPath ) then Exit;
  Result := 0;
  if ACheckLevel = 0 then Exit;
  Result := 2;
  AErrFileRPath := K_CMS3DImgResFolder + K_CMS3DImgResInfoFile;
  if not FileExists( AFPath + AErrFileRPath ) then Exit;
  AErrFileRPath := K_CMS3DImgResFolder + K_CMS3DImgResThumbFile;
  if not FileExists( AFPath + AErrFileRPath ) then Exit;
  Result := 0;
  if ACheckLevel = 1 then Exit;
  // Check all needed files
end; // function TK_CMEDDBAccess.EDACheckSlideImg3DData

//****************************************** TK_CMEDDBAccess.EDAStudySetCur ***
// Set given Study as current
//
//     Parameters
// AStudy - given AStudy
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAStudySetCur( AStudy: TN_UDCMStudy ): TK_CMEDResult;
var
  IsNewStudy: Boolean;
  StudyID: string;
  LogStr: string;

begin
  try
    with CurSlidesDSet, AStudy, P()^ do
    begin
      Connection := LANDBConnection;

      Result := EDACheckDBConnection(Connection);
      if Result <> K_edOK then
        Exit;

      IsNewStudy := cmsfIsNew in CMSRFlags;

      if IsNewStudy then
        StudyID := '-1'
      else
        StudyID := ObjName;

      if not Connection.InTransaction then
        Connection.BeginTrans;

      ExtDataErrorCode := K_eeDBSelect;
      SQL.Text := 'select ' +
        EDAGetSlideSelectFieldsStr( [K_sffAddThumbField,K_sffAddStudyOnlyFields] ) +
        ' from ' + EDAGetSlideSelectFromStr( ) +
        ' where ' +  K_CMENDBSTFSlideID + ' = ' + StudyID +
                     K_CMEDAGetSlideSelectWhereStr( K_swfSkipFlagsCond );
//                     EDAGetSlideSelectWhereStr( K_swfSkipFlagsCond );
      LogStr := SQL.Text;
      Filtered := false;
      Open;

      if IsNewStudy then
      begin
        ExtDataErrorCode := K_eeDBIns;
        Insert;
        Fields[K_CMENDBSTFPatIDInd].AsInteger := CMSPatId;
        if K_CMEDDBVersion >= 24 then
        begin
          Fields[K_CMENDBSTFSlideStudyIDInd].AsInteger := -CMSStudySampleID;
          Fields[K_CMENDBSTFSlideStudyItemInd].AsInteger := CMSStudyItemsCount; // Study Sample Items Count
        end;
        CurDSet1.Connection := Connection;
        if K_CMEDDBVersion >= 40 then
        begin // Get New Slide ID
          if not K_CMEDAMSSQL then
            CurDSet1.SQL.Text := 'SELECT dba.NextSlideID.NEXTVAL'
          else
            CurDSet1.SQL.Text := 'SELECT NEXT VALUE FOR dba.NextSlideID';
          CurDSet1.Filtered := false;
          CurDSet1.Open;
          StudyID := CurDSet1.FieldList.Fields[0].AsString;
          FieldList.Fields[0].AsString := StudyID;
        end;
        UpdateBatch();
        if K_CMEDDBVersion < 40 then
        begin // Get New Slide ID
          CurDSet1.SQL.Text := 'select @@identity';
          CurDSet1.Filtered := false;
          CurDSet1.Open;
          StudyID := CurDSet1.FieldList.Fields[0].AsString;
        end;
        CurDSet1.Close();
        ObjName := StudyID;
        LogStr := 'DB>> Add new Study record ID=';
        CMSRFlags := CMSRFlags + [cmsfAttribsChanged, cmsfMapRootChanged];
      end
      else
        LogStr := 'DB>> Edit existing Study record ID=';

      Edit;
      N_Dump2Str(LogStr + ObjName);

      CurSlide := TN_UDCMSLide(AStudy);
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAStudySetCur ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAStudySetCur

//********************************************* TK_CMEDDBAccess.EDAStudyGetFields ***
// Get given Study fields from AllSlides table
//
//     Parameters
// AStudy - given Study
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAStudyGetFields(AStudy: TN_UDCMStudy; ADataSet : TADOQuery = nil ): TK_CMEDResult;
var
  WByte : Byte;

begin
  Result := K_edOK;
  N_Dump2Str('DB>> EDAStudyGetFields' );
  try
    if ADataSet = nil then ADataSet := CurSlidesDSet;
    with ADataSet, AStudy, P()^ do
    begin
      ObjName := FieldList[K_CMENDBSTFSlideIDInd].AsString; // Study ID

      CMSPatId := FieldList[K_CMENDBSTFPatIDInd].AsInteger; // Patient ID

      CMSDTTaken := TDateTimeField(FieldList[K_CMENDBSTFSlideDTTakenInd]).Value;

      CMSDTCreated := TDateTimeField(FieldList[K_CMENDBSTFSlideDTCrInd]).Value; // DT Created

      CMSDTMapRootMod := TDateTimeField(FieldList[K_CMENDBSTFSlideDTMapRootInd]).Value; // DT MapRoot Modified

      CMSProvIDCreated := FieldList[K_CMENDBSTFSlideProvIDCrInd].AsInteger; // Created Provider ID

      CMSProvIDModified := FieldList[K_CMENDBSTFSlideProvIDModInd].AsInteger; // Modified Provider ID

      CMSLocIDModified := FieldList[K_CMENDBSTFSlideLocIDModInd].AsInteger; // Modified  Location ID

      CMSCompIDCreated := EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideCompCrInd]); // Created Computer Name

      CMSCompIDModified := EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideCompModInd]); // Modified Computer Name

//??      EDAGetSlideSysFieldsData( EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideSysInfoInd]), @CMSDB); // SysInfo

      WByte := FieldList[K_CMENDBSTFSlideFlagsInd].AsInteger; // Slide DB Flags
      CMSDBStateFlags := TN_CMSlideDBFlags(WByte);

//??      CMSlideEdState := K_edsFullAccess;
      if K_CMEDDBVersion >= 24 then
      begin
        CMSStudySampleID := - FieldList[K_CMENDBSTFSlideStudyIDInd].AsInteger; // Study Sample ID
        CMSStudyItemsCount := FieldList[K_CMENDBSTFSlideStudyItemInd].AsInteger; // Study Sample Items Count
        if K_CMEDDBVersion >= 39 then
          CMSStudyCaptStartPos := FieldList[K_CMENDBSTFSlideStudyItemPosInd].AsInteger; // Direct Study Capture Start Position
      end;

      // User Defined Properties
      CMSDTPropMod := TDateTimeField(FieldList[K_CMENDBSTFSlideDTPropInd]).Value; // DT Properties Modified

      CMSDiagn := EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideDiagnosesInd]); // Study Notes

      CMSSourceDescr := EDAGetStringFieldValue(FieldList[K_CMENDBSTFSlideSrcDescrInd]); // Study Name

      CMSMediaType := FieldList[K_CMENDBSTFSlideMTypeIDInd].AsInteger;                  // Study Color Label Index
    end;

    N_Dump2Str('DB>> EDAStudyGetFields fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAStudyGetFields ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAStudyGetFields

//********************************************* TK_CMEDDBAccess.EDAStudyGetMapRoot ***
// Get given Study Map Root
//
//     Parameters
// AStudy - given Study
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAStudyGetMapRoot( AStudy: TN_UDCMStudy ) : TK_CMEDResult;
begin
  Result := K_edOK;
  AStudy.InitBySample();
  if AStudy.DirChild(K_CMSlideIndMapRoot) <> nil then
end; // end of TK_CMEDDBAccess.EDAStudyGetMapRoot

//********************************************* TK_CMEDDBAccess.EDAStudySaveFields ***
// Save given Study fields
//
//     Parameters
// AStudy - given Study
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAStudySaveFields(): TK_CMEDResult;

var
  PCMSlide: TN_PCMSlide;
  SaveMode : Integer;
begin
  Result := K_edOK;
  try
    PCMSlide := CurSlide.P();
    with CurSlidesDSet, TN_UDCMStudy(CurSlide), PCMSlide^ do
    begin

      SaveMode := 0;
      if cmsfCurImgChanged in CMSRFlags then
        SaveMode := 1;

      if cmsfIsNew in CMSRFlags then
      begin
        SaveMode := 2;
        // New Slide Fields!!!
//        FieldList[K_CMENDBSTFPatIDInd].AsInteger := CMSPatId; // Not Needed because value was set while recored was created

        TDateTimeField(FieldList[K_CMENDBSTFSlideDTTakenInd]).Value := CMSDTTaken;

        TDateTimeField(FieldList[K_CMENDBSTFSlideDTCrInd]).Value := CMSDTCreated;

        FieldList[K_CMENDBSTFSlideProvIDCrInd].AsInteger := CMSProvIDCreated;
        FieldList[K_CMENDBSTFSlideLocIDCrInd].AsInteger := CMSLocIDCreated;

        EDAPutStringFieldValue( FieldList[K_CMENDBSTFSlideCompCrInd], CMSCompIDCreated );

//        FieldList[K_CMENDBSTFSlideStudyIDInd].AsInteger := - CMSStudySampleID; // Not Needed because value was set while recored was created
//        FieldList[K_CMENDBSTFSlideStudyItemInd].AsInteger := CMSStudyItemsCount; // Not Needed because value was set while recored was created

        // End of New Slide Fields
      end;

      FieldList[K_CMENDBSTFSlideProvIDModInd].AsInteger := CMSProvIDModified;

      FieldList[K_CMENDBSTFSlideLocIDModInd].AsInteger := CMSLocIDModified;

      EDAPutStringFieldValue( FieldList[K_CMENDBSTFSlideCompModInd], CMSCompIDModified );

      if SaveMode > 0 then // 1 or 2 - new or change study properties
      begin
      // User Modified properties
        TDateTimeField(FieldList[K_CMENDBSTFSlideDTPropInd]).Value := CMSDTPropMod;

        EDAPutStringFieldValue( FieldList[K_CMENDBSTFSlideDiagnosesInd], CMSDiagn );      // Study Notes

        EDAPutStringFieldValue( FieldList[K_CMENDBSTFSlideSrcDescrInd], CMSSourceDescr ); // Study Name

        FieldList[K_CMENDBSTFSlideMTypeIDInd].AsInteger := CMSMediaType;                  // Study Color Label Index
      end;

      if SaveMode <> 1 then // 0 or 2 - new or change study slides list
      begin
      // Study Items where changed
        TDateTimeField(FieldList[K_CMENDBSTFSlideDTMapRootInd]).Value := CMSDTMapRootMod;
      end;
    end;

  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAStudySaveFields ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAStudySaveFields

//********************************************* TK_CMEDDBAccess.EDAStudySave ***
// Save given Study
//
//     Parameters
// ASlide - given Study
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAStudySave(AStudy: TN_UDCMStudy): TK_CMEDResult;
var
  InTrans : Boolean;
label LExit, Rollback;
begin
  Result := K_edOK;
  CurSlide := nil;
  InTrans := LANDBConnection.InTransaction;

  // PCMSlide := ASlide.P();
  with AStudy.P()^ do
  begin
    if (cmsfThumbChanged in CMSRFlags) or
       (cmsfMapRootChanged in CMSRFlags) then
    begin
      if CurSlide = nil then
      begin
        Result := EDAStudySetCur( AStudy );
        if Result <> K_edOK then
          goto LExit;
      end;
      Result := EDASaveSlideThumbnail();
      if Result <> K_edOK then
      begin
Rollback :
        LANDBConnection.RollbackTrans;
        goto LExit;
      end;
      CMSRFlags := CMSRFlags - [cmsfThumbChanged, cmsfMapRootChanged];
    end;

    if cmsfAttribsChanged in CMSRFlags then
    begin
      if CurSlide = nil then
      begin
        Result := EDAStudySetCur( AStudy );
        if Result <> K_edOK then
          goto LExit;
      end;

      Result := EDAStudySaveFields();
      if Result <> K_edOK then
        goto Rollback;
      Exclude(CMSRFlags, cmsfAttribsChanged);
    end;

    if CurSlide <> nil then
    begin
      CurSlidesDSet.UpdateBatch();
      CurSlidesDSet.Close;
      EDAStudySaveToFile( AStudy );
    end;


LExit :
      // Close Lock Mode and Error Exit
    if not InTrans and LANDBConnection.InTransaction then
      LANDBConnection.CommitTrans;

    Exclude(CMSRFlags, cmsfIsNew); // cmsfIsNew flag should be excluded only in the End of Save procedure
    if CurSlidesDSet.Active then
      CurSlidesDSet.Close;

  end;
end; // end of TK_CMEDDBAccess.EDAStudySave

//********************************* TK_CMEDDBAccess.EDAStudyCaptStartPosGet ***
// Get Study direct capture start position
//
//     Parameters
// ASlide - given Study
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAStudyCaptStartPosGet( AStudy: TN_UDCMStudy ): TK_CMEDResult;
begin
  Result := K_edOK;
end; // function TK_CMEDDBAccess.EDAStudyCaptStartPosGet

//************************** TK_CMEDDBAccess.EDAStudyCaptStartPosSavingPrep ***
// Study direct capture start position saving prepare
//
//     Parameters
// ASlide - given Study
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAStudyCaptStartPosSavingPrep( AStudy: TN_UDCMStudy ): TK_CMEDResult;
begin
  Result := K_edOK;
  TK_CMEDDBAccess(K_CMEDAccess).SlideStudyInfoUpdateStrings.Add(
     format( '%s=StudyID="-%d" StudyItem="%d" StudyItemPos="%d"',
     [AStudy.ObjName, AStudy.CMSStudySampleID, AStudy.CMSStudyItemsCount, AStudy.CMSStudyCaptStartPos] ) );
end; // function TK_CMEDDBAccess.EDAStudyCaptStartPosSavingPrep

//********************************************* TK_CMEDDBAccess.EDARestoreAllMountedSlidesLinks ***
//  Restore All mounted Slides Links to Studies
//
//     Parameters
// AStudiesList - Studies List
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDARestoreAllMountedSlidesLinks( AStudiesList : TStringList ): TK_CMEDResult;
var
  i, j : Integer;
  Slide : TN_UDCMSlide;
  Study: TN_UDCMStudy;
  StudyID : Integer;
  StudyMapRoot : TN_UDBase;
  Item: TN_UDBase;
  Ind : Integer;
  ItemSlides : TN_UDCMSArray;
begin
  Result := K_edOK;
  if AStudiesList = nil then
  begin
  // Build Studies List in TmpStrings
    TmpStrings.Clear;
    TmpStrings.Sorted := FALSE;
    for i := 0 to CurSlidesList.Count - 1 do
    begin
      Slide := TN_UDCMSlide(CurSlidesList[i]);
      if TN_UDCMBSlide(Slide) is TN_UDCMSlide then Continue;
      TmpStrings.AddObject( Slide.ObjName, Slide );
    end;
    AStudiesList := TmpStrings;
  end; // if AStudiesList = nil then

  // Order Studies List if needed
  if not AStudiesList.Sorted then
    AStudiesList.Sort();

  // Remove Old Not Correct Links
  for i := 0 to AStudiesList.Count - 1 do
  begin
    Study := TN_UDCMStudy(AStudiesList.Objects[i]);
    Study.InitBySample;
    StudyMapRoot := Study.DirChild(K_CMSlideIndMapRoot);
    StudyID := StrToInt(Study.ObjName);
    for j := 0 to Study.CMSStudyItemsCount - 1 do
    begin
      Item := StudyMapRoot.DirChild(j);
      Slide := K_CMStudyGetOneSlideByItem( Item );
      if Slide = nil then Continue;

      if (Slide.CMSStudyID <> StudyID)                            or
         ((K_CMEDDBVersion < 39) and (Slide.CMSStudyItemID <> j)) or 
         (IntToStr(Slide.CMSStudyItemID) <> Item.ObjName) then
      begin
        if K_CMEDDBVersion >= 39 then
          EDAStudyDismountAllSlidesFromItem( Item, ItemSlides, Study, TRUE )
        else
          EDAStudyDismountOneSlideFromItem( Item, Slide, Study, TRUE );
      end;
    end;
  end; // for i := 0 to AStudiesList.Count - 1 do

  // Build New Links
  for i := 0 to CurSlidesList.Count - 1 do
  begin
    Slide := TN_UDCMSlide(CurSlidesList[i]);
    if TN_UDCMBSlide(Slide) is TN_UDCMStudy then Continue;
    if Slide.CMSStudyID = 0 then
    begin // no link to study
      Item := Slide.DirChild(K_CMSlideIndStudyItem);
      if Item = nil then Continue; // Slide is not linked Study
      Slide.PutDirChild(K_CMSlideIndStudyItem, nil); // Clear Old Link
      Continue;
    end;

    if not AStudiesList.Find( IntToStr(Slide.CMSStudyID), Ind ) then // !!! Error detected
      raise Exception.Create( format( 'DB >> Study ID=%d not found Item=%d for Slide ID=%s',
                                      [Slide.CMSStudyID, Slide.CMSStudyItemID, Slide.ObjName] ) );

    Study := TN_UDCMStudy(AStudiesList.Objects[Ind]);
    if K_CMEDDBVersion < 39 then
      Item := Study.DirChild(K_CMSlideIndMapRoot).DirChild(Slide.CMSStudyItemID)
    else
      Item := Study.DirChild(K_CMSlideIndMapRoot).DirChildByObjName(IntToStr(Slide.CMSStudyItemID));

    if Item = nil then // !!! Error detected
      raise Exception.Create( format( 'DB >> Study ID=%s Item=%d not found for Slide ID=%s',
                                      [Study.ObjName, Slide.CMSStudyItemID, Slide.ObjName] ) );

//    if Slide.DirChild(K_CMSlideIndStudyItem) <> nil then
    if Slide.DirChild(K_CMSlideIndStudyItem) <> Item then
    begin
    // Link not linked Slide to Study
      if K_CMEDDBVersion >= 39 then
        EDAStudyMountAddSlideToItem( Item, Slide, Study, TRUE )
      else
        EDAStudyMountOneSlideToEmptyItem( Item, Slide, Study, TRUE );
    end;
  end; // for i := 0 to CurSlidesList.Count - 1 do

  // Clear TmpStrings Sorted Flag
  if AStudiesList = TmpStrings then
  begin
    TmpStrings.Clear;
    TmpStrings.Sorted := FALSE;
  end; // if AStudiesList = TmpStrings then

end; // end of TK_CMEDDBAccess.EDARestoreAllMountedSlidesLinks

//********************************************* TK_CMEDDBAccess.EDAStudySavingStart ***
// Start Study Saving Transaction
//
function TK_CMEDDBAccess.EDAStudySavingStart() : TK_CMEDResult;
begin
  Result := K_edOK;
  N_DumpStr( K_CMStudyDetailsDumpCInd, 'DB >> StudySavingStart' );
  LANDBConnection.BeginTrans;
end; // end of TK_CMEDDBAccess.EDAStudySavingStart

//********************************************* TK_CMEDDBAccess.EDAStudySavingFinish ***
// Finish Study Saving Transaction
//
function TK_CMEDDBAccess.EDAStudySavingFinish() : TK_CMEDResult;
var
  i : Integer;
  SQLStr : string;
begin
  Result := K_edOK;
  try
    if SlideStudyInfoUpdateStrings.Count > 0 then
    begin // Save Slide->Study Links Info

      for i := 0 to SlideStudyInfoUpdateStrings.Count - 1 do
      begin
        SlideStudyInfoUpdateStrings[i] := '<item SlideID="' +
           SlideStudyInfoUpdateStrings.Names[i] + '" ' +
           SlideStudyInfoUpdateStrings.ValueFromIndex[i] + ' />';
      end;

      SQLStr := '<links>' +
        Copy( StrTextBuf, 1, K_GetStringsToBuf( StrTextBuf, SlideStudyInfoUpdateStrings, 0, SlideStudyInfoUpdateStrings.Count, TRUE, Chr($0A) ) )
          +'</links>';

      N_DumpStr( K_CMStudyDetailsDumpCInd, 'DB >> Start StudySavingFin'#13#10 + SQLStr );
      with CurStoredProc1 do
      begin
        Connection := LANDBConnection;
        // Exec Procedure
        ProcedureName := 'dba.cms_UpdateStudyLinks';
        Parameters.Clear;
        with Parameters.AddParameter do
        begin
          Name := '@xml_data';
          Direction := pdInput;
          DataType := ftString;
          Value := SQLStr;
        end;
        ExecProc;
      end; // with CurStoredProc1 do
    end; // if SlideStudyInfoUpdateStrings.Count > 0 then
    SlideStudyInfoUpdateStrings.Clear;
    if LANDBConnection.InTransaction then
      LANDBConnection.CommitTrans;
    N_DumpStr( K_CMStudyDetailsDumpCInd, 'DB >> Fin StudySavingFin' );
  except
    on E: Exception do
    begin
      ExtResultCode := K_edExDataError;
      ExtDataErrorCode := K_eeDBUpdate;
      ExtDataErrorString := 'DB ERROR >> ' + E.Message;
      EDAShowErrMessage(  TRUE );
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAStudySavingFinish

//******************************** TK_CMEDDBAccess.EDAStudyAddSlideLinkInfo ***
// Mount given not mount Slide to given Empty Study Item
//
//     Parameters
// AStudy - Study to Mount Slide
// AItem  - Empty Study Item to mount Slide
// ASlide - Slide to mount
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// Result - Returns operation Resulting Code
//
procedure TK_CMEDDBAccess.EDAStudyAddSlideLinkInfo( const ASlideID, AlinkInfo : string );
var
  Ind : Integer;
begin
  Ind := SlideStudyInfoUpdateStrings.IndexOfName( ASlideID );
  if Ind < 0 then
    SlideStudyInfoUpdateStrings.Add( ASlideID + '=' + AlinkInfo )
  else
    SlideStudyInfoUpdateStrings.ValueFromIndex[Ind] := AlinkInfo;
end; // function TK_CMEDDBAccess.EDAStudyAddSlideLinkInfo

//************************ TK_CMEDDBAccess.EDAStudyDismountOneSlideFromItem ***
// Mount given not mount Slide to given Empty Study Item
//
//     Parameters
// AItem  - Empty Study Item to mount Slide
// ASlide - Slide to mount
// AStudy - Study to Mount Slide
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAStudyDismountOneSlideFromItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide = nil; AStudy: TN_UDCMStudy = nil; ARuntimeInfoOnly : Boolean = FALSE ) : TK_CMEDResult;
var
  LinkInfo : string;
begin
  Result := K_edOK;
  if AItem = nil then Exit;
  if ASlide = nil then ASlide := K_CMStudyGetOneSlideByItem(AItem);
  Result := inherited EDAStudyDismountOneSlideFromItem( AItem, ASlide, AStudy, ARuntimeInfoOnly );
  if (Result <> K_edOK) or ARuntimeInfoOnly then Exit;

  LinkInfo := 'StudyID="0" StudyItem="0"';
  if K_CMEDDBVersion >= 39 then
    LinkInfo := 'StudyID="0" StudyItem="0" StudyItemPos="0"';
  EDAStudyAddSlideLinkInfo( ASlide.ObjName, LinkInfo );

end; // function TK_CMEDDBAccess.EDAStudyDismountOneSlideFromItem

//************************ TK_CMEDDBAccess.EDAStudyMountOneSlideToEmptyItem ***
// Mount given not mount Slide to given Empty Study Item
//
//     Parameters
// AItem  - Empty Study Item to mount Slide
// ASlide - Slide to mount
// AStudy - Study to Mount Slide
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAStudyMountOneSlideToEmptyItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE  ) : TK_CMEDResult;
var
  LinkInfo : string;
begin
  Result := K_edOK;
  if AItem = nil then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);
  Result := inherited EDAStudyMountOneSlideToEmptyItem( AItem, ASlide, AStudy, ARuntimeLinksOnly );
  if (Result <> K_edOK) or ARuntimeLinksOnly then Exit;

  LinkInfo := 'StudyID="' + AStudy.ObjName + '" StudyItem="' + AItem.ObjName + '"';
  if K_CMEDDBVersion >= 39 then
    LinkInfo := LinkInfo + ' StudyItemPos="' + IntToStr(ASlide.CMSStudyItemPos) + '"';

  EDAStudyAddSlideLinkInfo( ASlide.ObjName, LinkInfo );

end; // function TK_CMEDDBAccess.EDAStudyMountOneSlideToEmptyItem

//*********************** TK_CMEDDBAccess.EDAStudyDismountAllSlidesFromItem ***
// Mount given not mount Slide to given Empty Study Item
//
//     Parameters
// AItem  - Empty Study Item to mount Slide
// ASlide - Slide to mount
// AStudy - Study to Mount Slide
// ARuntimeInfoOnly
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAStudyDismountAllSlidesFromItem( AItem: TN_UDBase; out ASlides : TN_UDCMSArray; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                               ASelfItemFRFlags : Integer = 0; ASelfItemTeethFlags : Int64 = 0;
                                               AMountItemFRFlags : Integer = 0; AMountItemTeethFlags : Int64 = 0 ) : TK_CMEDResult;
var
  LinkInfo : string;
  i : Integer;
begin
  Result := K_edOK;
  if AItem = nil then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);
  Result := inherited EDAStudyDismountAllSlidesFromItem( AItem, ASlides, AStudy, ARuntimeLinksOnly,
                                                         ASelfItemFRFlags, ASelfItemTeethFlags,
                                                         AMountItemFRFlags, AMountItemTeethFlags );

  if (Result <> K_edOK) or ARuntimeLinksOnly then Exit;

  // Remove Slides Link to Study Item
  for i := 0 to High(ASlides) do
  begin
    LinkInfo := 'StudyID="0" StudyItem="0"';
    if K_CMEDDBVersion >= 39 then
      LinkInfo := 'StudyID="0" StudyItem="0" StudyItemPos="0"';
    EDAStudyAddSlideLinkInfo( ASlides[i].ObjName, LinkInfo );
  end; // for i := 0 to High(MountedSlides) do

end; // function TK_CMEDDBAccess.EDAStudyDismountAllSlidesFromItem

//*********************** TK_CMEDDBAccess.EDAStudyMountAllSlidesToEmptyItem ***
// Mount given not mount Slide to given Empty Study Item
//
//     Parameters
// AItem  - Empty Study Item to mount Slide
// ASlides - Slides to mount array
// AStudy - Study to Mount Slide
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAStudyMountAllSlidesToEmptyItem( AItem: TN_UDBase; ASlides : TN_UDCMSArray; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                                            ASelfItemFRFlags : Integer = 0; ASelfItemTeethFlags : Int64 = 0 ) : TK_CMEDResult;
var
  i : Integer;
  SLinkInfo : string;
  WLinkInfo : string;
begin
  Result := K_edOK;
  if (AItem = nil) or (Length(ASlides) = 0) then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);
  Result := inherited EDAStudyMountAllSlidesToEmptyItem( AItem, ASlides, AStudy, ARuntimeLinksOnly, ASelfItemFRFlags, ASelfItemTeethFlags );

  if (Result <> K_edOK) or ARuntimeLinksOnly then Exit;

  SLinkInfo := 'StudyID="' + AStudy.ObjName + '" StudyItem="' + AItem.ObjName + '"';
  for i := 0 to High(ASlides) do
  begin
    WLinkInfo := SLinkInfo;
    if K_CMEDDBVersion >= 39 then
      WLinkInfo := SLinkInfo + ' StudyItemPos="' + IntToStr(ASlides[i].CMSStudyItemPos) + '"';

    EDAStudyAddSlideLinkInfo( ASlides[i].ObjName, WLinkInfo );
  end; // for i := 0 to High(ASlides) do

end; // function TK_CMEDDBAccess.EDAStudyMountAllSlidesToEmptyItem

//***************************** TK_CMEDDBAccess.EDAStudyMountAddSlideToItem ***
// Mount (add) given not mount Slide to given Study Item
//
//     Parameters
// AItem  - Empty Study Item to mount Slide
// ASlide - Slide to add to Item
// AStudy - Study to Mount Slide
// ARuntimeLinksOnly - TRUE means call from Restore Links in DB Mode
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAStudyMountAddSlideToItem( AItem: TN_UDBase; ASlide : TN_UDCMSlide; AStudy: TN_UDCMStudy = nil; ARuntimeLinksOnly : Boolean = FALSE;
                                         ASelfItemFRFlags : Integer = -1; ASelfItemTeethFlags : Int64 = -1 ) : TK_CMEDResult;
var
  WLinkInfo : string;
  PrevCurSlide : TN_UDCMSlide;

begin
  Result := K_edOK;
  if (AItem = nil) then Exit;
  if AStudy = nil then AStudy := TN_UDCMStudy(AItem.Owner.Owner);

  PrevCurSlide := K_CMStudyGetOneSlideByItem(AItem);
  Result := inherited EDAStudyMountAddSlideToItem( AItem, ASlide, AStudy, ARuntimeLinksOnly, ASelfItemFRFlags, ASelfItemTeethFlags );
  // Inherited Error or RuntimeLinksOnly or EmptyItem and LinkInfo was Added inside Inherited
  if (Result <> K_edOK) or ARuntimeLinksOnly or (PrevCurSlide = nil) then Exit;

  // Prepare Study Item invisible Slides Root
  WLinkInfo := 'StudyID="' + AStudy.ObjName + '" StudyItem="' + AItem.ObjName + '"';
  if K_CMEDDBVersion >= 39 then
    WLinkInfo := WLinkInfo + ' StudyItemPos="' + IntToStr(PrevCurSlide.CMSStudyItemPos) + '"';
  EDAStudyAddSlideLinkInfo( PrevCurSlide.ObjName, WLinkInfo );

end; // function TK_CMEDDBAccess.EDAStudyMountAddSlideToItem

//************************************** TK_CMEDDBAccess.EDAStudySaveToFile ***
// Save given Study state to file
//
//     Parameters
// AStudy - Study to Mount Slide
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAStudySaveToFile( AStudy: TN_UDCMStudy ) : TK_CMEDResult;
var
  i : Integer;
  Slides : TN_UDCMSArray;
  LinkInfo : string;
begin
  TmpStrings.Clear;

  AStudy.GetAllSlidesToArray( Slides );

  for i := 0 to High(Slides) do
  begin
    LinkInfo := format( '%s=%d', [Slides[i].ObjName, Slides[i].CMSStudyItemID] );
    if K_CMEDDBVersion >= 39 then
      LinkInfo := LinkInfo + '|' + IntToStr( Slides[i].CMSStudyItemPos );

    TmpStrings.Add( LinkInfo );
  end;

  Result := EDAStudySaveAttrsToFile( AStudy.ObjName, EDAGetSlideImgPath( AStudy ),
                                     AStudy.P(), AStudy.CMSStudySampleID,
                                     AStudy.CMSStudyItemsCount, TmpStrings );

end; // function TK_CMEDDBAccess.EDAStudySaveToFile

//********************************* TK_CMEDDBAccess.EDAStudySaveAttrsToFile ***
// Save given Study Attributes to file
//
//     Parameters
// AStudyID - Study ID
// AFilesPath - Study Files Base Path
// APCMStudy - Pointer to Study attributes
// AStudySID - Study Sample ID
// AStudySICount - Study Sample Items Count
// AStudyLinksInfo - Strings with Study Links Info
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAStudySaveAttrsToFile( const AStudyID, AFilesPath : string;
                                                  APCMStudy : TN_PCMSlide;
                                                  AStudySID, AStudySICount : Integer;
                                                  AStudyLinksInfo : TStrings ) : TK_CMEDResult;
var
  FileName: string;
begin

  Result := EDAForceFilePath( AFilesPath, SlidesImgRootFDA, TRUE);
  if Result <> K_edOK then
  begin
    N_Dump1Str( format( '!!EDAStudySaveAttrsToFile >> Path "%s" force fails', [AFilesPath] ) );
    Exit;
  end;
  FileName := AFilesPath + K_CMStudyGetFileName( AStudyID );

  K_CMEDAMemIniStrings.Clear;
  K_CMEDAMemIniStrings.Add('[Attrs]');
  with APCMStudy^ do
  begin
  // Fields for new Study
    K_CMEDAMemIniStrings.Add( 'SampleID=' + IntToStr( AStudySID ) );
    K_CMEDAMemIniStrings.Add( 'ItemsCount=' + IntToStr( AStudySICount ) );

    K_CMEDAMemIniStrings.Add( 'DTTaken=' + FloatToStr( CMSDTTaken ) );
    K_CMEDAMemIniStrings.Add( 'DTCr=' + FloatToStr( CMSDTCreated ) );

    K_CMEDAMemIniStrings.Add( 'ProvIDCr=' + IntToStr( CMSProvIDCreated ) );
    K_CMEDAMemIniStrings.Add( 'LocIDCr=' + IntToStr( CMSLocIDCreated ) );

    K_CMEDAMemIniStrings.Add( 'CompIDCr=' + CMSCompIDCreated );

  // Fields for any Study
    K_CMEDAMemIniStrings.Add( 'ProvIDMod=' + IntToStr( CMSProvIDModified ) );
    K_CMEDAMemIniStrings.Add( 'LocIDMod=' + IntToStr( CMSLocIDModified ) );
    K_CMEDAMemIniStrings.Add( 'CompIDMod=' + CMSCompIDModified );

  // Fields for properties modified
    if CMSDTPropMod <> 0 then
      K_CMEDAMemIniStrings.Add( 'DTPropMod=' + FloatToStr( CMSDTPropMod ) );

    if CMSDiagn <> '' then
      K_CMEDAMemIniStrings.Add( 'Diagn=' + CMSDiagn );

    if CMSSourceDescr <> '' then
      K_CMEDAMemIniStrings.Add( 'Name=' + CMSSourceDescr );

    if CMSMediaType <> 0 then
      K_CMEDAMemIniStrings.Add( 'ColorInd=' + IntToStr( CMSMediaType ) );

  // Fields for new and slides links modified
    if CMSDTMapRootMod <> 0 then
      K_CMEDAMemIniStrings.Add( 'DTLinksMod=' + FloatToStr( CMSDTMapRootMod ) );
  end;

  K_CMEDAMemIniStrings.Add('');

  K_CMEDAMemIniStrings.Add('[Links]');

  K_CMEDAMemIniStrings.AddStrings( AStudyLinksInfo );

  if not K_VFSaveStrings( K_CMEDAMemIniStrings, FileName, K_DFCreateEncrypted ) then
  begin
    Result := K_edFails;
    N_Dump1Str( format( '!!EDAStudySaveAttrsToFile >> File "%s" write error', [FileName] ) );
  end;
end; // function TK_CMEDDBAccess.EDAStudySaveAttrsToFile

//******************************** TK_CMEDDBAccess.EDAStudyGetAttrsFromFile ***
// Get Study Attributes from given file
//
//     Parameters
// AFilesName - Study Attributes File Name
// APCMStudy - Pointer to Study attributes
// AStudySID - resulting Study Sample ID
// AStudySICount - resulting Study Sample Items Count
// AStudyLinksInfo - resulting Strings with Study Links Info
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAStudyGetAttrsFromFile( const AFileName : string;
                                                   AStudyLinksInfo : TStrings;
                                                   APCMStudy : TN_PCMSlide = nil;
                                                   APStudySID : PInteger = nil;
                                                   APStudySICount : PInteger = nil ) : TK_CMEDResult;
begin

  Result := K_edFails;

  if not K_VFLoadStrings( K_CMEDAMemIniStrings, AFileName ) then Exit;

  K_CMEDAMemIniFile.SetStrings( K_CMEDAMemIniStrings );

  if APCMStudy <> nil then
  with APCMStudy^ do
  begin
  // Fields for new Study
    if APStudySID <> nil then
      APStudySID^     := K_CMEDAMemIniFile.ReadInteger( 'Attrs', 'SampleID',  0 );
    if APStudySICount <> nil then
      APStudySICount^ := K_CMEDAMemIniFile.ReadInteger( 'Attrs', 'ItemsCount', 0 );

    CMSDTTaken   :=  K_CMEDAMemIniFile.ReadFloat( 'Attrs', 'DTTaken', 0 );
    CMSDTCreated := K_CMEDAMemIniFile.ReadFloat( 'Attrs', 'DTCr', 0 );

    CMSProvIDCreated := K_CMEDAMemIniFile.ReadInteger( 'Attrs', 'ProvIDCr', 0 );
    CMSLocIDCreated := K_CMEDAMemIniFile.ReadInteger( 'Attrs', 'LocIDCr', 0 );

    CMSCompIDCreated := K_CMEDAMemIniFile.ReadString( 'Attrs', 'CompIDCr', '' );


  // Fields for any Study
    CMSProvIDModified := K_CMEDAMemIniFile.ReadInteger( 'Attrs', 'ProvIDMod', 0 );
    CMSLocIDCreated   := K_CMEDAMemIniFile.ReadInteger( 'Attrs', 'LocIDMod', 0 );
    CMSCompIDModified := K_CMEDAMemIniFile.ReadString( 'Attrs', 'CompIDMod', '' );

  // Fields for properties modified
    CMSDTPropMod := K_CMEDAMemIniFile.ReadFloat( 'Attrs', 'DTPropMod', 0 );

    CMSDiagn := K_CMEDAMemIniFile.ReadString( 'Attrs', 'Diagn', '' );

    CMSSourceDescr := K_CMEDAMemIniFile.ReadString( 'Attrs', 'Name', '' );

    CMSMediaType := K_CMEDAMemIniFile.ReadInteger( 'Attrs', 'ColorInd', 0 );

  // Fields for new and slides links modified
    CMSDTMapRootMod := K_CMEDAMemIniFile.ReadFloat( 'Attrs', 'DTLinksMod', 0 );
  end; // with APCMStudy^ do

  K_CMEDAMemIniFile.ReadSectionValues( 'Links', AStudyLinksInfo);
  Result := K_edOK;

end; // function TK_CMEDDBAccess.EDAStudyGetAttrsFromFile

//****************************** TK_CMEDDBAccess.EDAStudyGetLinksInfoFromDB ***
// Get Study link info from DB
//
//     Parameters
// ASStudyID - Study ID string
// ADataSet - Data Set to select slides linked to study
// AStudyLinksInfo - resulting Strings with Study Links Info
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAStudyGetLinksInfoFromDB( const ASStudyID : string;
                                                     ADataSet : TADOQuery;
                                                     AStudyLinksInfo : TStrings ) : TK_CMEDResult;
var
  WStr : string;

begin

  Result := K_edFails;

  AStudyLinksInfo.Clear;
  try
    with ADataSet do
    begin
      ADataSet.Connection := LANDBConnection;
      WStr := K_CMENDBSTFSlideID + ',' + K_CMENDBSTFSlideStudyItem;
      if K_CMEDDBVersion >= 39 then
        WStr := WStr + ',' + K_CMENDBSTFSlideStudyItemPos;

      SQL.Text := 'select ' +  WStr +
                ' from ' + K_CMENDBSlidesTable +
                ' where ' +  K_CMENDBSTFSlideStudyID + ' = ' + ASStudyID;

      Filtered := FALSE;
      Open();
      if RecordCount > 0 then
      First();
      while not Eof do
      begin
        WStr := Fields[0].AsString + '=' + Fields[1].AsString;
        if K_CMEDDBVersion >= 39 then
          WStr := WStr + '|' + Fields[2].AsString;
        AStudyLinksInfo.Add( WStr );
        Next();
      end;
      Close();
    end;
    Result := K_edOK;
  except
    on E: Exception do begin
      ExtDataErrorString := 'DB >> EDAStudyGetLinksInfoFromDB >> ' + E.Message;
      ADataSet.Close;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // function TK_CMEDDBAccess.EDAStudyGetLinksInfoFromDB

//**************************** TK_CMEDDBAccess.EDACalcFixStudyDataModeByTime ***
// Calculate Fix Study Data Mode by Time Delta
//
//     Parameters
// ANumHours - number of hours from last check
// Result - Returns Fix Study Data Mode value
//  =0 - nothing to do
//  =1 - warning to remember user about "Fixing Study Data" should be done
//  =2 - menu option "Fix Study Data" should be visible
//
function TK_CMEDDBAccess.EDACalcFixStudyDataModeByTime( ANumHours : Integer ): Integer;
begin
  if ANumHours < -7200 then //(more then 300 days)
    Result := 0 // nothing to do with studies
  else if ANumHours <= -1 then
    Result := 1 // warning should be done
  else
    Result := 2; // menu FixStudyData should be visible
end; // function TK_CMEDDBAccess.EDACalcFixStudyDataModeByTime

//********************************** TK_CMEDDBAccess.EDAGetFixStudyDataMode ***
// Get Fix Study Data Mode from DB
//
//     Parameters
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAGetFixStudyDataMode: TK_CMEDResult;
begin
  try
    with TK_CMEDDBAccess(K_CMEDAccess), CurDSet1 do
    begin
      SQL.Text := 'select DATEDIFF(hour,GETDATE(),' +  K_CMENDBGTFFixStudyDate + ')' +
                 ' from ' + K_CMENDBGlobAttrsTable;
      Filtered := false;
      Open;

      K_CMSFixStudyDataMode := EDACalcFixStudyDataModeByTime( CurDSet1.FieldList.Fields[0].AsInteger );

      Close;
    end;
    Result := K_edOK;
  except
    on E: Exception do begin
      Result := K_edExDataError;
      ExtDataErrorString := 'DB >> EDAGetFixStudyDataMode >> ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // function TK_CMEDDBAccess.EDAGetFixStudyDataMode

//******************************* TK_CMEDDBAccess.EDAChangeFixStudyDataMode ***
// Set Fix Study Data Mode from DB
//
//     Parameters
// AClearFixMode - if = TRUE then clear Fix Study Data mode, set Remember Next Day Mode
// Result - Returns operation Resulting Code
//
function TK_CMEDDBAccess.EDAChangeFixStudyDataMode( AClearFixMode : Boolean = FALSE ): TK_CMEDResult;
var
  ShiftFixStudyDate : string;
begin
  Result := K_edOK;
  if AClearFixMode then
  begin
    K_CMSFixStudyDataMode := 0;
    ShiftFixStudyDate := '-350'
  end
  else
  begin
    K_CMSFixStudyDataMode := 2;
    ShiftFixStudyDate := '1';
  end;
  try
    with CurSQLCommand1 do
    begin
      CommandText := 'UPDATE ' + K_CMENDBGlobAttrsTable +
                     ' SET ' + K_CMENDBGTFFixStudyDate + ' = DATE( DATEADD( day, ' +
                     ShiftFixStudyDate + ', GETDATE() ))';
      Execute;
    end;
  except
   on E: Exception do begin
      Result := K_edExDataError;
      ExtDataErrorString := 'DB >> EDAChangeFixStudyDataMode >> ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
   end;
end; // function TK_CMEDDBAccess.EDAChangeFixStudyDataMode

//******************************** TK_CMEDDBAccess.EDAStudyTemplatesPrepare ***
function TK_CMEDDBAccess.EDAStudyTemplatesPrepare: TK_CMEDResult;
var
  DSize: Integer;
  PData: Pointer;
  ResCode : TK_CMEDResult;
  SampleUDMapRoot : TN_UDBase;
  StubImgUDFolder : TN_UDBase;
  OrderIndsBuf, FlipRotateCodesBuf, FlipRotateInfoBuf  : TN_IArray;
  OrderInds, FlipRotateCodes : TN_IArray;
  SID, WStr : string;
  i, FRCount, OrderIndsCount : Integer;
begin
  OrderInds := nil;
  FlipRotateCodes := nil;
  Result := inherited EDAStudyTemplatesPrepare();

  if K_CMEDDBVersion < 39 then Exit;

  Result := K_edFails;
  if not K_CMStudyTemplatePrepSampleMapRoot( SampleUDMapRoot ) or
     not K_CMStudyTemplatePrepStubImgUDFolder( StubImgUDFolder ) then Exit;
  Result := K_edOK;

  try
    N_Dump2Str('DB>> EDAStudyTemplatesPrepare Start' );

    // Prepare Study Samples Root
    ArchStudySamplesLibRoot := TN_UDBase.Create;

    // Prepare Buffers
    SetLength(OrderIndsBuf,30);
    SetLength(FlipRotateCodesBuf,30);
    SetLength(FlipRotateInfoBuf,60);

    with CurDSet2 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      SQL.Text := 'select ' + K_CMENDASTempID    + ',' +
                              K_CMENDASTempDescr +
        ' from ' + K_CMENDBAllStudyTemplatesTable ;

      Filtered := false;
      Open;
      while not EOF do
      begin
        SID := Fields[0].AsString;
        N_Dump2Str( format('DB>> Template %s Start', [SID] ) );
        DSize := 0;
        ResCode := EDAGetBlobFieldValue(CurDSet2, Fields[1], PData, DSize);

        if (DSize > 0) and (ResCode = K_edOK) then
        begin
          // Prepare AUDTemplate
          CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMStudyCI));

          // Prepare Template Description
          EDAAnsiTextToString(PData, DSize);
          TmpStrings.Text := PChar(PData);
          N_Dump2Str( TmpStrings[0] );

          // Prepare AOrderInds
          WStr := N_MemIniToString( 'StudyTemplatesPosOrder', SID, '' );
          OrderInds := nil;
          if WStr <> '' then
          begin
            N_Dump2Str( 'Order:' + WStr );
            OrderIndsCount := N_ScanIArray( WStr, OrderIndsBuf );
            OrderInds := Copy( OrderIndsBuf, 0, OrderIndsCount );
          end; // if WStr <> '' then

          // Prepare AFlipRotateCodes
          FlipRotateCodes := nil;
          WStr := N_MemIniToString( 'StudyTemplatesPosFlipRotate', SID, '' );
          if WStr <> '' then
          begin
            N_Dump2Str( 'FlipRotate:' + WStr );
            FRCount := N_ScanIArray( WStr, FlipRotateInfoBuf );
                                             {number of positions}
            FillChar( FlipRotateCodesBuf[0], (TmpStrings.Count - 2)* SizeOf(Integer), - 1 );
            i := 0;
            while i < FRCount do
            begin
              FlipRotateCodesBuf[FlipRotateInfoBuf[i]] := FlipRotateInfoBuf[i+1];
              Inc(i, 2);
            end;
            FlipRotateCodes := FlipRotateCodesBuf;
          end; // if WStr <> '' then

          K_CMStudyTemplateLoadDescr( CurSlide, TmpStrings, FALSE, OrderInds, FlipRotateCodes,
                                      SampleUDMapRoot, StubImgUDFolder );
          ArchStudySamplesLibRoot.AddOneChild( CurSlide );

          N_Dump2Str( format('DB>> Template %s=%s Fin', [CurSlide.ObjName,CurSlide.ObjAliase] ) );

        end; // if (DSize > 0) and (ResCode = K_edOK) then

        Next();
      end; // while not EOF do

      Close;
    end; // with CurDSet2 do

    N_Dump2Str('DB>> EDAStudyTemplatesPrepare Fin' );
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAInit >> EDAStudyTemplatesPrepare >> ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // function TK_CMEDDBAccess.EDAStudyTemplatesPrepare

//************************************ TK_CMEDDBAccess.EDAGetAllMediaTypes0 ***
// Get all Media Types list
//
//     Parameters
// Result - Returns operation resulting code
//
// Returns both build in and users defined Media Types list.
//
function TK_CMEDDBAccess.EDAGetAllMediaTypes0(): TStrings;
var
  i, RCount: Integer;
begin
  ExtResultCode := K_edOK;
  Result := AllMediaTypes;
  if AllMediaTypes = nil then
  begin
    // *** Create and Init Bufferd Media Types List
    AllMediaTypes := TStringList.Create;
    Result := AllMediaTypes;

    EDAGetBuildInMediaTypes(AllMediaTypes);

    ExtResultCode := EDACheckDBConnection(LANDBConnection);
    if ExtResultCode <> K_edOK then
      Exit;

    N_Dump2Str('DB>> EDAGetAllMediaTypes0');
    CurDSet1.Connection := LANDBConnection;
    try
      ExtDataErrorCode := K_eeDBSelect;
      CurDSet1.SQL.Text := 'select ' +
        K_CMENDBMTFMTypeID + ',' + K_CMENDBMTFMTypeTitle +
        ' from ' + K_CMENDBMTypesTable;
      CurDSet1.Filtered := false;
      CurDSet1.Open;
      RCount := CurDSet1.RecordCount;
      CurDSet1.First;
      with CurDSet1.FieldList do
        for i := 0 to RCount - 1 do
        begin
          AllMediaTypes.AddObject(Trim(EDAGetStringFieldValue(Fields[1])),
            TObject(Fields[0].AsInteger));
          CurDSet1.Next;
        end;
      CurDSet1.Close;
      EDAPrepIniMediaTypeTexts();

      ////////////////////////////////////////
      // Save new MediaTypes for CMScan
      //

      if K_CMSAppStartContext.CMASMode = K_cmamCOMVEUI then
        K_CMScanRebuildCommonInfoFile(); // Should be called only in K_cmamCOMVEUI mode
      N_Dump2Str('DB>> EDAGetAllMediaTypes0 fin');
    except
      on E: Exception do
      begin
        ExtDataErrorString := 'EDAGetAllMediaTypes0 ' + E.Message;
        CurDSet1.Close;
        EDAShowErrMessage(TRUE);
        ExtResultCode := K_edExDataError;
        ExtDataErrorCode := K_eeDBSetField;
        Exit;
      end;
    end;
  end; // end of Buffered Media Types List Creation

end; // end of TK_CMEDDBAccess.EDAGetAllMediaTypes0

//********************************************* TK_CMEDDBAccess.EDASearchMediaTypeTitle ***
// Search MediaType ID by given Title in given Datat Set
//
//     Parameters
// ADataSet - DataSet to accese to MediaTypes Table
// AMTypeTitle - MediaType Title to search
// AMTypID - resulting MediaType ID: -1 if MediaType record is not found and MediaType ID else
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASearchMediaTypeTitle(ADataSet: TADOQuery;
  AMTypeTitle: string; out AMTypeID: Integer): TK_CMEDResult;
begin
  try
    Result := K_edOK;
    ExtDataErrorCode := K_eeDBSelect;
    with ADataSet do
    begin
      // *** Check Uniq Aliase
      SQL.Text := 'select ' +
        K_CMENDBMTFMTypeID + ',' + K_CMENDBMTFMTypeTitle +
        ' from ' + K_CMENDBMTypesTable;
      Filtered := false;
      Open;
      First;
      with FieldList do
        while not Eof do
        begin
          if SameText(Trim(EDAGetStringFieldValue(Fields[1])), AMTypeTitle) then
          begin
            AMTypeID := Fields[0].AsInteger;
            Exit;
          end;
          Next;
        end; // end of Search Aliase
      AMTypeID := -1;
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASearchMediaTypeTitle ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASearchMediaTypeTitle

//********************************************* TK_CMEDDBAccess.EDAddNewMediaType ***
// Add new Media Type with given Aliase
//
//     Parameters
// AMTypID - resulting new Media Type ID
// AMTypeAliase - given new Media Type aliase
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAddNewMediaType( out AMTypeID: Integer; const AMTypeTitle: string ): TK_CMEDResult;
var
  InTrans: Boolean;
  AddFlag : Integer;

begin
  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>> EDAddNewMediaType T=' + AMTypeTitle);

  try
    if  K_CMEDDBVersion >= 40 then
    begin
      with CurStoredProc1 do
      begin
        Connection := LANDBConnection;

        // Exec Procedure
        // cms_AddMTypeByTitle"( in @MTypeName long varchar, out @MTypeID integer, out @AddFlag integer )
        ProcedureName := 'dba.cms_AddMTypeByTitle';
        Parameters.Clear;
        with Parameters.AddParameter do
        begin
          Name := '@MTypeName';
          Direction := pdInput;
          DataType := ftString;
          Value := AMTypeTitle;
        end;
        with Parameters.AddParameter do
        begin
          Name := '@MTypeID';
          Direction := pdOutput;
          DataType := ftInteger;
        end;
        with Parameters.AddParameter do
        begin
          Name := '@AddFlag';
          Direction := pdOutput;
          DataType := ftInteger;
          ExecProc;
          AddFlag := Value;
          if AddFlag = 0 then
          begin
            N_Dump2Str( format('DB>> EDAddNewMediaType new Title=%s already exists', [AMTypeTitle] ) );
            AMTypeID := 0;
            Result := K_edExistedMediaType;
          end
          else
          begin
            AMTypeID := Parameters.FindParam('@MTypeID').Value;
            N_Dump2Str( format('DB>> EDAddNewMediaType do ID=%d new Title=%s', [AMTypeID, AMTypeTitle] ) );
            FreeAndNil(AllMediaTypes); // free MediaTypes Buffered List
            Result := K_edOK;
          end;
        end; // with Parameters.AddParameter do
      end; // with CurStoredProc1 do
    end   // endof if  K_CMEDDBVersion >= 40 then
    else
    begin // if  K_CMEDDBVersion < 40 then
      InTrans := LANDBConnection.InTransaction;
      // InTrans = TRUE during initial MediaTypes Adding
      if not InTrans then
      begin
        LANDBConnection.BeginTrans;
        // Lock table
        ExtDataErrorCode := K_eeDBLock;
        with CurSQLCommand1 do
        begin
          Connection := LANDBConnection;
          CommandText := 'LOCK TABLE ' + K_CMENDBMTypesTable + ' IN EXCLUSIVE MODE';
          N_Dump2Str( 'DB>> before lock Table=' + K_CMENDBMTypesTable );
          Execute;
          N_Dump2Str( 'DB>> after lock Table=' + K_CMENDBMTypesTable );
        end;
      end;

      ExtDataErrorCode := K_eeDBSelect;
      with CurDSet1 do
      begin
        Connection := LANDBConnection;
        Result := EDASearchMediaTypeTitle(CurDSet1, AMTypeTitle, AMTypeID);
        if Result <> K_edOK then
        begin
          if not InTrans then
            Connection.RollbackTrans;
          Exit;
        end;
        if AMTypeID <> -1 then
        begin
          // Exists
          Close;
          if not InTrans then
            Connection.CommitTrans;
          Result := K_edExistedMediaType;
          N_Dump2Str('DB>> EDAddNewMediaType exists fin ');
          Exit;
        end;
        ExtDataErrorCode := K_eeDBIns;
        Insert;
        ExtDataErrorCode := K_eeDBSetField;

        EDAPutStringFieldValue( FieldList.Fields[1], AMTypeTitle );
        UpdateBatch;
        Close;
        SQL.Text := 'select @@identity';
        Open;
        AMTypeID := FieldList.Fields[0].AsInteger;
        Close();
        N_Dump2Str('DB>> Add media type ID=' + IntToStr(AMTypeID)
            + ' T=' + AMTypeTitle);
      end; // *** end of Check Uniq Aliase

      FreeAndNil(AllMediaTypes); // free MediaTypes Buffered List

      if not InTrans then
        LANDBConnection.CommitTrans;
    end; // endof if  K_CMEDDBVersion < 40 then
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAddNewMediaType ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAddNewMediaType

//********************************************* TK_CMEDDBAccess.EDADeleteMediaTypeByID ***
// Delete Media Type by given ID
//
//     Parameters
// AMTypeID   - Media Type ID
// APatsList - list of patients which have slides with given Media Type
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDADeleteMediaTypeByID(AMTypeID: Integer; out APatID: Integer ) : TK_CMEDResult;
var
  SMTID: string;
  WStr: string;
  CurPatientUseMTFlag: Boolean;
  // Ind : Integer;
begin
  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;
  N_Dump2Str('DB>> EDADeleteMediaTypeByID ID=' + IntToStr(AMTypeID));

  CurPatientUseMTFlag := EDACheckMediaTypeInCurSlidesSet(AMTypeID);
  if CurPatientUseMTFlag then
  begin
    // return immediate result if Patients list is not given
    Result := K_edUsedMediaType;
    APatID := CurSlidesSelectAttrs.SSPatID;
    N_Dump2Str( 'DB>> EDADeleteMediaTypeByID CurPat used fin');
    Exit;
  end;

  try
    if  K_CMEDDBVersion >= 40 then
    begin
      with CurStoredProc1 do
      begin
        Connection := LANDBConnection;

        // Exec Procedure
        // cms_DeleteMTypeByID"( in @MTypeID integer, out @PatID integer )
        ProcedureName := 'dba.cms_DeleteMTypeByID';
        Parameters.Clear;
        with Parameters.AddParameter do
        begin
          Name := '@MTypeID';
          Direction := pdInput;
          DataType := ftInteger;
          Value := AMTypeID;
        end;
        with Parameters.AddParameter do
        begin
          Name := '@PatID';
          Direction := pdOutput;
          DataType := ftInteger;
          ExecProc;
          APatID := Value;
        end; // with Parameters.AddParameter do
      end; // with CurStoredProc1 do

      if APatID < 0 then
      begin
        N_Dump2Str( format('DB>> EDADeleteMediaTypeByID MTypeID=%d is deleted', [AMTypeID] ) );
        FreeAndNil(AllMediaTypes); // free MediaTypes Buffered List
        Result := K_edOK;
      end
      else
      begin
        N_Dump2Str( format('DB>> EDADeleteMediaTypeByID MTypeID=%d is used by PatID=%d', [AMTypeID, APatID] ) );
        FreeAndNil(AllMediaTypes); // free MediaTypes Buffered List
        Result := K_edUsedMediaType;
      end;
    end   // endof if  K_CMEDDBVersion >= 40 then
    else
    begin // if  K_CMEDDBVersion < 40 then
      SMTID := IntToStr(AMTypeID);

      LANDBConnection.BeginTrans;
      with CurSQLCommand1 do
      begin
        Connection := LANDBConnection;
        CommandText := 'LOCK TABLE ' + K_CMENDBMTypesTable + ' IN EXCLUSIVE MODE';
        N_Dump2Str( 'DB>> before lock Table=' + K_CMENDBMTypesTable );
        Execute;
        N_Dump2Str( 'DB>> after lock Table=' + K_CMENDBMTypesTable );
      end;

      ExtDataErrorCode := K_eeDBSelect;
      CurDSet1.Connection := LANDBConnection;
      with CurDSet1 do
      begin
        WStr := ' from ' + K_CMENDBSlidesTable + ' where ' + K_CMENDBSTFSlideMTypeID +
          '=' + SMTID;
//        if APatsList <> nil then
//          WStr := 'select distinct ' + K_CMENDBSTFPatID + WStr
//        else
//          WStr := 'select count(*)' + WStr;
        SQL.Text := WStr;
        Filtered := false;
        Open;
        APatID := 0;
        if RecordCount > 0 then
        begin
          APatID := FieldList.Fields[0].AsInteger;
          Result := K_edUsedMediaType;
        end;
        Close;

        if Result = K_edUsedMediaType then
        begin
          // MediaType is used
          LANDBConnection.CommitTrans;
          N_Dump2Str('DB>> EDADeleteMediaTypeByID MediaType is used fin');
          Exit;
        end;
{
        if APatsList <> nil then
        begin
          // get Patients List
          // Ind := RecordCount;
          First;
          while not Eof do
          begin
            APatsList.Add(Pointer(FieldList.Fields[0].AsInteger));
            // add new Patient ID to list
            Next;
          end;
          if CurPatientUseMTFlag and (APatsList.IndexOf
              (Pointer(CurSlidesSelectAttrs.SSPatID)) < 0) then
            APatsList.Add(Pointer(CurSlidesSelectAttrs.SSPatID));
          // add cur Patient ID to list
          if APatsList.Count > 0 then
            Result := K_edUsedMediaType;
        end
        else
        if FieldList.Fields[0].AsInteger > 0 then
          Result := K_edUsedMediaType;
        Close;

        if Result = K_edUsedMediaType then
        begin
          // MediaType is used
          LANDBConnection.CommitTrans;
          N_Dump2Str('DB>> EDADeleteMediaTypeByID MediaType is used fin');
          Exit;
        end;
}
      end; // endof if  K_CMEDDBVersion < 40 then

      // Delete not used MediaType

      ExtDataErrorCode := K_eeDBDel;
      with CurSQLCommand1 do
      begin
        N_Dump2Str('DB>> Delete media type ID=' + SMTID);
        CommandText := 'DELETE FROM ' + K_CMENDBMTypesTable + ' WHERE ' +
          K_CMENDBMTFMTypeID + ' = ' + SMTID;
        Execute;
      end;

      LANDBConnection.CommitTrans;
      FreeAndNil(AllMediaTypes); // free MediaTypes Buffered List

      N_Dump2Str('DB>> EDADeleteMediaTypeByID fin');
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDADeleteMediaTypeByID ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDADeleteMediaTypeByID

//********************************************* TK_CMEDDBAccess.EDARenameMediaType ***
// Rename given Media Type
//
//     Parameters
// AMTypID - given Media Type ID
// AMTypeAliase - given Media Type new Aliase
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDARenameMediaType( AMTypeID: Integer; AMTypeTitle: string ): TK_CMEDResult;
var
  SMTID: string;
  WMTypeID: Integer;
  RFlag : Integer;
begin
  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>> EDARenameMediaType T=' + AMTypeTitle);

  try
    if  K_CMEDDBVersion >= 40 then
    begin
      with CurStoredProc1 do
      begin
        Connection := LANDBConnection;

        // Exec Procedure
        // CREATE PROCEDURE "DBA"."cms_RenameMTypeByTitle"( in @MTypeName long varchar, in @MTypeID integer, out @RFlag integer )
        ProcedureName := 'dba.cms_RenameMTypeByTitle';
        Parameters.Clear;
        with Parameters.AddParameter do
        begin
          Name := '@MTypeName';
          Direction := pdInput;
          DataType := ftString;
          Value := AMTypeTitle;
        end;
        with Parameters.AddParameter do
        begin
          Name := '@MTypeID';
          Direction := pdInput;
          DataType := ftInteger;
          Value := AMTypeID;
        end;
        with Parameters.AddParameter do
        begin
          Name := '@RFlag';
          Direction := pdOutput;
          DataType := ftInteger;
          ExecProc;
          RFlag := Value;
        end; // with Parameters.AddParameter do
      end; // with CurStoredProc1 do
      if RFlag = 0 then
      begin
        N_Dump2Str( format('DB>> EDARenameMediaType new Title=%s already exists', [AMTypeTitle] ) );
        Result := K_edExistedMediaType;
      end
      else
      begin
        N_Dump2Str( format('DB>> EDARenameMediaType do ID=%d new Title=%s', [AMTypeID, AMTypeTitle] ) );
        Result := K_edOK;
      end;
    end   // endof if  K_CMEDDBVersion >= 40 then
    else
    begin // if  K_CMEDDBVersion < 40 then
      LANDBConnection.BeginTrans;
      // Lock tables
      ExtDataErrorCode := K_eeDBLock;
      with CurSQLCommand1 do
      begin
        Connection := LANDBConnection;
        CommandText := 'LOCK TABLE ' + K_CMENDBMTypesTable + ' IN EXCLUSIVE MODE';
        N_Dump2Str( 'DB>> before lock Table=' + K_CMENDBMTypesTable );
        Execute;
        N_Dump2Str( 'DB>> after lock Table=' + K_CMENDBMTypesTable );
      end;

      ExtDataErrorCode := K_eeDBSelect;
      with CurDSet1 do
      begin
        // *** Check Uniq Aliase
        Connection := LANDBConnection;
        Result := EDASearchMediaTypeTitle(CurDSet1, AMTypeTitle, WMTypeID);
        if Result <> K_edOK then
        begin
          Connection.RollbackTrans;
          Exit;
        end;
        if WMTypeID <> -1 then
        begin
          // Exists
          Close;
          Connection.CommitTrans;
          N_Dump2Str('DB>> EDARenameMediaType exists fin');
          Exit;
        end;

        SMTID := IntToStr(AMTypeID);
        Filter := K_CMENDBMTFMTypeID + ' = ' + SMTID;
        Filtered := TRUE;
        Result := K_edAbsentMediaType;
        if RecordCount = 1 then
        begin
          Edit;
          EDAPutStringFieldValue( FieldList.Fields[1], AMTypeTitle );
          UpdateBatch;
          Result := K_edOK;
          N_Dump2Str('DB>> Rename media type ID=' + SMTID + ' T=' +
              AMTypeTitle);
        end;
        Filtered := false;
        Close;
      end; // *** end of Check Uniq Aliase

      FreeAndNil(AllMediaTypes); // free MediaTypes Buffered List
      LANDBConnection.CommitTrans;

      N_Dump2Str('DB>> EDARenameMediaType fin');
    end; // endof if  K_CMEDDBVersion < 40 then
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDARenameMediaType ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDARenameMediaType

//********************************************* TK_CMEDDBAccess.EDAddInitialMediaTypes ***
// Set initial Media Types to DB if needed
//
//     Parameters
// APInitMTypesNum - pointer to resulting added Initial Media Types number
// Result - Returns operation resulting code
//
// Initial Media Types Info is get from Ini-File [CMSIniMediaTypes]
//
function TK_CMEDDBAccess.EDAddInitialMediaTypes(APInitMTypesNum: PInteger = nil) : TK_CMEDResult;
var
  RCount: Integer;

  i, MTypeID, ICount: Integer;
  WrkSL: TStringList;
label EndTransAction, RollbackTrans, EndInit;

begin
  //
  if APInitMTypesNum <> nil then
    APInitMTypesNum^ := 0;

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  try

    if  K_CMEDDBVersion >= 40 then
    begin
      with CurStoredProc1 do
      begin
        Connection := LANDBConnection;

        // Exec Procedure
        // CREATE PROCEDURE "DBA"."cms_InitMTypes"( out @RCount integer )
        ProcedureName := 'dba.cms_InitMTypes';
        Parameters.Clear;
        with Parameters.AddParameter do
          begin
            Name := '@RFlag';
            Direction := pdOutput;
            DataType := ftInteger;
            ExecProc;
            RCount := Value;
          end; // with Parameters.AddParameter do
      end; // with CurStoredProc1 do
      N_Dump2Str( format('DB>> EDAddInitialMediaTypes Count=%d', [RCount] ) );

      if APInitMTypesNum <> nil then
        APInitMTypesNum^ := RCount;
      Result := K_edOK;
    end
    else
    begin
      WrkSL := TStringList.Create();
  //    N_CurMemIni.ReadSectionValues('CMSIniMediaTypes', WrkSL);
      WrkSL.Assign( K_CMSIniMediaTypes );
      if WrkSL.Count = 0 then
        goto EndInit;

      LANDBConnection.BeginTrans;
      // Lock tables
      ExtDataErrorCode := K_eeDBLock;
      with CurSQLCommand1 do
      begin
        Connection := LANDBConnection;
        CommandText := 'LOCK TABLE ' + K_CMENDBMTypesTable + ' IN EXCLUSIVE MODE';
        N_Dump2Str( 'DB>> before lock Table=' + K_CMENDBMTypesTable );
        Execute;
        N_Dump2Str( 'DB>> after lock Table=' + K_CMENDBMTypesTable );
      end;

      N_Dump2Str('DB>> Add Initial Media Types');
      ICount := 0;
      for i := 0 to WrkSL.Count - 1 do
        if EDAddNewMediaType(MTypeID, WrkSL.ValueFromIndex[i]) = K_edOK then
          Inc(ICount);

      if APInitMTypesNum <> nil then
        APInitMTypesNum^ := ICount;

      FreeAndNil(AllMediaTypes); // free MediaTypes Buffered List

      LANDBConnection.CommitTrans;

      N_Dump2Str('DB>> Add Initial Media Types fin');

    EndInit :
      WrkSL.Free;
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAddInitialMediaTypes ' + E.Message;
      if LANDBConnection.InTransaction then
        LANDBConnection.RollbackTrans;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAddInitialMediaTypes

//********************************************************** TK_CMEDDBAccess.EDAClearAllEData ***
// Clear All DB Tables and Init Global Attributes record
//
function TK_CMEDDBAccess.EDAClearAllEData(): TK_CMEDResult;
label Rollback;
begin
  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>> EDAClearAllEData');
  try
    LANDBConnection.BeginTrans;
    CurSQLCommand1.Connection := LANDBConnection;
    with CurSQLCommand1 do
    begin
      Connection := LANDBConnection;
      CommandText := 'TRUNCATE TABLE ' + K_CMENDBSlidesTable;
      Execute;

      CommandText := 'TRUNCATE TABLE ' + K_CMENDBMTypesTable;
      Execute;

      CommandText := 'TRUNCATE TABLE ' + K_CMENDBContextsTable;
      Execute;

      CommandText := 'TRUNCATE TABLE ' + K_CMENDBGAInstsTable;
      Execute;

      CommandText := 'TRUNCATE TABLE ' + K_CMENDBAAInstsTable;
      Execute;

      CommandText := 'TRUNCATE TABLE ' + K_CMENDBLockSlidesTable;
      Execute;

      CommandText := 'TRUNCATE TABLE ' + K_CMENDBMediaUniqIDTable;
      Execute;
    end;
    FreeAndNil(AllMediaTypes);

    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      SQL.Text := 'select ' + K_CMENDBGTFDBVersion +
        ' from ' + K_CMENDBGlobAttrsTable;
      Filtered := false;
      Open;
      Edit;
      ExtDataErrorCode := K_eeDBEdit;
      with FieldList do
      begin
        Fields[0].AsInteger := K_CMEDDBVersion;
        // Current DB Data Structure Version
      end;
      if Result = K_edOK then
      begin
        UpdateBatch;
        Close;
        LANDBConnection.CommitTrans;
      end
      else
      begin
      Rollback :
        LANDBConnection.RollbackTrans;
      end;
    end;
    N_Dump2Str('DB>> EDAClearAllEData fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAClearAllEData ' + E.Message;
      CurDSet1.Close;
      LANDBConnection.RollbackTrans;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAClearAllEData

//********************************************* TK_CMEDDBAccess.EDAGetDirFreeSpace ***
// Get given Directory Free Space
//
//     Parameters
// AFPath - directory path for free space detect
// ADAFlag - if FALSE then Sybase sf_GetPathFreeSpace will be used
//           Windows GetDiskFreeSpaceEx will be used else.
// AFreeSpace - resulting disk free space
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetDirFreeSpace(const AFPath: string;
                        ADAFlag: Boolean; out AFreeSpace: Int64): TK_CMEDResult;
var
  PathPar0: string;
  PathPar: string;
//  FreeSpaceAvailable, TotalSpace: Int64;
  ResCode: Integer;

begin
  Result := K_edOK;
  AFreeSpace := 0;
  PathPar := AFPath;
  if not ADAFlag then
    try
      with CurDSet1 do
      begin
        ExtDataErrorCode := K_eeFilesPocessing;
        Connection := LANDBConnection;
        Filtered := false;
        // Search for Existing Parent Directory for Space Check
        while TRUE do
        begin
          SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A)
           + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(PathPar, '\', '\\')) + ';' + Chr($0A)
           + 'select sf_path_exists(@ls_source);' + Chr($0A) + 'end';

          // SQL.Text := 'select sf_path_exists(''' + PathPar + ''')';
          Open;
          ResCode := FieldList.Fields[0].AsInteger;
          Close();
          if ResCode = 0 then
            break; // Path Exists
          PathPar0 := ExtractFilePath(ExcludeTrailingPathDelimiter(PathPar));
          if PathPar0 = PathPar then
            Exit;
          PathPar := PathPar0;
        end;
        PathPar := AnsiReplaceText(PathPar, '\', '\\');
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' +
          Chr($0A) + 'set @ls_source = ' + QuotedStr(PathPar) + ';' + Chr($0A) +
          'select sf_GetPathFreeSpace(@ls_source);' + Chr($0A) + 'end';

        // SQL.Text := 'select sf_GetPathFreeSpace(''' + PathPar + ''')';
        Open;
        AFreeSpace := FieldList.Fields[0].AsInteger;
        AFreeSpace := AFreeSpace * N_BytesInMB;
        Close();
      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorString := 'EDAGetDirFreeSpace ' + E.Message;
        EDAShowErrMessage(TRUE);
      end;
    end
  else
    Result := inherited EDAGetDirFreeSpace( AFPath, ADAFlag, AFreeSpace );
{
  begin
    // Search for Existing Parent Directory for Space Check
    while not DirectoryExists(PathPar) do
    begin
      PathPar0 := ExtractFilePath(ExcludeTrailingPathDelimiter(PathPar));
      if PathPar0 = PathPar then
        Exit;
      PathPar := PathPar0;
    end;
    // Get Free Space
    if GetDiskFreeSpaceEx(@PathPar[1], FreeSpaceAvailable, TotalSpace, nil) then
      AFreeSpace := FreeSpaceAvailable;
  end;
}
end; // end of TK_CMEDDBAccess.EDAGetDirFreeSpace

//******************************** TK_CMEDDBAccess.EDAGetImg3DDiskFreeSpace ***
// Get 3D Images Disk Free Space
//
//     Parameters
// AFreeSpace - resulting disk free space
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetImg3DDiskFreeSpace( out AFreeSpace: Int64): TK_CMEDResult;
begin
  Result := EDAGetDirFreeSpace( SlidesImg3DRootFolder, TRUE, AFreeSpace );
end; // end of TK_CMEDDBAccess.EDAGetImg3DDiskFreeSpace

//********************************** TK_CMEDDBAccess.EDAGetImgDiskFreeSpace ***
// Get Images Disk Free Space
//
//     Parameters
// AFreeSpace - resulting disk free space
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetImgDiskFreeSpace( out AFreeSpace: Int64): TK_CMEDResult;
begin
  Result := EDAGetDirFreeSpace( SlidesImgRootFolder, SlidesImgRootFDA, AFreeSpace );
end; // end of TK_CMEDDBAccess.EDAGetImgDiskFreeSpace

//******************************** TK_CMEDDBAccess.EDAGetVideoDiskFreeSpace ***
// Get Video Disk Free Space
//
//     Parameters
// AFreeSpace - resulting disk free space
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetVideoDiskFreeSpace( out AFreeSpace: Int64): TK_CMEDResult;
begin
  if (K_CMMediaFilesStoringMode <> 0) then
    Result := EDAGetDirFreeSpace( SlidesMediaRootFolder, SlidesMediaRootFDA, AFreeSpace )
  else
    Result := inherited EDAGetVideoDiskFreeSpace( AFreeSpace );
end; // end of TK_CMEDDBAccess.EDAGetVideoDiskFreeSpace

//********************************************* TK_CMEDDBAccess.EDAVideoFolderAccessPrevCheck ***
// Video Folder access previous check Flag
//
//     Parameters
// Result - Returns TRUE if Video Folder Access Check before Video Slide Creation is needed
//
function TK_CMEDDBAccess.EDAVideoFolderAccessPrevCheck: Boolean;
begin
  Result := (K_CMMediaFilesStoringMode <> 0) and SlidesMediaRootFDA;
end; // end of TK_CMEDDBAccess.EDAVideoFolderAccessPrevCheck

//********************************************* TK_CMEDDBAccess.EDACheckImgFilesFolderAccess ***
// Check Image Files Access
//
//     Parameters
// Result - Returns:
//#F
//   0 - CMS can write files to and read it from  given folder
//   1 - given folder does not exist
//   2 - CMS can not write files to given folder
//   3 - CMS can not delete files from given folder
//#/F
//
function TK_CMEDDBAccess.EDACheckImgFilesFolderAccess() : Integer;
begin
  Result := EDACheckFilesFolderAccess( SlidesImgRootFolder, SlidesImgRootFDA );
end; // function TK_CMEDDBAccess.EDACheckImgFilesFolderAccess

//********************************************* TK_CMEDDBAccess.EDACheckVideoFilesFolderAccess ***
// Check Video Files Access
//
//     Parameters
// Result - Returns:
//#F
//   0 - CMS can write files to and read it from  given folder
//   1 - given folder does not exist
//   2 - CMS can not write files to given folder
//   3 - CMS can not delete files from given folder
//#/F
//
function TK_CMEDDBAccess.EDACheckVideoFilesFolderAccess() : Integer;
begin
  Result := EDACheckFilesFolderAccess( SlidesMediaRootFolder, SlidesMediaRootFDA );
end; // function TK_CMEDDBAccess.EDACheckVideoFilesFolderAccess

{
//********************************************* TK_CMEDDBAccess.EDACheckVideoFolderAccessDlg ***
// Check Video Folder access dialog
//
//     Parameters
// Result - Returns TRUE if Video Folder Access is OK
//
function TK_CMEDDBAccess.EDACheckVideoFolderAccessDlg(): Boolean;
begin
  Result := EDACheckFilesFolderAccess( SlidesMediaRootFolder, SlidesMediaRootFDA ) = 0;
  if not Result then
  begin
  // Some access problems were detected
    K_CMShowMessageDlg1(
      '           There is a problem to access the Video folder.'#13#10 +
      'Please check network connection and permission to access this folder.'#13#10 +
      'Press OK when ready to continue.',
       mtWarning, [mbOK] );

    Result := EDACheckFilesFolderAccess( SlidesMediaRootFolder, SlidesMediaRootFDA ) = 0;
    if not Result then
      K_CMShowMessageDlg1(
        'The Video folder is still not accessible. Press OK to stop Video data processing.',
         mtWarning, [mbOK] );
  end;
end; // end of TK_CMEDDBAccess.EDACheckVideoFolderAccessDlg
}
//********************************************* TK_CMEDDBAccess.EDACheckFilesFolderAccess ***
// Check Files Access
//
//     Parameters
// AFPath - Files Base Folder Path
// ADAFlag - Files Direct Access Flag
// Result - Returns:
//#F
//   0 - CMS can write files to and read it from  given folder
//   1 - given folder does not exist
//   2 - CMS can not write files to given folder
//   3 - CMS can not delete files from given folder
//#/F
//
function TK_CMEDDBAccess.EDACheckFilesFolderAccess( const AFPath: string;
                                              ADAFlag : Boolean ): Integer;
const
  CheckName = '123456789.123';
var
  TmpName: string;
  ErrMes0, ErrMes1 : string;
  RepeatCounter : Integer;

label DumpAndExit, CopyLoop, DeleteLoop;

  function LoopDumpProc() : Boolean;
  begin
    Result := RepeatCounter > 1;
    if Result then Exit;
    N_Dump1Str( ErrMes0 + ErrMes1 );
    sleep( 1000 );
    Inc(RepeatCounter);
  end;

begin
  Result := 0;
  if K_CMDisableDiskAccessCheck then Exit;
  Result := 1;
  ErrMes0 := format( 'EDACheckFilesFolderAccess "%s" ', [AFPath] );
  if (EDAPathOrFileExists( AFPath, ADAFlag, TRUE ) <> K_edOK) then
  begin
    ErrMes1 := 'folder is not found';
DumpAndExit:
    N_Dump1Str( ErrMes0 + ErrMes1 );
    Exit;
  end;

  TmpName := K_ExpandFileName('(#TmpFiles#)' + CheckName);
//  Create Temporary File if needed
  if not FileExists(TmpName) then
    with TFileStream.Create( TmpName, fmCreate ) do
    begin
      Write(TmpName[1], 1);
      Free;
    end;

  Result := 2;
  ErrMes1 := 'folder file write error';
  RepeatCounter := 0;
CopyLoop:
  if EDACopyFileToServer( TmpName, AFPath + CheckName, ADAFlag ) <> K_edOK then
  begin
    if not LoopDumpProc() then
      goto CopyLoop
    else
      goto DumpAndExit;
  end;

  Result := 3;
  ErrMes1 := 'folder file delete error';
  RepeatCounter := 0;
DeleteLoop:
  if EDAFileDelete( AFPath + CheckName, ADAFlag ) <> K_edOK then
  begin
    if not LoopDumpProc() then
      goto DeleteLoop
    else
      goto DumpAndExit;
  end;

  Result := 0;

end; // function TK_CMEDDBAccess.EDACheckFilesFolderAccess

//********************************************* TK_CMEDDBAccess.EDACheckFilesAccessBySlidesSet ***
// Check Images and/or Video Files Access by Slides Set
//
//     Parameters
// APUDSlide - pointer to 1-st slide in slides array
// ASlidesCount - slides count
// AddWarnStr   - aditional warning string if problem will not be resolved
// AMDButtons  - set of Message Dialog buttons
// AMDResult   - Message Dialog OK result corresponding to AMDButtons
// Result - Returns string with problem Folders Name:
//#F
//   '' - no problems with access to folders
//   'Images' - problem with access to Images files folder
//   'Video'  - problem with access to Video files folder
//   'Images and Video' - problem with access to Images and Video files folders
//#/F
//
function TK_CMEDDBAccess.EDACheckFilesAccessBySlidesSet( APUDSlide: TN_PUDCMSlide;
                                            ASlidesCount : Integer;
                                            const AddWarnStr : string;
                                            AMDButtons : TMsgDlgButtons = [];
                                            AMDResult : word = mrOk ): Integer;
var
  i, ImgSlides, VideoSlides, Img3DSlides : Integer;
begin
  // Search for slides type - Image/Video
  ImgSlides := 0;
  VideoSlides := 0;
  Img3DSlides := 0;
  for i := 1 to ASlidesCount do
  begin
    if TN_UDCMBSlide(APUDSlide^) is TN_UDCMSlide then
      TN_UDCMBSlide(APUDSlide^).GetFileTypeCounts( @ImgSlides, @VideoSlides, @Img3DSlides );
    Inc(APUDSlide);
  end;
  Result := EDACheckAllFilesAccess( ImgSlides > 0, VideoSlides > 0,
                                    Img3DSlides > 0, AddWarnStr, '',
                                    AMDButtons, AMDResult );
end; // function TK_CMEDDBAccess.EDACheckFilesAccessBySlidesSet

//************************************ TK_CMEDDBAccess.EDACheckFoldersEquality1 ***
// Check to Folders for equivalence
//
//     Parameters
// AFPath1 - 1-st compared folder path
// AFDA1  - 1-st compared folder direc access flag
// AFPath2 - 2-nd compared folder path
// AFDA2  - 2-nd compared folder direc access flag
// Result - Returns TRUE if folders are the same
//
function TK_CMEDDBAccess.EDACheckFoldersEquality1( AFPath1 : string; AFDA1 : Boolean;
                                                   AFPath2 : string; AFDA2 : Boolean ) : Boolean;
const
  CheckName = '123456789.123';

var
  TmpName: string;

begin
  if AFDA1 and AFDA2 then
    Result := EDACheckFoldersEquality( AFPath1, AFPath2 )
  else
  begin
    Result := AFPath1 = AFPath2;
    if Result then Exit;

    TmpName := K_ExpandFileName('(#TmpFiles#)' + CheckName);
    if not FileExists(TmpName) then
      with TFileStream.Create(TmpName, fmCreate) do
      begin
        Write(TmpName[1], 1);
        Free;
      end;

    AFPath1 := AFPath1 + CheckName;
    AFPath2 := AFPath2 + CheckName;
    EDAFileDelete( AFPath2, AFDA2 );
    if EDACopyFileToServer( TmpName, AFPath1, AFDA1 ) = K_edOK then
    begin
      Result := EDAPathOrFileExists( AFPath2, AFDA2, false ) = K_edOK;
      EDAFileDelete( AFPath1, AFDA1 );
    end;
  end;
end; // function TK_CMEDDBAccess.EDACheckFoldersEquality1

//********************************************* TK_CMEDDBAccess.EDAWarnMinFreeSpace ***
// Show Minimal Server Free Space Warning
//
//     Parameters
// AFreeSpace - disk free space
// ADriveName - disk drive name
// Result - Returns Warning Dialog Resulting Code
//
function TK_CMEDDBAccess.EDAWarnMinFreeSpace( AFreeSpace : Int64; ADriveName : string ) : Integer;
begin
   Result :=  K_CMShowMessageDlg1( EDAPrepFreeSpaceWarnText( AFreeSpace, ADriveName ) +
         K_CML1Form.LLLFreeSpaceWarn2.Caption,
//        'Media Suite requires minimum 500.00Mb of free space to operate.'#13#10 +
//        'Please free up more space on your Server PC Hard Drive and restart CMS.',
         mtWarning, [mbOK] );
end; // function TK_CMEDDBAccess.EDAWarnMinFreeSpace

//********************************************* TK_CMEDDBAccess.EDACheckMinDiskFreeSpace ***
// Ñheñk Minimal Server Free Space
//
//     Parameters
//  Result - Returns TRUE if CMS has not enough Disk Free Space to Continue
//
function TK_CMEDDBAccess.EDACheckMinDiskFreeSpace( ) : Boolean;
var
  FreeSpaceAvailable : Int64;
  CheckDriveName : string;
begin
  Result := FALSE;
  if K_CMDisableDiskFreeSpaceCheck then Exit;
  if SlidesImgRootFolder <> '' then
  begin
  // check free space if SlidesImgRootFolder is OK
    EDAGetImgDiskFreeSpace( FreeSpaceAvailable );
    if SlidesMediaImgSameDrive then
      CheckDriveName := ''
    else
      CheckDriveName := ExtractFileDrive(SlidesImgRootFolder);

    if FreeSpaceAvailable < K_CMSMinServerFreeSpace then
    begin
      EDAWarnMinFreeSpace( FreeSpaceAvailable, CheckDriveName );
      Result := TRUE;
    end;
  end;

  if (not SlidesMediaImgSameDrive) and
     (SlidesMediaRootFolder <> '') then
  begin
  //  check free space if SlidesMediaRootFolder is not equal
  // to SlidesImgRootFolder and SlidesMediaRootFolder is OK
    EDAGetVideoDiskFreeSpace( FreeSpaceAvailable );
    if FreeSpaceAvailable < K_CMSMinServerFreeSpace then
    begin
      EDAWarnMinFreeSpace( FreeSpaceAvailable, ExtractFileDrive(SlidesMediaRootFolder) );
      Result := TRUE;
    end;
  end;
  if Result then
    N_CM_MainForm.CMMFAppClose( '***** Close by Disk FreeSpace check' ); // close
end; // procedure TK_CMEDDBAccess.EDACheckMinDiskFreeSpace

//*************************** TK_CMEDDBAccess.EDABuildSelectSQLBySlidesList ***
// Build SQL and corresponding Log strings by given SLides List
//
//     Parameters
// APSlides - pointer to slides array start element to change Host Location
// ASlidesCount - number of slides to change Host Location
// APSQLStr - pointer to resulting SQL string (SlideID=ID or ...)
// APLogStr - pointer to resulting Log string (ID, ...)
//
procedure TK_CMEDDBAccess.EDABuildSelectSQLBySlidesList( APSlide: TN_PUDCMSlide;
               ASlidesCount: Integer; APSQLStr, APLogStr : PString );
var
  i : Integer;

begin
  if ASlidesCount = 0 then Exit;

  if APSQLStr <> nil then
    APSQLStr^ := '';
  if APLogStr <> nil then
    APLogStr^ := 'Slides IDs=';
  for i := 1 to ASlidesCount do
  begin
    with APSlide^, P^ do
    begin
      if i > 1 then
      begin
        if APSQLStr <> nil then
          APSQLStr^ := APSQLStr^ + ' or ';
        if APLogStr <> nil then
          APLogStr^ := APLogStr^ + ','
      end;
      if APLogStr <> nil then
        APLogStr^ := APLogStr^ + ObjName;
      if APSQLStr <> nil then
        APSQLStr^ := APSQLStr^ + K_CMENDBSTFSlideID + ' = ' + ObjName;
    end;
    Inc(APSlide);
  end;
end; // end of TK_CMEDDBAccess.EDABuildSelectSQLBySlidesList

//********************************* TK_CMEDDBAccess.EDABuildXMLBySlidesList ***
// Build XML and corresponding Log strings by given SLides List
//
//     Parameters
// APSlides - pointer to slides array start element to change Host Location
// ASlidesCount - number of slides to change Host Location
// AXMLFormat - XML element format (like <slide ID="%s" />)
// APSQLStr - pointer to resulting XML string
// APLogStr - pointer to resulting Log string (ID, ...)
//
procedure TK_CMEDDBAccess.EDABuildXMLBySlidesList( APSlide: TN_PUDCMSlide;
                         ASlidesCount: Integer; const AXMLFormat : string;
                         APXMLStr, APLogStr : PString );
var
  i : Integer;
begin
  if ASlidesCount = 0 then Exit;

  if APXMLStr <> nil then
  begin
    APXMLStr^ := '';
    TmpStrings.Clear;
  end;
  if APLogStr <> nil then
    APLogStr^ := 'Slides IDs=';
  for i := 1 to ASlidesCount do
  begin
    with APSlide^{, P^} do
    begin
      if (i > 1) and (APLogStr <> nil) then
          APLogStr^ := APLogStr^ + ',';
      if APLogStr <> nil then
        APLogStr^ := APLogStr^ + ObjName;

      if APXMLStr <> nil then
        TmpStrings.Add( format( AXMLFormat, [ObjName] ) );
    end;
    Inc(APSlide);
  end;

  if APXMLStr <> nil then
    APXMLStr^ := Copy( StrTextBuf, 1, K_GetStringsToBuf( StrTextBuf, TmpStrings, 0, TmpStrings.Count, TRUE, Chr($0A) ) );
end; // procedure TK_CMEDDBAccess.EDABuildXMLBySlidesList

{
//********************************************* TK_CMEDDBAccess.EDALockUnlockEGAMode ***
// Lock/Unlock Enterprise Global Admin Mode
//
//     Parameters
// ALockGAMode - if =0 then clear Global Admin Mode Lock, else set Global Admin Mode Lock
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDALockUnlockEGAMode( ALockGAMode: Integer ): TK_CMEDResult;

var
  SSelfAppRTID: string;
  SLockMode: string;

begin

  Result := K_edOK;
  SSelfAppRTID := IntToStr(AppRTID);
  SLockMode := IntToStr(ALockGAMode);
  N_Dump2Str('DB>> EDALockUnlockEGAMode ActRTID=' + SSelfAppRTID + ' given LockMode=' + SLockMode );

  try
    with CurDSet1 do
    begin
      // Select all records from Locked Slides Table
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      if K_CMEDDBVersion >= 17 then
        SQL.Text := 'select cms_LockGAMode( ' + SSelfAppRTID + ', ' + SLockMode + ');'
      else
        SQL.Text := 'select cms_LockActMode( ' + SSelfAppRTID + ', 1, ' + SLockMode + ');';
      Filtered := false;
      Open;
      if (ALockGAMode = 1) and (FieldList.Fields[0].AsInteger = 0) then
        Result := K_edFails;
      N_Dump2Str('DB>> EDALockUnlockEGAMode ActRTID=' + SSelfAppRTID + ' resulting LockMode=' + FieldList.Fields[0].AsString );
      Close;
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDALockUnlockEGAMode ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDALockUnlockEGAMode
}
//********************************************* TK_CMEDDBAccess.EDALockUnlockActMode ***
// Lock/Unlock CMS Instance Action Mode
//
//     Parameters
// AActModeFlag - Action Mode Flag to Lock or Unlock
// ALockMode - if =0 then clear Action Mode Lock state, else set Action Mode Lock state
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDALockUnlockActMode( AActModeFlag : TK_CMEDAInstanceActModeFlags; ALockMode: Integer ): TK_CMEDResult;

var
  SSelfAppRTID: string;
  SLockMode: string;
  SActModeFlag : string;
  ResCode : Integer;
begin

  Result := K_edOK;
  SSelfAppRTID := IntToStr(AppRTID);
  SLockMode := IntToStr(ALockMode);
  SActModeFlag := IntToStr(Byte(AActModeFlag));
  N_Dump2Str( format( 'DB>> EDALockUnlockActMode ActRTID=%s LockFlag=%s LockMode=%s', [SSelfAppRTID, SActModeFlag, SLockMode] ) );
//  N_Dump2Str('DB>> EDALockUnlockActMode ActRTID=' + SSelfAppRTID + ' given LockMode=' + SLockMode );

  try
//    if (K_CMEDDBVersion < 39) and not K_CMEDDBUseSQLProcs then
    if K_CMEDDBVersion < 39 then
      with CurDSet1 do
      begin
        // Select all records from Locked Slides Table
        ExtDataErrorCode := K_eeDBSelect;
        Connection := LANDBConnection;
        if K_CMEDDBVersion <= 16 then
          SQL.Text := 'select cms_LockGAMode( ' + SSelfAppRTID + ', ' + SLockMode + ');'
        else
          SQL.Text := 'select cms_LockActMode( ' + SSelfAppRTID + ', ' + SActModeFlag + ', ' + SLockMode + ');';
        Filtered := false;
        Open;
        ResCode := FieldList.Fields[0].AsInteger;

//        N_Dump2Str('DB>> EDALockUnlockActMode ActRTID=' + SSelfAppRTID + ' resulting LockMode=' + FieldList.Fields[0].AsString );
        Close;
      end
//    else // if (K_CMEDDBVersion >= 39) or K_CMEDDBUseSQLProcs then
    else // if K_CMEDDBVersion >= 39 then
      with CurStoredProc1 do
      begin
        Connection := LANDBConnection;
        ProcedureName := 'dba.cms_LockActMode';
        Parameters.Clear;
        with Parameters.AddParameter do
        begin
          Name := '@AppRTID';
          Direction := pdInput;
          DataType := ftInteger;
          Value := AppRTID;
        end;
        with Parameters.AddParameter do
        begin
          Name := '@ActFlag';
          Direction := pdInput;
          DataType := ftInteger;
          Value := Byte(AActModeFlag);
        end;
        with Parameters.AddParameter do
        begin
          Name := '@ActState';
          Direction := pdInput;
          DataType := ftInteger;
          Value := Ord(ALockMode);
        end;
        with Parameters.AddParameter do
        begin
          Name := '@RET';
          Direction := pdOutput;
          DataType := ftInteger;
          ExecProc;
          ResCode := Value;
        end; // with Parameters.AddParameter do
      end; // with CurStoredProc1 do

    if (ALockMode = 1) and (ResCode = 0) then
      Result := K_edFails;
    N_Dump2Str('DB>> EDALockUnlockActMode ActRTID=' + SSelfAppRTID + ' resulting LockMode=' + IntToStr(ResCode) );
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDALockUnlockActMode ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDALockUnlockActMode

//************************************* TK_CMEDDBAccess.EDAGetDCMStudiesAttrs ***
// Build Slides DICOM Studies IDs and TimeStamps
//
//     Parameters
// APSlides - pointer to slides array start element
// ASlidesCount - number of slides
// AStudiesSID - resulting array of slides corresponding studies IDs
// AStudiesTS - resulting array of slides corresponding studies TimeStamps
//
procedure TK_CMEDDBAccess.EDAGetDCMStudiesAttrs( APSlide: TN_PUDCMSlide;
               ASlidesCount: Integer; out AStudiesSID : TN_SArray;
               out AStudiesTS : TN_DArray );
var
  i : Integer;
  WhereStr : string;
begin
  N_Dump2Str('DB>> EDAGetDCMStudiesAttrs start' );

  if K_CMEDDBVersion < 13 then
    inherited EDAGetDCMStudiesAttrs( APSlide, ASlidesCount, AStudiesSID, AStudiesTS )
  else
  try
    SetLength( AStudiesSID, ASlidesCount );
    SetLength( AStudiesTS, ASlidesCount );
    if ASlidesCount = 0 then Exit;
    with CurDSet1 do
    begin
      // Select all records from Locked Slides Table
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      EDABuildSelectSQLBySlidesList( APSlide, ASLidesCount, @WhereStr, nil );
       SQL.Text :=
      'SELECT S.SlideID, S.SessionID, Q.SessionTS'+
      ' FROM ' +
      '(SELECT ' + K_CMENDBSlidesNHTFSlideID + ' as SlideID,' + K_CMENDBSlidesNHTFSessionID + ' as SessionID' +
      ' FROM ' + K_CMENDBSlidesNewHistTable +
      ' WHERE (' + WhereStr + ') ' +
      ' AND ('+ '('+ K_CMENDBSlidesNHTFActCode + '=' + IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCACreate))) + ')' +
//         ' OR ('+ K_CMENDBSlidesNHTFActCode + '=' + IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCACreateIAC))) + ')' +
      ') ) S  LEFT OUTER JOIN ' +
      '(SELECT ' + K_CMENDBSlidesNHTFSessionID + ' as SessionID,' + K_CMENDBSlidesNHTFActTS  + ' as SessionTS' +
      ' FROM ' + K_CMENDBSlidesNewHistTable +
      ' WHERE '+ K_CMENDBSlidesNHTFActCode + '=' + IntToStr(EDABuildHistActionCode( K_shATNotChange, Ord(K_shNCAStartSession))) + ') Q' +
      ' ON S.SessionID = Q.SessionID';
//N_S := SQL.Text;
//K_GetFormTextEdit.EditText(N_S,'');
      Filtered := FALSE;
      Open;
      for i := 0 to ASLidesCount - 1 do
      begin
        Filtered := FALSE;
        with APSlide^, P()^ do
        begin
          Filter := 'SlideID=' + ObjName;
          Filtered := TRUE;
          if RecordCount > 0 then
          begin
            AStudiesSID[i] := Fields[1].AsString;
            AStudiesTS[i]  := TDateTimeField(Fields[2]).Value;
          end
          else
          begin
            AStudiesSID[i] := ObjName;
          end;
          if AStudiesTS[i] = 0 then // Session Start event is absent
            AStudiesTS[i]  := CMSDTCreated;
        end;
        Inc(APSlide);
      end;

      N_Dump2Str('DB>> EDAGetDCMStudiesAttrs fin' );
      Close;
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetDCMStudiesAttrs ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAGetDCMStudiesAttrs

//************************************* TK_CMEDDBAccess.EDAGetDCMStudiesAttrs ***
// Build Slides DICOM Studies UIDs, IDs and TimeStamps
//
//     Parameters
// APSlides - pointer to slides array start element
// ASlidesCount - number of slides
// AStudiesUID  - resulting array of slides corresponding studies UIDs
// AStudiesSID  - resulting array of slides corresponding studies IDs
// AStudiesTS   - resulting array of slides corresponding studies TimeStamps
//
procedure TK_CMEDDBAccess.EDAGetDCMStudiesUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
             ADCMFNames : TN_SArray;
             out AStudiesUID, AStudiesSID : TN_SArray; out AStudiesTS : TN_DArray );
var
  i, j : Integer;
  WhereStr : string;
  UseCurContext : Integer;
  SQLTxt : string;
  WSlides : TN_UDCMSArray;
  WInd : Integer;
  WPSlide: TN_PUDCMSlide;
  SkipOpenDBDataSet : Boolean;

label NoD4WDCMStudyID, NextSlide;

begin
  N_Dump2Str('DB>> EDAGetDCMStudiesUIDAttrs start' );
  SetLength( AStudiesUID, ASlidesCount );
  SetLength( AStudiesSID, ASlidesCount );
  SetLength( AStudiesTS, ASlidesCount );
  if ASlidesCount = 0 then Exit;

  if K_CMEDDBVersion < 13 then
    inherited EDAGetDCMStudiesUIDAttrs( APSlide, ASlidesCount, ADCMFNames, AStudiesUID, AStudiesSID, AStudiesTS )
  else
  begin // K_CMEDDBVersion >= 13
    UseCurContext := 0;
    with CurDSet1 do
    begin
      SkipOpenDBDataSet := FALSE;
      WPSlide := APSlide;
      for i := 0 to ASlidesCount - 1 do
      begin
        with APSlide^, P^ do
        begin

          if  ADCMFNames[i] <> '' then goto NextSlide;

          if UseCurContext = 0 then
          begin
            if K_CMEDDBVersion < 44 then
              UseCurContext := 2
            else
            if cmsfIsNew in CMSRFlags then
              UseCurContext := 1
            else
              UseCurContext := 2;
          end; // if UseCurContext = 0 then

          if not SkipOpenDBDataSet and (UseCurContext = 2) then
          begin
            SkipOpenDBDataSet := TRUE;
            SetLength( WSlides, ASlidesCount );
            WInd := 0;
            for j := 0 to ASlidesCount - 1 do
            begin
              with WPSlide^, P^ do
              begin
                if (ADCMFNames[j] = '') and not ((cmsfIsMediaObj in CMSDB.SFlags) or (cmsfIsImg3DObj in CMSDB.SFlags)) then
                begin
                  WSlides[Wind] := WPSlide^;
                  Inc(WInd);
                end;
              end;
              Inc(WPSlide);
            end; // for j := 0 to ASlidesCount - 1 do

            if WInd > 0 then
            begin
              // Select all records from Locked Slides Table
              ExtDataErrorCode := K_eeDBSelect;
              Connection := LANDBConnection;

              EDABuildSelectSQLBySlidesList( @WSlides[0], WInd, @WhereStr, nil );
              SQLTxt :=
              'SELECT S.SlideID as SLID, S.SessionID as SEID, Q.SessionTS as SETS'+
              ' FROM ' +
              '(SELECT ' + K_CMENDBSlidesNHTFSlideID + ' as SlideID,' + K_CMENDBSlidesNHTFSessionID + ' as SessionID' +
              ' FROM ' + K_CMENDBSlidesNewHistTable +
              ' WHERE (' + WhereStr + ') ' +
              ' AND ('+ '('+ K_CMENDBSlidesNHTFActCode + '=' + IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCACreate))) + ')' +
//                 ' OR ('+ K_CMENDBSlidesNHTFActCode + '=' + IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCACreateIAC))) + ')' +
              ') ) S  LEFT OUTER JOIN ' +
              '(SELECT ' + K_CMENDBSlidesNHTFSessionID + ' as SessionID,' + K_CMENDBSlidesNHTFActTS  + ' as SessionTS' +
              ' FROM ' + K_CMENDBSlidesNewHistTable +
              ' WHERE '+ K_CMENDBSlidesNHTFActCode + '=' + IntToStr(EDABuildHistActionCode( K_shATNotChange, Ord(K_shNCAStartSession))) + ') Q' +
              ' ON S.SessionID = Q.SessionID';

              if K_CMEDDBVersion >= 44 then
                SQLTxt := 'SELECT R.SLID, R.SEID, R.SETS, ' + K_CMENDBSessionsHTFDCMSTUID +
                ' FROM (' + SQLTxt + ') R join ' +  K_CMENDBSessionsHistTable +
                ' ON R.SEID = ' + K_CMENDBSessionsHTFSessionID;

//       K_GetFormTextEdit.EditText(SQLTxt,'');
              SQL.Text := SQLTxt;
              Filtered := FALSE;
              Open;
            end; // if WInd > 0 then
          end; // if (i = 0) and (UseCurContext = 2) then

          if not ((cmsfIsMediaObj in CMSDB.SFlags) or (cmsfIsImg3DObj in CMSDB.SFlags)) then
          begin
            if UseCurContext = 1 then
            begin // Special case for new Slides
              AStudiesSID[i] := IntToStr(CurSessionHistID);
              AStudiesTS[i]  := CurSessionHistStartTS;
              if K_CMDCMD4WStudyUID = '' then
              begin
NoD4WDCMStudyID: // ****
                AStudiesUID[i] := '4.' + AStudiesSID[i];
                if K_CMDCMUIDPrefix <> '' then
                  AStudiesUID[i] := K_CMDCMUIDPrefix + '.' + AStudiesUID[i];
              end
              else
                AStudiesUID[i] := K_CMDCMD4WStudyUID;
            end   // if UseCurContext = 1 then
            else
            begin // if UseCurContext = 2 then
              if CurDSet1.Active then
              begin
//                Filter := 'SlideID=' + ObjName;
                Filter := 'SLID=' + ObjName;
                Filtered := TRUE;
              end;
              if RecordCount > 0 then
              begin
                if K_CMEDDBVersion >= 44 then
                  AStudiesUID[i] := Fields[3].AsString;

                AStudiesSID[i] := Fields[1].AsString;
                AStudiesTS[i]  := TDateTimeField(Fields[2]).Value;
                if AStudiesUID[i] = '' then goto NoD4WDCMStudyID;
              end
              else
              begin
                AStudiesSID[i] := ObjName;
                AStudiesTS[i]  := CMSDTCreated;
                AStudiesUID[i] := '1.' + ObjName;
                if K_CMDCMUIDPrefix <> '' then
                  AStudiesUID[i] := K_CMDCMUIDPrefix + '.' + AStudiesUID[i];
              end;
            end; // if UseCurContext = 2 then
          end; // Slide is Image
        end; // with APSlide^, P^ do
NextSlide: //****
        Inc(APSlide);
      end; // for i := 0 to ASlidesCount - 1 do
    end; // with curdset1
    if CurDSet1.Active then CurDSet1.Close;
  end; // K_CMEDDBVersion >= 13
end; // procedure TK_CMEDDBAccess.EDAGetDCMStudiesUIDAttrs

//********************************* TK_CMEDDBAccess.EDAGetDCMSeriesUIDAttrs ***
// Build Slides DICOM Series UIDs, IDs and TimeStamps
//
//     Parameters
// APSlides - pointer to slides array start element
// ASlidesCount - number of slides
// ASeriesUID   - resulting array of slides corresponding series UIDs
// ASeriesSID   - resulting array of slides corresponding series IDs
// ASeriesTS    - resulting array of slides corresponding series TimeStamps
//
procedure TK_CMEDDBAccess.EDAGetDCMSeriesUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
             ADCMFNames : TN_SArray;
             out ASeriesUID, ASeriesSID  : TN_SArray; out ASeriesTS  : TN_DArray );
var
  i,j,SerID : Integer;
  WhereStr, WStr : string;
  UseCurContext : Integer;
  SQLTxt : string;
  WPSlide: TN_PUDCMSlide;

label NoSeries, NextSlide;
begin
  N_Dump2Str('DB>> EDAGetDCMSeriesUIDAttrs start' );
  SetLength( ASeriesUID, ASlidesCount );
  SetLength( ASeriesSID, ASlidesCount );
  SetLength( ASeriesTS, ASlidesCount );
  if ASlidesCount = 0 then Exit;

  if K_CMEDDBVersion < 13 then
    inherited EDAGetDCMSeriesUIDAttrs( APSlide, ASlidesCount, ADCMFNames, ASeriesUID, ASeriesSID, ASeriesTS )
  else
  begin // K_CMEDDBVersion >= 13
    UseCurContext := 0;
    with CurDSet1 do
    begin
      WPSlide := APSlide;
      for i := 0 to ASlidesCount - 1 do
      begin
        with APSlide^, P^ do
        begin
          if  ADCMFNames[i] <> '' then goto NextSlide;

          if UseCurContext = 0 then
          begin // define process context before 1-st Slide
            // define  UseCurContext
            if K_CMEDDBVersion < 44 then
              UseCurContext := 3
            else
            if cmsfIsNew in CMSRFlags then
              UseCurContext := 1
            else
              UseCurContext := 2;

            if UseCurContext = 2 then
            begin // Prepare Series DB context
              TmpStrings.Clear;
              for j := 0 to ASlidesCount - 1 do
              begin
                with WPSlide^, P^ do
                begin
                  if (ADCMFNames[j] = '') and not ((cmsfIsMediaObj in CMSDB.SFlags) or (cmsfIsImg3DObj in CMSDB.SFlags)) then
                  begin
                    SerID := CMDCMSerID;
                    if SerID = 0 then
                      SerID := CMSDB.DCMSerID;
                    if SerID > 0 then
                    begin
                      WStr := IntToStr( SerID );
                      if TmpStrings.IndexOf( WStr ) < 0 then
                        TmpStrings.Add( WStr );
                    end;
                  end;
                end; // with WPSlide^, P^ do
                Inc(WPSlide);
              end; // for j := 0 to ASlidesCount - 1 do

              // Prepare Series SQL
              if TmpStrings.Count >= 1 then
              begin
                WhereStr := K_CMENDDCMSRID + ' = ' + TmpStrings[0];
                for j := 1 to TmpStrings.Count - 1 do
                  WhereStr := WhereStr + ' or ' + K_CMENDDCMSRID + ' = ' + TmpStrings[j];

                // Select all needed records from DCM Series Table
                ExtDataErrorCode := K_eeDBSelect;
                Connection := LANDBConnection;
                SQLTxt :=
                'SELECT ' + K_CMENDDCMSRID + ',' + K_CMENDDCMSRDT +
                ' FROM ' + K_CMENDBDCMSeriesTable +
                ' WHERE ' + WhereStr;

          //K_GetFormTextEdit.EditText(SQLTxt,'');
                SQL.Text := SQLTxt;
                Filtered := FALSE;
                Open;
              end;
            end; // if UseCurContext = 2 then
          end; // if UseCurContext = 0 then


          if not ((cmsfIsMediaObj in CMSDB.SFlags) or (cmsfIsImg3DObj in CMSDB.SFlags)) then
          begin
            if UseCurContext = 1 then
            begin // Special case for new Slides
              if K_CMDCMSeriesID = 0 then
              begin
                N_Dump1Str( 'NoSeries in EDAGetDCMSeriesUIDAttrs >> K_CMDCMSeriesID=0' );
                goto NoSeries;
              end
              else
              begin
                ASeriesSID[i] := IntToStr(K_CMDCMSeriesID);
                ASeriesTS[i]  := K_CMDCMSeriesIDTS;
                ASeriesUID[i] := '5.' + ASeriesSID[i];
              end;
            end   // if UseCurContext = 1 then
            else
            begin // if UseCurContext = 2 then
              SerID := CMDCMSerID;
              if SerID = 0 then
                SerID := CMSDB.DCMSerID;
              if SerID > 0 then
              begin
                if CurDSet1.Active then
                begin
                  Filter := K_CMENDDCMSRID+'=' + IntToStr(SerID);
                  Filtered := TRUE;
                  if RecordCount > 0 then
                  begin
                    ASeriesSID[i] := Fields[0].AsString;
                    ASeriesTS[i]  := TDateTimeField(Fields[1]).Value;
                    ASeriesUID[i] := '5.' + ASeriesSID[i];
                  end  // if CMSDB.DCMSerID > 0 then
                  else
                  begin
                    N_Dump1Str( format('NoSeries in EDAGetDCMSeriesUIDAttrs >> DCMSerID=%d is not found in ' + K_CMENDBDCMSeriesTable,[SerID]) );
                    goto NoSeries;
                  end
                end; // if CurDSet1.Active then
              end
              else
              begin // NoSeries
NoSeries: //********
                ASeriesSID[i] := ObjName;
                ASeriesTS[i]  := CMSDTCreated;
                ASeriesUID[i] := '2.' + ObjName;
              end; // NoSeries
            end; // if UseCurContext = 2 then
            if K_CMDCMUIDPrefix <> '' then
              ASeriesUID[i] := K_CMDCMUIDPrefix + '.' + ASeriesUID[i]
          end; // Slide is Image
        end; // with APSlide^, P^ do
NextSlide: //*****
        Inc(APSlide);
      end; // for i := 0 to ASlidesCount - 1 do
    end; // with curdset1
    if CurDSet1.Active then CurDSet1.Close;
  end; // K_CMEDDBVersion >= 13
end; // procedure TK_CMEDDBAccess.EDAGetDCMSeriesUIDAttrs

//********************************** TK_CMEDDBAccess.EDAGetDCMSlideUIDAttrs ***
// Build Slides DICOM Content UIDs, IDs, Change TimeStamps and Acquisition TimeStamps
//
//     Parameters
// APSlides - pointer to slides array start element
// ASlidesCount - number of slides
// AContentUID  - resulting array of slides corresponding content UIDs
// AContentSID  - resulting array of slides corresponding content IDs
// AContentTS   - resulting array of slides corresponding content TimeStamps
// AcqTS        - resulting array of slides corresponding content acquisition TimeStamps
//
procedure TK_CMEDDBAccess.EDAGetDCMSlideUIDAttrs( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
             out ADCMFNames, AContentUID, AContentSID : TN_SArray; out AContentTS, AcqTS : TN_DArray );
var
  i : Integer;
  WhereStr : string;
  UseCurContext : Integer;
  SQLTxt : string;
  ChangeCount : Integer;
  DCMAttrsFName : string;

label ContentUID;

begin
  N_Dump2Str('DB>> EDAGetDCMSlideUIDAttrs start' );
  SetLength( ADCMFNames, ASlidesCount );
  SetLength( AContentUID, ASlidesCount );
  SetLength( AContentSID, ASlidesCount );
  SetLength( AContentTS, ASlidesCount );
  SetLength( AcqTS, ASlidesCount );
  if ASlidesCount = 0 then Exit;

  if K_CMEDDBVersion < 13 then
    inherited EDAGetDCMSlideUIDAttrs( APSlide, ASlidesCount, ADCMFNames, AContentUID, AContentSID, AContentTS, AcqTS )
  else
  begin // K_CMEDDBVersion >= 13
    UseCurContext := 0;
    with CurDSet1 do
    begin
      for i := 0 to ASlidesCount - 1 do
      begin
        with APSlide^, P^ do
        begin

          if UseCurContext = 0 then
          begin
            if cmsfIsNew in CMSRFlags then
              UseCurContext := 1
            else
              UseCurContext := 2;
          end; // if UseCurContext = 0 then

          if (i = 0) and (UseCurContext = 2) then
          begin
            // Select all records from Locked Slides Table
            ExtDataErrorCode := K_eeDBSelect;
            Connection := LANDBConnection;
            EDABuildSelectSQLBySlidesList( APSlide, ASLidesCount, @WhereStr, nil );
            SQLTxt :=
            'SELECT ' + K_CMENDBSlidesNHTFSlideID + ' as SlideID, Count(*) as ChngCount, Max(' + K_CMENDBSlidesNHTFActTS + ') as ActTS ' +
            ' FROM ' + K_CMENDBSlidesNewHistTable +
            ' WHERE (' + WhereStr + ') ' +
            ' AND ('+ K_CMENDBSlidesNHTFActCode + ' & 0xFF000000 = ' + IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCAImage))) + ')' +
            ' GROUP BY SlideID';

      //K_GetFormTextEdit.EditText(SQLTxt,'');
            SQL.Text := SQLTxt;
            Filtered := FALSE;
            Open;
          end; // if (i = 0) and (UseCurContext = 2) then

          if not ((cmsfIsMediaObj in CMSDB.SFlags) or (cmsfIsImg3DObj in CMSDB.SFlags)) then
          begin

            ChangeCount := 0;
            AContentTS[i]  := CMSDTTaken;
            if UseCurContext = 2 then // Special case for new Slides
            begin // if UseCurContext = 2 then
              Filter := 'SlideID=' + ObjName;
              Filtered := TRUE;
              if RecordCount > 0 then
              begin
                AContentTS[i]  := TDateTimeField(Fields[2]).Value;
                ChangeCount := Fields[1].AsInteger;
              end;

              // Check File with DCM Attrs
//              DCMAttrsFName := EDAGetSlideImgPath(APSlide^) + K_CMSlideGetDCMAttrsFileName( ObjName );
              DCMAttrsFName := APSlide^.GetDCMFileName( EDAGetSlideImgPath(APSlide^) );
              if FileExists(DCMAttrsFName) then
                ADCMFNames[i] := DCMAttrsFName;
            end; // if UseCurContext = 2 then

            AContentSID[i] := ObjName;
            AcqTS[i]  := CMSDTTaken;
            AContentUID[i] := format( '3.%d.%s', [ChangeCount, ObjName] );
            if K_CMDCMUIDPrefix <> '' then
              AContentUID[i] := K_CMDCMUIDPrefix + '.' + AContentUID[i];
          end; // Slide is Image
        end; // with APSlide^, P^ do
        Inc(APSlide);
      end; // for i := 0 to ASlidesCount - 1 do
    end; // with curdset1
    if CurDSet1.Active then CurDSet1.Close;
  end; // K_CMEDDBVersion >= 13
end; // procedure TK_CMEDDBAccess.EDAGetDCMSlideUIDAttrs

//****************************************** TK_CMEDDBAccess.EDAClearGAMode ***
// Clear Global Administrator mode
//
function  TK_CMEDDBAccess.EDAClearGAMode() : TK_CMEDResult;
begin
  Result := K_edOK;
  if K_CMEDDBVersion >= 15 then
    Result := EDALockUnlockActMode( [K_iafEGAMode], 0 );
  if Result <> K_edOK then Exit;
  Result := inherited EDAClearGAMode();
end; // procedure TK_CMEDDBAccess.EDAClearGAMode

//************************** TK_CMEDAccess.EDAScanFilesToClearImg3DTmpFiles ***
// Select and process Delete TmpFiles Task scan files subtree function
//
//     Parameters
// APathName - testing path
// AFileName - testing file name
//
// Resulting files names (not file path, name only) are added to TmpStrings
//
function TK_CMEDDBAccess.EDAScanFilesToClearImg3DTmpFiles(const APathName,
  AFileName: string; AScanLevel: Integer): TK_ScanTreeResult;
var
  FileStream : TFileStream;
  TaskFileFullName : string;
begin
  Result := K_tucSkipSubTree;

  if AFileName = '' then
    Exit;
  FileStream := nil;
  N_Dump1Str( 'DB>> ClearImg3DTmpFiles Start Task ' + AFileName );
  try
    // if Stream will be opened then task is actual and can be processed
    TaskFileFullName := APathName + AFileName;
    FileStream := TFileStream.Create( TaskFileFullName, fmOpenReadWrite );
    TmpStrings.Clear;
    TmpStrings.LoadFromStream( FileStream );
    if TmpStrings.Count > 0 then
      N_Dump1Str( format( 'DB>> ClearImg3DTmpFiles Finish Task RC=%d',
                          [K_CMImg3DTmpFilesClear( TmpStrings[0] )] ) )
    else
      N_Dump1Str( 'DB>> ClearImg3DTmpFiles empty Task ' );
  finally
    FileStream.Free;
    K_DeleteFile(TaskFileFullName); // Delete Task File
  end;
end; // function TK_CMEDDBAccess.EDAScanFilesToClearImg3DTmpFiles

//*********************************** TK_CMEDAccess.EDAClearInstLostRecords ***
// Clear Old CMSuite Instance 
//
//     Parameters
// Result - returns TRUE if Next Clear is needed else FALSE is returned
//
function TK_CMEDDBAccess.EDAClearInstLostRecords(): Boolean;
var
  DeadlockCount : Integer;
  SQLTxt : string;

label DeadLockLoop;
begin
  N_Dump2Str( 'DB>> EDAClearInstLostRecords start' );

  DeadlockCount := 0;
  Result := FALSE;

DeadLockLoop: //*****
  with CurSQLCommand1 do
  begin
    CommandText := EDADBIsolationLevelSet(K_tilSerializable);
    Execute;
  end;

  try
    LANDBConnection.BeginTrans;

    //////////////////////////////////////////////
    // Register Instance to Active Sessions Table
    //
    if K_CMEDDBVersion >= 15 then
      SQLTxt := '(' + K_CMENDBAAInstsTFActFlags +' < 128  and ' +
                      K_CMENDBAAInstsTFActTS + ' < dateadd( minute, -3, GETDATE () ) ) or ' +
                '(' + K_CMENDBAAInstsTFActFlags +' >= 128 and ' +
                      K_CMENDBAAInstsTFActTS + ' < dateadd( minute, -360, GETDATE () ) )'
    else
      SQLTxt := K_CMENDBAAInstsTFActTS + ' < dateadd( minute, -3, GETDATE () )';

    with CurDSet2 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      SQL.Text := 'select top 1 ' + K_CMENDBAAInstsTFActRTID +
                ' from ' + K_CMENDBAAInstsTable +
                ' where ' + SQLTxt;
      Filtered := false;
      Open;
      Result := RecordCount > 0;

      if Result then
      begin
        if InstLostRecordsCount = 0 then
        begin
          TmpStrings.Clear;
          EDADumpActiveContext( CurBlobDSet, TmpStrings );
          N_Dump1Str('DB>> Before LostRecords deletion >> Active Instances Dump ***'#13#10 + TmpStrings.Text);
        end;

        EDAAppUnlockObjects(Fields[0].AsString);
        Delete();
        UpdateBatch();
        Inc(InstLostRecordsCount);
      end;

      Close;
    end; // with CurDSet1 do

    LANDBConnection.CommitTrans;

    with CurSQLCommand1 do
    begin
      CommandText := EDADBIsolationLevelDefault();
      Execute;
    end;
    N_Dump2Str( 'DB>> EDAClearInstLostRecords fin' );

  except
    on E: Exception do
    begin
      ExtDataErrorString := E.Message;
      if (Pos( 'eadlock', E.Message ) = 0) or (DeadlockCount > 100) then
      begin
        ExtDataErrorString := 'EDAClearInstLostRecords ' + ExtDataErrorString;
        EDAShowErrMessage(TRUE);
      end
      else
        Inc(DeadlockCount);
    end;
  end;

  if not LANDBConnection.InTransaction then Exit;

  N_Dump1Str( format( 'DB>> EDAClearInstLostRecords E.Count=%d >> %s',
                      [DeadlockCount,ExtDataErrorString] ) );
  LANDBConnection.RollbackTrans;
  sleep(100);
  goto DeadlockLoop;
end; // function TK_CMEDDBAccess.EDAClearInstLostRecords

//****************************** TK_CMEDDBAccess.EDAPatObjCopyMoveProcCheck ***
// Resume Copy/Move Patient Slides procedure
//
//     Parameters
// Result - Returns TRUE if CopyMove procedure exists, or FALSE if it is removed
//          from active or suspended
//
// CMPProcID field is used as Copy/Move procedure record ID container
//
function  TK_CMEDDBAccess.EDAPatObjCopyMoveProcCheck( ): Boolean;
begin
  Result := TRUE;
  if WaitCMPProcID = 0 then Exit;
  Result := FALSE;
  try
   ///////////////////////////////////////
   // Get CopyMove State
    with CurDSet1 do
    begin
      // Select all records from Locked Slides Table
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SQL.Text := 'SELECT ' + K_CMENDBACMPDataTFCMPState +
      ' FROM ' + K_CMENDBACMPDataTable +
      ' WHERE ' + K_CMENDBACMPDataTFCMPActID + '=' + IntToStr(WaitCMPProcID);
      Filtered := false;
      Open;
      if RecordCount = 0 then
        Result := TRUE;
      Close;
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAPatObjCopyMoveProcCheck ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := FALSE;
    end;
  end;
end; // TK_CMEDDBAccess.EDAPatObjCopyMoveProcCheck
{
//****************************** TK_CMEDDBAccess.EDAPatObjCopyMoveProcCheck ***
// Resume Copy/Move Patient Slides procedure
//
//     Parameters
// ACMPProcID - Copy/Move procedure record ID
// Result - Returns operation resulting code
//
function  TK_CMEDDBAccess.EDAPatObjCopyMoveProcCheck( ACMPProcID : Integer ): TK_CMEDResult;
begin
  Result := K_edOK;
  try
   ///////////////////////////////////////
   // Get CopyMove State
    with CurDSet1 do
    begin
      // Select all records from Locked Slides Table
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SQL.Text := 'SELECT ' + K_CMENDBACMPDataTFCMPState +
      ' FROM ' + K_CMENDBACMPDataTable +
      ' WHERE ' + K_CMENDBACMPDataTFCMPActID + '=' + IntToStr(ACMPProcID);
      Filtered := false;
      Open;
      if RecordCount = 0 then
        Result := K_edFails;
      Close;
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAPatObjCopyMoveProcCheck ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // TK_CMEDDBAccess.EDAPatObjCopyMoveProcCheck
}

//***************************** TK_CMEDDBAccess.EDAPatObjCopyMoveProcResume ***
// Resume Copy/Move Patient Slides procedure
//
//     Parameters
// ACMPProcID - Copy/Move procedure record ID
// AShowResDlgFlag - Show Results Dialog Flag
// Result - Returns resulting code:
//#F
// >=0 - number of copied/moved objects if OK
// -1  - files copy error,
// -2  - files delete error
// -3  - debug break
//#/F
//
function TK_CMEDDBAccess.EDAPatObjCopyMoveProcResume( ACMPProcID : Integer; AShowResDlgFlag : Boolean ): Integer;
type TK_SlidesCopyInfo = record
  SlideSID : Integer;
  SlideDID : Integer;
  StudyID : Integer;
  StudyItemID : Integer;
  StudyPosCode : Integer;
  SlideDTCr : TDateTime;
  SlideSysInfo : string;
end;
type TK_SlidesCopyInfoArray = array of TK_SlidesCopyInfo;

type TK_StudiesCopyInfo = record
  StudySID : Integer;
  StudyDID : Integer;
  LinkSlidesCount : Integer;
  ArchSlidesCount : Integer;
  StudyDTCr : TDateTime;
  StudySampleID : Integer;
end;
type TK_StudiesCopyInfoArray = array of TK_StudiesCopyInfo;

var
  i, PatSID : Integer;
  PatDID : Integer;
  SPatSID : string;
  SPatDID : string;
  CMPState : Integer;
  CMPStartState : Integer;
  SCMPProcID : string;
  SrcImgFiles : string;
  SrcVideoFiles : string;
  SrcImg3DFiles : string;
  SlidesCopyCount : Integer;
  SCurStudyID : string;
  SNewStudyID : string;
  CopyFields1 : string;
  SQLStr : string;
  SavedCurSessionHistID : Integer;
  SavedCurSessionHistStartTS : TDateTime;
//  SavedCurPatID : Integer;
  MaxID : Integer;
  SkipDebugDlg : Boolean;
  DebugMessage : string;
  BreakLoopMode : Integer; // 0 - no break;
                           // 1 - break in the middle, operation state=executed
                           // 2 - break in the middle, operation state=broken
  BreakCount : Integer;
  BreakMessage : string;

  AddSQLStr, AddMoveSQLStr    : string;
  SMaxNewID   : string;
  NextIDSQLStr: string;

  // Objects Move Copy Context
  SLL, STL : THashedStringList;  // Slides and Studies Lists (obj - index of Info Arrya)
  SLA : TK_SlidesCopyInfoArray;  // Slides Info Array
  STA : TK_StudiesCopyInfoArray; // Studies Info Array
  SLC, STC : Integer; // SLA and STA fill counter
  SLAC : Integer; // Archived Counter
  SLNAC : Integer; // not Archived Counter
  FinalMessage : string;
  ErrFilesCount : Integer;
label Loop, LExit, LBreak, BreakMove;

  //***************************** PrepareSlidesAndStudiesInfo ***
  //
  procedure PrepareSlidesAndStudiesInfo();
  var
    NCapacity : Integer;
    WStudyID : Integer;
    ID : Integer;
    SID : string;
    i, Ind : Integer;
  begin
    with CurDSet1 do
    begin
      // Remove SlideID from Diagn in Source Slides
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SQL.Text := 'SELECT ' + K_CMENDBSTFSlideID + ','           // 0
                            + K_CMENDBSTFSlideThumbnail + ','    // 1
                            + K_CMENDBSTFSlideStudyID + ','      // 2
                            + K_CMENDBSTFSlideStudyItem + ','    // 3
                            + K_CMENDBSTFSlideStudyItemPos + ',' // 4
                            + K_CMENDBSTFSlideDTCr + ','         // 5
                            + K_CMENDBSTFSlideSysInfo +          // 6
      ' FROM ' + K_CMENDBSlidesTable +
      ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatSID;
      Filtered := false;
      Open;
      SLC  := 0;
      STC  := 0;
      SLAC := 0;
      if SLL = nil then
        SLL := THashedStringList.Create  // Slides Info Array
      else
        SLL.Clear;

      if STL = nil then
        STL := THashedStringList.Create  // Slides Info Array
      else
        STL.Clear;

      //////////////////////////
      // Init Info from DB Loop
      while not EOF do
      begin
        WStudyID := FieldList[2].AsInteger;
        ID := FieldList[0].AsInteger;
        SID := FieldList[0].AsString;
        if WStudyID < 0 then
        begin // Study
          STL.AddObject( SID, TObject(STC) );
          NCapacity := Length(STA);
          if K_NewCapacity( STC + 1, NCapacity ) then
            SetLength(STA, NCapacity);

          with STA[STC] do
          begin
            StudySID := ID;
            StudyDID := ID;
            StudyDTCr := FieldList[5].AsDateTime;
            StudySampleID := WStudyID;
          end;
          Inc(STC);
        end   // Study
        else
        begin // Slide
          SLL.AddObject( SID, TObject(SLC) );
          NCapacity := Length(SLA);
          if K_NewCapacity( SLC + 1, NCapacity ) then
            SetLength(SLA, NCapacity);

          with SLA[SLC] do
          begin
            SlideSID := ID;
            StudyID := WStudyID;
            StudyItemID := FieldList[3].AsInteger;
            StudyPosCode := FieldList[4].AsInteger;
            if FieldList[1].IsNull then
            begin
              SlideDID := -1;
              Inc(SLAC);
            end
            else
            begin
              SlideDID := ID;
              SlideDTCr := FieldList[5].AsDateTime;
              SlideSysInfo := FieldList[6].AsString;
            end;
          end; // with SLA[SLC] do

          Inc(SLC);
        end; // Slide
        Next;
      end; // while not EOF do
      // Init Info from DB Loop
      //////////////////////////
      Close;
    end; // with CurDSet1 do

    for i := 0 to SLC - 1 do
    begin
      with SLA[i] do
      begin
        if StudyID = 0 then Continue;
        Ind := STL.IndexOf( IntToStr(StudyID) );
        with STA[Ind] do
          if SlideDID = - 1 then
            Inc(ArchSlidesCount)
          else
            Inc(LinkSlidesCount);
      end; // with SLA[i] do
    end; // for i := 0 to SLC - 1 do
  end; // procedure PrepareSlidesAndStudiesInfo

  //***************************** ClearSourceSlidesAndStudiesDB ***
  //
  procedure ClearSourceSlidesAndStudiesDB();
  var
    SDiagn : string;
    Ind : Integer;
  begin
    with CurDSet1 do
    begin
      // Remove SlideID from Diagn in Source Slides
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SQL.Text := 'SELECT ' + K_CMENDBSTFSlideID + ',' + K_CMENDBSTFSlideDiagnoses +
      ' FROM ' + K_CMENDBSlidesTable +
      ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatSID + AddSQLStr;
      Filtered := false;
      Open;

      while not EOF do
      begin
        SDiagn := FieldList[1].AsString;
        Ind := Length(SDiagn);
        if (Ind >= 10) and (SDiagn[Ind] = '>') and (SDiagn[Ind-9] = '<') then
        begin
          Edit;
          if (Ind >= 20) and (SDiagn[Ind-10] = '>') and (SDiagn[Ind-19] = '<') then
          // Clear Move Mark
            FieldList[1].AsString := copy( SDiagn, 1, Ind - 20 )
          else
          // Clear OldID only
            FieldList[1].AsString := copy( SDiagn, 1, Ind - 10 );
        end;
        Next;
      end;
      Close;
    end; // with CurDSet1 do

  end; // procedure ClearSourceSlidesAndStudiesDB

  //***************************** FinishSlidesAndStudiesInfo ***
  //
  procedure FinishSlidesAndStudiesInfo();
  var
    SDiagn, SOldSlideID : string;
    Ind, NewID : Integer;
  begin
    with CurDSet1 do
    begin
      // Remove SlideID from Diagn in Source Slides
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SQL.Text := 'SELECT ' + K_CMENDBSTFSlideID + ','
                            + K_CMENDBSTFSlideDiagnoses + ','
                            + K_CMENDBSTFSlideStudyID +
      ' FROM ' + K_CMENDBSlidesTable +
      ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatDID +
      ' AND '   + K_CMENDBSTFSlideID + ' > ' + SMaxNewID;
      Filtered := false;
      Open;


      SQLStr := '';
      while not EOF do
      begin
        SDiagn := FieldList[1].AsString;
        i := Length(SDiagn);
        if (i >= 10) and (SDiagn[i] = '>') and (SDiagn[i-9] = '<') then
        begin
          SOldSlideID := Trim( copy(SDiagn, i-8, 8 ) );

          if SQLStr <> '' then
            SQLStr := SQLStr + ' or ' + K_CMENDBSTFSlideID + '=' + FieldList[0].AsString
          else
            SQLStr := K_CMENDBSTFSlideID + '=' + FieldList[0].AsString;

          NewID := FieldList[0].AsInteger;
          if FieldList[2].AsInteger < 0 then
          begin // study
            Ind := STL.IndexOf( SOldSlideID );
            with STA[Ind] do
              StudyDID := NewID;

            // Clear OldID in Diagn
            Edit;
            if (i >= 20) and (SDiagn[i-10] = '>') and (SDiagn[i-19] = '<') then
            // Clear Move Mark
              FieldList[1].AsString := copy( SDiagn, 1, i - 20 )
            else
            // Clear OldID only
              FieldList[1].AsString := copy( SDiagn, 1, i - 10 );
          end
          else
          begin // Slide
            Ind := SLL.IndexOf( SOldSlideID );
            with SLA[Ind] do
              SlideDID := NewID;
          end;
        end; // if Copied Object

        Next;
      end;
      Close;
    end; // with CurDSet1 do
  end; // procedure FinishSlidesAndStudiesInfo

  //***************************** CorrectPositionsData ***
  //
  procedure CorrectPositionsData( PrimSL, SecSL, WrkSL, CorPrimSL, CorSecSL : TStrings );
  var
    i, j, k, Ind, RInd, ItemID : Integer;
    SItemID : string;

  Label CheckSecSL, FinLoop;
  begin
    for i := 0 to PrimSL.Count - 1 do
    begin
      Ind := Integer(PrimSL.Objects[i]);
      ItemID := SLA[Ind].StudyItemID;
      SItemID := IntToStr(ItemID);
      if WrkSL.IndexOf(SItemID) >= 0 then Continue;
      RInd := Ind;
      // Check ItemID
      for j := i to PrimSL.Count - 1 do
      begin
        Ind := Integer(PrimSL.Objects[j]);
        if SLA[Ind].StudyItemID <> ItemID then Continue;
        if SLA[Ind].StudyPosCode = 0 then
          goto CheckSecSL;
      end; // for j := i to PrimSL.Count - 2 do

      // Correct Last Slide
      SLA[RInd].StudyPosCode := 0;
      CorPrimSL.AddObject( '', TObject(RInd) );
      goto FinLoop;

      // Check ItemID in Secondary List
CheckSecSL: //******
      for k := 0 to SecSL.Count -1 do
      begin
        RInd := Integer(SecSL.Objects[k]);
        if SLA[RInd].StudyItemID <> ItemID then Continue;
        SLA[RInd].StudyPosCode := 0;
        CorSecSL.AddObject('', TObject(RInd));
        break;
      end;

FinLoop: //******
      WrkSL.Add(SItemID);
    end;
  end; // procedure CorrectPositionsData

  //***************************** RebuildStudyThumbnail ***
  //
  procedure RebuildStudyThumbnail( ASStudyID : string; StudySampleID : Integer; ASLItemsUsed : TStrings );
  var
    CurStudy : TN_UDBase;
    Item : TN_UDBase;
    MapRoot : TN_UDBase;
    PUP : TN_POneUserParam;
    i, Ind : Integer;
    DIB : TN_DIBObj; 
  begin

    CurStudy := K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMStudyCI);
    TN_UDCMStudy(CurStudy).CMSStudySampleID := - StudySampleID;
    TN_UDCMStudy(CurStudy).InitBySample();
    MapRoot := TN_UDCMStudy(CurStudy).GetMapRoot();

    // Mark Used Items
    for i := 0 to ASLItemsUsed.Count - 1 do
    begin
      Ind := StrToInt(ASLItemsUsed[i]);
      Item := MapRoot.DirChild( Ind );
      PUP := N_GetUserParPtr(TN_UDCompBase(Item).R, 'NotEmptyItem');
      PByte(PUP.UPValue.P)^ := 1;
    end; // for i := 0 to ASLItemsUsed.Count - 1 do

    // Create Thumbnail DIB
    DIB := K_CMBStudyCreateThumbnailDIBByMapRoot( TN_UDCompBase(MapRoot) );

    // Save DIB in DB
    with CurDSet1 do
    begin
      SQL.Text := 'SELECT ' + K_CMENDBSTFSlideID + ',' +        //0
                              K_CMENDBSTFSlideThumbnail +       //1
      ' FROM ' + K_CMENDBSlidesTable +
      ' WHERE ' + K_CMENDBSTFSlideID + '=' + ASStudyID;
      Filtered := false;
      Open;
      Edit;
      EDPutBlobFieldFromDIB( CurDSet1, Fields[1], DIB, rietJPG, K_CMSlideThumbQuality );
      UpdateBatch;
      N_Dump1Str( 'DB>> EDAPatObjCopyMoveProcResume rebuild Thumbnail SudyID=' + ASStudyID );
      Close;
    end;

    // Free created objects
    DIB.Free;
    CurStudy.Free;
  end; // procedure RebuildStudyThumbnail

  //***************************** ProcessStudiesCopyLoop ***
  //
  procedure ProcessStudiesCopyLoop( AMoveFlag : Boolean );
  var
    i, j, Ind : Integer;
    DatePathSegm, SPatPath, DPatPath, StudySFName, StudyDFName : string;
    WStr, SQLLinks, SStudySID, SStudyDID, SStudyItem : string;
    {SLSQLArch,} SLSQLLink, SLStudyArch, SLStudyLink, SLStudy1, SLStudy2,
    SLCorLink, SLCorArch, SLStudyUNAItems, SLStudyUItems, SLStudyUAItems :  TStringList;
  begin
    SPatPath := K_CMSlideGetPatientFilesPathSegm(PatSID);
    DPatPath := K_CMSlideGetPatientFilesPathSegm(PatDID);

//    SLSQLArch := TStringList.Create;
    SLSQLLink := TStringList.Create;
    SLStudyArch := TStringList.Create;
    SLStudyLink := TStringList.Create;
    SLStudy1 := TStringList.Create;
    SLStudy2 := TStringList.Create;
    SLCorLink := TStringList.Create;
    SLCorArch := TStringList.Create;
    SLStudyUNAItems := TStringList.Create;
    SLStudyUItems := TStringList.Create;
    SLStudyUAItems := TStringList.Create;

    for i := 0 to STL.Count - 1 do
    begin
      with STA[i] do
      begin
        // Analize Study Slides
//        SLSQLArch.Clear;
        SLSQLLink.Clear;
        SLStudyArch.Clear;
        SLStudyLink.Clear;
        SLStudy1.Clear;
        SLStudy2.Clear;
        SLCorLink.Clear;
        SLCorArch.Clear;
        SLStudyUNAItems.Clear;
        SLStudyUItems.Clear;
        SLStudyUAItems.Clear;

        for j := 0 to SLC - 1 do
        begin
          with SLA[j] do
          begin
            if StudyID = StudySID then
            begin
              WStr := IntToStr(SlideSID);
              SStudyItem := IntToStr(StudyItemID);
              if SLStudyUItems.IndexOf( SStudyItem ) < 0 then
                SLStudyUItems.Add(SStudyItem);
              if SlideDID = -1 then
              begin
//                SLSQLArch.Add( K_CMENDBSTFSlideID+'='+ WStr );
                SLStudyArch.AddObject( WStr, TObject(j) );
                if AMoveFlag and (SLStudyUAItems.IndexOf( SStudyItem ) < 0) then
                  SLStudyUAItems.Add(SStudyItem);
              end
              else
              begin
                if SLStudyUNAItems.IndexOf( SStudyItem ) < 0 then
                  SLStudyUNAItems.Add(SStudyItem);
                SLSQLLink.Add( K_CMENDBSTFSlideID+'='+ IntToStr(SlideDID) );
                SLStudyLink.AddObject( WStr, TObject(j) );
              end;
            end; // if StudyID = StudySID then
          end; // with SLA[j].SlideDID do
        end;  // for j = 0 to High(SLA) do

        K_CMEDAccess.TmpStrings.Clear;
        CorrectPositionsData( SLStudyLink, SLStudyArch, K_CMEDAccess.TmpStrings, SLCorLink, SLCorArch );

        if AMoveFlag and (SLCorArch.Count > 0) then
        begin // Correct Source Archived StudyItemPos
          SQLLinks := '';
          for j := 0 to SLCorArch.Count - 1 do
          begin
            WStr := IntToStr(SLA[Integer(SLCorArch.Objects[j])].SlideSID);
            if SQLLinks <> '' then
              SQLLinks := SQLLinks + ' or ' + K_CMENDBSTFSlideID+'='+ WStr
            else
              SQLLinks := K_CMENDBSTFSlideID+'='+ WStr
          end;

          with CurSQLCommand1 do
          begin
            CommandText :=
              'UPDATE ' + K_CMENDBSlidesTable +
              ' SET '   + K_CMENDBSTFSlideStudyItemPos + ' = 0' +
              ' WHERE ' + SQLLinks;
            Execute;
          end; // with CurSQLCommand1 do
        end; // if SLCorArch.Count > 0 then

        if SLCorLink.Count > 0 then
        begin // Correct Resulting StudyItemPos
          SQLLinks := '';
          for j := 0 to SLCorLink.Count - 1 do
          begin
            WStr := IntToStr(SLA[Integer(SLCorLink.Objects[j])].SlideDID);
            if SQLLinks <> '' then
              SQLLinks := SQLLinks + ' or ' + K_CMENDBSTFSlideID+'='+ WStr
            else
              SQLLinks := K_CMENDBSTFSlideID+'='+ WStr
          end;

          with CurSQLCommand1 do
          begin
            CommandText :=
              'UPDATE ' + K_CMENDBSlidesTable +
              ' SET '   + K_CMENDBSTFSlideStudyItemPos + ' = 0' +
              ' WHERE ' + SQLLinks;
            Execute;
          end; // with CurSQLCommand1 do
        end; // if SLCorArch.Count > 0 then

        // Set NewStudyID to Copied Objects
        if SLSQLLink.Count > 0 then
        begin
          SQLLinks := '';
          for j := 0 to SLSQLLink.Count - 1 do
          begin
            if SQLLinks <> '' then
              SQLLinks := SQLLinks + ' or ' + SLSQLLink[j]
            else
              SQLLinks := SLSQLLink[j]
          end;
          with CurSQLCommand1 do
          begin
          // Set Replace References to New Study in new Slides
            CommandText :=
              'UPDATE ' + K_CMENDBSlidesTable +
              ' SET '   + K_CMENDBSTFSlideStudyID + ' = ' + IntToStr(StudyDID) +
              ' WHERE ' + SQLLinks;
            Execute;
          end; // with CurSQLCommand1 do
        end; // if SLStudyLink.Count > 0 then

        // Save Studies Files
        DatePathSegm := K_CMSlideGetFileDatePathSegm( StudyDTCr );
        SStudySID := IntToStr(StudySID);
        StudySFName := SlidesImgRootFolder + SPatPath + DatePathSegm + K_CMStudyGetFileName( SStudySID );
        if not K_VFLoadStrings( SLStudy1, StudySFName ) then
        begin
          N_Dump1Str( format( 'DB>> EDAPatObjCopyMoveProcResume StudyFile is absent !!! >> %s',
                              [StudySFName] ) );
          Continue;
        end   // if not K_VFLoadStrings( SLStudy1, StudySFName )
        else
        begin // Copy Study resulting file and correct source file if needed
          Ind := SLStudy1.IndexOf('[Links]');
          if Ind = -1 then
          begin
            N_Dump1Str( format( 'DB>> EDAPatObjCopyMoveProcResume StudyFile is corrupted !!! >> %s',
                                [StudySFName] ) );
            Continue;
          end;
          // Clear Old Links
          for j := SLStudy1.Count - 1 downto Ind + 1 do
            SLStudy1.Delete(j);
          SLStudy2.AddStrings(SLStudy1);

          if AMoveFlag and (SLStudyArch.Count > 0) and (SLStudyLink.Count > 0) then
          begin // Correct Source Study Links
            //
            for j := 0 to SLStudyArch.Count - 1 do
            begin
              with SLA[Integer(SLStudyArch.Objects[j])] do
                SLStudy1.Add( format('%d=%d|%d',[SlideSID,StudyItemID,StudyPosCode]));
            end;
            if not K_VFSaveStrings( SLStudy1, StudySFName, K_DFCreateEncrypted ) then
            begin
              N_Dump1Str( format( 'DB>> EDAPatObjCopyMoveProcResume StudyFile save error !!! >> %s',
                                  [StudySFName] ) );
              Continue;
            end;
            N_Dump1Str( format( 'DB>> EDAPatObjCopyMoveProcResume rebuild StudyFile >> %s',
                                  [StudySFName] ) );
            if SLStudyUAItems.Count <> SLStudyUItems.Count then
            // Change Source Study Thumbnail
              RebuildStudyThumbnail( SStudySID, StudySampleID, SLStudyUAItems );
          end; // if (SLStudyArch.Count > 0) and (SLStudyLink > 0) then

          // Correct Source Study Links
          for j := 0 to SLStudyLink.Count - 1 do
          begin
            with SLA[Integer(SLStudyLink.Objects[j])] do
              SLStudy2.Add( format('%d=%d|%d',[SlideDID,StudyItemID,StudyPosCode]));
          end;
          SStudyDID := IntToStr(StudyDID);
          StudyDFName := SlidesImgRootFolder + DPatPath + DatePathSegm;
          if K_ForceDirPath( StudyDFName ) then
          begin
            StudyDFName :=  StudyDFName + K_CMStudyGetFileName( SStudyDID );
            if not K_VFSaveStrings( SLStudy2, StudyDFName, K_DFCreateEncrypted ) then
              N_Dump1Str( format( 'DB>> EDAPatObjCopyMoveProcResume StudyFile save error !!! >> %s',
                                  [StudyDFName] ) )
            else
              N_Dump1Str( format( 'DB>> EDAPatObjCopyMoveProcResume rebuild StudyFile >> %s',
                                  [StudyDFName] ) );
          end
          else
            N_Dump1Str( format( 'DB>> EDAPatObjCopyMoveProcResume StudyFile path force error !!! >> %s',
                                  [StudyDFName] ) );
          if SLStudyUNAItems.Count <> SLStudyUItems.Count then
          // Change Dest Study Thumbnail
            RebuildStudyThumbnail( SStudyDID, StudySampleID, SLStudyUNAItems );
        end; // if K_VFLoadStrings( SLStudy1, StudySFName )
      end; // with STA[i] do
    end; // for i := 0 to STL.Count - 1 do

//    SLSQLArch.Free;
    SLSQLLink.Free;
    SLStudyArch.Free;
    SLStudyLink.Free;
    SLStudy1.Free;
    SLStudy2.Free;
    SLCorLink.Free;
    SLCorArch.Free;
    SLStudyUNAItems.Free;
    SLStudyUItems.Free;
    SLStudyUAItems.Free;
  end; // procedure ProcessStudiesCopyLoop

  //***************************** CopyPatientFiles ***
  //
  procedure CopyPatientFiles( );
  var
    ErrCopyCode : Integer;
    i : Integer;
    SFName, DFName : string;
    PatSPath, PatDPath : string;
    DstImgFiles, DstVideoFiles, DstImg3DFiles : string;
    SlideSDBF : TN_CMSlideSDBF;
    SDiagn : string;
    SSlideID : string;
    SOldSLideID : string;
    DatePathSegm : string;
    AllCount     : Integer;
    FCount       : Integer;

    procedure CopyFile1();
    begin
      ErrCopyCode := K_CopyFile( SFName, DFName );
      if ErrCopyCode < 4 then
      begin
        if ErrCopyCode > 0 then
          N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy file "%s" to "%s" error=%d',
                              [SFName, DFName, ErrCopyCode] ) )
        else
        begin
//          Inc(SlidesCopyCount);
          Inc(FCount);
          N_Dump2Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy file "%s" to "%s"',
                              [SFName, DFName] ) )
        end
      end
      else
      begin
        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy file "%s" to "%s" error=%d',
                          [SFName, DFName, ErrCopyCode] ) );
        Result := -1;
        Inc(ErrFilesCount);
      end;
    end; // procedure CopyFile1()

  begin

    ////////////////////////
    // Copy All Files
    PatSPath := K_CMSlideGetPatientFilesPathSegm(PatSID);
    SrcImgFiles := SlidesImgRootFolder + PatSPath;
    SrcVideoFiles := SlidesMediaRootFolder + PatSPath;
    SrcImg3DFiles := SlidesImg3DRootFolder + PatSPath;
    PatDPath := K_CMSlideGetPatientFilesPathSegm(PatDID);
    DstImgFiles := SlidesImgRootFolder + PatDPath;
    DstVideoFiles := SlidesMediaRootFolder + PatDPath;
    DstImg3DFiles := SlidesImg3DRootFolder + PatDPath;

    with CurDSet1 do
    begin
      // Select all records from Locked Slides Table
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      SQL.Text := 'SELECT ' + K_CMENDBSTFSlideID + ',' +        //0
                              K_CMENDBSTFSlideDiagnoses + ',' + //1
                              K_CMENDBSTFSlideSysInfo + ',' +   //2
                              K_CMENDBSTFSlideDTCr + ',' +      //3
                              K_CMENDBSTFSlideStudyID +         //4
      ' FROM ' + K_CMENDBSlidesTable +
      ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatDID;
      Filtered := false;
      Open;
      SlidesCopyCount := 0;
      ErrFilesCount := 0;

      // Check Break Loop Mode
      BreakCount := -1;
      if BreakLoopMode > 0 then
      begin
        i := RecordCount;
        BreakCount := i shr 1;
        First();
        if ((i and 1) = 1) and (Random > 0.5) then
          BreakCount := BreakCount + 1;
      end;

      AllCount := 0;
      FCount := 0;
      while not Eof do
      begin
        SDiagn := FieldList[1].AsString;
        i := Length(SDiagn);
        if (i >= 10) and (SDiagn[i] = '>') and (SDiagn[i-9] = '<') then
        begin
          K_CMEDAGetSlideSysFieldsData( FieldList[2].AsString, @SlideSDBF); // SysInfo
          Inc(AllCount);
          if (BreakCount < 0) or (BreakCount > SlidesCopyCount) then
          begin
          // Slide DB record was copied - copy files
            ErrCopyCode := 0;
            SSlideID := FieldList[0].AsString;
            SOldSLideID := Trim( copy(SDiagn, i-8, 8 ) );
            DatePathSegm := K_CMSlideGetFileDatePathSegm( FieldList[3].AsDateTime );
            if cmsfIsImg3DObj in SlideSDBF.SFlags then
            begin
            // Copy Img3D
// 2020-07-28 add Capt3DDevObjName <> '' if SlideSDBF.Capt3DDevObjName = '' then
// 2020-09-25 add new condition for Dev3D objs
              if (SlideSDBF.Capt3DDevObjName = '') or (SlideSDBF.MediaFExt = '') then
              begin
                ErrCopyCode := 0;
                SFName := SrcImg3DFiles + DatePathSegm + K_CMSlideGetImg3DFolderName( SOldSLideID );
                DFName := DstImg3DFiles + DatePathSegm + K_CMSlideGetImg3DFolderName( SSlideID );
                if not K_CopyFolderFiles( SFName, DFName, '*.*', [K_cffOverwriteNewer] ) then
                begin
                  N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy folder "%s" error',
                              [DFName] ) );
                  Result := -1;
                  ErrCopyCode := 4;
                  Inc(ErrFilesCount);
                end
                else
                begin
{
                  Inc(SlidesCopyCount);
                  Edit;
                  FieldList[1].AsString := copy( SDiagn, 1, i-10 );
}
                  Inc(FCount);
                end
              end // if SlideSDBF.Capt3DDevObjName = '' then
//              else
//                FieldList[1].AsString := copy( SDiagn, 1, i-10 );
            end   // Img3D
            else
            begin //Video, Image or Study
              if cmsfIsMediaObj in SlideSDBF.SFlags then
              begin
              // Copy Video
                SFName := SrcVideoFiles + DatePathSegm + K_CMSlideGetMediaFileNamePref( SOldSLideID ) + SlideSDBF.MediaFExt;
                DFName := DstVideoFiles + DatePathSegm + K_CMSlideGetMediaFileNamePref( SSlideID ) + SlideSDBF.MediaFExt;
              end
              else
              begin // if Not Video
              // Copy Img or study
                if cmsfHasSrcImg in SlideSDBF.SFlags then
                begin
                  SFName := SrcImgFiles + DatePathSegm + K_CMSlideGetSrcImgFileName( SOldSLideID );
                  DFName := DstImgFiles + DatePathSegm + K_CMSlideGetSrcImgFileName( SSlideID );
                  CopyFile1();
                end;

                if FieldList[4].AsInteger < 0 then
                begin
                // Copy Study - if DB version >= 40 studies files are not copied (Studies has no < oldID> in diagn)
                  SFName := SrcImgFiles + DatePathSegm + K_CMStudyGetFileName( SOldSLideID );
                  DFName := DstImgFiles + DatePathSegm + K_CMStudyGetFileName( SSlideID );
                end
                else
                begin
                // Copy Cur Img
                  SFName := SrcImgFiles + DatePathSegm + K_CMSlideGetCurImgFileName( SOldSLideID );
                  DFName := DstImgFiles + DatePathSegm + K_CMSlideGetCurImgFileName( SSlideID );
                end;
              end; // if Not Video

              CopyFile1();
            end; // //Video, Image or Study

            if ErrCopyCode < 4 then
            begin
              Edit;
              FieldList[1].AsString := copy( SDiagn, 1, i-10 );
              Inc(SlidesCopyCount);
            end;

            // Copy Attrs File Name
            SFName := SrcImgFiles + DatePathSegm + K_CMSlideGetAttrsFileName( SOldSLideID );
            if FileExists( SFName ) then
            begin
              DFName := DstImgFiles + DatePathSegm + K_CMSlideGetAttrsFileName( SSlideID );
              CopyFile1();
            end;

          end; // if (BreakCount < 0) or (BreakCount < SlidesCopyCount) then
        end; // if (i >= 10) and (SDiagn[i] = '>') and (SDiagn[i-9] = '<') then

        Next();
      end; // while not Eof do
      if SlidesCopyCount > 0 then
        UpdateBatch;
      Close;
      N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> %d obj files and folders were copied ',
                              [FCount] ) );
      if BreakLoopMode > 0 then
      begin
        Result := -3;
        BreakMessage := format( '%d files should be copied later', [max(AllCount - SlidesCopyCount, 0)] );
        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> User Break %d of %d files were copied ',
                              [BreakCount,AllCount] ) );
      end;

    end; // with CurDSet1 do

  end; // procedure CopyPatientFiles

  //***************************** CopyPatientFilesForMove ***
  //
  procedure CopyPatientFilesForMove( );
  var
    SrcFPath : string;
    i : Integer;
    SFName, DFName : string;
    ErrCopyCode : Integer;
    PatSPath, PatDPath : string;
    DstImgFiles, DstVideoFiles, DstImg3DFiles : string;
    BPLength : Integer;
    BreakCount1 : Integer;
    VideoStartInd : Integer;
    Img3DStartInd : Integer;
    CopyCount : Integer;
    ImgFilePat : string;
  begin

    ////////////////////////
    // Copy All Files
    PatSPath := K_CMSlideGetPatientFilesPathSegm(PatSID);
    SrcFPath := SlidesImgRootFolder + PatSPath;
    TmpStrings.Clear;
    ImgFilePat := '?F_*.cm*';
    K_ScanFilesTree( SrcFPath, EDASelectDataFiles, ImgFilePat );

    ////////////////////////
    // Copy Image Files
    //
    SrcImgFiles := '';
    BreakMessage := '';
    if TmpStrings.Count > 0 then
    begin
      // Check Break Loop Mode
      BreakCount := TmpStrings.Count;
      if BreakLoopMode > 0 then
      begin
        BreakCount1 := BreakCount;
        BreakCount := BreakCount1 shr 1;
        if ((BreakCount1 and 1) = 1) and (Random > 0.5) then
          BreakCount := BreakCount + 1;
      end;

    // Copy Image Files
      SrcImgFiles := SrcFPath;
      PatDPath := K_CMSlideGetPatientFilesPathSegm(PatDID);
      DstImgFiles := SlidesImgRootFolder + PatDPath;
      N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy  from "%s" to "%s" %d files start',
                         [SrcImgFiles, DstImgFiles, TmpStrings.Count] ) );

    // Check Files Copy
      BPLength := Length(SrcFPath) + 1;
      CopyCount := 0;
      for i := 0 to BreakCount - 1 do
      begin
        SFName := TmpStrings[i];
        DFName := copy( SFName, BPLength, 1000 );
        N_Dump2Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy file "%s"', [DFName] ) );
        ErrCopyCode := K_CopyFile( SFName, DstImgFiles + DFName );
        if ErrCopyCode < 4 then
        begin
          Inc(CopyCount);
          if ErrCopyCode > 0 then
            N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy file "%s" error=%d',
                                [DFName, ErrCopyCode] ) );
          Continue;
        end;
        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy file "%s" error=%d',
                            [DFName, ErrCopyCode] ) );
        Result := -1;

      end; // for i := 0 to BreakCount - 1 do

      if BreakLoopMode > 0 then
      begin
        BreakMessage := format( '%d image files should be copyed later', [TmpStrings.Count - CopyCount] );
        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> User Break %d of %d Img files were copied',
                              [BreakCount,TmpStrings.Count] ) );
      end;
    end; // if TmpStrings.Count > 0 then

    ////////////////////////
    // Copy Video Files
    //
    VideoStartInd := TmpStrings.Count;
    SrcFPath := SlidesMediaRootFolder + PatSPath;
    K_ScanFilesTree( SrcFPath, EDASelectDataFiles, 'MF_*.*' );
    SrcVideoFiles := '';
    if TmpStrings.Count > VideoStartInd then
    begin
      // Check Break Loop Mode
      BreakCount := TmpStrings.Count;
      if BreakLoopMode > 0 then
      begin
        BreakCount1 := BreakCount;
        BreakCount := BreakCount1 shr 1;
        if ((BreakCount1 and 1) = 1) and (Random > 0.5) then
          BreakCount := BreakCount + 1;
      end;

      SrcVideoFiles := SrcFPath;
      if PatDPath = '' then
        PatDPath := K_CMSlideGetPatientFilesPathSegm(PatDID);
      DstVideoFiles := SlidesMediaRootFolder + PatDPath;

      N_Dump2Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy  from "%s" to "%s" %d files start',
                         [SrcVideoFiles, DstVideoFiles, TmpStrings.Count - VideoStartInd] ) );
      BPLength := Length(SrcVideoFiles) + 1;
      CopyCount := 0;
      for i := VideoStartInd to BreakCount - 1 do
      begin
        SFName := TmpStrings[i];
        DFName := copy( SFName, BPLength, 1000 );
        N_Dump2Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy file "%s"', [DFName] ) );
        ErrCopyCode := K_CopyFile( SFName, DstVideoFiles + DFName );
        if ErrCopyCode < 4 then
        begin
          Inc(CopyCount);
          if ErrCopyCode > 0 then
            N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy file "%s" error=%d',
                                [DFName, ErrCopyCode] ) );
          Continue;
        end;
        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy file "%s" error=%d',
                            [DFName, ErrCopyCode] ) );
        Result := -1;
      end;

      if BreakLoopMode > 0 then
      begin
        i := TmpStrings.Count - VideoStartInd;
        if BreakMessage <> '' then BreakMessage := BreakMessage + #13#10;
        BreakMessage := BreakMessage +
           format( '%d video files should be copyed later', [i - CopyCount] );
        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> User Break %d of %d Video files were copied',
                              [BreakCount - VideoStartInd,i] ) );
      end;
    end; // if TmpStrings.Count > i then

    ////////////////////////
    // Copy 3D Files
    //
    Img3DStartInd := TmpStrings.Count;
    SrcFPath := SlidesImg3DRootFolder + PatSPath;
    K_ScanFilesTree( SrcFPath, EDASelectDataFiles, '3F_*', TRUE );
    SrcImg3DFiles := '';
    if TmpStrings.Count > Img3DStartInd then
    begin
      // Check Break Loop Mode
      BreakCount := TmpStrings.Count;
      if BreakLoopMode > 0 then
      begin
        BreakCount1 := BreakCount;
        BreakCount := BreakCount1 shr 1;
        if ((BreakCount1 and 1) = 1) and (Random > 0.5) then
          BreakCount := BreakCount + 1;
      end;

      SrcImg3DFiles := SrcFPath;
      if PatDPath = '' then
        PatDPath := K_CMSlideGetPatientFilesPathSegm(PatDID);
      DstImg3DFiles := SlidesImg3DRootFolder + PatDPath;

      N_Dump2Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy  from "%s" to "%s" %d files start',
                         [SrcImg3DFiles, DstImg3DFiles, TmpStrings.Count - Img3DStartInd] ) );
      BPLength := Length(SrcImg3DFiles) + 1;
      CopyCount := 0;
      for i := Img3DStartInd to BreakCount - 1 do
      begin
        SFName := TmpStrings[i];
        DFName := copy( SFName, BPLength, 1000 );
        N_Dump2Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy folder "%s"', [DFName] ) );
        if not K_CopyFolderFiles( SFName, DstImg3DFiles + DFName, '*.*', [K_cffOverwriteNewer] ) then
        begin
          N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy folder "%s" error',
                    [DFName] ) );
          Result := -1;
        end
        else
        begin
          Inc(CopyCount);
          Continue;
        end;
      end;

      if BreakLoopMode > 0 then
      begin
        i := TmpStrings.Count - Img3DStartInd;
        if BreakMessage <> '' then BreakMessage := BreakMessage + #13#10;
        BreakMessage := BreakMessage +
           format( '%d 3D image objects files should be copyed later', [i - CopyCount] );
        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> User Break %d of %d Img3d files were copied',
                              [BreakCount - Img3DStartInd,i] ) );
      end;
    end; // if TmpStrings.Count > i then

    if BreakLoopMode > 0 then
      Result := -3;

  end; // procedure CopyPatientFilesForMove

  //***************************** DelSrcPatientFiles ***
  //
  procedure DelSrcPatientFiles( );
  var
    i : Integer;
    DFName : string;
    PatSPath : string;
    CurDeleteErrFlag : Boolean;
    DeleteErrCount : Integer;
    DeleteCount : Integer;
    ClearImgFoldersPath : string;
    ClearVideoFoldersPath : string;
    ClearImg3DFoldersPath : string;
    VideoSInd, Img3DSInd : Integer;
    SL : TstringList;
  begin

    //////////////////////////////
    // Delete Source Patient Files

//    if (SrcImgFiles = '') and (SrcVideoFiles = '') then
    PatSPath := K_CMSlideGetPatientFilesPathSegm(PatSID);
// 2019-02-03 Some problems on deletion
//    VideoSInd := 0;
//    Img3DSInd := 0;
//    if CMPStartState = Ord(K_cmpsFilesAreCopied) then
    begin
    // Resume Move from Last Phase - Prepare Source Files List
      TmpStrings.Clear;

      SrcImgFiles := SlidesImgRootFolder + PatSPath;
      K_ScanFilesTree( SrcImgFiles, EDASelectDataFiles, '?F_*.cm*' );
      VideoSInd := TmpStrings.Count;
      if VideoSInd = 0 then SrcImgFiles := '';

      SrcVideoFiles := SlidesMediaRootFolder + PatSPath;
      K_ScanFilesTree( SrcVideoFiles, EDASelectDataFiles, 'MF_*.*' );
      if VideoSInd = TmpStrings.Count then SrcVideoFiles := '';


      Img3DSind := TmpStrings.Count;
      SrcImg3DFiles := SlidesImg3DRootFolder + PatSPath;
      K_ScanFilesTree( SrcImg3DFiles, EDASelectDataFiles, '3F_*', TRUE );
      if Img3DSind = TmpStrings.Count then SrcImg3DFiles := '';

    end;
    ClearImgFoldersPath := SrcImgFiles;
    ClearVideoFoldersPath := SrcVideoFiles;
    ClearImg3DFoldersPath := SrcImg3DFiles;

// 2019-02-03 Some problems on deletion
//    if CMPStartState <> Ord(K_cmpsMoveIsStarted) then
    begin
      if ClearImgFoldersPath = '' then
        ClearImgFoldersPath := SlidesImgRootFolder + PatSPath;
      if ClearVideoFoldersPath = '' then
        ClearVideoFoldersPath := SlidesMediaRootFolder + PatSPath;
      if ClearImg3DFoldersPath = '' then
        ClearImg3DFoldersPath := SlidesImg3DRootFolder + PatSPath;
    end;

    N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Delete  from "%s" %d Image files, %d Video files, %d 3D Objects start',
                       [PatSPath, VideoSInd, Img3DSind - VideoSInd, TmpStrings.Count - Img3DSind] ) );
     // Check Break Loop Mode
    BreakCount := TmpStrings.Count;
    if BreakLoopMode > 0 then
    begin
      i := BreakCount;
      BreakCount := i shr 1;
      if ((i and 1) = 1) and (Random > 0.5) then
        BreakCount := BreakCount + 1;
    end;

    DeleteErrCount := 0;
    SL := TstringList.Create;
    while TRUE do
    begin
      DeleteCount := 0;
      for i := 0 to BreakCount - 1 do
      begin
        DFName := TmpStrings[i];
        if i < Img3DSind then
        // Image or Video
          CurDeleteErrFlag := not K_DeleteFile( DFName )
        else
        begin
        // Img3D
          SL.Clear;
          K_DeleteFolderFilesEx( DFName, SL );
          CurDeleteErrFlag := SL.Count > 0;
        end;

        if not CurDeleteErrFlag then
        begin
          Inc(DeleteCount);
          N_Dump2Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Delete "%s" RepCount=%d',
                    [DFName, DeleteErrCount] ) );
          Continue;
        end;

        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Delete  error "%s" RepCount=%d',
                    [DFName, DeleteErrCount] ) );
      end; // for i := 0 to BreakCount - 1 do

      if BreakLoopMode > 0 then
      begin
        Result := -3;
        BreakMessage := format( '%d objects files should be deleted later', [TmpStrings.Count - DeleteCount] );
        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> User Break %d of %d objects files were deleted',
                              [BreakCount,TmpStrings.Count] ) );
        break;
      end;

      if ClearImgFoldersPath <> '' then
        K_DeleteFolderFiles( ClearImgFoldersPath ); // for not used folders deletion
      if ClearVideoFoldersPath <> '' then
        K_DeleteFolderFiles( ClearVideoFoldersPath ); // for not used folders deletion
      if ClearImg3DFoldersPath <> '' then
        K_DeleteFolderFiles( ClearImg3DFoldersPath ); // for not used folders deletion

     // Check Deletion
      VideoSInd := 0;
      TmpStrings.Clear;
      if SrcImgFiles <> '' then
      begin
        K_ScanFilesTree( SrcImgFiles, EDASelectDataFiles, '?F_*.cm*' );
        VideoSInd := TmpStrings.Count;
        if VideoSInd = 0 then SrcImgFiles := '';
      end;

      if SrcVideoFiles <> '' then
      begin
        SrcVideoFiles := SlidesMediaRootFolder + PatSPath;
        K_ScanFilesTree( SrcVideoFiles, EDASelectDataFiles, 'MF_*.*' );
        if VideoSInd = TmpStrings.Count then SrcVideoFiles := '';
      end;

      Img3DSind := TmpStrings.Count;
      if SrcImg3DFiles <> '' then
      begin
        SrcImg3DFiles := SlidesImg3DRootFolder + PatSPath;
        K_ScanFilesTree( SrcImg3DFiles, EDASelectDataFiles, '3F_*', TRUE );
        if Img3DSind = TmpStrings.Count then SrcImg3DFiles := '';
      end;

      if TmpStrings.Count = 0 then break; // All done

      ClearImgFoldersPath := SrcImgFiles;
      ClearVideoFoldersPath := SrcVideoFiles;
      ClearImg3DFoldersPath := SrcImg3DFiles;

      BreakCount := TmpStrings.Count;

      Inc(DeleteErrCount);

      if DeleteErrCount < 5 then
      begin
        Sleep( 100 ); // wait a little
        Continue;
      end;

      Result := -2;
      Break;
    end; // while TRUE do
    SL.Free;

  end; // procedure DelSrcPatientFiles

  //***************************** SaveSlidesHistory ***
  //
  procedure SaveSlidesHistory( AHistCode : Integer );
  begin
  //////////////////////////////////
  // Save History Session Context
  //

    SavedCurSessionHistID := CurSessionHistID;
    SavedCurSessionHistStartTS := CurSessionHistStartTS;
//    SavedCurPatID := CurPatID;
//    CurPatID := PatDID;
    EDAAddSessionHistRecord( PatDID );

    EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                             Ord(K_shNCAStartSession) ) );
    EDASaveSlidesHistory( SQLStr, EDABuildHistActionCode(K_shATChange, AHistCode) );

    EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                     Ord(K_shNCAFinishSession) ) );
  //////////////////////////////////
  // Restore History Session Context
  //
//    CurPatID := SavedCurPatID;
    CurSessionHistID := SavedCurSessionHistID;
    CurSessionHistStartTS := SavedCurSessionHistStartTS;
  end; // procedure SaveSlidesHistory

  //***************************** ShowDebugDlg ***
  //
  function ShowDebugDlg( const AMessage : string ) : Integer;
  var
    DebugForm : TForm;
    i : Integer;
  begin
    DebugForm := K_CMPrepMessageDlg( format( AMessage, [SPatSID, SPatDID] ), mtInformation, [mbIgnore,mbCancel,mbAbort,mbRetry],
                                     'Debug Copy|Move' );
    for i := 0 to DebugForm.ControlCount - 1 do
    begin
      if not (DebugForm.Controls[i] is TButton) then Continue;
      with TButton(DebugForm.Controls[i]) do
      case ModalResult of
      mrIgnore : Caption := 'Continue';
      mrCancel : Caption := 'CancelDlg';
      mrAbort  : Caption := 'Break|Busy';
      mrRetry  : Caption := 'Break|Free';
      end;
    end;
    DebugForm.ShowModal();
    case DebugForm.ModalResult of
    mrIgnore: Result := 0;  // 'Continue'
    mrCancel: Result := 1;  // 'CancelDlg'
    mrAbort:  Result := -1; // 'Break|Busy'
    mrRetry:  Result := -2; // 'Break|Free'
    else
    Result := 0;
    end;
    DebugForm.Release();
  end;  // function ShowDebugDlg

  //***************************** FilesCopyMoveBreak ***
  //
  procedure FilesCopyMoveBreak();
  begin
   // Break the operation - clear
    with CurSQLCommand1 do
    begin
      CommandText :=
        'UPDATE ' + K_CMENDBACMPDataTable +
        ' SET '   + K_CMENDBACMPDataTFCMPActRTID + ' = 0' +
        ' WHERE ' + K_CMENDBACMPDataTFCMPActID + '=' + SCMPProcID;
      Execute;
    end;
    N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Files CopyMove is broken R=' + IntToStr(Result) );
  end; // procedure FilesCopyMoveBreak

begin

  // Prep Additional SQL condition
  AddSQLStr := '';
  if K_CMEDDBVersion >= 41 then
    AddSQLStr := ' AND NOT ' + K_CMENDBSTFSlideThumbnail + ' IS NULL';

  SLL := nil;
  STL := nil;

  Result := 0;
  try
   ///////////////////////////////////////
   // Get CopyMove State
    with CurDSet1 do
    begin
      // Select Copy/Move context from the first ActCopyMovePatData Table record
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SCMPProcID := IntToStr(ACMPProcID);
      SQL.Text := 'SELECT ' +
         K_CMENDBACMPDataTFCMPatSID + ',' +
         K_CMENDBACMPDataTFCMPatDID + ',' +
         K_CMENDBACMPDataTFCMPState +
      ' FROM ' + K_CMENDBACMPDataTable +
      ' WHERE ' + K_CMENDBACMPDataTFCMPActID + '=' + SCMPProcID;
      Filtered := false;
      Open;
      if RecordCount = 0 then
        raise Exception.Create( 'DB >> EDAPatObjCopyMoveProcResume wrong ID=' + SCMPProcID )
      else
      begin
        PatSID   := Fields[0].AsInteger;
        SPatSID  := Fields[0].AsString;

        PatDID   := Fields[1].AsInteger;
        SPatDID  := Fields[1].AsString;

        CMPState := Fields[2].AsInteger;
        N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> CopyMove from patient %s to %s State=%d',
                            [SPatSID, SPatDID, CMPState] ) );
      end;
      Close;
    end;

    SrcImgFiles := '';
    SrcVideoFiles := '';
    SkipDebugDlg := FALSE;
    CMPStartState := CMPState;
     /////////////////////////////
     // Process CopyMove Loop
Loop:

    BreakLoopMode := 0;
    if K_CMPShowDebugDlgFlag and not SkipDebugDlg then
    begin
      case CMPState of
      Ord(K_cmpsCopyIsStarted) : DebugMessage := 'Copy data from patient %s to %s. DB info copying will be done.';
      Ord(K_cmpsMoveIsStarted) : DebugMessage := 'Move data from patient %s to %s. DB info moving will be done.';
      Ord(K_cmpsDBDataIsCopied): DebugMessage := 'Copy data from patient %s to %s. Files copying will be done.';
      Ord(K_cmpsDBDataIsMoved) : DebugMessage := 'Move data from patient %s to %s. Files copying will be done.';
      Ord(K_cmpsFilesAreCopied): DebugMessage := 'Move data from patient %s to %s. Files deleting will be done.';
      end;

      i := ShowDebugDlg( DebugMessage );
      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume ShowDebugDlg Result=' + IntToStr(i) );

      case i of
       1: SkipDebugDlg := TRUE;
//      -1: begin Result := -3; goto LExit; end;
//      -2: begin FilesCopyMoveBreak(); goto LExit; end;
      -1: BreakLoopMode := 1;
      -2: BreakLoopMode := 2;
      end;
    end; // if K_CMPShowDebugDlgFlag and not SkipDebugDlg then


    case CMPState of

    Ord(K_cmpsCopyIsStarted):
    begin // Copy Src Patient Slides Records to Dest Patient
      case BreakLoopMode of
       1: begin Result := -3; goto LExit; end;
       2: begin FilesCopyMoveBreak(); goto LExit; end;
      end;
      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Copy DBData start' );

      SQLStr := '';

      if K_CMEDDBVersion >= 41 then
      begin
      /////////////////
      // New copy code
      //
        PrepareSlidesAndStudiesInfo();

        Result := SLC - SLAC + STC;
        if AShowResDlgFlag and // to skip dialog if auto repeat operation after crash
           (SLAC > 0)      and
           (mrOK <> K_CMShowMessageDlg(
        'The patient has archived object(s) which cannot be copied.'#13#10 +
        'To copy these objects they should be recovered from the archive first.'#13#10 +
        'If you''re willing to proceed without the archived object(s) please click "OK".'#13#10 +
        '                     Otherwise click "Cancel".',
           mtConfirmation, [mbOK,mbCancel] ) ) then
        begin
          Result := 0;
          goto LBreak;
        end;

        if (SLAC > 0) and (SLAC = SLC) then
          Result := 0; // to skip copy empty studies only

        FinalMessage := '';
        if AShowResDlgFlag and ((Result > 0) or (SLAC > 0)) then
          FinalMessage := format( '%d media objects and studies are copied, '#13#10 +
                                  '%d archived media objects are not copied', [Result,SLAC] );
        if Result > 0 then
        begin

          LANDBConnection.BeginTrans;

          if not K_CMEDAMSSQL then
            NextIDSQLStr := 'dba.NextSlideID.NEXTVAL'
          else
            NextIDSQLStr := 'NEXT VALUE FOR dba.NextSlideID';

          /////////////////////////////////////////////////////////////
          // Save SlideID in Diagn in Source Slides that will be copied
          with CurSQLCommand1 do
          begin
            CommandText :=
              'UPDATE ' + K_CMENDBSlidesTable +
              ' SET '   + K_CMENDBSTFSlideDiagnoses + ' = STRING(' + K_CMENDBSTFSlideDiagnoses + ',''<'',STR('+ K_CMENDBSTFSlideID + ',8),''>'')' +
              ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatSID + AddSQLStr;
            Execute;
          end; // with CurSQLCommand1 do
          // Save SlideID in Diagn in Source Slides that will be copied
          /////////////////////////////////////////////////////////////

          ////////////////////////////////
          // Get Max Slide ID
          with CurDSet1 do
          begin
            SQL.Text := 'SELECT ' + NextIDSQLStr;
            Filtered := false;
            Open;
            SMaxNewID := Fields[0].AsString;
            Close;
          end; // with CurDSet1 do
          // Get Max Slide ID
          ////////////////////////////////

          CopyFields1 := NextIDSQLStr + ' as ' + K_CMENDBSTFSlideID + ',' +
                         EDAGetSlideSelectFieldsStr( [K_sffAllFieldsForCopy] );
          with CurSQLCommand1 do
          begin
            //////////////////////////////////
            // Copy Source Slides and Studies
            CommandText :=
              'INSERT INTO ' + K_CMENDBSlidesTable + ' WITH AUTO NAME' +
              ' SELECT ' + CopyFields1 + ' FROM '   + K_CMENDBSlidesTable +
              ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatSID + AddSQLStr;
            Execute;
            // Copy Source Slides and Studies
            //////////////////////////////////

            ///////////////////////////////////////
            // Set Dest Patient ID in copied Slides and
            // remove archive restore info 
            CommandText :=
              'UPDATE ' + K_CMENDBSlidesTable +
              ' SET '   + K_CMENDBSTFPatID + ' = ' + SPatDID + ','
                        + K_CMENDBSTFSlideDTArch + ' = Date(' + K_CMENDBSTFSlideDTCr + ')' +
              ' WHERE ' + K_CMENDBSTFPatID + ' = ' + SPatSID +
              ' AND '   + K_CMENDBSTFSlideID + ' > ' + SMaxNewID;

            Execute;
            // Set Dest Patient ID in copied Slides
            ///////////////////////////////////////
          end;

          ClearSourceSlidesAndStudiesDB();

          FinishSlidesAndStudiesInfo();

          ProcessStudiesCopyLoop( FALSE );

          SaveSlidesHistory( Ord(K_shCACreate) );

          with CurSQLCommand1 do
          begin
         // Set new CopyMove State
            CMPState := Ord(K_cmpsDBDataIsCopied);
            CommandText :=
              'UPDATE ' + K_CMENDBACMPDataTable +
              ' SET '   + K_CMENDBACMPDataTFCMPState + ' = ' + IntToStr(CMPState) +
              ' WHERE ' + K_CMENDBACMPDataTFCMPActID + ' = ' + SCMPProcID;
            Execute;
          end; // with CurSQLCommand1 do

          LANDBConnection.CommitTrans;

          N_Dump1Str( format( 'DB >> EDAPatObjCopyMoveProcResume >> Copy DBData Fin Slides=%d Studies=%d', [SLC - SLAC, STC] ) );

          goto Loop;
        end // if Result > 0 then
        else
          N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Copy DBData nothing to do' );

        if FinalMessage <> '' then
          K_CMShowMessageDlg( FinalMessage, mtInformation );
      //
      // New copy code
      /////////////////
      end   // if K_CMEDDBVersion >= 41 then
      else
      begin // if K_CMEDDBVersion < 41 then
      /////////////////
      // Old copy code
      //
        with CurDSet1 do
        begin
          // Select all records from Locked Slides Table
          ExtDataErrorCode := K_eeDBSelect;
          Connection := LANDBConnection;

          SQL.Text := 'SELECT Count(*)' +
          ' FROM ' + K_CMENDBSlidesTable +
          ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatSID +
          ' AND '   + K_CMENDBSTFSlideStudyID + ' >= 0';
          Filtered := false;
          Open;
          SlidesCopyCount := Fields[0].AsInteger;
          Close;

        end; // with CurDSet1 do

        if SlidesCopyCount > 0 then
        begin
        /////////////////
        // Copy Slides
        //
          LANDBConnection.BeginTrans;

          CopyFields1 := EDAGetSlideSelectFieldsStr( [K_sffAllFieldsForCopy] );
          with CurSQLCommand1 do
          begin
         // Set new CopyMove State
            CommandText :=
              'INSERT INTO ' + K_CMENDBSlidesTable + ' WITH AUTO NAME' +
              ' SELECT ' + CopyFields1 + ' FROM '   + K_CMENDBSlidesTable +
              ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatSID +
              ' AND '   + K_CMENDBSTFSlideStudyID + ' >= 0';
            Execute;
          end; // with CurSQLCommand1 do

          with CurDSet1 do
          begin
            ExtDataErrorCode := K_eeDBSelect;
            Connection := LANDBConnection;
            SQL.Text := 'SELECT @@identity';
            Open;
            MaxID := FieldList.Fields[0].AsInteger;
            Close();
          end; // with CurDSet2 do

          SQLStr := K_CMENDBSTFSlideID + '=' + IntToStr(MaxID);
          for i := MaxID - 1 downto MaxID - SlidesCopyCount + 1 do
            SQLStr := SQLStr + ' or ' + K_CMENDBSTFSlideID + '=' + IntToStr(i);

          with CurSQLCommand1 do
          begin
         // Set Patient ID
            CommandText :=
              'UPDATE ' + K_CMENDBSlidesTable +
              ' SET '   + K_CMENDBSTFPatID + ' = ' + SPatDID +
              ' WHERE ' + K_CMENDBSTFSlideID + ' <= ' + IntToStr(MaxID) +
              ' AND '   + K_CMENDBSTFSlideID + ' >= ' + IntToStr(MaxID - SlidesCopyCount + 1);

            Execute;
          end; // with CurSQLCommand1 do
        //
        // Copy Slides
        /////////////////
        end; // if SlidesCopyCount > 0 then

        /////////////////////
        // Copy Studies Loop
        with CurDSet1 do
        begin
          // Select all records from Locked Slides Table
          ExtDataErrorCode := K_eeDBSelect;
          Connection := LANDBConnection;

          SCMPProcID := IntToStr(ACMPProcID);
          SQL.Text := 'SELECT ' + K_CMENDBSTFSlideID +
          ' FROM '  + K_CMENDBSlidesTable +
          ' WHERE ' + K_CMENDBSTFPatID + ' = ' + SPatSID +
          ' AND '   + K_CMENDBSTFSlideStudyID + ' < 0';
          Filtered := false;
          Open;

          Result := SlidesCopyCount;
          while not Eof do
          begin
            if not LANDBConnection.InTransaction then
              LANDBConnection.BeginTrans;

            SCurStudyID := FieldList.Fields[0].AsString;

            // Create new Study
            with CurSQLCommand1 do
            begin
              CommandText :=
                'INSERT INTO ' + K_CMENDBSlidesTable + ' WITH AUTO NAME' +
                ' SELECT ' + CopyFields1 + ' FROM '   + K_CMENDBSlidesTable +
                ' WHERE ' + K_CMENDBSTFSlideID + '=' + SCurStudyID;
              Execute;
            end; // with CurSQLCommand1 do

            // Get New Study ID
            with CurDSet2 do
            begin
              ExtDataErrorCode := K_eeDBSelect;
              Connection := LANDBConnection;
              SQL.Text := 'SELECT @@identity';
              Open;
              SNewStudyID := FieldList.Fields[0].AsString;
              Close();
            end; // with CurDSet2 do

            with CurSQLCommand1 do
            begin
           // Set Patient ID
              CommandText :=
                'UPDATE ' + K_CMENDBSlidesTable +
                ' SET '   + K_CMENDBSTFPatID   + ' = ' + SPatDID +
                ' WHERE ' + K_CMENDBSTFSlideID + ' = ' + SNewStudyID;

              Execute;
            end; // with CurSQLCommand1 do

            Inc(Result);

            if SQLStr <> '' then
              SQLStr := SQLStr + ' or ' + K_CMENDBSTFSlideID + '=' + SNewStudyID
            else
              SQLStr := K_CMENDBSTFSlideID + '=' + SNewStudyID;

            if SlidesCopyCount > 0 then
            begin
            // Set References to new Study

              with CurSQLCommand1 do
              begin
              // Set Replace References to New Study in new Slides
                CommandText :=
                  'UPDATE ' + K_CMENDBSlidesTable +
                  ' SET '   + K_CMENDBSTFSlideStudyID + ' = ' + SNewStudyID +
                  ' WHERE ' + K_CMENDBSTFPatID        + ' = ' + SPatDID +
                  ' AND '   + K_CMENDBSTFSlideStudyID + ' = ' + SCurStudyID;
                Execute;
              end; // with CurSQLCommand1 do
            end; // if SlidesCopyCount > 0 then

            Next();

          end; // while not Eof do
          Close;
        end; // with CurDSet1 do

        // Copy Studies Loop
        ////////////////////

        if Result > 0 then
        begin
          SaveSlidesHistory( Ord(K_shCACreate) );

          with CurSQLCommand1 do
          begin
         // Set new CopyMove State
            CMPState := Ord(K_cmpsDBDataIsCopied);
            CommandText :=
              'UPDATE ' + K_CMENDBACMPDataTable +
              ' SET '   + K_CMENDBACMPDataTFCMPState + ' = ' + IntToStr(CMPState) +
              ' WHERE ' + K_CMENDBACMPDataTFCMPActID + '=' + SCMPProcID;
            Execute;
          end; // with CurSQLCommand1 do

          LANDBConnection.CommitTrans;

          N_Dump2Str( 'DB >> EDAPatObjCopyMoveProcResume >> Copy DBData Fin' );
          goto Loop;
        end
        else
          N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Copy DBData nothing to do' );
      //
      // Old copy code
      /////////////////
      end; // if K_CMEDDBVersion < 41 then
    end; // end of Ord(K_cmpsCopyIsStarted)

    Ord(K_cmpsMoveIsStarted):
    begin // Move Src Patient Slides Records to Dest Patient
      case BreakLoopMode of
       1: begin Result := -3; goto LExit; end;
       2: begin FilesCopyMoveBreak(); goto LExit; end;
      end;

      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Move DBData start' );

      AddMoveSQLStr := '';
      if K_CMEDDBVersion >= 41 then
      begin
      /////////////////
      // New copy code
      //
        PrepareSlidesAndStudiesInfo();

        if (SLAC > 0) then
        begin // If some Slides are archived
          if STC > 0 then
          begin
            if AShowResDlgFlag then
              K_CMShowMessageDlg(
          'The Move is not possible because the patient has both archived objects and studies.'#13#10 +
          'To Move archived objects they should be recovered from the archive first.'#13#10 +
          'You can also proceed later without archived objects if you select Copy and'#13#10 +
          'delete the source patient objects manually. Please click "OK" to stop moving.',
             mtWarning );
BreakMove: //*****
            N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Move DBData is stoped' );
            Result := 0;
            goto LBreak;
          end
          else
          if AShowResDlgFlag and (mrOK <> K_CMShowMessageDlg(
        'The patient has archived object(s) which cannot be moved.'#13#10 +
        'To Move these objects they should be recovered from the archive first.'#13#10 +
        'If you''re willing to proceed without the archived object(s) please click "OK".'#13#10 +
        '                        Otherwise click "Cancel".',
           mtConfirmation, [mbOK,mbCancel] ) ) then
            goto BreakMove;
        end; // if (SLAC > 0) then

        FinalMessage := '';
        if AShowResDlgFlag and ((SLC - SLAC > 0) or (SLAC > 0)) then
          FinalMessage := format( '%d media objects are moved, '#13#10 +
                                  '%d archived media objects are not moved', [SLC - SLAC,SLAC] );
        AddMoveSQLStr := ',' + K_CMENDBSTFSlideDTArch + ' = Date(' + K_CMENDBSTFSlideDTCr + ')';
      //
      // New copy code
      /////////////////
      end; // if K_CMEDDBVersion >= 41 then

      //////////////////////////
      // Common Move DBData code
      //
      with CurDSet1 do
      begin
        // Select all records from Locked Slides Table
        ExtDataErrorCode := K_eeDBSelect;
        Connection := LANDBConnection;
{
        SQL.Text := 'SELECT Count(*)' +
        ' FROM ' + K_CMENDBSlidesTable +
        ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatSID;
        Filtered := false;
        Open;
        Result := Fields[0].AsInteger;
        Close;
}
        SQL.Text := 'SELECT ' + K_CMENDBSTFSlideID +
        ' FROM ' + K_CMENDBSlidesTable +
        ' WHERE ' + K_CMENDBSTFPatID + '=' + SPatSID + AddSQLStr;
        Filtered := false;
        Open;
        Result := 0;
        SQLStr := '';
        while not Eof do
        begin
          if SQLStr <> '' then
            SQLStr := SQLStr + ' or ' + K_CMENDBSTFSlideID + '=' + Fields[0].AsString
          else
            SQLStr := K_CMENDBSTFSlideID + '=' + Fields[0].AsString;
          Inc(Result);
          Next();
        end;
        Close;

      end; // with CurDSet1 do

      if Result > 0 then
      begin
        LANDBConnection.BeginTrans;

        SaveSlidesHistory( Ord(K_shCAPat) );

        with CurSQLCommand1 do
        begin
        // Change Patient and remove archive restore info
          CommandText :=
            'UPDATE ' + K_CMENDBSlidesTable +
            ' SET '   + K_CMENDBSTFPatID + ' = ' + SPatDID +
            AddMoveSQLStr +
            ' WHERE ' + K_CMENDBSTFPatID + ' = ' + SPatSID + AddSQLStr;
          Execute;

       // Set new CopyMove State
          CMPState := Ord(K_cmpsDBDataIsMoved);
          CommandText :=
            'UPDATE ' + K_CMENDBACMPDataTable +
            ' SET '   + K_CMENDBACMPDataTFCMPState + ' = ' + IntToStr(CMPState) +
            ' WHERE ' + K_CMENDBACMPDataTFCMPActID + '=' + SCMPProcID;
          Execute;
          N_Dump2Str( 'DB >> EDAPatObjCopyMoveProcResume >> Move DBData ' );
        end;
        LANDBConnection.CommitTrans;
        N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Move DBData fin Count=' + IntToStr(Result) );
        goto Loop;
      end
      else
        N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Move DBData Nothing to do' );
      //
      // Common Move DBData code
      //////////////////////////
      if FinalMessage <> '' then
        K_CMShowMessageDlg( FinalMessage, mtInformation );

    end; // end of Ord(K_cmpsMoveIsStarted)

    Ord(K_cmpsDBDataIsCopied):
    begin // Copy Src Patient Files to Dest Patient for Copy
      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Copy Files start' );
      LANDBConnection.BeginTrans;
      CopyPatientFiles( );

      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Copy Files Result=' + IntToStr(Result) );
      if Result < 0 then
      begin
        if (Result <> -3) or (BreakLoopMode = 2) then
          FilesCopyMoveBreak();
        LANDBConnection.CommitTrans;
        if (FinalMessage <> '') and (Result = -1) then
        begin
//          FinalMessage := FinalMessage + format( #13#10'%d files and folders are not copied', [ErrFilesCount] );
          FinalMessage := FinalMessage + #13#10 +
               'Not all needed files and folders were copied.' + #13#10 +
               'All needed files and folders will be copied later automaticaly.';
          K_CMShowMessageDlg( FinalMessage, mtInformation );
        end
        else
        if Result = -3 then
          K_CMShowMessageDlg( BreakMessage, mtInformation );
        goto LExit;
      end; // if Result < 0 then

      if FinalMessage <> '' then
        K_CMShowMessageDlg( FinalMessage, mtInformation );
      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Copy Files fin' );
    end; // end of Ord(K_cmpsDBDataIsCopied)

    Ord(K_cmpsDBDataIsMoved):
    begin // Copy Src Patient Files to Dest Patient for Move
      N_Dump2Str( 'DB >> EDAPatObjCopyMoveProcResume >> Move Files Copy start' );
      CopyPatientFilesForMove( );

      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Copy for Move Files Result=' + IntToStr(Result) );
      if Result < 0 then
      begin
        if (Result <> -3) or (BreakLoopMode = 2) then
          FilesCopyMoveBreak();
        if (FinalMessage <> '') and (Result = -1) then
        begin
//          FinalMessage := FinalMessage + format( #13#10'%d files and folders are not copied', [ErrFilesCount] );
          FinalMessage := FinalMessage + #13#10 +
               'Not all needed files and folders were copied.' + #13#10 +
               'All needed files and folders will be copied automaticaly later.';
          K_CMShowMessageDlg( FinalMessage, mtInformation );
        end
        else
        if Result = -3 then
          K_CMShowMessageDlg( BreakMessage, mtInformation );
        goto LExit;
      end; // if Result < 0 then

      // if continue interrupted then try delete step even if no files are copied
      // else try delete step only if Img or Video were copied
      if (CMPStartState = Ord(K_cmpsDBDataIsMoved)) or
         (SrcImgFiles <> '') or
         (SrcVideoFiles <> '') or
         (SrcImg3DFiles <> '') then
      begin
       // Set new CopyMove State
        with CurSQLCommand1 do
        begin
          CMPState := Ord(K_cmpsFilesAreCopied);
          CommandText :=
            'UPDATE ' + K_CMENDBACMPDataTable +
            ' SET '   + K_CMENDBACMPDataTFCMPState + ' = ' + IntToStr(CMPState) +
            ' WHERE ' + K_CMENDBACMPDataTFCMPActID + '=' + SCMPProcID;
          Execute;
        end;
        N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Move Files Copy fin' );
        goto Loop;
      end; // if (CMPStartState = K_cmpsDBDataIsMoved) or (SrcImgFiles <> '') or (SrcVideoFiles <> '')
    end; // end of Ord(K_cmpsDBDataIsMoved)

    Ord(K_cmpsFilesAreCopied):
    begin // Delete Src Patient Files
      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Move Files Delete start' );
      DelSrcPatientFiles( );

      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Delete Files Result=' + IntToStr(Result) );
      if Result < 0 then
      begin
        if (Result <> -3) or (BreakLoopMode = 2) then
          FilesCopyMoveBreak();
        if (FinalMessage <> '') and (Result = -2) then
        begin
//          FinalMessage := FinalMessage + format( #13#10'%d files and folders are not copied', [ErrFilesCount] );
          FinalMessage := FinalMessage + #13#10 +
               'Not all needed files and folders were deleted.' + #13#10 +
               'All needed files and folders will be deleted later automaticaly.';
          K_CMShowMessageDlg( FinalMessage, mtWarning );
        end
        else
        if Result = -3 then
          K_CMShowMessageDlg( BreakMessage, mtInformation );
        goto LExit;
      end; // if Result < 0 then

      if FinalMessage <> '' then
        K_CMShowMessageDlg( FinalMessage, mtInformation );

      N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> Move Files Delete fin' );
    end; // end of  Ord(K_cmpsFilesAreCopied)

    else
      raise Exception.Create( 'DB >> EDAPatObjCopyMoveProcResume wrong CopyMoveState' + IntToStr(CMPState) );
    end; // case CMPState of

LBreak: //********
   // All done Remove CopyMove Record
    with CurSQLCommand1 do
    begin
      CommandText :=
        'DELETE ' + K_CMENDBACMPDataTable +
        ' WHERE ' + K_CMENDBACMPDataTFCMPActID + '=' + SCMPProcID;
      Execute;
    end;
    if LANDBConnection.InTransaction then
      LANDBConnection.CommitTrans;

    if K_CMPShowDebugDlgFlag and not SkipDebugDlg then
    begin
      DebugMessage := 'Move data from patient %s to %s is finished';
      if CMPState = Ord(K_cmpsDBDataIsCopied) then
        DebugMessage := 'Copy data from patient %s to %s is finished';
      K_CMShowMessageDlg( format( DebugMessage, [SPatSID, SPatDID] ), mtInformation );
    end;
    N_Dump1Str( 'DB >> EDAPatObjCopyMoveProcResume >> All done R=' + IntToStr(Result) );

LExit: // Exit
  SLL.Free;
  STL.Free;

  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAPatObjCopyMoveProcResume ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := -1;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAPatObjCopyMoveProcResume

//********************** TK_CMEDDBAccess.EDAPatObjCopyMoveProcGet ***
// Get Copy/Move Patient Slides procedure
//
//     Parameters
// ACMPProcID - resulting Copy/Move record ID, or 0 if proper Copy/Move
//              is not found
// APatID     - patient ID used in selecting CopyMove, if =0 then select with any patient
// AMode      - select and lock CopyMove records mode:
//#F
//  =0 - select and lock first uncompleted CopyMove
//  =1 - select first executed CopyMove
//  =2 - select any CopyMove
//#/F
// Result - Returns operation resulting code
//
function  TK_CMEDDBAccess.EDAPatObjCopyMoveProcGet( out ACMPProcID : Integer;
                  APatID : Integer; AMode : Integer ): TK_CMEDResult;
var
  SQLWHERE : string;
  SPatID : string;
  SCMPProcID : string;
begin

  Result := K_edOK;
  try
    N_Dump2Str( 'DB >> EDAPatObjCopyMoveProcGet start Mode=' + IntToStr(AMode) );
   ///////////////////////////////////////
   // Get CopyMove procedure
    while TRUE do
    begin
      ACMPProcID := 0;
      with CurDSet2 do
      begin
        ExtDataErrorCode := K_eeDBSelect;
        Connection := LANDBConnection;

        SQLWHERE := '';
        case AMode of
        0:  SQLWHERE := ' WHERE ' + K_CMENDBACMPDataTFCMPActRTID + '= 0';
        1:  SQLWHERE := ' WHERE ' + K_CMENDBACMPDataTFCMPActRTID + '<> 0';
        else
          if APatID <> 0 then
            SQLWHERE := ' WHERE ';
        end;

        if APatID <> 0 then
        begin
          SPatID := IntToSTr( APatID );
          if SQLWHERE <> ' WHERE ' then
            SQLWHERE := SQLWHERE + ' AND ';
          SQLWHERE := SQLWHERE +
                     '(' + K_CMENDBACMPDataTFCMPatSID + '=' + SPatID +
                     ' OR ' + K_CMENDBACMPDataTFCMPatDID + '=' + SPatID + ')';
        end;

        SQL.Text := 'SELECT ' + K_CMENDBACMPDataTFCMPActID +
        ' FROM ' + K_CMENDBACMPDataTable + SQLWHERE;
        Filtered := false;
        Open;

        if RecordCount > 0 then
          ACMPProcID := Fields[0].AsInteger;
        Close;

        SCMPProcID := IntToStr(ACMPProcID);

        if (ACMPProcID = 0) or (AMode <> 0) then break;

        SQLWHERE := K_CMENDBACMPDataTFCMPActID + '=' + SCMPProcID;

        // try to lock uncompleted CopyMove
        with CurSQLCommand1 do
        begin
          CommandText :=
            'UPDATE ' + K_CMENDBACMPDataTable +
            ' SET '   + K_CMENDBACMPDataTFCMPActRTID + ' = ' + IntToStr(AppRTID) +
            ' WHERE ' + K_CMENDBACMPDataTFCMPActRTID + '= 0' +
            ' AND '   + SQLWHERE;
          Execute;
        end;

        // check if lock is success
        SQL.Text := 'SELECT ' + K_CMENDBACMPDataTFCMPActRTID +
        ' FROM ' + K_CMENDBACMPDataTable +
        ' WHERE ' + SQLWHERE;
        Filtered := false;
        Open;
        if (RecordCount = 0) or (Fields[0].AsInteger <> AppRTID) then
          ACMPProcID := 0;
        Close;
        if ACMPProcID <> 0 then break; // Lock is Success

      end; // with CurDSet2 do
    end; // while TRUE do

    N_Dump2Str( 'DB >> EDAPatObjCopyMoveProcGet fin CMPID=' + SCMPProcID );
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAPatObjCopyMoveProcGet ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAPatObjCopyMoveProcGet

//***************************** TK_CMEDDBAccess.EDAPatObjCopyMoveProcLaunch ***
// Launch Copy/Move Patient Slides procedure
//
//     Parameters
// ACMPProcID   - resulting launched Copy/Move record ID or problem Code:
//                >0  - =launched Copy/Move record ID
//                =-1 - Src or Dst Patients are used by some active CMS
//                =-2 - Src or Dst Patients are used by some CopyMove proc
// ACMPatSrc    - source patient ID
// ACMPatDst    - destination patient ID
// ACMPMoveMode - if =TRUE then Move procedures should be lanch, Copy else.
// Result - Returns operation resulting code
//
function  TK_CMEDDBAccess.EDAPatObjCopyMoveProcLaunch( out ACMPProcID : Integer;
                ACMPatSrc, ACMPatDst : Integer; ACMPMoveMode : Boolean ) : TK_CMEDResult;
var
  DeadlockCount : Integer;
{
  SPatSID, SPatDID :  string;
  State : TK_CMPatObjCMPState;

label LExit;
}
label DeadlockLoop;
begin

  Result := K_edOK;
  DeadlockCount := 0;
DeadlockLoop: //******

  try

    N_Dump2Str( 'DB >> EDAPatObjCopyMoveProcLaunch start' );

    LANDBConnection.BeginTrans;
    with CurSQLCommand1 do
    begin
      // Lock Active Instance Table in exclusive mode
      Connection := LANDBConnection;
      CommandText := EDADBIsolationLevelSet(K_tilSerializable);
      Execute;
    end;

    ACMPProcID := 0;
    with CurStoredProc1 do
    begin
      Connection := LANDBConnection;

      // Exec Procedure
      // cms_PatObjCopyMoveTaskPrep"( in @SrcPatID integer, in @DstPatID integer,
      //                     in @TaskState integer, in @InstRTID integer, out @RCode integer )
      ProcedureName := 'dba.cms_PatObjCopyMoveTaskPrep';
      Parameters.Clear;
      with Parameters.AddParameter do
      begin
        Name := '@SrcPatID';
        Direction := pdInput;
        DataType := ftInteger;
        Value := ACMPatSrc;
      end;
      with Parameters.AddParameter do
      begin
        Name := '@DstPatID';
        Direction := pdInput;
        DataType := ftInteger;
        Value := ACMPatDst;
      end;
      with Parameters.AddParameter do
      begin
        Name := '@TaskState';
        Direction := pdInput;
        DataType := ftInteger;
        if ACMPMoveMode then
          Value := Ord(K_cmpsMoveIsStarted)
        else
          Value := Ord(K_cmpsCopyIsStarted);
      end;
      with Parameters.AddParameter do
      begin
        Name := '@InstRTID';
        Direction := pdInput;
        DataType := ftInteger;
        Value := AppRTID;
      end;
      with Parameters.AddParameter do
      begin
        Name := '@RCode';
        Direction := pdOutput;
        DataType := ftInteger;
        ExecProc;
        ACMPProcID := Value;
      end; // with Parameters.AddParameter do
    end; // with CurStoredProc1 do

    LANDBConnection.CommitTrans(); // Suggested by Lopatin always use CommitTrans instead of Rollback
    with CurSQLCommand1 do
    begin
      CommandText := EDADBIsolationLevelDefault();
      Execute;
    end;

{
    LANDBConnection.BeginTrans;
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
      CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end; // with CurSQLCommand1 do

    SPatSID := IntToStr(ACMPatSrc);
    SPatDID := IntToStr(ACMPatDst);
    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;
      SQL.Text := 'select ' + K_CMENDBAAInstsTFActRTID +
        ' from ' + K_CMENDBAAInstsTable +
        ' where ' + K_CMENDBAAInstsTFPatID + '=' + SPatSID +
        ' or '    + K_CMENDBAAInstsTFPatID + '=' + SPatDID;
      Filtered := false;
      Open;
      if RecordCount > 0 then ACMPProcID := -1;
      Close();
      if ACMPProcID = -1 then goto LExit;


      SQL.Text := 'SELECT ' + K_CMENDBACMPDataTFCMPActID +
      ' FROM ' + K_CMENDBACMPDataTable +
      ' WHERE ' + K_CMENDBACMPDataTFCMPatSID + '=' + SPatSID +
      ' OR '   + K_CMENDBACMPDataTFCMPatSID + '=' + SPatDID +
      ' OR '   + K_CMENDBACMPDataTFCMPatDID + '=' + SPatSID +
      ' OR '   + K_CMENDBACMPDataTFCMPatDID + '=' + SPatDID;
      Filtered := false;
      Open;
      if RecordCount > 0 then ACMPProcID := -2;
      Close();
      if ACMPProcID = -2 then goto LExit;
    end;

    // Add new CopyMove record
    State := K_cmpsCopyIsStarted;
    if ACMPMoveMode then
      State := K_cmpsMoveIsStarted;
    with CurSQLCommand1 do
    begin
      CommandText := 'INSERT INTO ' + K_CMENDBACMPDataTable +
              ' ( ' + K_CMENDBACMPDataTFCMPatSID + ',' +
                      K_CMENDBACMPDataTFCMPatDID + ',' +
                      K_CMENDBACMPDataTFCMPState + ',' +
                      K_CMENDBACMPDataTFCMPActRTID + ')' +
              ' VALUES (' + SPatSID + ',' + SPatDID + ',' +
                            IntToStr(Ord(State)) + ',' + IntToStr(AppRTID) + ')';
      Execute;
    end; // with CurSQLCommand1 do

    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      SQL.Text := 'SELECT @@identity';
      Open;
      ACMPProcID := Fields[0].AsInteger;
      Close();
    end; // with CurDSet2 do
LExit:
    LANDBConnection.CommitTrans;
}
    N_Dump2Str( 'DB >> EDAPatObjCopyMoveProcLaunch fin CMPID=' +
                                                 IntToStr(ACMPProcID) );
  except
    on E: Exception do
    begin
      ExtDataErrorString := E.Message;
      if (Pos( 'eadlock', E.Message ) = 0) or (DeadlockCount > 100) then
      begin
        ExtDataErrorString := 'EDAPatObjCopyMoveProcGet ' + ExtDataErrorString;
        Result := K_edExDataError;
        EDAShowErrMessage(TRUE);
      end
      else
        Inc(DeadlockCount);
    end;
  end; // Try/Except

  if not LANDBConnection.InTransaction then Exit;
  N_Dump1Str( format( 'DB>> EDAPatObjCopyMoveProcGet E.Count=%d >> %s',
                      [DeadlockCount,ExtDataErrorString] ) );
  LANDBConnection.RollbackTrans;
  sleep(100);
  goto DeadlockLoop;
end; // end of TK_CMEDDBAccess.EDAPatObjCopyMoveProcLaunch

//********************************************* TK_CMEDDBAccess.EDACheckAllFilesAccess ***
// Check All Images and/or Video Files Access
//
//     Parameters
// AFImgCheck   - if = TRUE then check Images files access
// AFVideoCheck - if = TRUE then check Video files access
// AFImg3DCheck - if = TRUE then check Img3D files access
// AddWarnStr2  - aditional warning string to 2-d dialog if problem will not be resolved
// AddWarnStr1  - aditional warning string to 1-st dialog when problem was detected
// AMDButtons   - set of Message Dialog buttons
// AMDResult    - Message Dialog OK result corresponding to AMDButtons
// Result       - Returns code:
//#F
//  -4 - first dialog returns Cancel and problem with access to 3D Images files folder
//  -3 - first dialog returns Cancel and problem with access to Images and Video files folder
//  -2 - first dialog returns Cancel and problem with access to Video files folder
//  -1 - first dialog returns Cancel and problem with access to Images files folder
//   0 - no problems with access to folders
//   1 - problem with access to Images files folder
//   2 - problem with access to Video files folder
//   3 - problem with access to Images and Video files folder
//   4 - problem with access to 3D Images files folder
//#/F
//
function  TK_CMEDDBAccess.EDACheckAllFilesAccess( AFImgCheck: Boolean;
                                                  AFVideoCheck: Boolean;
                                                  AFImg3DCheck: Boolean;
                                                  const AddWarnStr2 : string;
                                                  const AddWarnStr1 : string = '';
                                                  AMDButtons : TMsgDlgButtons = [];
                                                  AMDResult : word = mrOk ): Integer;
var
//  WStr1, WStr2, WStr3, WStr4, ErrText: string;
  Res : word;
  WMes : string;
  WStr3 : string;
begin

  Result := 0;
  if AFImgCheck and
     (EDACheckFilesFolderAccess( SlidesImgRootFolder, SlidesImgRootFDA ) <> 0) then
  begin
    Result := 1;
  end else
    AFImgCheck := FALSE;

  if (Result = 0) and
     AFImg3DCheck and
     (EDACheckFilesFolderAccess( SlidesImg3DRootFolder, TRUE ) <> 0) then
  begin
    Result := 4;
  end else
    AFImg3DCheck := FALSE;


  // Check Video Folder

  if (K_CMMediaFilesStoringMode <> 0) and
     AFVideoCheck                     and
     (EDACheckFilesFolderAccess( SlidesMediaRootFolder, SlidesMediaRootFDA ) <> 0) then
  begin
    if Result = 4 then
      Result := 1;
    Result := Result + 2;
  end else
    AFVideoCheck := FALSE;

  if Result = 0 then Exit;

// Some access problems was detected
  WStr3 := '';
  if AddWarnStr1 = '' then
    WStr3 := '                ';

  case Result of
  1: WMes := K_CML1Form.LLLFileAccessCheck1.Caption;
//'           There is a problem to access the Images folder.'#13#10 +
//'Please check network connection and permission to access this folder.'#13#10 +
//'%sPress OK when ready to continue.%s';
  2: WMes := K_CML1Form.LLLFileAccessCheck2.Caption;
//'           There is a problem to access the Video folder.'#13#10 +
//'Please check network connection and permission to access this folder.'#13#10 +
//'%sPress OK when ready to continue.%s';
  3: WMes := K_CML1Form.LLLFileAccessCheck3.Caption;
//'           There is a problem to access the Image and Video folders.'#13#10 +
//'Please check network connection and permission to access these folders.'#13#10 +
//'%sPress OK when ready to continue.%s';
  4: WMes := K_CML1Form.LLLFileAccessCheck31.Caption;
//'           There is a problem to access the 3D Images folder.'#13#10 +
//'Please check network connection and permission to access this folder.'#13#10 +
//'%sPress OK when ready to continue.%s';
  end;

  Res := K_CMShowMessageDlg1(  format( WMes, [WStr3,AddWarnStr1] ),
//    '           There is a problem to access the ' + ErrText + WStr1 + '.'#13#10 +
//    'Please check network connection and permission to access' + WStr4 + WStr1 + '.'#13#10 +
//    WStr3 + 'Press OK when ready to continue.' + AddWarnStr1,
      mtWarning, [mbOK,mbCancel] );
  if Res <> mrOK then
  begin
    Result := - Result;
    Exit;
  end;

  if AddWarnStr2 = '' then Exit; // Second Dialog is not needed

  Result := 0;
  if AFImgCheck and
     (EDACheckFilesFolderAccess( SlidesImgRootFolder, SlidesImgRootFDA ) <> 0) then
  begin
    Result := 1;
  end;

  if (Result = 0) and
     AFImg3DCheck and
     (EDACheckFilesFolderAccess( SlidesImg3DRootFolder, TRUE ) <> 0) then
  begin
    Result := 4;
  end;


  if (K_CMMediaFilesStoringMode <> 0) and
     AFVideoCheck                     and
     (EDACheckFilesFolderAccess( SlidesMediaRootFolder, SlidesMediaRootFDA ) <> 0) then
  begin
    if Result = 4 then
      Result := 1;
    Result := Result + 2;
  end;

  if Result <> 0 then
  begin

    case Result of
    1: WMes := K_CML1Form.LLLFileAccessCheck4.Caption;
  //'The Images folder is still not accessible.%s';
    2: WMes := K_CML1Form.LLLFileAccessCheck5.Caption;
  //'The Video folder is still not accessible.%s';
    3: WMes := K_CML1Form.LLLFileAccessCheck6.Caption;
  //'The Images and Video folders are still not accessible.%s';
    4: WMes := K_CML1Form.LLLFileAccessCheck34.Caption;
  //'The 3D Images folder is still not accessible.%s';
    end;

    if AMDButtons = [] then
      AMDButtons := [mbOK];

    Res := K_CMShowMessageDlg1( format( WMes, [AddWarnStr2] ),
//      'The ' + ErrText + WStr1 + WStr2 + ' still not accessible.' + AddWarnStr2,
       mtWarning, AMDButtons );

    if (AMDButtons <> [mbOK]) and (Res <> AMDResult) then
    begin
      Result := - Result;
      Exit;
    end;

  end;

end; // function TK_CMEDDBAccess.EDACheckAllFilesAccess

//*********************************** TK_CMEDDBAccess.EDAGetSlidesFilesInfo ***
// Get Slides Files Info
//
//     Parameters
// AFilesPath  - Files Path
// AFilesCount - Files total number
// AFilesSize  - Files total size
// AFilesDA - Files Direct Access
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetSlidesFilesInfo( out AFilesPath: string;
                       out AFilesCount: Integer; out AFilesSize: Int64;
                       out AFilesDA: Boolean ): TK_CMEDResult;
var
  SDBF: TN_CMSlideSDBF;
  AddSelect: string;
begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>> EDAGetSlidesFilesInfo');
  try
    AddSelect := '';
    if SlidesCRFC.MediaFCopy then
    begin
      AFilesPath := SlidesMediaRootFolder;
      AFilesDA := SlidesMediaRootFDA;
      if SlidesCRFC.MovingFSDDescr > 0 then
      begin
        AddSelect := ' where ' + K_CMENDBSTFSlideCompCr + '=''' +
          K_CMSServerClientInfo.CMSClientVirtualName + '''';
        if (SlidesCRFC.MovingFSDDescr and 1) = 1 then
        begin
          // Copy from Client
          AFilesPath := SlidesClientMediaRootFolder;
          AFilesDA := TRUE;
        end;
      end;
    end
    else
    if SlidesCRFC.Img3DFCopy then
    begin
      AFilesPath := SlidesImg3DRootFolder;
      AFilesDA := TRUE;
    end
    else
    begin
      AFilesPath := SlidesImgRootFolder;
      AFilesDA := SlidesImgRootFDA;
    end;

    ExtDataErrorCode := K_eeDBSelect;
    CurDSet1.Connection := LANDBConnection;
    with CurDSet1 do
    begin
      SQL.Text := 'select ' +
        K_CMENDBSTFSlideID + ',' + K_CMENDBSTFSlideSysInfo +
        ' from ' +  K_CMENDBSlidesTable +
        AddSelect;

      Filtered := false;
      Open;

      AFilesCount := 0;
      AFilesSize := 0;
      First;
      while not Eof do
      begin
        K_CMEDAGetSlideSysFieldsData( FieldList.Fields[1].AsString, @SDBF );
        if ((cmsfIsMediaObj in SDBF.SFlags) = SlidesCRFC.MediaFCopy) and
           ((cmsfIsImg3DObj in SDBF.SFlags) = SlidesCRFC.Img3DFCopy) then
        begin
        // Media, Img  and Img3D
          Inc(AFilesCount);
          AFilesSize := AFilesSize + SDBF.BytesSize;
          if cmsfHasSrcImg in SDBF.SFlags then
          begin
          // Img only
            Inc(AFilesCount);
            AFilesSize := AFilesSize + SDBF.BytesSize;
          end;
        end;
        Next;
      end;
      Close;
    end;

    N_Dump2Str('DB>> EDAGetSlidesFilesInfo fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAGetSlidesFilesInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAGetSlidesFilesInfo

//********************************************* TK_CMEDDBAccess.EDAPrepSlidesFilesMoving ***
// Prepare Files moving or checking
//
//     Parameters
// ANewFPath - Files new location base path
// ADAFlag    - Files Direct Access Flag
// ASplitFlag - Files Split Flag
// ASkipMovingSlidesContext - skip moving slides context prepare
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAPrepSlidesFilesMoving(const ANewFPath: string;
  ADAFlag, ASplitFlag, ASkipMovingSlidesContext : Boolean): TK_CMEDResult;
//const
//  CheckName = '123456789.123';

var
  SDBF: TN_CMSlideSDBF;
  // CSysInfo : string;
  ActiveCount: Integer;
  ActiveGIDs: TN_IArray;
  i: Integer;
  CDTime: TDateTime;
  WStr: string;
  SourceFolder: string;
  SourceDA: Boolean;
//  TmpName: string;
  SQLStr: string;
  WActPatID : Integer;

  procedure CheckFoldersEqual();
  begin
    SlidesCRFC.SameFolder := false;
    if (SourceFolder = '') or (ExcludeTrailingPathDelimiter(SourceFolder) = '')
      then
      Exit;

    if (EDAPathOrFileExists(SourceFolder, SourceDA, TRUE) <> K_edOK) then
    begin
      K_CMShowMessageDlg( K_CML1Form.LLLFilesMove.Caption,
//                          'Current folder doesn''t exist',
                          mtWarning);
      Exit;
    end;

    SlidesCRFC.SameFolder := EDACheckFoldersEquality1( SourceFolder, SourceDA,
                                  SlidesCRFC.RootFolder, SlidesCRFC.RootFDA );
  end;

begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  with SlidesCRFC do
    N_Dump2Str('DB>>  Prep Files moving P=' + RootFolder + format
        ('M=%d N=%d S=%.2g MB', [MovingFSDDescr, CopiedFNum,
        CopiedFSize/1024/1024]));

  ExtDataErrorString := '';
  try

    if SlidesCRFC.MovingFSDDescr = 0 then
    begin
      // *** Server to server copy ImgFiles or MediaFiles
      LANDBConnection.BeginTrans;
      with CurSQLCommand1 do
      begin
        Connection := LANDBConnection;
        CommandText := EDADBIsolationLevelSet(K_tilSerializable);
//        ExtDataErrorCode := K_eeDBLock;
//        CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
        Execute;
      end;

      with CurDSet2 do
      begin
        ExtDataErrorCode := K_eeDBSelect;
        Connection := LANDBConnection;

        // Check Active Instances Table for other Active
{
        SQL.Text := 'select ' +
          K_CMENDBAAInstsTFActRTID + ',' +                                  // 0
          K_CMENDBAAInstsTFActTS + ',' + K_CMENDBAAInstsTFGlobID + ',' +    // 1,2
          K_CMENDBAAInstsTFActTSUID + ',' + K_CMENDBAAInstsTFPatID + ',' +  // 3,4
          K_CMENDBAAInstsTFProvID + ',' + K_CMENDBAAInstsTFLocID +          // 5,6
          ' from ' + K_CMENDBAAInstsTable;
}
        WStr := 'select ' +
          K_CMENDBAAInstsTFActRTID + ',' +                                  // 0
          K_CMENDBAAInstsTFActTS +   ',' + K_CMENDBAAInstsTFGlobID + ',' +  // 1,2
          K_CMENDBAAInstsTFActTSUID + ',' + K_CMENDBAAInstsTFPatID + ',' +  // 3,4
          K_CMENDBAAInstsTFProvID + ',' + K_CMENDBAAInstsTFLocID;           // 5,6

        if K_CMEDDBVersion >= 15 then
          WStr := WStr + ',' + K_CMENDBAAInstsTFActFlags;              // 7

        SQL.Text := WStr + ' from ' + K_CMENDBAAInstsTable;
        Filtered := false;
        Open;
        SetLength(ActiveGIDs, RecordCount);
        ActiveCount := 0;
        // CDTime := Now();
        CDTime := EDAGetSyncTimestamp();
        First;
        while not Eof do
        begin
          WActPatID := FieldList.Fields[4].AsInteger;
          if not K_CMDBCheckAppInstanceLostRecord( CurDSet2, 1, 7, CDTime ) and  // Active CMS
            ((WActPatID >= 0) or (WActPatID <-100))    and // with Actual Patient
            (FieldList.Fields[0].AsInteger <> AppRTID) and // not Self
            (FieldList.Fields[2].AsInteger <> ClientAppGlobID) and // not Self Client computer
            ( not K_CMEnterpriseModeFlag                or // Not Enterprise Mode
             (FieldList.Fields[6].AsInteger = CurLocID) ) then // Instance is Active on Handling Location
          begin // Not Self Application
            ActiveGIDs[ActiveCount] := FieldList.Fields[2].AsInteger;
            Inc(ActiveCount);
          end;
          Next;
        end; // while not Eof do

        Close;

        if ActiveCount >= 1 then
        begin
          // Image Files Moving couldn't be done because of other active
          SQL.Text := 'select ' +
            K_CMENDBGAInstsTFGlobID + ',' + K_CMENDBGAInstsTFCName +
            ' from ' + K_CMENDBGAInstsTable;
          Filtered := false;
          Open;
          for i := 0 to ActiveCount - 1 do
          begin
            Filter := K_CMENDBGAInstsTFGlobID + ' = ' + IntToStr(ActiveGIDs[i]);
            Filtered := TRUE;
            if ExtDataErrorString <> '' then
              ExtDataErrorString := ExtDataErrorString + ', ';
            ExtDataErrorString := ExtDataErrorString + EDAGetStringFieldValue(FieldList.Fields[1]);
            Filtered := false;
          end;
          Close;
        end;

        if K_CMEnterpriseModeFlag then
        begin // Check Files Sync Process State
        // Add FilesSyncInfo to >> ExtDataErrorString
          SQL.Text := 'select ' + K_CMENDBGTFSSState +
            ' from ' + K_CMENDBGlobAttrsTable;
          Filtered := false;
          Open;
          if FieldList.Fields[0].AsInteger <> 0 then
          begin
            if ExtDataErrorString <> '' then
              ExtDataErrorString := ExtDataErrorString + ', ';
            ExtDataErrorString := ExtDataErrorString + 'Files Syncronize Process'
          end;
          Close;
        end; // if K_CMEnterpriseModeFlag then

        if ExtDataErrorString <> '' then
        begin
          N_Dump1Str('Active CMS on computers ' + ExtDataErrorString);
          Result := K_edFails;
        end;

        if not K_CMEnterpriseModeFlag then
          SQL.Text := 'select ' +
            K_CMENDBGTFNewFPath + ',' + K_CMENDBGTFNewFProvID +
            ' from ' + K_CMENDBGlobAttrsTable
        else
          // Use Context from Location Files Access Table in Enterprise Mode
          SQL.Text := 'select ' +
            K_CMENDBLFALocNewFPath + ',' + K_CMENDBLFALocNewFProvID + ',' +
            K_CMENDBLFALocID +
            ' from ' + K_CMENDBLocsFAccessTable +
            ' where ' + K_CMENDBLFALocID + '=' + IntToStr(CurLocID);
        Filtered := false;
        Open;
        if FieldList.Fields[0].AsString = '' then
        begin // Files Moving Context is Free - Lock it for Self Use
          SlidesCRFC.RootFolder := IncludeTrailingPathDelimiter(ANewFPath);
          SlidesCRFC.RootFDA     := ADAFlag;
          SlidesCRFC.MediaFSplit := ASplitFlag;
          SlidesCRFC.OpProvID    := CurProvID;
          Edit;
          WStr := '';
          if SlidesCRFC.ChangePathStage > 0 then
            WStr := '?'+IntToStr(SlidesCRFC.ChangePathStage);
          if SlidesCRFC.RootFDA then
            WStr := WStr + '>';
          if SlidesCRFC.MediaFCopy then
          begin
            WStr := WStr + '#';
            if SlidesCRFC.MediaFSplit then
              WStr := WStr + '*';
          end
          else
          if SlidesCRFC.Img3DFCopy then
            WStr := WStr + ':';


          EDAPutStringFieldValue( FieldList.Fields[0], WStr + SlidesCRFC.RootFolder );
          FieldList.Fields[1].AsInteger := CurProvID;
          UpdateBatch;
        end;
        Close;

        LANDBConnection.CommitTrans();
        with CurSQLCommand1 do
        begin
          CommandText := EDADBIsolationLevelDefault();
          Execute;
        end;

        if Result <> K_edOK then
          Exit;

        //////////////////////////////////////
        // Check if Src and Dest same Folder
        //
        if SlidesCRFC.MediaFCopy then
        begin
          SourceFolder := SlidesMediaRootFolder;
          SourceDA := SlidesMediaRootFDA;
        end
        else
        if SlidesCRFC.Img3DFCopy then
        begin
          SourceFolder := SlidesImg3DRootFolder;
          SourceDA := TRUE;
        end
        else
        if SlidesCRFC.MediaFCopy then
        begin
          SourceFolder := SlidesImgRootFolder;
          SourceDA := SlidesImgRootFDA;
        end;
        CheckFoldersEqual();

        //////////////////////////////////////
        // Prepare Image Files Moving Context
        // CurDSet2 - GlobAttrs Table
        // CurSlidesDSet - for slides loop
        //
        if not K_CMEnterpriseModeFlag then
        // Use Context from Global Attrs Table in Ordinary Mode
          SQL.Text := 'select ' +
            K_CMENDBGTFCopiedFNum + ',' +  K_CMENDBGTFCopiedFSize +
            ' from ' + K_CMENDBGlobAttrsTable
        else
        // Use Context from Location Files Access Table in Enterprise Mode
          SQL.Text := 'select ' +
            K_CMENDBLFALocNewFCopiedNum + ',' + K_CMENDBLFALocNewFCopiedSize +
            ' from ' + K_CMENDBLocsFAccessTable +
            ' where ' + K_CMENDBLFALocID + '=' + IntToStr(CurLocID);
        Filtered := false;
        Open;
        // Get Real Starting Move Position - actual after copy error
        SlidesCRFC.CopiedFNum := FieldList.Fields[0].AsInteger;
        SlidesCRFC.CopiedFSize := TLargeintField(FieldList.Fields[1]).AsLargeint;
      end; // with CurDSet2 do

      WStr := '';
    end   // if SlidesCRFC.MovingFSDDescr = 0 then
    else
    begin // if SlidesCRFC.MovingFSDDescr <> 0 then
      // *** Media Client Copy - Save Context to IniSection
      SlidesCRFC.RootFolder := IncludeTrailingPathDelimiter(ANewFPath);
      SlidesCRFC.RootFDA := ADAFlag;
      SlidesCRFC.MediaFSplit := ASplitFlag;
      SourceFolder := SlidesClientMediaRootFolder;
      SourceDA := TRUE;
      CheckFoldersEqual();
      EDASaveFilesMovingInfo();
      WStr := ' where ' + K_CMENDBSTFSlideCompCr + '=''' + K_CMSServerClientInfo.CMSClientVirtualName +
        ''' ';
    end; // if SlidesCRFC.MovingFSDDescr <> 0 then

    if not ASkipMovingSlidesContext then
      with CurSlidesDSet do
      begin
        N_Dump2Str('DB>>  Step to 1-st slide to move');
        SQLStr := 'select ' +
          K_CMENDBSTFSlideID + ',' + K_CMENDBSTFSlideSysInfo + ',' +  //0,1
          K_CMENDBSTFPatID + ',' + K_CMENDBSTFSlideDTCr;              //2,3
        if K_CMEDDBVersion >= 24 then
          SQLStr := SQLStr + ','+ K_CMENDBSTFSlideStudyID;            //4
        SQL.Text := SQLStr +
          ' from ' + K_CMENDBSlidesTable + WStr +
          ' order by ' +  K_CMENDBSTFPatID + ' asc';
        Filtered := false;
        Open;

        // Move to start Slide for files copy
        First;
        i := 0;
        while not Eof do
        begin
          K_CMEDAGetSlideSysFieldsData( FieldList.Fields[1].AsString, @SDBF);
  //        if not((cmsfIsMediaObj in SDBF.SFlags) <> SlidesCRFC.MediaFCopy) then
          if ((cmsfIsMediaObj in SDBF.SFlags) = SlidesCRFC.MediaFCopy) and
             ((cmsfIsImg3DObj in SDBF.SFlags) = SlidesCRFC.Img3DFCopy) then
          begin
            Inc(i);
            if i > SlidesCRFC.CopiedFNum then
              break;
            if cmsfHasSrcImg in SDBF.SFlags then
            begin
              Inc(i);
              if i > SlidesCRFC.CopiedFNum then
                break;
            end;
          end;
          Next;
        end; // while not Eof do
      end; // with CurSlidesDSet do
    N_Dump2Str('DB>>  Prep Files moving fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAPrepSlidesFilesMoving ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAPrepSlidesFilesMoving

//********************************************* TK_CMEDDBAccess.EDACopyNextSlideFiles ***
// Copy Next Image Files
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDACopyNextSlideFiles(): TK_CMEDResult;
var
  PrevFPath, NewFPath, FilesExt, CurFName, DestFName: string;
  WPatID, NextPatID, PatFilesStartCount: Integer;
  ChangeMediaSplitMode, CopyNotServerMediaFiles, CopyImgFiles, SkipPatientSubtree,
    SourceMediaDA, SourceMediaSplit, SlideMediaSplit,
    SlideMediaShouldBeSplited : Boolean;
  MFStream: TStream;
  PCMSlide: TN_PCMSlide;

label LExit, LFCErr;

  procedure SetMediaFilePath();
  begin
    if (SlidesCRFC.MovingFSDDescr and 1) = 0 then
      PrevFPath := SlidesMediaRootFolder + PrevFPath
    else
      PrevFPath := SlidesClientMediaRootFolder + PrevFPath;
  end; // procedure SetMediaFilePath

  procedure CopyPatientFiles();
  begin
    PrevFPath := CurSlide.GetFilesPatientPathSegm();
    NewFPath := ExcludeTrailingPathDelimiter(SlidesCRFC.RootFolder + PrevFPath);
    if SlidesCRFC.MediaFCopy then
    begin
      // Copy Media Files
      SetMediaFilePath();
//      FilesExt := 'MF_*.*';
      FilesExt := '?F_*.*'; // for MF_xxxxxxxx.* and AF_xxxxxxxx.cma
    end
    else
    if SlidesCRFC.Img3DFCopy then
    begin
      PrevFPath := SlidesImg3DRootFolder + PrevFPath;
      FilesExt := '*.*'; // for 3F_xxxxxxxx\*.*
    end
    else
    begin
      // Copy Image Files
      PrevFPath := SlidesImgRootFolder + PrevFPath;
//      FilesExt := '*.cmi';
      FilesExt := '*.cm?'; // for *.cmi and *.cma
      // AF_xxxxxxxx.cma and RF_xxxxxxxx.cmi and RF_xxxxxxxxr.cmi or
      // SF_xxxxxxxx.cma
    end;

    ExtDataErrorString := PrevFPath + FilesExt;
    // Copy Files
    // Result := K_edOK;
    Result := EDAPathOrFileExists(PrevFPath, SlidesCRFC.RootFDA, TRUE);
    if Result <> K_edOK then
    begin
      Result := K_edImageFilesMoving;
      Exit;
    end;
    if SlidesCRFC.RootFDA then
    begin
      if not K_CopyFolderFiles( PrevFPath,
        IncludeTrailingPathDelimiter(NewFPath), FilesExt,
        [K_cffOverwriteNewer] ) then
        Result := K_edImageFilesMoving;
    end
    else
      with CurBlobDSet do
      begin
        ExtDataErrorCode := K_eeFilesPocessing;
        Connection := LANDBConnection;

        SQL.Text := 'begin' + Chr($0A) +
          'declare @ls_source long varchar;' + Chr($0A) +
          'declare @ls_destination long varchar;' + Chr($0A) +
          'set @ls_source = ' + QuotedStr(AnsiReplaceText(PrevFPath + FilesExt, '\', '\\')) + ';' + Chr($0A) +
          'set @ls_destination = ' + QuotedStr(AnsiReplaceText(NewFPath, '\', '\\')) + ';' + Chr($0A) +
          'select sf_file_xcopy(@ls_source,@ls_destination);' + Chr($0A) +
          'end';

        Open;

        if FieldList.Fields[0].AsInteger <> 0 then
          Result := K_edImageFilesMoving;

        Close;
      end;
  end; // procedure CopyPatientFiles

  function CopyImgFile(): TK_CMEDResult;
  begin
    DestFName := SlidesCRFC.RootFolder + CurFName;
    CurFName := SlidesImgRootFolder + CurFName;
    if SlidesImgRootFDA then
      Result := EDACopyFileToServer(CurFName, DestFName, false)
    else
      Result := EDACopyFileFromServer(CurFName, DestFName, false);
    if Result <> K_edOK then
      Exit;
    Inc(SlidesCRFC.CopiedFNum);
    with PCMSlide^ do
      SlidesCRFC.CopiedFSize := SlidesCRFC.CopiedFSize + CMSDB.BytesSize;
  end; // function CopyImgFile

  function CopyMediaFile(): TK_CMEDResult;
  begin
    DestFName := NewFPath + ExtractFileName(CurFName);
    if SlidesMediaRootFDA then
      Result := EDACopyFileToServer(CurFName, DestFName, false)
    else
      Result := EDACopyFileFromServer(CurFName, DestFName, false);
  end; // function CopyMediaFile

begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>>  Copy files P=' + SlidesCRFC.RootFolder + format
      (' N=%d S=%.2g MB', [SlidesCRFC.CopiedFNum,
      SlidesCRFC.CopiedFSize/1024/1024]));

  SourceMediaSplit := ((SlidesCRFC.MovingFSDDescr and 1) = 0)
    and SlidesMediaFSplit;
  SourceMediaDA := SlidesMediaRootFDA or
    ((SlidesCRFC.MovingFSDDescr and 1) = 1);
  ChangeMediaSplitMode := SlidesCRFC.MediaFCopy and
    (SourceMediaSplit <> SlidesCRFC.MediaFSplit);
  CopyNotServerMediaFiles := SlidesCRFC.MediaFCopy and (SlidesCRFC.MovingFSDDescr <> 0);
  // because Local Folder May Contain not all separate files of patient (for correct calculation)

  CopyImgFiles := not SlidesCRFC.MediaFCopy and not SlidesCRFC.Img3DFCopy and
                 (SlidesImgRootFDA <> SlidesCRFC.RootFDA);

  // Img3D files should copy by all patient files copy - SkipPatientSubtree = FALSE

  SkipPatientSubtree := not SlidesCRFC.Img3DFCopy and
                       (ChangeMediaSplitMode or CopyNotServerMediaFiles or CopyImgFiles);
  try
    WPatID := -1;

    Result := K_edFails;
    with CurSlidesDSet do
    begin
      CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1,
          N_UDCMSlideCI));
      PCMSlide := CurSlide.P;
      PatFilesStartCount := SlidesCRFC.CopiedFNum;
      while not Eof do
      begin
        with CurSlide, PCMSlide^ do
        begin
          NextPatID := FieldList.Fields[2].AsInteger;
//if NextPatID = 10000 then
//NextPatID:=10000;
          if not SkipPatientSubtree and (WPatID <> -1)    and
            (PatFilesStartCount <> SlidesCRFC.CopiedFNum) and
            (WPatID <> NextPatID) then
          begin
            // Copy previous Patient Files
            CopyPatientFiles();
            if Result <> K_edOK then
              goto LExit;
            WPatID := -1;
            break;
          end;
          WPatID := NextPatID;
//          CMSPatId := WPatID;
          // Clear Slide TN_CMSlideSDBF Field
          CMSDB.MediaFExt   := '';
          CMSDB.DCMModality := '';
          FillChar( CMSDB, SizeOf(TN_CMSlideSDBF), 0 );
          K_CMEDAGetSlideSysFieldsData( FieldList.Fields[1].AsString, @CMSDB );

          if ((cmsfIsMediaObj in CMSDB.SFlags) <> SlidesCRFC.MediaFCopy) or
             ((cmsfIsImg3DObj in CMSDB.SFlags) <> SlidesCRFC.Img3DFCopy) then
          begin
            Next;
            Continue;
          end;

          // Change CurPatient context for PatientSubtree copy mode
          CMSPatId := WPatID;
//!!! this code is removed 19.10.2015 - needed to check
//          WPatID := CMSPatId;

          if not SkipPatientSubtree then
          begin
            // Calc CurImage and SrcImage Files and Media
            Inc(SlidesCRFC.CopiedFNum);
            SlidesCRFC.CopiedFSize := SlidesCRFC.CopiedFSize + CMSDB.BytesSize;
            if (cmsfHasSrcImg in CMSDB.SFlags) then
            begin
              Inc(SlidesCRFC.CopiedFNum);
              SlidesCRFC.CopiedFSize := SlidesCRFC.CopiedFSize + CMSDB.BytesSize;
            end;
          end   // if not SkipPatientSubtree then
          else
          begin // if SkipPatientSubtree then
            // Individual Files Copy
            Result := K_edOK;
            // Add Slide Fileds for proper File Name Creation
            ObjName := FieldList.Fields[0].AsString;
            CMSDTCreated := TDateTimeField(FieldList.Fields[3]).Value;

            if CopyImgFiles then
            begin
              // Special processing for some Image Files moving modes (Direct Access Source mode differs from Destination )

              if FieldList.Fields[3].AsInteger < 0 then
                CurFName := K_CMStudyGetFileName( ObjName )
              else
                CurFName := K_CMSlideGetCurImgFileName( ObjName );

              CurFName := GetFilesPathSegm() + CurFName;
              if CopyImgFile() <> K_edOK then
                Result := K_edImageFilesMoving
              else
              begin
                if (cmsfHasSrcImg in CMSDB.SFlags) then
                begin
                  CurFName := GetFilesPathSegm() + GetSrcImgFileName('');
                  if CopyImgFile() <> K_edOK then
                    Result := K_edImageFilesMoving;
                end;
              end;

              if Result <> K_edOK then
              begin
                ExtDataErrorString := CurFName;
                goto LExit;
              end;
              Next;
              break;
            end   // if CopyImgFiles then
            else
            begin // if CopyMediaFiles or ChangeMediaSplitMode then
              // Special processing for some MediaFiles moving modes

              // Media Files Copy
              PrevFPath := CurSlide.GetFilesPathSegm();
              NewFPath := SlidesCRFC.RootFolder + PrevFPath;
              SetMediaFilePath();
              if ChangeMediaSplitMode then
              begin
                // Change Split Media Files mode (could be done only in direct access mode)
                MFStream := nil;
               // Dynamic Split Control
                CurFName := GetMediaFileNamePref(PrevFPath) + '_0.mfp';
                SlideMediaSplit := EDAPathOrFileExists(CurFName, SourceMediaDA,
                            false) = K_edOK;

                SlideMediaShouldBeSplited :=
                            not SlideMediaSplit and EDASplitMediaFileIsNeeded
                            (CMSDB.BytesSize);

                if not SlideMediaSplit and not SlideMediaShouldBeSplited then
                begin
                  // Small File - Split and Join is not needed
                  if not SlidesCRFC.SameFolder then
                  begin
                    CurFName := GetMediaFileName(PrevFPath);
                    ExtDataErrorString := CurFName;
                    if SourceMediaDA = SlidesCRFC.RootFDA then
                    begin
                      // Source and Destination Foledrs have equal DA modes
                      if SourceMediaDA then
                      begin
                        if FileExists(CurFName) and
                           (0 <> K_CopyFile( CurFName, GetMediaFileName(NewFPath),
                                             [K_cffOverwriteNewer])) then
                          Result := K_edImageFilesMoving;
                      end
                      else
                        // this couldn't be realy use because Change Split state could be performed in direct access mode
                        with CurBlobDSet do
                        begin
                          ExtDataErrorCode := K_eeFilesPocessing;
                          Connection := LANDBConnection;
                          CurFName := AnsiReplaceText(CurFName, '\', '\\');

                          SQL.Text := 'begin' + Chr($0A) +
                            'declare @ls_source long varchar;' + Chr($0A)
                            + 'set @ls_source = ' + QuotedStr(CurFName) + ';' + Chr
                            ($0A) + 'select sf_path_exists(@ls_source);' + Chr
                            ($0A) + 'end';

                          // SQL.Text := 'select sf_path_exists( ''' + CurFName + ''' )';
                          Open;
                          if FieldList.Fields[0].AsInteger = 0 then
                          begin
                            Close;
                            if K_edOK <>
                               EDAForceFilePath( ExcludeTrailingPathDelimiter(NewFPath),
                                                 SlidesCRFC.RootFDA, false ) then
                              goto LFCErr;

                            SQL.Text := 'begin' + Chr($0A) +
                'declare @ls_source long varchar;' + Chr($0A) +
                'declare @ls_destination long varchar;' + Chr($0A)
     + 'set @ls_source = ' + QuotedStr(CurFName) + ';' + Chr($0A)
     + 'set @ls_destination = ' + QuotedStr(AnsiReplaceText(NewFPath, '\', '\\')) + ';' + Chr($0A) +
                 'select sf_file_copy(@ls_source,@ls_destination);' + Chr($0A) + 'end';

                            // SQL.Text := 'select sf_file_copy( ''' + CurFName + ''', '''
                            // + AnsiReplaceText( ImgNewFPath, '\', '\\' ) + ''' )';
                            Open;
                            if FieldList.Fields[0].AsInteger <> 0 then
                              Result := K_edImageFilesMoving;
                          end;
                          Close;
                        end;
                    end
                    else
                    begin
                      // Source and Destination Foledrs have different DA modes
                      if K_edOK <> EDAForceFilePath
                        (ExcludeTrailingPathDelimiter
                          (NewFPath), SlidesCRFC.RootFDA, false) then
                        goto LFCErr;
                      if CopyMediaFile() <> K_edOK then
                        Result := K_edImageFilesMoving;
                    end;
                  end;
                  // end else if SourceMediaSplit then begin
                end
                else if SlideMediaSplit then
                begin
                  // Join splitted file parts to single file (can be performed only if new DA)
                  if K_edOK = EDAForceFilePath
                    (ExcludeTrailingPathDelimiter(NewFPath),
                    SlidesCRFC.RootFDA, false) then
                  begin
                    MFStream := TFileStream.Create
                      (GetMediaFileName(NewFPath), fmCreate);
                    Result := EDAJoinFilesToMediaStream(MFStream,
                      GetMediaFileNamePref(PrevFPath), SlidesMediaRootFDA);
                  end
                  else
                  begin
                  LFCErr :
                    Result := K_edExDataError;
                    ExtDataErrorString :=
                      'Could''t create folder ' + NewFPath;
                    goto LExit;
                  end;
                end
                else
                begin
                  // Split single file to smaller parts (can be performed only if src DA)
                  CurFName := GetMediaFileName(PrevFPath);
                  if FileExists(CurFName) then
                  begin
                    if K_edOK <> EDAForceFilePath
                      (ExcludeTrailingPathDelimiter(NewFPath),
                      SlidesCRFC.RootFDA, false) then
                      goto LFCErr;
                    MFStream := TFileStream.Create(CurFName, fmOpenRead);
                    Result := EDASplitMediaStreamToFiles(MFStream,
                      GetMediaFileNamePref(NewFPath), SlidesCRFC.RootFDA);
                  end;
                end;
                MFStream.Free;
                if Result <> K_edOK then
                  goto LExit;

                Inc(SlidesCRFC.CopiedFNum);
                SlidesCRFC.CopiedFSize :=
                  SlidesCRFC.CopiedFSize + CMSDB.BytesSize;
                Next;
                break;
              end   // if ChangeMediaSplitMode then
              else
              if CopyNotServerMediaFiles then //??? this if may not be needed
              begin // if not ChangeMediaSplitMode then
                // Copy Slide Media Files (could be done only in direct access mode)
                ExtDataErrorString := GetMediaFileName(PrevFPath);
                if FileExists(ExtDataErrorString) and
                  (0 <> K_CopyFile(ExtDataErrorString,
                    GetMediaFileName(NewFPath), [K_cffOverwriteNewer])) then
                  Result := K_edImageFilesMoving;
                if Result <> K_edOK then
                  goto LExit;
                Inc(SlidesCRFC.CopiedFNum);
                SlidesCRFC.CopiedFSize :=
                  SlidesCRFC.CopiedFSize + CMSDB.BytesSize;
                Next;
                break;
              end; // end of if not ChangeMediaSplitMode and CopyMediaFiles then
            end; // end of if CopyMediaFiles or ChangeMediaSplitMode then
          end; // end of if SkipPatientSubtree then
        end; // end of with CurSlide, P^
        Next;
      end; // end of while not Eof

      if not SkipPatientSubtree                        and
         (PatFilesStartCount <> SlidesCRFC.CopiedFNum) and
         (WPatID <> -1) then // Copy Last Patient Files
        CopyPatientFiles();

      // Save Moving New State
    end; // with CurSlidesDSet do

    if not CopyNotServerMediaFiles then
      // Save Moving Context
      with CurDSet2 do
      begin
        Edit;
        FieldList.Fields[0].AsInteger := SlidesCRFC.CopiedFNum;
        TLargeintField(FieldList.Fields[1]).AsLargeint :=
          SlidesCRFC.CopiedFSize;
        UpdateBatch;
      end
    else
      // Media Client Copy - Save Context to IniSection
      EDASaveFilesMovingInfo();
LExit :
    FreeAndNil(CurSlide);
    N_Dump2Str('DB>> Copy files fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDACopyNextSlideFiles ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDACopyNextSlideFiles

//********************************************* TK_CMEDDBAccess.EDAPrepClearFilesMoving ***
// Prepare Clear Files moving Info
//
//     Parameters
// AFPath - Files base path for restoring file access context
// ADAFlag   - Files Direct Access Flag
// Result - Returns operation resulting code
// ADAFlag   - Files Direct Access Flag//
function TK_CMEDDBAccess.EDAPrepClearFilesMoving(const AFPath: string;
  ADAFlag, ASplitFlag: Boolean): TK_CMEDResult;
var
  AddSelect: string;
begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str
    ('DB>>  Prepare clear Files moving P=' + SlidesCRFC.RootFolder +
      format(' N=%d S=%.2g MB', [SlidesCRFC.CopiedFNum,
      SlidesCRFC.CopiedFSize / 1024 /1024]));
  try

    with CurSlidesDSet do
    begin
      AddSelect := '';
      if AFPath <> '' then
      begin
        if SlidesCRFC.MediaFCopy then
        begin
          SlidesMediaRootFolder := AFPath; // Replace Slides Media Files Path for Deletion
          SlidesMediaRootFDA := ADAFlag;
          SlidesMediaFSplit := ASplitFlag;
          if SlidesCRFC.MovingFSDDescr > 0 then
            AddSelect := ' where ' + K_CMENDBSTFSlideCompCr + '=''' +
              K_CMSServerClientInfo.CMSClientVirtualName + ''' ';
        end
        else
        if SlidesCRFC.Img3DFCopy then
          SlidesImg3DRootFolder := AFPath // Replace Slides 3D Image Files Path for Deletion
        else
        begin
          SlidesImgRootFolder := AFPath; // Replace Slides Image Files Path for Deletion
          SlidesImgRootFDA := ADAFlag;
        end;
      end;

      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBSelect;
      SQL.Text := 'select ' +
        K_CMENDBSTFSlideID + ',' + K_CMENDBSTFSlideSysInfo + ',' +
        K_CMENDBSTFPatID + ',' + K_CMENDBSTFSlideDTCr +
        ' from ' + K_CMENDBSlidesTable +
        AddSelect +
        ' order by ' + K_CMENDBSTFPatID + ' asc';
      Filtered := false;
      Open;

      First;

    end;
    SlidesCRFCopiedFilesPaths.Clear;
    N_Dump2Str('DB>>  Prepare clear Files moving fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAPrepClearFilesMoving ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAPrepClearFilesMoving

//********************************************* TK_CMEDDBAccess.EDARestoreFilesContext ***
// Restore Files Context and Clear Files moving Info
//
//     Parameters
// AFPath - Files base path for restoring file access context
// ADAFlag   - Files Direct Access Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDARestoreFilesContext(const AFPath: string;
  ADAFlag, ASplitFlag: Boolean): TK_CMEDResult;
var
  PathFieldName: string;
  PathFieldValue: string;
  i: Integer;
  RemoveDAFlag: Boolean;
begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>>  Clear Files moving Info P=' + SlidesCRFC.RootFolder +
      format(' N=%d S=%.2g MB', [SlidesCRFC.CopiedFNum,
      SlidesCRFC.CopiedFSize / 1024 /1024]));
  // Remove Deleted Files Folders

  if (SlidesCRFC.MovingFSDDescr = 3) or SlidesCRFC.Img3DFCopy then
    RemoveDAFlag := TRUE
  else
  begin
    if SlidesCRFC.MediaFCopy then
      RemoveDAFlag := SlidesMediaRootFDA
    else
      RemoveDAFlag := SlidesImgRootFDA;
  end;

  with SlidesCRFCopiedFilesPaths, CurBlobDSet do
  begin
    ExtDataErrorCode := K_eeFilesPocessing;
    Connection := LANDBConnection;
    Filtered := false;
    for i := 0 to Count - 1 do
    begin
      PathFieldValue := ExcludeTrailingPathDelimiter(Strings[i]);
      if RemoveDAFlag then
      begin
        RemoveDir(PathFieldValue)
      end
      else
      begin
        SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A)
          + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(PathFieldValue, '\', '\\')) + ';' + Chr($0A)
          + 'select sf_folder_delete(@ls_source);' + Chr($0A) + 'end';
        // SQL.Text := 'select sf_folder_delete( ''' + AnsiReplaceText( PathFieldValue, '\', '\\' ) + ''' )';
        Open;
        Close;
      end;
    end;
  end;

  try
    CurSlidesDSet.Close;

    ///////////////////////////////////
    // Change and Save Files Context
    //
    if SlidesCRFC.MovingFSDDescr = 0 then
    begin
      // *** Server to Server ImgFiles or MediaFiles Context
{
      LANDBConnection.BeginTrans;
      with CurSQLCommand1 do
      begin
        ExtDataErrorCode := K_eeDBLock;
        Connection := LANDBConnection;
        CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
        Execute;
      end;
}
      if SlidesCRFC.MediaFCopy then
      begin // Media Files
        if AFPath <> '' then
        begin // Restore Files Base Path
          SlidesMediaRootFolder := AFPath;
          SlidesMediaRootFDA := ADAFlag;
          SlidesMediaFSplit := ASplitFlag;
        end;

        if not K_CMEnterpriseModeFlag then
          PathFieldName := K_CMENDBGTFMediaFPath
        else
          PathFieldName := K_CMENDBLFALocVideoFPath;
        ADAFlag := SlidesMediaRootFDA;
        PathFieldValue := SlidesMediaRootFolder;
        if ASplitFlag then
          PathFieldValue := '*' + PathFieldValue;
      end
      else
      if SlidesCRFC.Img3DFCopy then
      begin // 3D Image Files
        if AFPath <> '' then
          SlidesImg3DRootFolder := AFPath;
        PathFieldName := K_CMENDBGTFImg3DFPath;
        PathFieldValue := SlidesImg3DRootFolder;
        ADAFlag := TRUE;
      end
      else
      begin // Image Files
        if AFPath <> '' then
        begin // Restore Files Base Path
          SlidesImgRootFolder := AFPath;
          SlidesImgRootFDA := ADAFlag;
        end;
        if not K_CMEnterpriseModeFlag then
          PathFieldName := K_CMENDBGTFImgFPath
        else
          PathFieldName := K_CMENDBLFALocImgFPath;
        PathFieldValue := SlidesImgRootFolder;
        ADAFlag := SlidesImgRootFDA;
      end;

      // Change server root folder
      if ADAFlag then
        PathFieldValue := '>' + K_CMDBFilePathPrepStr(PathFieldValue);

      with CurSQLCommand1 do
      begin
        ExtDataErrorCode := K_eeDBUpdate;
        Connection := LANDBConnection;
        if not K_CMEnterpriseModeFlag then
          CommandText := 'UPDATE ' + K_CMENDBGlobAttrsTable +
                       ' SET ' + PathFieldName + '=''' + PathFieldValue + ''', ' +
                                 K_CMENDBGTFNewFPath    + '='''', ' +
                                 K_CMENDBGTFCopiedFNum  + '=0, ' +
                                 K_CMENDBGTFCopiedFSize + '=0, ' +
                                 K_CMENDBGTFNewFProvID  + '=-1;'
        else
          CommandText := 'UPDATE ' + K_CMENDBLocsFAccessTable +
                       ' SET ' + PathFieldName + '=''' + PathFieldValue + ''', ' +
                                 K_CMENDBLFALocNewFPath       + '='''', ' +
                                 K_CMENDBLFALocNewFCopiedNum  + '=0, ' +
                                 K_CMENDBLFALocNewFCopiedSize + '=0, ' +
                                 K_CMENDBLFALocNewFProvID     + '=-1 ' +
                       ' WHERE ' + K_CMENDBLFALocID + '=' + IntToStr(CurLocID);
        Execute;
        N_Dump1Str( 'EDARestoreFilesContext>> by SQL :' + CommandText );
      end;
{
      with CurDSet2 do
      begin
        if Active then
          Close; // for Moving finish case
        Connection := LANDBConnection;
        if not K_CMEnterpriseModeFlag then
        // Use Context from Global Attrs Table in Ordinary Mode
          SQL.Text := 'select ' +
            PathFieldName + ',' + K_CMENDBGTFNewFPath + ',' +            // 0,1
            K_CMENDBGTFCopiedFNum + ',' + K_CMENDBGTFCopiedFSize + ',' + // 2,3
            K_CMENDBGTFNewFProvID +                                      //4
            ' from ' + K_CMENDBGlobAttrsTable
        else
        // Use Context from Location Files Access Table in Enterprise Mode
          SQL.Text := 'select ' +
            PathFieldName + ',' + K_CMENDBLFALocNewFPath + ',' +                      // 0,1
            K_CMENDBLFALocNewFCopiedNum + ',' + K_CMENDBLFALocNewFCopiedSize + ',' +  // 2,3
            K_CMENDBLFALocNewFProvID +                                                //4
            ' from ' + K_CMENDBLocsFAccessTable +
            ' where ' + K_CMENDBLFALocID + '=' + IntToStr(CurLocID);
        Filtered := false;
        Open;
        Edit;
        EDAPutStringFieldValue( FieldList.Fields[0], PathFieldValue );
        FieldList.Fields[1].AsString := '';
        FieldList.Fields[2].AsInteger := 0;
        TLargeintField(FieldList.Fields[3]).AsLargeint := 0;
        FieldList.Fields[4].AsInteger := -1;
        UpdateBatch;
        Close;
      end;

      LANDBConnection.CommitTrans();
}
      EDAClearSlidesCRFC();
    end   // if SlidesCRFC.MovingFSDDescr = 0 then
    else
    begin // if SlidesCRFC.MovingFSDDescr <> 0 then
      // *** Client Media Files Context
      if SlidesCRFC.MovingFSDDescr = 3 then
        SlidesClientMediaRootFolder := SlidesCRFC.RootFolder;
      EDAClearSlidesCRFC();
      EDASaveFilesMovingInfo();
    end;  // if SlidesCRFC.MovingFSDDescr <> 0 then
    //
    // end of Change and Save Files Context
    ///////////////////////////////////
    N_Dump2Str('DB>>  Clear Files moving Info fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDARestoreFilesContext ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDARestoreFilesContext

//********************************************* TK_CMEDDBAccess.EDASetFilesEnterpriseContext ***
// Set Current Files Enterpise Context to DB
//
//     Parameters
// ALocHeadFlag - if TRUE then Current Location should be Head Office
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASetFilesEnterpriseContext( ) : TK_CMEDResult;
var
  PrevLocFlags : Integer;
  LocHeadPrevFlag : Boolean;
  LocHeadNewFlag : Boolean;
  ChangeStateFlag : Boolean;
  SCurLocID : string;
begin
  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>>  EDASetFilesEnterpriseContext start');
  // Remove Deleted Files Folders

  try
    LANDBConnection.BeginTrans;
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
        //Code Not used now
      CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end;
    with CurDSet2 do
    begin
      SCurLocID := IntToStr(CurLocID);
      Connection := LANDBConnection;
      // Use Context from Location Files Access Table in Enterprise Mode
      SQL.Text := 'select ' +
        K_CMENDBLFALocImgExtFPath + ',' + K_CMENDBLFALocVideoExtFPath + ',' +
        K_CMENDBLFALocFlags + ',' + K_CMENDBLFALocID +
        ' from ' + K_CMENDBLocsFAccessTable +
        ' where ' + K_CMENDBLFALocID + '=' + SCurLocID;
      Filtered := false;
      Open;
      PrevLocFlags := FieldList.Fields[2].AsInteger;
      LocHeadPrevFlag := (PrevLocFlags and 1) <> 0;
      LocHeadNewFlag := (CurLocEFlags and 1) <> 0;
      ChangeStateFlag := (EDAGetStringFieldValue(FieldList.Fields[0]) <> SlidesImgRootEFolder) or
                         (EDAGetStringFieldValue(FieldList.Fields[1]) <> SlidesMediaRootEFolder) or
                         (LocHeadNewFlag <> LocHeadPrevFlag);
      if ChangeStateFlag then
      begin
        Edit;
        EDAPutStringFieldValue( FieldList.Fields[0], SlidesImgRootEFolder );
        EDAPutStringFieldValue( FieldList.Fields[1], SlidesMediaRootEFolder );
        if LocHeadNewFlag <> LocHeadPrevFlag then
        begin
        // Change previous Head Office Flag
          FieldList.Fields[2].AsInteger := CurLocEFlags;
        end;
        UpdateBatch;
      end;
      Close;
      if LocHeadNewFlag and not LocHeadPrevFlag then
      // Clear previous Head Office Flag
        with CurSQLCommand1 do
        begin
          ExtDataErrorCode := K_eeDBUpdate;
          Connection := LANDBConnection;
          CommandText := 'UPDATE ' + K_CMENDBLocsFAccessTable +
            ' SET ' +  K_CMENDBLFALocFlags + ' = 0 WHERE ' +
            K_CMENDBLFALocID + '<>' + SCurLocID;
          Execute;
        end;

    end;

    LANDBConnection.CommitTrans();
    // end of Change and Save Files Context
    ///////////////////////////////////
    N_Dump2Str('DB>>  EDASetFilesEnterpriseContext fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDASetFilesEnterpriseContext ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASetFilesEnterpriseContext

//********************************************* TK_CMEDDBAccess.EDADelNextSlideFiles ***
// Delete Next Image Files
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDADelNextSlideFiles(): TK_CMEDResult;
var
  // SDBF : TN_CMSlideSDBF;
  WPatID, NextPatID: Integer;
  RootPatPath, RootFPath: string;
  FilesExt, CurFName: string;
  ChangeMediaSplitMode, CopyNotServerMediaFiles, SourceMediaDA, SourceMediaSplit,
    SlideMediaSplit, SlideMediaShouldBeSplited: Boolean;
  SkipDeletePatientFiles: Boolean;

label LExit;

  procedure SetMediaFilePath();
  begin
    if (SlidesCRFC.MovingFSDDescr and 1) = 0 then
    begin
      RootPatPath := SlidesMediaRootFolder;
      RootFPath := SlidesMediaRootFolder + RootFPath
    end
    else
    begin
      RootPatPath := SlidesClientMediaRootFolder;
      RootFPath := SlidesClientMediaRootFolder + RootFPath;
    end;
  end; // procedure SetMediaFilePath

  procedure DeleteSlideMedia1();
  begin
    CurFName := CurSlide.GetMediaFileName(RootFPath);
    if EDAFileDelete(CurFName, SourceMediaDA) <> K_edOK then
      Result := K_edImageFilesMoving;
  end; // procedure DeleteSlideMedia1

  procedure DelPatientFiles(ANextPatientID: Integer; SkipFilesDeletion: Boolean);
  var
    PathSegm: string;
  begin
    RootFPath := CurSlide.GetFilesPatientPathSegm();
    Result := K_edOK;
    if SlidesCRFC.MediaFCopy then
    begin
      // Del Media Files
      SetMediaFilePath();
      FilesExt := 'MF_*.*';
    end
    else
    if SlidesCRFC.Img3DFCopy then
    begin
      // Del Img3D Files
      RootPatPath := SlidesImg3DRootFolder;
      RootFPath := SlidesImg3DRootFolder + RootFPath;
      FilesExt := '*.*';
    end
    else
    begin
      // Del Image Files
      RootPatPath := SlidesImgRootFolder;
      RootFPath := SlidesImgRootFolder + RootFPath;
//      FilesExt := '*.cmi';
      FilesExt := '*.cm?'; // for *.cmi and *.cma
    end;

    if not SkipFilesDeletion then
    begin // Delete files for each Patient
      // Delete Patient Files
      if SlidesCRFC.RootFDA then
      begin
        K_DeleteFolderFiles(RootFPath, FilesExt);
      end
      else
        with CurBlobDSet do
        begin
          ExtDataErrorCode := K_eeFilesPocessing;
          Connection := LANDBConnection;

          SQL.Text := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A)
     + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(RootFPath + FilesExt, '\', '\\')) + ';' + Chr($0A)
     + 'select sf_file_delete_s(@ls_source);' + Chr($0A) + 'end';

          // SQL.Text := 'select sf_file_delete_s( ''' + AnsiReplaceText( RootFPath + FilesExt, '\', '\\' ) + ''' )';
          Open;
          if FieldList.Fields[0].AsInteger <> 0 then
            Result := K_edImageFilesMoving;
          Close;
        end;
    end;

    // Add Patient Slides Path
    SlidesCRFCopiedFilesPaths.Add(RootFPath);

    // Add Patients Group Path if needed
    PathSegm := K_CMSlideGetPatientFilesGroupPathSegm(CurSlide.P().CMSPatId);
    if (ANextPatientID = -1) or (PathSegm <>
        K_CMSlideGetPatientFilesGroupPathSegm(ANextPatientID)) then
      SlidesCRFCopiedFilesPaths.Add(RootPatPath + PathSegm);
  end; //  procedure DelPatientFiles

begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>>  Delete files P=' + SlidesCRFC.RootFolder + format
      (' N=%d ', [SlidesCRFC.CopiedFNum]));
  WPatID := -1;
  Result := K_edFails;

  SourceMediaSplit := ((SlidesCRFC.MovingFSDDescr and 1) = 0)
    and SlidesMediaFSplit;
  SourceMediaDA := SlidesMediaRootFDA or
    ((SlidesCRFC.MovingFSDDescr and 1) = 1);
  ChangeMediaSplitMode := SlidesCRFC.MediaFCopy and
    (SourceMediaSplit <> SlidesCRFC.MediaFSplit);
  CopyNotServerMediaFiles := SlidesCRFC.MediaFCopy and (SlidesCRFC.MovingFSDDescr > 0);
  SkipDeletePatientFiles := CopyNotServerMediaFiles or ChangeMediaSplitMode;
  try
    with CurSlidesDSet do
    begin

      CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1,
          N_UDCMSlideCI));
      while not Eof do
      begin
        with CurSlide, P^ do
        begin
          NextPatID := FieldList.Fields[2].AsInteger;
          if (WPatID <> -1) and (WPatID <> NextPatID) then
          begin
            // Delete previous Patient Files
            DelPatientFiles(NextPatID, SkipDeletePatientFiles);
            if Result <> K_edOK then
              goto LExit;
            WPatID := -1;
            break;
          end;

          // Clear Slide TN_CMSlideSDBF Field
          CMSDB.MediaFExt   := '';
          CMSDB.DCMModality := '';
          FillChar( CMSDB, SizeOf(TN_CMSlideSDBF), 0 );
          K_CMEDAGetSlideSysFieldsData( FieldList.Fields[1].AsString, @CMSDB );

          if ((cmsfIsMediaObj in CMSDB.SFlags) <> SlidesCRFC.MediaFCopy) or
             ((cmsfIsImg3DObj in CMSDB.SFlags) <> SlidesCRFC.Img3DFCopy) then
          begin // Skip if not proper Slide type
            Next;
            Continue;
          end;

          WPatID := NextPatID;
          CMSPatId := WPatID;
          CMSDTCreated := TDateTimeField(FieldList.Fields[3]).Value;
          ObjName := FieldList.Fields[0].AsString;

          // Save Probably Deleted Folders List
          RootFPath := CurSlide.GetFilesPathSegm();
          if SlidesCRFC.MediaFCopy then
            // Copy Media Files
            SetMediaFilePath()
          else
          if SlidesCRFC.Img3DFCopy then
            RootFPath := SlidesImg3DRootFolder + RootFPath
          else
            // Copy Image Files
            RootFPath := SlidesImgRootFolder + RootFPath;


          // Add Slide Folder to Folders List
          if SlidesCRFCopiedFilesPaths.IndexOf(RootFPath) < 0 then
            SlidesCRFCopiedFilesPaths.Add(RootFPath);


          if not SkipDeletePatientFiles then
          begin // Calc MediaFile, Img3D Folder or CurImage and SrcImage Files
            if SlidesCRFC.CopiedFNum > 0 then
            begin
              Dec(SlidesCRFC.CopiedFNum);
              if (SlidesCRFC.CopiedFNum > 0) and (cmsfHasSrcImg in CMSDB.SFlags)
                then
                Dec(SlidesCRFC.CopiedFNum);
            end;
          end
          else
          begin
           // Try Special Actions for Media Files if not server copy or change split

            Result := K_edOK;
            if ChangeMediaSplitMode then
            begin
              // Media Mode was changed -  special processing
              SlideMediaSplit := false;
              // Static Split control
              if SourceMediaSplit then
              begin
                CurFName := GetMediaFileNamePref(RootFPath) + '_0.mfp';
                SlideMediaSplit := EDAPathOrFileExists(CurFName, SourceMediaDA,
                  false) = K_edOK;
              end;
              SlideMediaShouldBeSplited :=
                not SourceMediaSplit and EDASplitMediaFileIsNeeded
                (CMSDB.BytesSize);
              { !! Skip Dinamic Split control
                // Dinamic Split control
                CurFName := GetMediaFileNamePref( ImgFPath ) + '_0.mfp';
                SlideMediaSplit := EDAPathOrFileExists( CurFName, SourceMediaDA ) = K_edOK;
                SlideMediaShouldBeSplited := not SlideMediaSplit and
                EDASplitMediaFileIsNeeded( CMSDB.BytesSize );
              }
              if not SlideMediaSplit and not SlideMediaShouldBeSplited then
              begin
                // Delete not splitable File
                if not SlidesCRFC.SameFolder then
                  DeleteSlideMedia1();
                // end else if SourceMediaSplit then begin
              end
              else
              if SlideMediaSplit then
              begin
                // Delete splited Files at source folder
                FilesExt := GetMediaFileNamePref('') + '_*.mfp';
                if SourceMediaDA then
                begin
                  K_DeleteFolderFiles(RootFPath, FilesExt, []);
                end
                else
                  with CurBlobDSet do
                  begin
                    ExtDataErrorCode := K_eeFilesPocessing;
                    Connection := LANDBConnection;
                    SQL.Text := 'begin' + Chr($0A) +
                      'declare @ls_source long varchar;' + Chr($0A)
          + 'set @ls_source = ' + QuotedStr(AnsiReplaceText(RootFPath + FilesExt, '\', '\\')) + ';' + Chr($0A)
          + 'select sf_file_delete(@ls_source);' + Chr($0A) + 'end';

                    // SQL.Text := 'select sf_file_delete( ''' + AnsiReplaceText( ImgFPath + FilesExt, '\', '\\' ) + ''' )';
                    Open;
                    if FieldList.Fields[0].AsInteger <> 0 then
                      Result := K_edImageFilesMoving;
                    Close;
                  end;
              end
              else
              begin
                // Delete Joned File at source folder
                DeleteSlideMedia1();
              end;
            end
            else
            if CopyNotServerMediaFiles then
            begin
              // Delete Slide Media Files (could be done only in direct access mode)
              DeleteSlideMedia1();
            end; // end of if ChangeMediaSplitMode then
            if Result = K_edOK then
              Dec(SlidesCRFC.CopiedFNum);
          end; // if SkipDeletePatientFiles then
        end; // end of with CurSlide, P^ do
        Next;
      end; // while not Eof do

      if WPatID <> -1 then // Copy Last Patient Files
        DelPatientFiles(-1, SkipDeletePatientFiles);
LExit: //*********
      FreeAndNil(CurSlide);
    end;
    N_Dump2Str('DB>>  Delete files fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDADelNextSlideFiles ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDADelNextSlideFiles

//********************************************* TK_CMEDDBAccess.EDAPrepSetFilesPathInfo ***
// Prepare Set Files Location Info
//
//     Parameters
// AImgFPath  - Files new base path
// ADAFlag    - Files Direct Access Flag
// ASplitFlag - Files Split Flag
// AEmptyFolder - if TRUE then resulting Root Folder shouldn't contain files
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAPrepSetFilesPathInfo(const AFPath: string;
  ADAFlag, ASplitFlag, AEmptyFolder: Boolean): TK_CMEDResult;
var
  PathValue: string;
  Mes: string;

begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  Mes := '"';
  if ADAFlag then
    Mes := '" DA=1';
  N_Dump2Str('DB>>  Prepare Set Files Info P="' + AFPath + Mes);
  try
    PathValue := ExcludeTrailingPathDelimiter(AFPath);
    if not AEmptyFolder then
    begin
      // Check path existance
      Result := EDAPathOrFileExists( PathValue,
                                     ADAFlag, TRUE );
      ExtDataErrorString := '';
    end
    else
    begin
      // Force path for Empty folder
      Result := EDAForceFilePath(PathValue, ADAFlag, false);
      ExtDataErrorString := '*';
    end;

    if Result = K_edFails then
      Exit;

    Result := EDAPrepSlidesFilesMoving(AFPath, ADAFlag, ASplitFlag, FALSE );
    if Result <> K_edOK then
      Exit;
    if CurDSet2.Active then
      CurDSet2.Close;
    N_Dump2Str('DB>>  Prepare Set Files fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAPrepSetFilesPathInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAPrepSetFilesPathInfo

//********************************************* TK_CMEDDBAccess.EDAPrepSetFilesPathInfo ***
// Prepare Set Files Location Info
//
//     Parameters
// AImgFPath  - Files new base path
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAPrepSetFilesPathInfo1( const AFPath: string; ASkipPrepSlidesMovingContext : Boolean ): TK_CMEDResult;
var
  PathValue: string;

begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>>  Prepare Set Files Info P="' + AFPath + '"');
  try
    PathValue := ExcludeTrailingPathDelimiter(AFPath);
    // Check path existance
    Result := EDAPathOrFileExists( PathValue, TRUE, TRUE );
    ExtDataErrorString := '';
    if Result <> K_edOK then
    begin
      // Force path for Empty folder
      Result := EDAForceFilePath(PathValue, TRUE, false);
      ExtDataErrorString := '*';
    end;

    if Result = K_edFails then
      Exit;

    Result := EDAPrepSlidesFilesMoving(AFPath, TRUE, FALSE, ASkipPrepSlidesMovingContext );
    if Result <> K_edOK then
      Exit;
    if CurDSet2.Active then
      CurDSet2.Close;
    N_Dump2Str('DB>>  Prepare Set Files fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAPrepSetFilesPathInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAPrepSetFilesPathInfo1

//********************************************* TK_CMEDDBAccess.EDASetFilesPathInfo ***
// Prepare Set Files Location Info
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASetFilesPathInfo(): TK_CMEDResult;
var
  PathFieldName: string;
  PathFieldValue: string;
  Mes: string;
begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  Mes := ' M=' + IntToStr(SlidesCRFC.MovingFSDDescr);
  if SlidesCRFC.RootFDA then
    Mes := ' DA=1';

  N_Dump2Str('DB>>  Set Files Info P=' + SlidesCRFC.RootFolder + Mes);

  try
    ///////////////////////////////////
    // Change and Save Files Context
    //
    PathFieldValue := SlidesCRFC.RootFolder;
    if SlidesCRFC.MovingFSDDescr = 0 then
    begin
      // *** Server to Server ImgFiles, MediaFiles or Img3D Context
{
      LANDBConnection.BeginTrans;
      with CurSQLCommand1 do
      begin
        ExtDataErrorCode := K_eeDBLock;
        Connection := LANDBConnection;
        CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
        Execute;
      end;
}
      if SlidesCRFC.MediaFCopy then
      begin
        if not K_CMEnterpriseModeFlag then
          PathFieldName := K_CMENDBGTFMediaFPath
        else
          PathFieldName := K_CMENDBLFALocVideoFPath;
        SlidesMediaRootFolder := PathFieldValue;
        if SlidesCRFC.MediaFSplit  then
          PathFieldValue := '*' + PathFieldValue;
        SlidesMediaRootFDA := SlidesCRFC.RootFDA;
        SlidesMediaFSplit := SlidesCRFC.MediaFSplit;
      end
      else
      if SlidesCRFC.Img3DFCopy then
      begin
        PathFieldName := K_CMENDBGTFImg3DFPath;
        SlidesImg3DRootFolder := PathFieldValue;
      end
      else
      begin
        if not K_CMEnterpriseModeFlag then
          PathFieldName := K_CMENDBGTFImgFPath
        else
          PathFieldName := K_CMENDBLFALocImgFPath;

        SlidesImgRootFolder := PathFieldValue;
        SlidesImgRootFDA := SlidesCRFC.RootFDA;
      end;

      // Change server root folder
      if SlidesCRFC.RootFDA then
        PathFieldValue := '>' + K_CMDBFilePathPrepStr(PathFieldValue);

      with CurSQLCommand1 do
      begin
        ExtDataErrorCode := K_eeDBUpdate;
        Connection := LANDBConnection;
        if not K_CMEnterpriseModeFlag then
          CommandText := 'UPDATE ' + K_CMENDBGlobAttrsTable +
                       ' SET ' + PathFieldName + '=''' + PathFieldValue + ''', ' +
                                 K_CMENDBGTFNewFPath    + '='''', ' +
                                 K_CMENDBGTFCopiedFNum  + '=0, ' +
                                 K_CMENDBGTFCopiedFSize + '=0, ' +
                                 K_CMENDBGTFNewFProvID  + '=-1;'
        else
          CommandText := 'UPDATE ' + K_CMENDBLocsFAccessTable +
                       ' SET ' + PathFieldName + '=''' + PathFieldValue + ''', ' +
                                 K_CMENDBLFALocNewFPath       + '='''', ' +
                                 K_CMENDBLFALocNewFCopiedNum  + '=0, ' +
                                 K_CMENDBLFALocNewFCopiedSize + '=0, ' +
                                 K_CMENDBLFALocNewFProvID     + '=-1 ' +
                       ' WHERE ' + K_CMENDBLFALocID + '=' + IntToStr(CurLocID);
        Execute;
        N_Dump1Str( 'EDASetFilesPathInfo>> by SQL :' + CommandText );
      end;
{
      with CurDSet1 do
      begin
        Connection := LANDBConnection;
        if not K_CMEnterpriseModeFlag then
        // Use Context from Global Attrs Table in Ordinary Mode
          SQL.Text := 'select ' +
            PathFieldName + ',' + K_CMENDBGTFNewFPath + ',' +
            K_CMENDBGTFCopiedFNum + ',' + K_CMENDBGTFCopiedFSize + ',' +
            K_CMENDBGTFNewFProvID +
            ' from ' + K_CMENDBGlobAttrsTable
        else
        // Use Context from Location Files Access Table in Enterprise Mode
          SQL.Text := 'select ' +
            PathFieldName + ',' + K_CMENDBLFALocNewFPath + ',' +
            K_CMENDBLFALocNewFCopiedNum + ',' + K_CMENDBLFALocNewFCopiedSize + ',' +
            K_CMENDBLFALocNewFProvID +
            ' from ' + K_CMENDBLocsFAccessTable +
            ' where ' + K_CMENDBLFALocID + '=' + IntToStr(CurLocID);

        Filtered := false;
        Open;
        Edit;
        EDAPutStringFieldValue( FieldList.Fields[0], PathFieldValue );
        FieldList.Fields[1].AsString := '';
        FieldList.Fields[2].AsInteger := 0;
        TLargeintField(FieldList.Fields[3]).AsLargeint := 0;
        FieldList.Fields[4].AsInteger := -1;
        UpdateBatch;
        Close;
      end;

      LANDBConnection.CommitTrans();
}
      EDAClearSlidesCRFC();
    end
    else
    begin
      // *** Client Media Files Context
      if SlidesCRFC.MovingFSDDescr = 3 then
        SlidesClientMediaRootFolder := SlidesCRFC.RootFolder;
      EDAClearSlidesCRFC();
      EDASaveFilesMovingInfo();
    end;
    //
    // end of Change and Save Files Context
    ///////////////////////////////////
    N_Dump2Str('DB>>  Set Files Info fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDASetFilesPathInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASetFilesPathInfo

//**************************** TK_CMEDDBAccess.EDASaveCurFilePathsInfoToDB ***
// Save Current File Paths Info to DB
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASaveCurFilePathsInfoToDB(): TK_CMEDResult;
begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;


  N_Dump1Str( format( 'DB>> EDASaveCurFilePathsInfoToDB: Img=%s Video=%s Img3D=%s',
              [SlidesImgRootFolder,SlidesMediaRootFolder,SlidesImg3DRootFolder] ) );

  try
    ///////////////////////////////////
    // Change and Save Files Context
    //
      // *** Server to Server ImgFiles, MediaFiles or Img3D Context
    with CurSQLCommand1 do
    begin
      CommandText := 'UPDATE ' + K_CMENDBGlobAttrsTable +
                     ' SET ' + K_CMENDBGTFImgFPath   + '=''>' + K_CMDBFilePathPrepStr(SlidesImgRootFolder)   + ''', ' +
                               K_CMENDBGTFMediaFPath + '=''>' + K_CMDBFilePathPrepStr(SlidesMediaRootFolder) + ''', ' +
                               K_CMENDBGTFImg3DFPath + '=''>' + K_CMDBFilePathPrepStr(SlidesImg3DRootFolder) + ''';';
      Execute;
      N_Dump1Str( 'EDASaveCurFilePathsInfoToDB>> by SQL :' + CommandText );
    end;
{
    LANDBConnection.BeginTrans;
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBLock;
      Connection := LANDBConnection;
      CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
      Execute;
    end;

    with CurDSet1 do
    begin
      Connection := LANDBConnection;
//      if not K_CMEnterpriseModeFlag then
      // Use Context from Global Attrs Table in Ordinary Mode
        SQL.Text := 'select ' +
          K_CMENDBGTFImgFPath   + ',' +
          K_CMENDBGTFMediaFPath + ',' +
          K_CMENDBGTFImg3DFPath +
          ' from ' + K_CMENDBGlobAttrsTable;

      Filtered := false;
      Open;
      Edit;
      // Means MediaSplit False and Direct Access for all path
      EDAPutStringFieldValue( Fields[0], '>' + SlidesImgRootFolder );
      EDAPutStringFieldValue( Fields[1], '>' + SlidesMediaRootFolder );
      EDAPutStringFieldValue( Fields[2], '>' + SlidesImg3DRootFolder );
      UpdateBatch;
      Close;
    end;

//    LANDBConnection.CommitTrans();
    //
    // end of Change and Save Files Context
    ///////////////////////////////////
}
    N_Dump2Str('DB>> EDASaveCurFilePathsInfoToDB fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDASaveCurFilePathsInfoToDB ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASetFilesPathInfo

//********************************************* TK_CMEDDBAccess.EDACheckNextSlideFiles ***
// Check Next Image Files
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDACheckNextSlideFiles(): TK_CMEDResult;
var
  ImgFPath: string;

  procedure CheckFileOrPath(AFName: string; APathFlag : Boolean = FALSE);
  begin
    Result := EDAPathOrFileExists(AFName, SlidesCRFC.RootFDA, APathFlag);
    if Result <> K_edFails then
      Inc(SlidesCRFC.CopiedFNum)
    else
      ExtDataErrorString := AFName;
  end;

begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>>  Check files P=' + SlidesCRFC.RootFolder + format
      (' N=%d ', [SlidesCRFC.CopiedFNum]));
  try

    with CurSlidesDSet do
    begin
      Result := K_edFails;
      CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1,
          N_UDCMSlideCI));
      ExtDataErrorString := '';
      while not Eof do
      begin
        with CurSlide, P^ do
        begin
          ObjName := FieldList.Fields[0].AsString;
          CMSPatId := FieldList.Fields[2].AsInteger;
          CMSDTCreated := TDateTimeField(FieldList.Fields[3]).Value;
          K_CMEDAGetSlideSysFieldsData(FieldList.Fields[1].AsString, @CMSDB );
          if ((cmsfIsMediaObj in CMSDB.SFlags) <> SlidesCRFC.MediaFCopy) or
             ((cmsfIsImg3DObj in CMSDB.SFlags) <> SlidesCRFC.Img3DFCopy) then
          begin
            Next;
            Continue;
          end;
          Result := K_edOK;
          ImgFPath := SlidesCRFC.RootFolder + GetFilesPathSegm;
          if SlidesCRFC.MediaFCopy then
          begin
            // Check Slide Media Files
            CheckFileOrPath(GetMediaFileName(ImgFPath));
            if (Result = K_edFails) and SlidesCRFC.MediaFSplit then
            begin
              Result := K_edOK;
              CheckFileOrPath(GetMediaFileNamePref(ImgFPath) + '_0.mfp');
            end;
          end
          else
          if SlidesCRFC.Img3DFCopy then
            // Check Slide 3D Image Folder
            CheckFileOrPath( GetImg3DFolderName( ImgFPath ), TRUE )
          else
          begin
            // Check Slide CurImage and SrcImage Files
            if (K_CMEDDBVersion >= 24) and (FieldList.Fields[4].AsInteger < 0) then
              CheckFileOrPath( ImgFPath + K_CMStudyGetFileName( ObjName ))
            else
            begin
              CheckFileOrPath(GetCurImgFileName(ImgFPath));
              if (Result = K_edOK) and (cmsfHasSrcImg in CMSDB.SFlags) then
                CheckFileOrPath(GetSrcImgFileName(ImgFPath));
            end;
          end;
        end; // end of with CurSlide, P^ do
        Next;
        break;
      end; // end of while not Eof do
      FreeAndNil(CurSlide);
    end;
    N_Dump2Str('DB>>  Check files fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDACheckNextSlideFiles ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDACheckNextSlideFiles

//********************************************* TK_CMEDDBAccess.EDAClearFilesMovingInfo ***
// Clear Files Moving Info
//
//     Parameters
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAClearFilesMovingInfo(): TK_CMEDResult;
begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>>  Clear Files Mooving');

  try
    ///////////////////////////////////
    // Clear Files Moving Context
    //
    if SlidesCRFC.MovingFSDDescr = 0 then
    begin
      // *** Server to Server ImgFiles or MediaFiles Context


      with CurSQLCommand1 do
      begin
        ExtDataErrorCode := K_eeDBUpdate;
        Connection := LANDBConnection;
        if not K_CMEnterpriseModeFlag then
          CommandText := 'UPDATE ' + K_CMENDBGlobAttrsTable +
                       ' SET ' + K_CMENDBGTFNewFPath    + '='''', ' +
                                 K_CMENDBGTFCopiedFNum  + '=0, ' +
                                 K_CMENDBGTFCopiedFSize + '=0, ' +
                                 K_CMENDBGTFNewFProvID  + '=-1;'
        else
          CommandText := 'UPDATE ' + K_CMENDBLocsFAccessTable +
                       ' SET ' + K_CMENDBLFALocNewFPath       + '='''', ' +
                                 K_CMENDBLFALocNewFCopiedNum  + '=0, ' +
                                 K_CMENDBLFALocNewFCopiedSize + '=0, ' +
                                 K_CMENDBLFALocNewFProvID     + '=-1 ' +
                       ' WHERE ' + K_CMENDBLFALocID + '=' + IntToStr(CurLocID);
        Execute;
      end;
{
      LANDBConnection.BeginTrans;
      with CurSQLCommand1 do
      begin
        ExtDataErrorCode := K_eeDBLock;
        Connection := LANDBConnection;
        CommandText := 'LOCK TABLE ' + K_CMENDBAAInstsTable + ' IN EXCLUSIVE MODE;';
        Execute;
      end;

      with CurDSet1 do
      begin
        Connection := LANDBConnection;
        if not K_CMEnterpriseModeFlag then
        // Use Context from Global Attrs Table in Ordinary Mode
          SQL.Text := 'select ' +
            K_CMENDBGTFNewFPath + ',' + K_CMENDBGTFCopiedFNum + ',' +
            K_CMENDBGTFCopiedFSize + ',' + K_CMENDBGTFNewFProvID +
            ' from ' + K_CMENDBGlobAttrsTable
        else
        // Use Context from Location Files Access Table in Enterprise Mode
          SQL.Text := 'select ' +
            K_CMENDBLFALocNewFPath + ',' + K_CMENDBLFALocNewFCopiedNum + ',' +
            K_CMENDBLFALocNewFCopiedSize + ',' + K_CMENDBLFALocNewFProvID +
            ' from ' + K_CMENDBLocsFAccessTable +
            ' where ' + K_CMENDBLFALocID + '=' + IntToStr(CurLocID);
        Filtered := false;
        Open;
        Edit;
        FieldList.Fields[0].AsString := '';
        FieldList.Fields[1].AsInteger := 0;
        TLargeintField(FieldList.Fields[2]).AsLargeint := 0;
        FieldList.Fields[3].AsInteger := -1;
        UpdateBatch;
        Close;

      end;

      LANDBConnection.CommitTrans();
}
      EDAClearSlidesCRFC();
    end
    else
    begin
      // *** Client Media Files Context
      EDAClearSlidesCRFC();
      EDASaveFilesMovingInfo();
    end;
    //
    // end of Change and Save Files Context
    ///////////////////////////////////
    N_Dump2Str('DB>>  Clear Files Mooving fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAClearFilesMovingInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAClearFilesMovingInfo

//********************************************* TK_CMEDDBAccess.EDAConfigGetInfo ***
// Get Media Files Configuration Info
//
//     Parameters
// AInfoFName - file name for Media Files Configuration Info
//
procedure TK_CMEDDBAccess.EDAConfigGetInfo(const AInfoFName: string);
var
  SInfo: TStringList;
  ResCode: TK_CMEDResult;

  procedure SaveInfo();
  begin
    K_ForceFilePath(AInfoFName);
    SInfo.SaveToFile(AInfoFName);
  end;

  procedure AddClientVideoInfo();
  begin
    SInfo.Add('VideoClientFolder=');
    SInfo.Add('VideoStoreMode=');
    N_Dump2Str('GMFC>> Put Client Info ');
  end;

begin

  // Remove Emergency Cache Files while CMS upgrading
  K_DeleteFolderFiles(K_ExpandFileName('(#CMECacheFiles#)'));

  SInfo := TStringList.Create;
  try
    K_CMSLiRegCheckBuild := false;
    ResCode := EDACheckDBConnection(LANDBConnection, false);
    if ResCode <> K_edOK then
      Exit;
    N_Dump2Str('GMFC>> Info File ' + AInfoFName);
    SInfo.Add('[Config]');
    if SlidesImgRootFolder = '' then
    begin
      SInfo.Add('ImgServerFolder=');
      SInfo.Add('ImgServerDirectAccess=');
      SInfo.Add('VideoServerFolder=');
      SInfo.Add('VideoServerDirectAccess=');
      N_Dump2Str('GMFC>> Put Server Info ');
      AddClientVideoInfo();
    end
    else
    begin
      //////////////////////////////////
      // Instance Ini Context
      ResCode := EDAOneAppContextToMemIni(Ord(K_actGInstIni), ClientAppGlobID, 0,
        'Instance|Load');
      if ResCode = K_edOK then
      begin
        if N_MemIniToString('CMS_Main', 'CMMediaFiles', '') = '' then
          AddClientVideoInfo();
      end;
    end;
  finally
    SaveInfo();
    SInfo.Free;
  end;

end; // end of TK_CMEDDBAccess.EDAConfigGetInfo

//********************************************* TK_CMEDDBAccess.EDAConfigSetInfo ***
// Set Media Files Configuration Info
//
//     Parameters
// AInfoFName - file name for Media Files Configuration Info
//
procedure TK_CMEDDBAccess.EDAConfigSetInfo(const AInfoFName: string);
var
  SInfo: TStringList;
  ParInd: Integer;
  SaveContext: Boolean;
  ResCode: TK_CMEDResult;
  VideoStoreMode, SlidesCount: Integer;
  ClientVideoPath: string;

begin
  // Remove Emergency Cache Files while CMS upgrading
  K_DeleteFolderFiles(K_ExpandFileName('(#CMECacheFiles#)'));

  N_Dump1Str('SMFC>> start ' + AInfoFName);
  if not FileExists(AInfoFName) then
  begin
    N_Dump1Str('SMFC>> Info file not found ');
    Exit;
  end;

  SInfo := TStringList.Create;
  SInfo.LoadFromFile(AInfoFName);
  try
    N_Dump1Str('SMFC>> Info file ' + AInfoFName + #13#10
        + SInfo.Text);
    if SInfo[0] <> '[Config]' then
      N_Dump1Str('SMFC>> Wrong file format')
    else
    begin // Proper File Format
      // Change DSN code should be placed here
      //    ParInd := SInfo.IndexOfName('DSN');
      //    if ParInd >= 0 then
      //    begin
      //      DSN := SInfo.ValueFromIndex[ParInd];
      //      N_Dump1Str('SMFC>> DSN=' + ...);
      //      N_StringToMemIni( 'CMSDB', 'DSN', DSN );
      //    Save Ini File
      //    end;
      //
      //

      K_CMSLiRegCheckBuild := false;
      ResCode := EDACheckDBConnection(LANDBConnection, false);
      if ResCode <> K_edOK then
        N_Dump1Str('SMFC>> DB Connection Error =' + IntToStr(Ord(ResCode)))
      else
      begin // DB Connection is Opened
{
        if K_CMEnterpriseModeFlag then
        begin
          N_Dump2Str('SMFC>> Should be run not in Enterprise Mode' );
          Exit;
        end;
}
        // Check if DB is Empty
        with CurDSet1 do
        begin
          Connection := LANDBConnection;
          ExtDataErrorCode := K_eeDBSelect;
          Filtered := false;
          SQL.Text := 'select Count(*) from ' + K_CMENDBSlidesTable;
          Open;
          SlidesCount := FieldList.Fields[0].AsInteger;
          Close;
        end;


        if SlidesCount = 0 then
        begin // Empty Data Base
        //////////////////////////
        // Image files Server info
        //
          SlidesCRFC.MediaFCopy := false;
          SlidesCRFC.Img3DFCopy := false;
          ParInd := SInfo.IndexOfName('ImgServerFolder');
          SlidesCRFC.RootFolder := '';
          if ParInd >= 0 then
          begin
            SlidesCRFC.RootFolder := SInfo.ValueFromIndex[ParInd];
            N_Dump1Str('SMFC>> ImgServerFolder=' + SlidesCRFC.RootFolder)
          end;

          ParInd := SInfo.IndexOfName('ImgServerDirectAccess');
          SlidesCRFC.RootFDA := TRUE;
          if ParInd >= 0 then
            SlidesCRFC.RootFDA := SInfo.ValueFromIndex[ParInd] = '1';
          N_Dump1Str('SMFC>> ImgServerDirectAccess=' + N_B2S( SlidesCRFC.RootFDA ));
          EDASetFilesPathInfo();

        //////////////////////////
        // Video files Server info
        //
          SlidesCRFC.MediaFCopy := TRUE;
          ParInd := SInfo.IndexOfName('VideoServerFolder');
          SlidesCRFC.RootFolder := '';
          if ParInd >= 0 then
          begin
            SlidesCRFC.RootFolder := SInfo.ValueFromIndex[ParInd];
            N_Dump1Str('SMFC>> VideoServerFolder=' + SlidesCRFC.RootFolder)
          end;
          ParInd := SInfo.IndexOfName('VideoServerDirectAccess');
          SlidesCRFC.RootFDA := TRUE;
          if ParInd >= 0 then
            SlidesCRFC.RootFDA := SInfo.ValueFromIndex[ParInd] = '1';
          N_Dump1Str('SMFC>> VideoServerDirectAccess=' + N_B2S(SlidesCRFC.RootFDA));
//          SlidesCRFC.MediaFSplit := not SlidesCRFC.RootFDA;
          SlidesCRFC.MediaFSplit := FALSE;
          EDASetFilesPathInfo();

        //////////////////////////
        // Img3D files Server info
        //
          SlidesCRFC.MediaFCopy := FALSE;
          SlidesCRFC.Img3DFCopy := TRUE;
          ParInd := SInfo.IndexOfName('Img3DServerFolder');
          SlidesCRFC.RootFolder := '';
          if ParInd >= 0 then
          begin
            SlidesCRFC.RootFolder := SInfo.ValueFromIndex[ParInd];
            N_Dump1Str('SMFC>> Img3DServerFolder=' + SlidesCRFC.RootFolder)
          end;
          if SlidesCRFC.RootFolder <> '' then
            EDASetFilesPathInfo();


        /////////////////////////////////
        // Video files Client Store info
        //
          SaveContext := FALSE;
          ClientVideoPath := '';
          ParInd := SInfo.IndexOfName('VideoClientFolder');
          if ParInd >= 0 then
          begin
            ClientVideoPath := SInfo.ValueFromIndex[ParInd];
            if ClientVideoPath <> '' then
              SaveContext := TRUE;
          end;

          VideoStoreMode := -1;
          ParInd := SInfo.IndexOfName('VideoStoreMode');
          if ParInd >= 0 then
          begin
            VideoStoreMode := StrToIntDef(SInfo.ValueFromIndex[ParInd], -1);
            if (VideoStoreMode >= 0) and (VideoStoreMode <= 2) then
              SaveContext := TRUE;
          end;

          if SaveContext then
          begin
            ResCode := EDAOneAppContextToMemIni(Ord(K_actGInstIni), ClientAppGlobID, 0,
              'Instance|Load');
            if ResCode <> K_edOK then
              N_Dump1Str('SMFC>> Get Instance context Error =' + IntToStr
                  (Ord(ResCode)))
            else
            begin // Change Instance Ini Context
              // Set Video Client Folder and Video Store Mode
              if ClientVideoPath <> '' then
              begin
                SlidesClientMediaRootFolder := ClientVideoPath;
                N_Dump1Str('SMFC>> VideoClientFolder=' + ClientVideoPath);
              end;

              if (VideoStoreMode >= 0) and (VideoStoreMode <= 2) then
              begin
                K_CMMediaFilesStoringMode := VideoStoreMode;
                N_Dump1Str('SMFC>> VideoStoreMode=' + IntToStr(VideoStoreMode));
              end;

              EDASaveContextsData([K_cmssSkipSlides, K_cmssSkipInstanceBinInfo,
                K_cmssSkipGlobalInfo, K_cmssSkipPatientInfo,
                K_cmssSkipProviderInfo, K_cmssSkipLocationInfo,
                K_cmssSkipExtIniInfo]);
            end; // end of Change Instance Ini Context
          end; // if SaveContext then

        end // Empty Data Base
        else
          N_Dump1Str( format( 'SMFC>> CMS DB contains %d objects', [SlidesCount] ) );


      end; // DB Connection is Opened
    end; // Proper File Format
  finally
    SInfo.Free;
  end; // try

  N_Dump2Str('SMFC>> fin ' );

end; // end of TK_CMEDDBAccess.EDAConfigSetInfo

{ //!!SkipOldReg
  //******************************************** TK_CMEDDBAccess.EDAGetLicenseKeyInfo ***
  // Set License Key Info
  //
  //    Parameters
  // ADataSet - License Key Data Set
  // AField   - License Key Field
  // Result - Returns operation resulting code
  //
  function TK_CMEDDBAccess.EDASetLicenseKeyInfo( APData : Pointer; ADataSize : Integer ): TK_CMEDResult;
  begin

  Result := EDACheckDBConnection( LANDBConnection );
  if Result <> K_edOK then Exit;

  N_Dump2Str( 'DB>> Set License Key Info' );

  try
  with CurDSet1 do begin
  Connection := LANDBConnection;
  ExtDataErrorCode := K_eeDBSelect;
  SQL.Text := 'select ' +  K_CMENDBGTFDBVersion + ',' + K_CMENDBGTFRegInfo +
  ' from ' + K_CMENDBGlobAttrsTable;
  Filtered := false;
  Open;
  Edit;
  BlobEncParams.DFEncryptionType := K_dfeEncr1; // Set Encryption Flag
  Result := EDAPutBlobFieldValue( CurDSet1, FieldList.Fields[1], APData, ADataSize );
  BlobEncParams.DFEncryptionType := K_dfePlain; // Clear Encryption Flag
  if Result = K_edOK then
  UpdateBatch();
  EDAGetLicenseKeyInfo( CurDSet1, FieldList.Fields[1] );
  Close;
  end;
  except
  on E: Exception do begin
  Result := K_edExDataError;
  ExtDataErrorString := E.Message;
  EDAShowErrMessage( true );
  Exit;
  end;
  end;

  end; // end of TK_CMEDDBAccess.EDASetLicenseKeyInfo

  //******************************************** TK_CMEDDBAccess.EDAGetLicenseKeyInfo ***
  // Get License Key Info
  //
  //    Parameters
  // ADataSet - License Key Data Set
  // AField   - License Key Field
  // Result - Returns operation resulting code
  //
  function TK_CMEDDBAccess.EDAGetLicenseKeyInfo( ADataSet : TDataSet; AField : TField ): TK_CMEDResult;
  var
  PData : Pointer;
  DataSize : Integer;
  BufStr : string;
  WMemIniFile : TMemIniFile;
  begin

  Result := EDACheckDBConnection( LANDBConnection );
  if Result <> K_edOK then Exit;

  N_Dump2Str( 'DB>> Get License Key Info' );

  try
  BlobEncParams.DFEncryptionType := K_dfeEncr1; // Set Encryption Flag
  Result := EDAGetBlobFieldValue( ADataSet, AField, PData, DataSize );
  ContMemIni.Clear;
  if Result = K_edOK then begin
  if DataSize > 0 then begin
  SetLength( BufStr, DataSize );
  Move( PData^, BufStr[1], DataSize );
  TmpStrings.Text := BufStr;
  ContMemIni.SetStrings(TmpStrings);
  end;
  end;
  BlobEncParams.DFEncryptionType := K_dfePlain; // Clear Encryption Flag

  // Get Licensing Info
  WMemIniFile := N_CurMemIni;
  N_CurMemIni := ContMemIni;

  K_CMSLiCommonBuildInfo := N_MemIniToString( 'CMSLiCommon', 'BuildInfo', N_CMSVersion );
  K_CMSLiCommonKeyDate   := N_MemIniToDbl( 'CMSLiCommon', 'KeyDate', 0 );
  K_CMSLiCommonDBSIDCode := N_MemIniToString( 'CMSLiCommon', 'DBSIDCode', '' );
  K_CMSLiCommonDBRegCode := N_MemIniToString( 'CMSLiCommon', 'DBRegCode', '' );

  K_CMSLiCommonLiNum     := N_MemIniToInt( 'CMSLiCommon', 'CLiNum', -1 );
  K_CMSLiCommonTwainNum  := N_MemIniToInt( 'CMSLiCommon', 'TwainNum', -1 );
  K_CMSLiCommonOtherNum  := N_MemIniToInt( 'CMSLiCommon', 'OtherNum', -1 );
  K_CMSLiCommonVideoNum  := N_MemIniToInt( 'CMSLiCommon', 'VideoNum', -1 );

  if K_CMSLiTwainDevList = nil then
  K_CMSLiTwainDevList := TStringList.Create; // Licesed Twain Device List
  N_MemIniToStrings( 'CMSLiTwainDevList', K_CMSLiTwainDevList );

  if K_CMSLiOtherDevList = nil then
  K_CMSLiOtherDevList := TStringList.Create; // Licesed Other Device List
  N_MemIniToStrings( 'CMSLiOtherDevList', K_CMSLiOtherDevList );

  if K_CMSLiVideoDevList = nil then
  K_CMSLiVideoDevList := TStringList.Create; // Licesed Video Device List
  N_MemIniToStrings( 'CMSLiVideoDevList', K_CMSLiVideoDevList );
  N_CurMemIni := WMemIniFile;

  //*** Compare CMS Version
  if (K_CMSLiRegState = K_lrsOK) and
  not CompareMem( @N_CMSVersion[1], @K_CMSLiCommonBuildInfo[1], 4 ) then begin
  K_CMSLiRegState := K_lrsVerTrial;
  //        K_CMSLiRegState := K_lrsVerTrialExpired;
  end;

  except
  on E: Exception do begin
  Result := K_edExDataError;
  ExtDataErrorString := E.Message;
  EDAShowErrMessage( true );
  Exit;
  end;
  end;

  end; // end of TK_CMEDDBAccess.EDAGetLicenseKeyInfo
}

//********************************************* TK_CMEDDBAccess.EDAAddRegInfoStrings ***
// Add DB Registration Info to given Strings
//
//     Parameters
// AMacroStrings - Resultings Strings to add
// Result - Returns operation resulting code
//
// CS Contact Info is returned via K_CMSLiRegTrialExpiredInfo
//
function TK_CMEDDBAccess.EDAAddRegInfoStrings(AMacroStrings: TStrings)
  : TK_CMEDResult;
var
  SVal: string;
begin

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  N_Dump2Str('DB>> Get Licensing Info');

  with CurBlobDSet do
  begin
    Connection := LANDBConnection;
    try
      SQL.Text := 'begin' + Chr($0A) + 'select secadm.sec_make_own_code();' +
        Chr($0A) + 'end';
      Filtered := false;
      Open;
      SVal := FieldList.Fields[0].AsString;
      N_Dump1Str( 'secadm.sec_make_own_code=' + SVal );
//      N_LCAdd(N_CMSDump1LCInd,
//        'secadm.sec_make_own_code=' + FieldList.Fields[0].AsString);
      if SVal = '' then
        SVal := '??????'; // Because of Kutukov Error
      Close;
    except
      on E: Exception do begin
        SVal := '!!!!!!';
        N_Dump1Str( 'secadm.sec_make_own_code >> Exception >> ' + E.Message );
      end;
    end;
    AMacroStrings.Add('ID=' + SVal);

    if K_CMSLiRegState = K_lrsDBTrial then
    begin
      try
        SQL.Text := 'begin' + Chr($0A) +
          'select secadm.sec_get_trial_minutes();' + Chr($0A) + 'end';
        Open;
        SVal := FieldList.Fields[0].AsString;
        N_Dump1Str( 'secadm.sec_get_trial_minutes=' + SVal );
//        N_LCAdd(N_CMSDump1LCInd,
//          'secadm.sec_get_trial_minutes=' + FieldList.Fields[0].AsString);
        AMacroStrings.Add('TM=' + K_CMSFormatTrialPeriod(FieldList.Fields[0].AsInteger));
        Close;
      except
        on E: Exception do begin
          N_Dump1Str( 'secadm.sec_get_trial_minutes >> Exception >> ' + E.Message );
        end;
      end;
    end;

    try
      SQL.Text := 'begin' + Chr($0A) + 'select secadm.sec_get_licount();' +
                  Chr($0A) + 'end';
      Open;
      SVal := FieldList.Fields[0].AsString;
      N_Dump1Str( 'secadm.secadm.sec_get_licount=' + SVal );
//      N_LCAdd(N_CMSDump1LCInd,
//        'secadm.sec_get_licount=' + FieldList.Fields[0].AsString);
      // if SVal = '-1' then SVal := '5';
      Close;
    except
      on E: Exception do begin
        SVal := '??';
        N_Dump1Str( 'secadm.sec_get_licount >> Exception >> ' + E.Message );
      end;
    end;
    AMacroStrings.Add('LI=' + SVal);

    try
      SQL.Text := 'begin' + Chr($0A) +
        'select secadm.sec_get_login_extra_param();' + Chr($0A) + 'end';
      Open;
      SVal := FieldList.Fields[0].AsString;
      N_Dump1Str( 'secadm.sec_get_login_extra_param=' + SVal );
//      N_LCAdd(N_CMSDump1LCInd,
//        'secadm.sec_get_login_extra_param=' + FieldList.Fields[0].AsString);
      K_CMSLiRegTrialExpiredInfo := SVal;
      Close;
    except
      on E: Exception do begin
        N_Dump1Str( 'secadm.sec_get_login_extra_param >> Exception >> ' + E.Message );
      end;
    end;
  end;
  N_Dump2Str('DB>> Get Licensing Info fin');

end; // end of TK_CMEDDBAccess.EDAAddRegInfoStrings

//********************************************* TK_CMEDDBAccess.EDASaveSlideToECache ***
// Save given Slide to Emergency Cache using given State Flags
//
//     Parameters
// AUDSlide - Slide to save
//
procedure TK_CMEDDBAccess.EDASaveSlideToECache(AUDSlide: TN_UDCMSlide);
begin
  AUDSlide.ECacheSave( AppRTID );
end; // end of TK_CMEDDBAccess.EDASaveSlideToECache

//********************************************* TK_CMEDDBAccess.EDAClearSlideECache ***
// Clear given Slide Emergency Cache Files
//
//     Parameters
// AUDSlide - Slide to Save
//
procedure TK_CMEDDBAccess.EDAClearSlideECache(AUDSlide: TN_UDCMSlide);
begin
  AUDSlide.ECacheClear( AppRTID );
end; // end of TK_CMEDDBAccess.EDAClearSlideECache


//********************************************* TK_CMEDDBAccess.EDAAddImportHistory ***
// Add New Import History Record
//
//     Parameters
// AImportID - new Import History Record ID
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAAddImportHistory(out AImportID: Integer)
  : TK_CMEDResult;
begin
  Result := K_edOK;
  if K_CMEDDBVersion < 9 then
    Exit;
  N_Dump2Str('DB>> Add Import History');
  try
    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBSelect;
      SQL.Text := 'select ' +
        K_CMENDBImportHTFID + ',' +  K_CMENDBImportHTFDate +
        ' from ' + K_CMENDBImportHistTable +
        ' order by ' + K_CMENDBImportHTFID + ' asc';
      Filtered := false;
      Open;
      if RecordCount > 0 then
      begin
        Last;
        AImportID := FieldList.Fields[0].AsInteger + 1;
      end
      else
        AImportID := 0;
      Insert;
      FieldList.Fields[0].Value := AImportID;
      TDateTimeField(FieldList.Fields[1]).Value := EDAGetSyncTimestamp();
      N_Dump1Str( 'DB>> New Import History ID=' + FieldList.Fields[0].AsString +
                  ' DT=' + FieldList.Fields[1].AsString );
      UpdateBatch();
      Close();
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAAddImportHistory ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAAddImportHistory

//********************************************* TK_CMEDDBAccess.EDAChangeImportInfo ***
// Change Last Import History Info
//
//     Parameters
// AImportID   - Import record ID to change
// AImportInfo - new import Info string to chage
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAChangeImportInfo(AImportID: Integer;
  const AImportInfo: string; ADumpFlag : Integer = 0): TK_CMEDResult;
var
  DumpInfo : string;
begin
  Result := K_edOK;
  if K_CMEDDBVersion < 9 then
    Exit;
  DumpInfo := format( 'DB>> Change Import History ID=%d Info=%s',
                       [AImportID,AImportInfo] );
  if ADumpFlag = 0 then
    N_Dump2Str(DumpInfo)
  else
    N_Dump1Str(DumpInfo);
    
  try
    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBSelect;
      SQL.Text := 'select ' +
        K_CMENDBImportHTFID + ',' + K_CMENDBImportHTFInfo +
        ' from ' + K_CMENDBImportHistTable +
        ' where ' + K_CMENDBImportHTFID + '=' + IntToStr(AImportID);
      Filtered := false;
      Open;
      Result := K_edFails;
      if RecordCount > 0 then
      begin
        Result := K_edOK;
        Edit;
        FieldList.Fields[1].Value := AImportInfo;
        UpdateBatch();
      end;
      Close();
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAChangeImportInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAChangeImportInfo

//********************************************* TK_CMEDDBAccess.EDAGetLastImportHistory ***
// Get Last Import History Record
//
//     Parameters
// AImportID - resulting Import Record ID
// AImportDate - resulting Import Date
// AImportInfo - resulting Import Info
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetLastImportHistory( out AImportID: Integer;
  out AImportDate: TDateTime; out AImportInfo: string ): TK_CMEDResult;
begin
  N_Dump2Str('DB>> Get Last Import History');
  AImportID := -1;
  AImportInfo := '';
  try
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBDel;
      CommandText := 'DELETE FROM ' + K_CMENDBImportHistTable + ' WHERE ' +
        K_CMENDBImportHTFInfo + ' IS NULL;';
      Execute;
    end;

    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBSelect;
      SQL.Text := 'select ' +
        K_CMENDBImportHTFID + ',' + K_CMENDBImportHTFDate + ',' +
        K_CMENDBImportHTFInfo +
        ' from ' + K_CMENDBImportHistTable +
        ' order by ' + K_CMENDBImportHTFID + ' asc';
      Filtered := false;
      Open;
      Result := K_edFails;
      if RecordCount > 0 then
      begin
        Result := K_edOK;
        Last;
        AImportID := FieldList.Fields[0].AsInteger;
        AImportDate := TDateTimeField(FieldList.Fields[1]).AsDateTime;
        AImportInfo := EDAGetStringFieldValue(FieldList.Fields[2]);
        N_Dump1Str('DB>> GetLast Import History ID=' + FieldList.Fields[0].AsString +
                   ' DT=' + FieldList.Fields[1].AsString + ' Info=' +  AImportInfo);
      end;
      Close();
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetLastImportHistory ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAGetLastImportHistory

//********************************************* TK_CMEDDBAccess.EDADeleteImportHistory ***
// Delete Import History Record given by ID
//
//     Parameters
// AImportID - import record ID to Delete
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDADeleteImportHistory(AImportID: Integer) : TK_CMEDResult;
var
  SImpID: string;
begin
  Result := K_edOK;
  if K_CMEDDBVersion < 9 then
    Exit;
  try
    ExtDataErrorCode := K_eeDBDel;
    SImpID := IntToStr(AImportID);
    with CurSQLCommand1 do
    begin
      N_Dump2Str('DB>> Delete Import History ID=' + SImpID);
      CommandText := 'DELETE FROM ' + K_CMENDBImportHistTable + ' WHERE ' +
        K_CMENDBImportHTFID + ' = ' + SImpID;
      Execute;
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDADeleteImportHistory ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDADeleteImportHistory

//********************************************* TK_CMEDDBAccess.EDAEMSetSlidesHLoc ***
// Save History Info for Slides given as SQL "WHERE" codition
//
//     Parameters
// ASQLStr - string with Slides SQL "WHERE" codition
// AHistActCode - History Action Code
//
// Result - Returns operation resulting code
//
// Save corresponding records to AllSlidesHistory Table with given Action Code
//
function TK_CMEDDBAccess.EDASaveSlidesHistory( const ASQLStr: string;
                                               AHistActCode: Integer ) : TK_CMEDResult;
var
  WStr : string;
  TS : TDateTime;
begin
  Result := K_edOK;
  if AHistActCode = -1 then Exit; // Skip Internal Wrk Action Code

  try
    with CurSQLCommand1 do
    begin
      if Connection = nil then Exit;
      // Add History
      if K_CMEDDBVersion < 13 then
      begin // Old History
        if ASQLStr = '' then Exit; // is needed before DBVersion 13 is not fully implemented
        CommandText :=
          'INSERT INTO ' + K_CMENDBSlidesHistTable +
          ' (' + K_CMENDBSlidesHTFSlideID + ',' +
                 K_CMENDBSlidesHTFProvID  + ',' +
                 K_CMENDBSlidesHTFActID   + ',' +
                 K_CMENDBSlidesHTFActTS   + ' )' +
           ' SELECT '+ K_CMENDBSTFSlideID + ',' +
                    IntToStr(CurProvID)   + ',' +
                    IntToStr(AHistActCode) +
                    ',GETDATE( )' +
           ' FROM ' + K_CMENDBSlidesTable + ' WHERE ' +  ASQLStr;
      end
      else
      begin // New History
{
        if ASQLStr <> '' then
          WStr :=
          'INSERT INTO ' + K_CMENDBSlidesNewHistTable +
          ' (' + K_CMENDBSlidesNHTFSlideID   + ',' +
                 K_CMENDBSlidesNHTFSessionID + ',' +
                 K_CMENDBSlidesNHTFActCode   + ',' +
                 K_CMENDBSlidesNHTFActTS     + ' )' +
            ' SELECT '+ K_CMENDBSTFSlideID   + ',' +
                IntToStr(CurSessionHistID)   + ',' +
                 IntToStr(AHistActCode)      + ',DATETIME(''' +
                     K_DateTimeToStr( EDAGetSyncTimestamp(), 'yyyy-mm-dd hh:nn:ss.zzz' ) + ''')'+
//                IntToStr(AHistActCode)       + ',GETDATE( )' +
           ' FROM ' + K_CMENDBSlidesTable +
           ' WHERE ' +  ASQLStr
        else
          WStr :=
          'INSERT INTO ' + K_CMENDBSlidesNewHistTable +
          ' (' + K_CMENDBSlidesNHTFSlideID   + ',' +
                 K_CMENDBSlidesNHTFSessionID + ',' +
                 K_CMENDBSlidesNHTFActCode   + ',' +
                 K_CMENDBSlidesNHTFActTS     + ' )' +
           ' VALUES ( 0,' +
                 IntToStr(CurSessionHistID)  + ',' +
                 IntToStr(AHistActCode)      + ',DATETIME(''' +
                     K_DateTimeToStr( EDAGetSyncTimestamp(), 'yyyy-mm-dd hh:nn:ss.zzz' ) + ''') )';
//                 IntToStr(AHistActCode)      + ',GETDATE( ) )';
}
        TS := EDAGetSyncTimestamp();
        if ((AHistActCode and $FF000000) shr 24) =
           ((Ord(K_shATNotChange) shl 4) + Ord(K_shNCAStartSession)) then
          CurSessionHistStartTS := TS;

        WStr := EDADBDateTimeToSQL( TS );
        if ASQLStr <> '' then
          WStr :=
          'INSERT INTO ' + K_CMENDBSlidesNewHistTable +
          ' (' + K_CMENDBSlidesNHTFSlideID   + ',' +
                 K_CMENDBSlidesNHTFSessionID + ',' +
                 K_CMENDBSlidesNHTFActCode   + ',' +
                 K_CMENDBSlidesNHTFActTS     + ' )' +
            ' SELECT '+ K_CMENDBSTFSlideID   + ',' +
                IntToStr(CurSessionHistID)   + ',' +
                IntToStr(AHistActCode)       + ',' + WStr +
           ' FROM ' + K_CMENDBSlidesTable +
           ' WHERE ' +  ASQLStr
        else
          WStr :=
          'INSERT INTO ' + K_CMENDBSlidesNewHistTable +
          ' (' + K_CMENDBSlidesNHTFSlideID   + ',' +
                 K_CMENDBSlidesNHTFSessionID + ',' +
                 K_CMENDBSlidesNHTFActCode   + ',' +
                 K_CMENDBSlidesNHTFActTS     + ' )' +
           ' VALUES ( 0,' +
                 IntToStr(CurSessionHistID)  + ',' +
                 IntToStr(AHistActCode)      + ',' + WStr + ')';
        CommandText := WStr;
      end;
{
INSERT INTO dba.AllObjHistory (AHObjID, AHSessionID, AHActCode, AHActTS )

VALUES ( 0, 0, 117440512, CAST('2017-12-08 10:47:58.008' as datetime))}
      Execute;
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDASaveSlidesHistory ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASaveSlidesHistory

//********************************************* TK_CMEDDBAccess.EDASaveSlidesListHistory ***
// Save History Info for Slides given as Slides List
//
//     Parameters
// APSlides - pointer to slides array start element to change Host Location
// ASlidesCount - number of slides to change Host Location
// AHistActCode - History Action Code
//
// Result - Returns operation resulting code
//
// Save corresponding records to AllSlidesHistory Table with given Action Code
//
function TK_CMEDDBAccess.EDASaveSlidesListHistory( APSlide: TN_PUDCMSlide;
                                                   ASlidesCount: Integer;
                                                   AHistActCode: Integer ) : TK_CMEDResult;
var
  SQLStr : string;

begin
  Result := K_edOK;
  if AHistActCode = -1 then Exit; // Skip Internal Wrk Action Code
  if K_CMEDDBVersion < 13 then
  begin
    EDABuildSelectSQLBySlidesList( APSlide, ASlidesCount, @SQLStr, nil );
// Add History
    Result := EDASaveSlidesHistory( SQLStr, AHistActCode );
  end
  else
  begin
    // Prep XML with Slected Slides
    Result := K_edOK;
    try
      EDABuildXMLBySlidesList( APSlide, ASlidesCount, '<record SlideID="%s" />', @SQLStr, nil );
      SQLStr := '<root>' + SQLStr + '</root>';

      // Exec Stored Procedure to Add Query Lements
      with CurStoredProc1 do
      begin
        Connection := LANDBConnection;
        ProcedureName := 'dba.cms_AddSlidesHistAct';
        Parameters.Clear;
        with Parameters.AddParameter do begin
          Name := '@SessionID';
          Direction := pdInput;
          DataType := ftInteger;
          Value := CurSessionHistID;
        end;
        with Parameters.AddParameter do begin
          Name := '@ActCode';
          Direction := pdInput;
          DataType := ftInteger;
          Value := AHistActCode;
        end;
        with Parameters.AddParameter do begin
          Name := '@xml_list';
          Direction := pdInput;
          DataType := ftString;
          Value := SQLStr;
        end;
        ExecProc;
      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorString := 'EDASaveSlidesListHistory ' + E.Message;
        EDAShowErrMessage(TRUE);
      end;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASaveSlidesListHistory

//********************************************* TK_CMEDDBAccess.EDAEMGetLocCaptsList ***
// Get Location Captions list
//
//     Parameters
// ALocList - Locations Captions and IDs List
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAEMGetLocCaptsList( ALocList : TStrings ) : TK_CMEDResult;
var
  i, RCount, LocID: Integer;
begin
  N_Dump2Str('DB>> EDAEMGetLocCaptsList');

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  CurDSet1.Connection := LANDBConnection;
  try
    ExtDataErrorCode := K_eeDBSelect;
    CurDSet1.SQL.Text := 'select ' +
      K_CMENDBLFALocID +
      ' from ' + K_CMENDBLocsFAccessTable;
    CurDSet1.Filtered := false;
    CurDSet1.Open;
    RCount := CurDSet1.RecordCount;
    CurDSet1.First;
    ALocList.Clear;
    with CurDSet1.FieldList do
      for i := 0 to RCount - 1 do
      begin
        LocID := Fields[0].AsInteger;
        ALocList.AddObject( K_CMGetLocationDetails( LocID ), TObject(LocID));
        CurDSet1.Next;
      end;
    CurDSet1.Close;
    N_Dump2Str('DB>> EDAEMGetLocCaptsList fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAEMGetLocCaptsList ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAEMGetLocCaptsList

//********************************************* TK_CMEDDBAccess.EDAEMSetSlidesHLoc ***
// Set new Host Location ID to given slides
//
//     Parameters
// APSlides - pointer to slides array start element to change Host Location
// ASlidesCount - number of slides to change Host Location
// ANewLockID - new Host Location ID to change
//
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAEMSetSlidesHLoc( APSlide: TN_PUDCMSlide;
               ASlidesCount: Integer; ANewHlocID: Integer ) : TK_CMEDResult;
var
//  i : Integer;
  SQLStr: string;
  LogStr: string;

begin
  Result := K_edOK;
  if ASlidesCount = 0 then Exit;

{
  SQLStr := '';
  LogStr := 'Slides IDs=';
  for i := 1 to ASlidesCount do
  begin
    with APSlide^, P^ do
    begin
      if SQLStr <> '' then
      begin
        SQLStr := SQLStr + ' or ';
        LogStr := LogStr + ','
      end;
      LogStr := LogStr + ObjName;
      SQLStr := SQLStr + K_CMENDBSTFSlideID + ' = ' + ObjName;
    end;
    Inc(APSlide);
  end;
}
  EDABuildSelectSQLBySlidesList( APSlide, ASlidesCount, @SQLStr, @LogStr );

  N_Dump2Str('DB>> EDAEMSetSlidesHLoc ' + LogStr);

  try
    LANDBConnection.BeginTrans;

    with CurSQLCommand1 do
    begin
      // Set HLocID
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBUpdate;
      CommandText := 'UPDATE ' + K_CMENDBSlidesTable +
        ' SET ' + K_CMENDBSTFSlideLocIDHost + ' = ' +  IntToStr(ANewHlocID) +
        ' WHERE ' +  SQLStr;
      Execute;
    end;
    // Add History
    EDASaveSlidesHistory( SQLStr, EDABuildHistActionCode(K_shATChange, Ord(K_shCAHLoc)) );

    LANDBConnection.CommitTrans(); // Suggested by Lopatin always use CommitTrans instead of Rollback)

    N_Dump2Str('DB>> EDAEMSetSlidesHLoc fin' );
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAEMSetSlidesHLoc ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAEMSetSlidesHLoc

//********************************************* TK_CMEDDBAccess.EDAEMDumpSFSyncSessionAttrs ***
// Dump files syncronizatio session attributes
//
//     Parameters
// AInfo -  Sync Session Info string to Dump
//
procedure TK_CMEDDBAccess.EDAEMDumpSFSyncSessionAttrs( const AInfo : string );
begin
  N_Dump1Str( 'DB >>' + AInfo + 'FSyncSession: ' +
     ' Start=' + K_DateTimeToStr( SyncSessionStartTS, 'hh":"nn":"ss' ) +
     ' Fin=' + K_DateTimeToStr( SyncSessionFinTS, 'hh":"nn":"ss' ) +
     ' Flags=' + IntToStr(SyncSessionFlags) );
end; // procedure TK_CMEDDBAccess.EDAEMDumpSFSyncSessionAttrs

//********************************************* TK_CMEDDBAccess.EDAEMGetFSyncSessionAttrs ***
// Get Files Synchronization Session Start and Finish Timestamps
//
//     Parameters
// ASSStartTS -  Files Synchronization Session Start Timestamp
// ASSFinTS -  Files Synchronization Session Finish Timestamp
//
function TK_CMEDDBAccess.EDAEMGetFSyncSessionTime( out ASSStartTS, ASSFinTS : TDateTime ) : TDateTime;
begin
    // Build Current Sync Window
    Result := EDAGetSyncTimestamp();
    ASSStartTS := TimeOf(SyncSessionStartTS);
    ASSFinTS   := TimeOf(SyncSessionFinTS);
//    if ASSStartTS >= ASSFinTS then
    if ASSStartTS > ASSFinTS then
      ASSFinTS := ASSFinTS + 1; // Sect Correct End Time
    ASSStartTS := DateOf(Result) + ASSStartTS; // Current Sync Window Start Time
    ASSFinTS   := DateOf(Result) + ASSFinTS;   // Current Sync Window Fin Time
    if ASSFinTS - 1 > Result then // Cur Time is inside Real Sync Window
    begin // correct calculated Sync Window
      ASSStartTS := ASSStartTS - 1;
      ASSFinTS := ASSFinTS - 1;
    end;
end; // end of TK_CMEDDBAccess.EDAEMGetFSyncSessionTime

//********************************************* TK_CMEDDBAccess.EDAEMGetFSyncSessionAttrs ***
// Get Files Synchronization Session settings
//
//     Parameters
// Result -  Returns operation resulting code
//
function TK_CMEDDBAccess.EDAEMGetFSyncSessionAttrs( ): TK_CMEDResult;
begin
  Result := K_edOK;
  N_Dump2Str('DB>> EDAEMGetFSyncSessionAttrs start');
  try
    with CurBlobDSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SQL.Text := 'select ' +
        K_CMENDBGTFSSStartTS + ',' + K_CMENDBGTFSSFinTS + ',' +
        K_CMENDBGTFSSFlags +
        ' from ' + K_CMENDBGlobAttrsTable;
      Filtered := false;
      Open;
      SyncSessionStartTS := TDateTimeField(FieldList[0]).Value;
      SyncSessionFinTS   := TDateTimeField(FieldList[1]).Value;
      SyncSessionFlags   := FieldList[2].AsInteger;

      Close();
      N_Dump2Str('DB>> EDAEMGetFSyncSessionAttrs fin');
    end;
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeFilesPocessing;
      ExtDataErrorString := 'EDAEMGetFSyncSessionAttrs ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAEMGetFSyncSessionAttrs

//********************************************* TK_CMEDDBAccess.EDAEMSaveFSyncSessionAttrs ***
// Save Files Synchronization Session settings
//
//     Parameters
// Result -  Returns operation resulting code
//
function TK_CMEDDBAccess.EDAEMSaveFSyncSessionAttrs( ): TK_CMEDResult;
begin
  Result := K_edOK;
  N_Dump2Str('DB>> EDAEMSaveFSyncSessionAttrs start');
  try
{
    with CurSQLCommand1 do
    begin
      // Set HLocID
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBUpdate;
      CommandText := 'UPDATE ' + K_CMENDBGlobAttrsTable +
        ' SET ' +
          K_CMENDBGTFSSStartTS + ' = DATETIME(''' + K_DateTimeToStr(SyncSessionStartTS, 'yyyy-mm-dd  hh:nn:ss.zzz' ) + ''') ' +
          K_CMENDBGTFSSFinTS   + ' = DATETIME(''' + K_DateTimeToStr(SyncSessionFinTS, 'yyyy-mm-dd  hh:nn:ss.zzz' ) + ''') ' +
          K_CMENDBGTFSSFlags   + ' = ' +  format('%d ', [SyncSessionFlags] ) +
        ';';
      N_s := CommandText;
      Execute;
    end;
{}
{}
    with CurBlobDSet do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      Connection := LANDBConnection;

      SQL.Text := 'select ' +
        K_CMENDBGTFSSStartTS + ',' + K_CMENDBGTFSSFinTS + ',' +
        K_CMENDBGTFSSFlags +
        ' from ' + K_CMENDBGlobAttrsTable;
      Filtered := false;
      Open;
      Edit;
      TDateTimeField(FieldList[0]).Value := SyncSessionStartTS;
      TDateTimeField(FieldList[1]).Value := SyncSessionFinTS;
      FieldList[2].AsInteger := SyncSessionFlags;
      UpdateBatch();
      Close();
    end;
{}
    N_Dump2Str('DB>> EDAEMSaveFSyncSessionAttrs fin');
  except
    on E: Exception do
    begin
      Result := K_edExDataError;
      ExtDataErrorString := 'EDAEMSaveFSyncSessionAttrs ' + E.Message;
      EDAShowErrMessage(TRUE);
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAEMSaveFSyncSessionAttrs

//********************************** TK_CMEDDBAccess.EDAGetPatientsOrderSQL ***
// Get Patients order SQL clause
//
//     Parameters
// AOrderCode - order code:
//   -1 - no order
//    0 - CardNum ASC order
//    1 - CardNum DESC order
//    2 - Surname ASC order
//    3 - Surname DESC order
//    4 - FisrtName ASC order
//    5 - FisrtName DESC order
// Result - Returns Patients order SQL clause text
//
function TK_CMEDDBAccess.EDAGetPatientsOrderSQL( AOrderCode : Integer ) : string;
begin
  Result := '';
  case AOrderCode of
  0: Result := ' ORDER BY ' + K_CMENDAPCardNum + ' ASC';
  1: Result := ' ORDER BY ' + K_CMENDAPCardNum + ' DESC';
  2: Result := ' ORDER BY ' + K_CMENDAPSurname + ' ASC';
  3: Result := ' ORDER BY ' + K_CMENDAPSurname + ' DESC';
  4: Result := ' ORDER BY ' + K_CMENDAPFirstname + ' ASC';
  5: Result := ' ORDER BY ' + K_CMENDAPFirstname + ' DESC';
  end;
end; // end of TK_CMEDDBAccess.EDAGetPatientsOrderSQL

//********************************** TK_CMEDDBAccess.EDAGetPatientsWhereSQL ***
// Get Patients WHERE SQL clause
//
//     Parameters
// AShowDelFlag - if =0 then skip marked as deleted, =1 show marked as deleted,
//                =2 show both
// ACardNumLike - CardNumber like filter start string
// ASurnameLike - Surname like filter start string
// AFirstnameLike - Firstname like filter start string
// Result - Returns Patients order SQL clause text
//
function TK_CMEDDBAccess.EDAGetPatientsWhereSQL( AShowDelFlag : Integer;
                       const ACardNumLike, ASurnameLike, AFirstnameLike : string ) : string;
begin
  Result := ' WHERE (' + K_CMENDAPFlags;
  if AShowDelFlag = 0 then
    Result := Result + ' & 1) = 0'
  else if AShowDelFlag = 1 then
    Result := Result + ' & 1) = 1'
  else
    Result := Result + ' & 2) = 0';

  if ACardNumLike <> '' then
    Result := Result + ' AND ' + K_CMENDAPCardNum + ' LIKE ' + ACardNumLike + '%';

  if ASurnameLike <> '' then
    Result := Result + ' AND ' + K_CMENDAPSurname + ' LIKE ' + ASurnameLike + '%';

  if AFirstnameLike <> '' then
    Result := Result + ' AND ' + K_CMENDAPFirstname + ' LIKE ' + AFirstnameLike + '%';
end; // end of TK_CMEDDBAccess.EDAGetPatientsWhereSQL

//***************************** TK_CMEDDBAccess.EDAGetPatientsFilteredCount ***
// Get Patients Filtered Counter
//
//     Parameters
// AWhereSQL - Patients filtering WHERE SQL clause
// AResCount - Resulting Patients Counter
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetPatientsFilteredCount( const AWhereSQL : string;
                                  out AllPatCount : Integer ) :  TK_CMEDResult;
begin
  N_Dump2Str('DB>> EDAGetPatientsFilteredCount');

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  try
    ExtDataErrorCode := K_eeDBSelect;

    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      SQL.Text := 'select count(*) ' +
        ' from ' + K_CMENDBAllPatientsTable + AWhereSQL;

      Filtered := false;
      Open;
      AllPatCount := Fields[0].AsInteger;
      Close;
    end; // with CurDSet1 do
    N_Dump2Str('DB>> EDAGetPatientsFilteredCount fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetPatientsFilteredCount ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDAGetPatientsFilteredCount

//*********************************** TK_CMEDDBAccess.EDAWEBGetPatientsInfo ***
// Get filtered Patients Info in Stand alone mode
//
//     Parameters
// AWhereSQL   - if = TRUE then show marked as deleted flag
// AOrderSQL   - order code:
// AStartInd    - start record based zero index, if = 0 then all records buffer should be resized by all records count
// ACount       - get records number
// APatAttrsArr - resulting Patients Attributes Array
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAWEBGetPatientsInfo(
                       const AWhereSQL, AOrderSQL : string;
                       AStartInd : Integer; ACount : Integer;
                       out APatAttrsArr : TK_WCMSPatAttrsArr ) : TK_CMEDResult;
var
  i, RCount : Integer;
  SQLText : string;
begin
  N_Dump2Str('DB>> EDAWEBGetPatientsInfo');

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  try
    ExtDataErrorCode := K_eeDBSelect;

    with CurDSet1 do
    begin
      SQLText := '';
      if ACount > 0 then
        SQLText := ' TOP ' + IntToStr(ACount);
      if AStartInd > 0 then
        SQLText := SQLText + ' START AT ' + IntToStr(AStartInd + 1);

      SQLText := 'select ' + SQLText + ' ' +
        K_CMENDAPBridgeID + ',' + K_CMENDAPCardNum + ',' +  // 0 1
        K_CMENDAPFirstname + ',' + K_CMENDAPSurname + ',' + // 2 3
        K_CMENDAPMiddle + ',' + K_CMENDAPTitle + ',' +      // 4 5
        K_CMENDAPDOB +                                      // 6
        ' from ' + K_CMENDBAllPatientsTable + ',' + K_CMENDBGlobAttrsTable;

      SQL.Text := SQLText + AWhereSQL + AOrderSQL;
      Filtered := false;
      Open;
      RCount := RecordCount;

      N_Dump2Str('DB>> Patients Count=' + IntToStr(RCount));
      SetLength( APatAttrsArr, RCount );
      First;
      for i := 0 to RCount - 1 do
      begin
        APatAttrsArr[i].WCPatID        := Fields[0].AsInteger;
        APatAttrsArr[i].WCPatCardNum   := Fields[1].AsString;
        APatAttrsArr[i].WCPatFirstName := Fields[2].AsString;
        APatAttrsArr[i].WCPatSurname   := Fields[3].AsString;
        APatAttrsArr[i].WCPatMiddle    := Fields[4].AsString;
        APatAttrsArr[i].WCPatTitle     := Fields[5].AsString;
        APatAttrsArr[i].WCPatDOB       := Fields[6].AsDateTime;
        Next;
      end;
      Close;
    end;
    N_Dump2Str('DB>> EDAWEBGetPatientsInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAGetPatientsInfo1 ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAWEBGetPatientsInfo

//********************************************* TK_CMEDDBAccess.EDASAInitDBInfo ***
// Init Providers Info in Stand alone mode
//
//     Parameters
// AInitFlags - flags to init:
//#F
//   bit0 - =1 locations init flag
//   bit1 - =2 providers init flag
//   bit4 - =4 patients init flag
//#/F
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAInitDBInfo( AInitFlags : Integer ) : TK_CMEDResult;
begin
  N_Dump2Str('DB>> EDASAInitDBInfo');

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;
  try
{
    with CurSQLCommand1 do
    begin
      ExtDataErrorCode := K_eeDBSelect;
      if (K_CMEDDBVersion >= 21) then
        CommandText := format( 'select dba.cms_InitStandalone(%d);',[AInitFlags] )
      else
        CommandText := 'select cms_InitStandalone();';
      Execute;
    end;
{}
{}
    with CurStoredProc1 do
    begin
      Connection := LANDBConnection;
      ProcedureName := 'dba.cms_InitStandalone';

      Parameters.Clear;
      if K_CMEDDBVersion >= 21 then
        with Parameters.AddParameter do begin
          Name := '@mode';
          Direction := pdInput;
          DataType := ftInteger;
          Value := AInitFlags;
        end;
      ExecProc;
    end;
{}
    N_Dump2Str('DB>> EDASAInitDBInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAInitDBInfo ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAInitDBInfo

//********************************************* TK_CMEDDBAccess.EDASAGetLocationsInfo ***
// Get Locations Info in Stand alone mode
//
//     Parameters
// AShowDelFlag - if =TRUE then only marked as deleted are placed to ProvidersInfo
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAGetLocationsInfo( AShowDelFlag : Boolean ) : TK_CMEDResult;
var
  i, RCount: Integer;
  SQLText : string;
begin
  N_Dump2Str('DB>> EDASAGetLocationsInfo');

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  CurDSet1.Connection := LANDBConnection;
  try
    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
       SQLText := 'select ' +
        K_CMENDALID + ',' +                           // 0
        K_CMENDALName + ',' +                         // 1
        K_CMENDALBridgeID + ',' + K_CMENDBGTFSAFlags; // 2,3

       if K_CMEDDBVersion >= 33 then
         SQLText := SQLText + ',' + K_CMENDALCustRefN;//4

       SQLText := SQLText +
        ' from ' + K_CMENDBAllLocationsTable +  ',' + K_CMENDBGlobAttrsTable +
        ' where (' + K_CMENDALFlags;
{
       SQLText := 'select ' +
        K_CMENDALID + ',' +
        K_CMENDALName + ',' +
        K_CMENDALBridgeID + ',' + K_CMENDBGTFSAFlags +
        ' from ' + K_CMENDBAllLocationsTable +  ',' + K_CMENDBGlobAttrsTable +
        ' where (' + K_CMENDALFlags;
}
      if AShowDelFlag then
        SQLText := SQLText + ' & 1) = 1'
      else
        SQLText := SQLText + ' & 1) = 0';
{
        ' where ' + K_CMENDALFlags;

      if AShowDelFlag then
        SQLText :=  SQLText + '=1'
      else
        SQLText := SQLText + '=0';
}

      SQL.Text := SQLText;
      Filtered := false;
      Open;
      RCount := RecordCount;
      N_Dump2Str('DB>> Locations Count=' + IntToStr(RCount));

      if RCount > 0 then
        Byte(K_CMStandaloneMode) := FieldList.Fields[3].AsInteger and 3;

      with LocationsInfo.R do
      begin
        ASetLength( 4, RCount + 1 );
        PString(PME(0, 0))^ := 'LocationID';
        PString(PME(1, 0))^ := 'LocationTitle';
        PString(PME(2, 0))^ := 'LocationSync';
        PString(PME(3, 0))^ := 'LocationRef#';
        First;
        with FieldList do
          for i := 1 to RCount do
          begin
            if K_CMEDDBVersion >= 22 then
              PString(PME(0, i))^ := Fields[2].AsString
            else
              PString(PME(0, i))^ := Fields[0].AsString;

            PString(PME(1, i))^ := Fields[1].AsString;
            if PString(PME(1, i))^ = '' then
              PString(PME(1, i))^ := '[' + PString(PME(0, i))^ + ']';

            if Fields[2].AsInteger > 0 then
              PString(PME(2, i))^ := '1'
            else
              PString(PME(2, i))^ := '';

            if (K_CMEDDBVersion >= 33) and (Fields[4].AsString <> '') then
              PString(PME(3, i))^ := Fields[4].AsString;

            Next;
          end;
      end;
      Close;
    end;
    N_Dump2Str('DB>> EDASAGetLocationsInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAGetLocationsInfo ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAGetLocationsInfo

//********************************************* TK_CMEDDBAccess.EDASAGetOneLocationInfo ***
// Get givev Provider Info and Lock in Stand alone mode
//
//     Parameters
// ALocSID - Patient ID string
// APCMSALocationDBData - pointer to Location Data
// ALockOnly - Lock Only Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAGetOneLocationInfo( const ALocSID : string;
                       APCMSALocationDBData : TK_PCMSALocationDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult;
var
  SAppRTID : string;
  SQLText : string;
  SQLIDFName : string;
begin
  N_Dump2Str('DB>> EDASAGetOneLocationInfo ID=' + ALocSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDALBridgeID
  else
    SQLIDFName := K_CMENDALID;

  SAppRTID := IntToStr(AppRTID);
  CurDSet1.Connection := LANDBConnection;
  try
    if not (K_cmsagiSkipLock  in ALockFlags ) then
    begin
      ExtDataErrorCode := K_eeDBUpdate;
      with CurSQLCommand1 do
      begin
      // Try to
        Connection := LANDBConnection;
        SQLText := 'UPDATE ' + K_CMENDBAllLocationsTable +
          ' SET ' + K_CMENDALActRTID + ' = ' + SAppRTID +
          ' WHERE ' + SQLIDFName + ' = ' + ALocSID +
          ' AND ' + K_CMENDALActRTID + ' = 0';
        if not (K_cmsagiLockOnly in ALockFlags) then
          SQLText := SQLText + ' AND (' + K_CMENDALFlags + ' & 1) = 0';
  //        SQLText := SQLText + ' AND ' + K_CMENDALFlags + ' = 0';

        CommandText := SQLText;
        Execute;
      end; // with CurSQLCommand1 do
    end; // if not (K_cmsagiSkipLock  in ALockFlags ) then

    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
      SQLText := 'select ' +
        K_CMENDALActRTID  + ',' + K_CMENDALFlags + ',' + K_CMENDALBridgeID;
      if not (K_cmsagiLockOnly in ALockFlags) then
        SQLText := SQLText + ',' +  K_CMENDALName;

      if K_CMEDDBVersion >= 33 then
        SQLText := SQLText + ',' + K_CMENDALCustRefN;

      SQL.Text := SQLText +
        ' from ' + K_CMENDBAllLocationsTable +
        ' where ' + SQLIDFName + ' = ' + ALocSID;

      Filtered := false;
      Open;
      if RecordCount > 0 then
      begin
        First;
        with APCMSALocationDBData^, FieldList do
        begin
          ALIsLocked     := Fields[0].AsInteger = AppRTID;
          ALDBFlags      := Fields[1].AsInteger and 1;
          ALIsPMSSync    := Fields[2].AsInteger > 0;

          if not (K_cmsagiLockOnly in ALockFlags) then
          begin
            ALName  := Fields[3].AsString;
            if K_CMEDDBVersion >= 33 then
              ALCustRefN := Fields[4].AsString;
          end;
        end;
      end
      else
        Result := K_edFails;

      Close;
      SQLText := 'fin';
      if Result = K_edFails then
        SQLText := 'fails';
      N_Dump2Str('DB>> EDASAGetOneLocationInfo ' + SQLText);
    end;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAGetOneLocationInfo ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAGetOneLocationInfo

//********************************************* TK_CMEDDBAccess.EDASASetOneLocationInfo ***
// Set Location Info in Stand alone mode
//
//     Parameters
// ALocSID - Location ID string
// APCMSALocationDBData - pointer to Location Data
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASASetOneLocationInfo( var ALocSID : string;
                        APCMSALocationDBData : TK_PCMSALocationDBData;
                        ASkipFieldsSet : Boolean ) : TK_CMEDResult;
var
  InTrans: Boolean;
  Ind : Integer;
  SQLText : string;
  SQLIDFName : string;
  SRLocID : string;
  LocID : Integer;
  FCol : Integer;
begin
  N_Dump2Str('DB>> EDASASetOneLocationInfo ' + ALocSID + ' ' + N_B2S(ASkipFieldsSet) );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDALBridgeID
  else
    SQLIDFName := K_CMENDALID;

  try
    if (ALocSID <> '') and ASkipFieldsSet then
    begin
      ExtDataErrorCode := K_eeDBUpdate;
      with CurSQLCommand1 do
      begin
      // Try to Unlock if Fields Setting is not needed
        Connection := LANDBConnection;
        CommandText := 'UPDATE ' + K_CMENDBAllLocationsTable +
          ' SET ' + K_CMENDALActRTID + ' =  0' +
          ' WHERE ' + SQLIDFName + ' = ' + ALocSID +
          ' AND ' + K_CMENDALActRTID + ' = ' + IntToStr(AppRTID);
        N_Dump2Str('DB>> EDASASetOneLocationInfo SQL1 >>' + CommandText);
        Execute;
      end;
      Exit;
    end;


    ExtDataErrorCode := K_eeDBSelect;

    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      Filtered := false;

      SQLText := 'select ' + K_CMENDALName + ',' +     // 0
                             K_CMENDALActRTID + ',' +  // 1
                             K_CMENDALID;              // 2
      if K_CMEDDBVersion >= 33 then
        SQLText := SQLText + ',' + K_CMENDALCustRefN;  // 3

      SQLText := SQLText + ' from ' + K_CMENDBAllLocationsTable;
{
      SQLText := 'select ' + K_CMENDALName + ',' +
                             K_CMENDALActRTID + ',' +
                             K_CMENDALID +
          ' from ' + K_CMENDBAllLocationsTable;
}

      if ALocSID = '' then
      begin // Add New
        InTrans := LANDBConnection.InTransaction;

        if not InTrans then
          LANDBConnection.BeginTrans;

        SQL.Text := SQLText + ' where ' + K_CMENDALID + ' = -1';
        Open;
        ExtDataErrorCode := K_eeDBIns;
        Insert;

        ExtDataErrorCode := K_eeDBSetField;
        EDAPutStringFieldValue( Fields[0], APCMSALocationDBData.ALName );
        if K_CMEDDBVersion >= 33 then
          EDAPutStringFieldValue(Fields[3], APCMSALocationDBData.ALCustRefN );
        UpdateBatch;
        Close;
        SQL.Text := 'select @@identity';
        Open;
        LocID := Fields[0].AsInteger;
        SRLocID := Fields[0].AsString;
        Close;

        ALocSID := SRLocID;
        APCMSALocationDBData.ALIsPMSSync := FALSE; // Clear PMS SynchFlag for new Location

        if K_CMEDDBVersion >= 22 then
        begin
          LocID := -100 - LocID;
          ALocSID := IntToStr(LocID);
          with CurSQLCommand1 do
          begin
            Connection := LANDBConnection;
            CommandText := 'UPDATE ' + K_CMENDBAllLocationsTable +
              ' SET ' + K_CMENDALBridgeID + ' = ' + ALocSID +
              ' WHERE ' + K_CMENDALID + ' = ' + SRLocID;
            Execute;
          end;
        end;

        if not InTrans then
          LANDBConnection.CommitTrans;
        with LocationsInfo.R do
        begin
          Ind := ARowCount();
          ASetLength( AColCount(), Ind + 1 );
          PString(PME(0, Ind))^ := ALocSID;
        end;
      end   // end of Add New
      else
      begin // Change Existing
        SQL.Text := SQLText + ' where ' + SQLIDFName + ' = ' + ALocSID;
        Open;
        N_Dump2Str('DB>> EDASASetOneLocationInfo SQL2 >>' + SQL.Text);
        Edit;
        ExtDataErrorCode := K_eeDBSetField;
        EDAPutStringFieldValue( Fields[0], APCMSALocationDBData.ALName );
        Fields[1].AsInteger := 0; // Clear Lock Mark
        if K_CMEDDBVersion >= 33 then
          EDAPutStringFieldValue( Fields[3], APCMSALocationDBData.ALCustRefN );
        UpdateBatch;
        Close;
        Ind := EDAArchUDTabIndexOf( ALocSID, LocationsInfo );
      end; // end of Change Existing
    end;

    // Set Values to LocationsInfo
    with LocationsInfo.R do
    begin
      FCol := EDAArchUDTabFieldIndex( 'LocationTitle', LocationsInfo );
      PString(PME(FCol, Ind))^ := APCMSALocationDBData.ALName;
      if APCMSALocationDBData.ALIsPMSSync then
      begin
        FCol := EDAArchUDTabFieldIndex( 'LocationSync', LocationsInfo );
        PString(PME(FCol, Ind))^ := '1';
      end;
      if K_CMEDDBVersion >= 33 then
      begin
        FCol := EDAArchUDTabFieldIndex( 'LocationRef#', LocationsInfo );
//        PString(PME(FCol, Ind))^ := IntToStr(APCMSALocationDBData.ALCustRefN);
        PString(PME(FCol, Ind))^ := APCMSALocationDBData.ALCustRefN;
      end;
    end;
    N_Dump2Str('DB>> EDASASetOneLocationInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASASetOneLocationInfo ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASASetOneLocationInfo

//********************************************* TK_CMEDDBAccess.EDASASetClearMarkLocatonAsDel ***
// Set or Clear Given Locaton Marked as Deleted Flag and Unlock
//
//     Parameters
// ALocSID - Provider ID string
// AFlags - ='1' set marked as deleted flag, ='0' - clear marked as deleted flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASASetClearMarkLocatonAsDel( const ALocSID, AFlags : string ) : TK_CMEDResult;
var
  SQLIDFName : string;

begin
  N_Dump2Str('DB>> EDASASetClearMarkLocatonAsDel ID=' + ALocSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDALBridgeID
  else
    SQLIDFName := K_CMENDALID;

  CurDSet1.Connection := LANDBConnection;
  try
    ExtDataErrorCode := K_eeDBUpdate;
    with CurSQLCommand1 do
    begin
    // Try to
      Connection := LANDBConnection;
      CommandText := 'UPDATE ' + K_CMENDBAllLocationsTable +
        ' SET ' + K_CMENDALActRTID + ' = 0,' +
                  K_CMENDALFlags + ' = ' + AFlags +
        ' WHERE ' + SQLIDFName + ' = ' + ALocSID +
        ' AND ' + K_CMENDALActRTID + ' = ' + IntToStr(AppRTID); // Prcaution

      Execute;
    end;
    N_Dump2Str('DB>> EDASASetClearMarkLocatonAsDel fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASASetClearMarkLocatonAsDel ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASASetClearMarkLocatonAsDel

//********************************************* TK_CMEDDBAccess.EDASADelLocation ***
// Delete given Location
//
//     Parameters
// ALocSID - Location ID string
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASADelLocation( const ALocSID : string  ) : TK_CMEDResult;
var
  SQLIDFName : string;
begin
  N_Dump2Str('DB>> EDASADelLocation ID=' + ALocSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDALBridgeID
  else
    SQLIDFName := K_CMENDALID;

  CurDSet1.Connection := LANDBConnection;
  try
    ExtDataErrorCode := K_eeDBUpdate;
    with CurSQLCommand1 do
    begin
    // Try to
      Connection := LANDBConnection;
      CommandText := 'DELETE ' + K_CMENDBAllLocationsTable +
        ' WHERE ' + SQLIDFName + ' = ' + ALocSID +
        ' AND ' + K_CMENDALActRTID + ' = ' + IntToStr(AppRTID); // Prcaution

      Execute;
    end;
    N_Dump2Str('DB>> EDASADelLocation fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASADelLocation ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASADelLocation

{
//********************************************* TK_CMEDDBAccess.EDASAUpdateLocationsByLinkInfo ***
// Update Locations data by PMS Link Info
//
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAUpdateLocationsByLinkInfo( ) : TK_CMEDResult;
var
  i  : Integer;
begin
  if not (K_uliLocations in UpdatePPLFlagsSet) then
  begin
    N_Dump2Str('DB>> EDASAUpdateLocationsByLinkInfo is skiped by UpdatePPLFlagsSet' );
    Result := K_edFails;
    Exit;
  end;

  N_Dump2Str('DB>> EDASAUpdateLocationsByLinkInfo' );
  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;

    i := LocationsInfo.R.AColCount;
    if i < 2 then
    begin
      Result := K_edAbsentData;
      N_Dump2Str( format( 'DB>> EDASAUpdateLocationsByLinkInfo >> wrong Fields Count %d < 2', [i] ) );
      Exit;
    end;

    N_Dump2Str( 'DB>> cms_UpdateLocationsData ' );
    ExtDataErrorCode := K_eeDBUpdate;

    TmpStrings.Clear;
    TmpStrings.Add( '<locations>' );
    with LocationsInfo.R do
      for i := 1 to ARowCount - 1 do
          TmpStrings.Add( format( '<location LocID="%s" LocName="%s" />',
               [PString(PME(0, i))^,
                PString(PME(1, i))^] ) );
    TmpStrings.Add( '</locations>' );

    with CurStoredProc1 do
    begin
      Connection := LANDBConnection;
      ProcedureName := 'dba.cms_UpdateLocationsData';
      Parameters.Clear;
      with Parameters.AddParameter do
      begin
        Name := '@xml_data';
        Direction := pdInput;
        DataType := ftString;
        Value := TmpStrings.Text;
      end;
      ExecProc;
    end;

    UpdatePPLFlagsSet := UpdatePPLFlagsSet - [K_uliLocations];
    N_Dump2Str('DB>> EDASAUpdateLocationsByLinkInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAUpdateLocationsByLinkInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAUpdateLocationsByLinkInfo
}
//********************************************* TK_CMEDDBAccess.EDASAUpdateLocationsByLinkInfo ***
// Update Locations data by PMS Link Info
//
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAUpdateLocationsByLinkInfo( ) : TK_CMEDResult;
var
  i  : Integer;
  SQLStr : string;
  FCol : Integer;
begin
  if not (K_uliLocations in UpdatePPLFlagsSet) then
  begin
    N_Dump2Str('DB>> EDASAUpdateLocationsByLinkInfo is skiped by UpdatePPLFlagsSet' );
    Result := K_edFails;
    Exit;
  end;

  N_Dump2Str('DB>> EDASAUpdateLocationsByLinkInfo' );
  UpdatePPLFlagsSet := UpdatePPLFlagsSet - [K_uliLocations];
  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;

    i := LocationsInfo.R.AColCount;
    if i < 2 then
    begin
      Result := K_edAbsentData;
      N_Dump2Str( format( 'DB>> EDASAUpdateLocationsByLinkInfo >> wrong Fields Count %d < 2', [i] ) );
      Exit;
    end;

    N_Dump2Str( 'DB>> cms_ImportLocationsData ' );
    ExtDataErrorCode := K_eeDBUpdate;

    TmpStrings.Clear;
    TmpStrings.Add( '<locations>' );
    FCol := EDAArchUDTabFieldIndex( 'LocationRef#', LocationsInfo );
    with LocationsInfo.R do
      for i := 1 to ARowCount - 1 do
      if K_CMEDDBVersion >= 33 then
        TmpStrings.Add( format( '<location LocID="%s" LocName="%s" LocCustRef="%s" />',
               [PString(PME(0, i))^,
                PString(PME(1, i))^,
                PString(PME(FCol, i))^] ) )
      else
        TmpStrings.Add( format( '<location LocID="%s" LocName="%s" />',
               [PString(PME(0, i))^,
                PString(PME(1, i))^] ) );
    TmpStrings.Add( '</locations>' );

    // Import Locations Data  to Import Table
    with CurStoredProc1 do
    begin
      Connection := LANDBConnection;

      ProcedureName := 'dba.cms_ImportLocationsData';
      Parameters.Clear;
      with Parameters.AddParameter do
      begin
        Name := '@xml_data';
        Direction := pdInput;
        DataType := ftString;
        Value := TmpStrings.Text;
      end;
      ExecProc;
    end;

   // Load Data from Import Table
    with CurSQLCommand1 do
    begin
    // Update Existing
      Connection := LANDBConnection;
      SQLStr := 'UPDATE ' + K_CMENDBAllLocationsTable +
                ' SET ' + K_CMENDALName + '=' + K_CMENDILName;
      if K_CMEDDBVersion >= 33 then
        SQLStr := SQLStr + ',' + K_CMENDALCustRefN + '=' + K_CMENDILCustRefN;

      CommandText := SQLStr +
                    ' FROM ' + K_CMENDBImportLocationsTable +
                    ' WHERE ' + K_CMENDALBridgeID + ' = ' + K_CMENDILID;
{
      CommandText :='UPDATE ' + K_CMENDBAllLocationsTable +
                    ' SET ' + K_CMENDALName + '=' + K_CMENDILName +
                    ' FROM ' + K_CMENDBImportLocationsTable +
                    ' WHERE ' + K_CMENDALBridgeID + ' = ' + K_CMENDILID;
}
      Execute;

    // Create New
      SQLStr := 'INSERT INTO ' + K_CMENDBAllLocationsTable;
      if K_CMEDDBVersion >= 33 then
        SQLStr := SQLStr + ' (' + K_CMENDALBridgeID + ',' + K_CMENDALName + ',' + K_CMENDALCustRefN + ')' +
                 ' SELECT ' + K_CMENDILID + ',' + K_CMENDILName + ',' + K_CMENDILCustRefN
      else
        SQLStr := SQLStr + ' (' + K_CMENDALBridgeID + ',' + K_CMENDALName + ')' +
                 ' SELECT ' + K_CMENDILID + ',' + K_CMENDILName;

      CommandText := SQLStr +
                    ' FROM ' + K_CMENDBImportLocationsTable +
                    ' WHERE NOT EXISTS (SELECT 1 FROM ' + K_CMENDBAllLocationsTable +
                                       ' WHERE ' + K_CMENDALBridgeID + ' = ' + K_CMENDILID + ')';
{
      CommandText :='INSERT INTO ' + K_CMENDBAllLocationsTable +
                    ' (' + K_CMENDALBridgeID + ',' + K_CMENDALName + ')' +
                    ' SELECT ' + K_CMENDILID + ',' + K_CMENDILName +
                    ' FROM ' + K_CMENDBImportLocationsTable +
                    ' WHERE NOT EXISTS (SELECT 1 FROM ' + K_CMENDBAllLocationsTable +
                                       ' WHERE ' + K_CMENDALBridgeID + ' = ' + K_CMENDILID + ')';
}
      Execute;
    end; // with CurSQLCommand1 do
    N_Dump2Str('DB>> EDASAUpdateLocationsByLinkInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAUpdateLocationsByLinkInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAUpdateLocationsByLinkInfo

//********************************************* TK_CMEDDBAccess.EDASAUpdateOneLocationByLinkInfo ***
// Update One Location data by PMS Link Info
//
// APCLLLocAttrs - Pointer to Command Line Location Info Attrs
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAUpdateOneLocationByLinkInfo(
                    APCLLLocAttrs : TK_PCMSCLLLocationAttrs ) : TK_CMEDResult;
var
  SID : string;
  RInd, TitleInd, CustRefInd : Integer;
  PInfo : PString;
  SQLStr : string;
  ChangeNameIsNeeded : Boolean;
  ChangeCustRefIsNeeded : Boolean;
begin
  if not (K_uliLocations in UpdatePPLFlagsSet) then
  begin
    N_Dump2Str('DB>> EDASAUpdateOneLocationByLinkInfo is skiped by UpdatePPLFlagsSet' );
    Result := K_edFails;
    Exit;
  end;

  UpdatePPLFlagsSet := UpdatePPLFlagsSet - [K_uliLocations];
  SID := IntToStr(APCLLLocAttrs.CLLLID);
  if APCLLLocAttrs.CLLLID <= 0 then
  begin
    N_Dump2Str('DB>> EDASAUpdateOneLocationByLinkInfo is skiped by CLLLID=' + SID );
    Result := K_edAbsentData;
    Exit;
  end;

  N_Dump2Str('DB>> EDASAUpdateOneLocationByLinkInfo CLLLID=' + SID );
  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;

    ExtDataErrorCode := K_eeDBSelect;

    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      Filtered := false;

      SQLStr := 'select ' + K_CMENDALBridgeID + ',' + // 0
                            K_CMENDALName;            // 1
      if K_CMEDDBVersion >= 33 then
        SQLStr := SQLStr + ',' + K_CMENDALCustRefN;   // 2

      SQL.Text := SQLStr +
          ' from ' + K_CMENDBAllLocationsTable +
          ' where ' + K_CMENDALBridgeID + ' = ' + SID;
{
      SQL.Text := 'select ' + K_CMENDALBridgeID + ',' +
                              K_CMENDALName +
          ' from ' + K_CMENDBAllLocationsTable +
          ' where ' + K_CMENDALBridgeID + ' = ' + SID;
}
      Open;

      if RecordCount = 0 then
      begin // Add New
        N_Dump2Str('DB>> EDASAUpdateOneLocationByLinkInfo Add New');
        Insert;
        ExtDataErrorCode := K_eeDBSetField;
        Fields[0].AsInteger := APCLLLocAttrs.CLLLID;
        if APCLLLocAttrs.CLLLName <> '' then
        begin
          N_Dump1Str( format( 'DB>> Update Location Name By Link Info "%s"',
                          [APCLLLocAttrs.CLLLName] ) );
          EDAPutStringFieldValue( Fields[1], APCLLLocAttrs.CLLLName );
        end;
        if K_CMEDDBVersion >= 33 then
        begin
          if APCLLLocAttrs.CLLLCustRefN <> '' then
          begin
            N_Dump1Str( format( 'DB>> Update Location CustRef By Link Info "%s"',
                            [APCLLLocAttrs.CLLLCustRefN] ) );
            EDAPutStringFieldValue( Fields[2], APCLLLocAttrs.CLLLCustRefN );
          end;
        end;
        UpdateBatch;
      end
      else
      begin // Change Existing
        ChangeNameIsNeeded := FALSE;
        if APCLLLocAttrs.CLLLName <> '' then
        begin
          N_Dump2Str('DB>> EDASAUpdateOneLocationByLinkInfo Update');
          ChangeNameIsNeeded := Fields[1].AsString <> APCLLLocAttrs.CLLLName;
          if ChangeNameIsNeeded then
          begin
            Edit;
            ExtDataErrorCode := K_eeDBSetField;
            N_Dump1Str( format( 'DB>> Update Location By Link Info "%s" to "%s"',
                        [Fields[1].AsString, APCLLLocAttrs.CLLLName] ) );
            EDAPutStringFieldValue( Fields[1], APCLLLocAttrs.CLLLName );
          end;
        end; // if APCLLLocAttrs.CLLLName <> '' then

        if K_CMEDDBVersion >= 33 then
        begin
          if APCLLLocAttrs.CLLLCustRefN <> '' then
          begin
            ChangeCustRefIsNeeded := Fields[2].AsString <> APCLLLocAttrs.CLLLCustRefN;
            if ChangeCustRefIsNeeded then
            begin
              if not ChangeNameIsNeeded then
              begin
                Edit;
                ExtDataErrorCode := K_eeDBSetField;
              end;
              N_Dump1Str( format( 'DB>> Update Location CustRef By Link Info "%s"',
                                  [APCLLLocAttrs.CLLLCustRefN] ) );
              EDAPutStringFieldValue( Fields[2], APCLLLocAttrs.CLLLCustRefN );
            end;
          end;
        end;
        UpdateBatch;
      end;

      with LocationsInfo.R do
      begin
        if ALength() <= 1 then
        begin
          ASetLength( 4, 1 );
          PString(PME(0, 0))^ := 'LocationID';
          PString(PME(1, 0))^ := 'LocationTitle';
          PString(PME(2, 0))^ := 'LocationSync';
          PString(PME(3, 0))^ := 'LocationRef#';
          TitleInd := 1;
          CustRefInd := 3;
        end
        else
        begin
          TitleInd := EDAArchUDTabFieldIndex( 'LocationTitle', LocationsInfo );
          CustRefInd := EDAArchUDTabFieldIndex( 'LocationRef#', LocationsInfo );
        end;

        RInd := EDAArchUDTabIndexOf( SID, LocationsInfo );
        if RInd = 0 then
        begin
          RInd := ARowCount;
          ASetLength( AColCount(), RInd + 1 );
          PString(PME(0, RInd))^ := SID;
        end;

        PInfo := PString(PME(TitleInd, RInd));
        if APCLLLocAttrs.CLLLName <> '' then
          PInfo^ := APCLLLocAttrs.CLLLName
        else
          PInfo^ := EDAGetStringFieldValue(Fields[1]);

        if K_CMEDDBVersion >= 33 then
        begin
          PInfo := PString(PME(CustRefInd, RInd));
{
          if APCLLLocAttrs.CLLLCustRefN <> 0 then
            PInfo^ := IntToStr(APCLLLocAttrs.CLLLCustRefN)
          else
            PInfo^ := Fields[2].AsString;
}
          if APCLLLocAttrs.CLLLCustRefN <> '' then
            PInfo^ := APCLLLocAttrs.CLLLCustRefN
          else
            PInfo^ := Fields[2].AsString;
        end;
      end;

      Close;
    end;


    N_Dump2Str('DB>> EDASAUpdateOneLocationByLinkInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAUpdateOneLocationByLinkInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAUpdateOneLocationByLinkInfo

//********************************************* TK_CMEDDBAccess.EDASAGetProvidersInfo ***
// Get Providers Info in Stand alone mode
//
//     Parameters
// AShowDelFlag - if =TRUE then only marked as deleted are placed to ProvidersInfo
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAGetProvidersInfo( AShowDelFlag : Boolean ) : TK_CMEDResult;
var
  i, RCount: Integer;
  WSTR, SQLText : string;
begin
  N_Dump2Str('DB>> EDASAGetProvidersInfo');

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  CurDSet1.Connection := LANDBConnection;
  try
    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
      SQLText := 'select ' +
        K_CMENDAUID + ',' + K_CMENDAUFirstname + ',' +           // 0, 1
        K_CMENDAUSurname + ',' + K_CMENDAUTitle + ',' +          // 2, 3
        K_CMENDAUAuthorities + ',' + K_CMENDAUBridgeID + ',' +   // 4, 5
        K_CMENDBGTFSAFlags + ',' + K_CMENDAUMiddle +             // 6, 7
        ' from ' + K_CMENDBAllProvidersTable + ',' + K_CMENDBGlobAttrsTable +
        ' where (' + K_CMENDAUFlags;

      if AShowDelFlag then
        SQLText := SQLText + ' & 1) = 1'
      else
        SQLText := SQLText + ' & 1) = 0';
{
        ' where ' + K_CMENDAUFlags;

      if AShowDelFlag then
        SQLText := SQLText + '=1'
      else
        SQLText := SQLText + '=0';
}
      SQL.Text := SQLText;

      Filtered := false;
      Open;
      RCount := RecordCount;
      N_Dump2Str('DB>> Providers Count=' + IntToStr(RCount));

      if RCount > 0 then
        Byte(K_CMStandaloneMode) := FieldList.Fields[6].AsInteger and 3;

      with ProvidersInfo.R do
      begin
        ASetLength( 7, RCount + 1 );
        PString(PME(0, 0))^ := 'ProviderID';
        PString(PME(1, 0))^ := 'ProviderFirstName';
        PString(PME(2, 0))^ := 'ProviderSurname';
        PString(PME(3, 0))^ := 'ProviderTitle';
        PString(PME(4, 0))^ := 'ProviderFlags';
        PString(PME(5, 0))^ := 'ProviderSync';
        PString(PME(6, 0))^ := 'ProviderMiddle';

        First;
        with FieldList do
          for i := 1 to RCount do
          begin
            // Provider ID
            if K_CMEDDBVersion >= 22 then
              PString(PME(0, i))^ := Fields[5].AsString
            else
              PString(PME(0, i))^ := Fields[0].AsString;

            // ProviderFirstName
            PString(PME(1, i))^ := Fields[1].AsString;

            // ProviderSurName
            PString(PME(2, i))^ := Fields[2].AsString;
            if PString(PME(2, i))^ = '' then
              PString(PME(2, i))^ := '[' + PString(PME(0, i))^ + ']';

            // ProviderTitle
            PString(PME(3, i))^ := Fields[3].AsString;

            // ProviderFlags
            WSTR := Fields[4].AsString;
            if (WSTR = '') or (WSTR = '0') then
              WSTR := '2047'; // Set maximal User Authorities
            PString(PME(4, i))^ := WSTR;

            // ProviderSync
            if Fields[5].AsInteger > 0 then
              PString(PME(5, i))^ := '1'
            else
              PString(PME(5, i))^ := '';
              
            // ProviderMiddle
            PString(PME(6, i))^ := Fields[7].AsString;
            Next;
          end;
      end;
      Close;
    end;
    N_Dump2Str('DB>> EDASAGetProvidersInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAGetProvidersInfo ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAGetProvidersInfo

//********************************************* TK_CMEDDBAccess.EDASAGetOneProviderInfo ***
// Get givev Provider Info and Lock in Stand alone mode
//
//     Parameters
// APatSID - Patient ID string
// APCMSAPatientDBData - pointer to Patient Data
// ALockOnly - Lock Only Flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAGetOneProviderInfo( const AProvSID : string;
                       APCMSAProviderDBData : TK_PCMSAProviderDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult;
var
  SAppRTID : string;
  SQLText : string;
  SQLIDFName : string;
//  SRProvID : string;
begin
  N_Dump2Str('DB>> EDASAGetOneProviderInfo ID=' + AProvSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDAUBridgeID
  else
    SQLIDFName := K_CMENDAUID;

  SAppRTID := IntToStr(AppRTID);
  try
    if not (K_cmsagiSkipLock  in ALockFlags ) then
    begin
      ExtDataErrorCode := K_eeDBUpdate;
      with CurSQLCommand1 do
      begin
      // Try to
        Connection := LANDBConnection;
        SQLText := 'UPDATE ' + K_CMENDBAllProvidersTable +
          ' SET ' + K_CMENDAUActRTID + ' = ' + SAppRTID +
          ' WHERE ' + SQLIDFName + ' = ' + AProvSID +
          ' AND ' + K_CMENDAUActRTID + ' = 0';
        if not (K_cmsagiLockOnly in ALockFlags) then
          SQLText := SQLText + ' AND (' + K_CMENDAUFlags + ' & 1) = 0';
  //        SQLText := SQLText + ' AND ' + K_CMENDAUFlags + ' = 0';

        CommandText := SQLText;
        Execute;
      end; // with CurSQLCommand1 do
    end; // if not (K_cmsagiSkipLock  in ALockFlags ) then
    CurDSet1.Connection := LANDBConnection;
    Result := K_CMDBGetOneProviderInfo( CurDSet1, SQLIDFName, AppRTID,
                       AProvSID, APCMSAProviderDBData, ALockFlags );

{
    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      SQLText := 'select ' +
        K_CMENDAUActRTID  + ',' + K_CMENDAUFlags + ',' + K_CMENDAUBridgeID;
        //   0                           1                      2
      if not (K_cmsagiLockOnly in ALockFlags) then
        SQLText := SQLText + ',' +
          K_CMENDAUTitle + ',' +                                 // 3
          K_CMENDAUSurname  + ',' + K_CMENDAUFirstname + ',' +   // 4, 5
          K_CMENDAUMiddle  + ',' + K_CMENDAUAuthorities ;        // 6, 7
//           + ',' +      K_CMENDAUID;

      SQL.Text := SQLText +
        ' from ' + K_CMENDBAllProvidersTable +
        ' where ' + SQLIDFName + ' = ' + AProvSID;

      Filtered := false;
      Open;
      if RecordCount > 0 then
      begin
        First;
        with APCMSAProviderDBData^, FieldList do
        begin
          AUIsLocked   := Fields[0].AsInteger = AppRTID;
          AUDBFlags    := Fields[1].AsInteger and 1;
          AUIsPMSSync  := Fields[2].AsInteger > 0;

          if not (K_cmsagiLockOnly in ALockFlags) then
          begin
            AUTitle       := Fields[3].AsString;
            AUSurname     := Fields[4].AsString;
            AUFirstname   := Fields[5].AsString;
            AUMiddle      := Fields[6].AsString;
            AUAuthorities := Fields[7].AsString;
//            SRProvID      := Fields[8].AsString;
          end;
        end;
      end
      else
        Result := K_edFails;

      Close;
      if Result = K_edFails then
        N_Dump2Str('DB>> EDASAGetOneProviderInfo fails')
      else
      begin
        SQL.Text := 'select count(*)' +
          ' from ' + K_CMENDBAllPatientsTable +
          ' where ' + K_CMENDAPProvID + ' = ' + AProvSID;

        Filtered := false;
        Open;
        APCMSAProviderDBData.AUPatCount := FieldList.Fields[0].AsInteger;
        Close;
        N_Dump2Str('DB>> EDASAGetOneProviderInfo fin');
      end;
    end;
}
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAGetOneProviderInfo ' + E.Message;
//      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAGetOneProviderInfo

//******************************** TK_CMEDDBAccess.EDASASetOneLoginPassword ***
// Set Provider's New Login|Password
//
//     Parameters
// AProvSID - Provider Code
// AEncLoginPassword - Encoded Login|Password
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASASetOneLoginPassword( const AProvSID : string;
                                           AEncLoginPassword : string ) : TK_CMEDResult;
begin
  N_Dump2Str('DB>> EDASASetOneLoginPassword ID=' + AProvSID );
  Result := K_edOK;
  if AEncLoginPassword = '' then Exit;
  try
    // Condition set new Login|Password
    with CurSQLCommand1 do
    begin
      Connection := LANDBConnection;
      CommandText := 'UPDATE ' + K_CMENDBAllProvidersTable +
          ' SET '  +  K_CMENDAUEncLP + ' = ''' + AEncLoginPassword + '''' +
          ' WHERE ' + K_CMENDAUBridgeID + ' = ' + AProvSID + ' and ' +
          ' NOT EXISTS (SELECT 1 ' + K_CMENDAUBridgeID +
          ' FROM ' + K_CMENDBAllProvidersTable  + ' P ' +
          ' WHERE P.' + K_CMENDAUBridgeID + ' <> ' + AProvSID +  ' and ' +
                 'P.' + K_CMENDAUEncLP    + ' = ''' + AEncLoginPassword + ''');';
      Execute;
    end;

    // Check if success
    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      Filtered := false;

      SQL.Text := 'select ' + K_CMENDAUEncLP +
                  ' from ' + K_CMENDBAllProvidersTable +
                  ' WHERE ' + K_CMENDAUBridgeID + ' = ' + AProvSID;
      Filtered := false;
      Open();
      if  Fields[0].AsString <> AEncLoginPassword then
        Result := K_edFails;
      Close();
    end;
    N_Dump2Str('DB>> EDASASetOneLoginPassword fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASASetOneLoginPassword ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;
end; // function TK_CMEDDBAccess.EDASASetOneLoginPassword

//********************************* TK_CMEDDBAccess.EDASACheckLoginPassword ***
// Check Provider new Login|Password
//
//     Parameters
// AProvSID - Provider Code
// AEncLoginPassword - Encoded Login|Password
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASACheckLoginPassword( const AProvSID : string;
                                                  AEncLoginPassword : string ) : TK_CMEDResult;
var
  SQLText : string;
begin
  N_Dump2Str('DB>> EDASACheckLoginPassword ID=' + AProvSID );
  Result := K_edOK;
  if AEncLoginPassword = '' then Exit;
  try
    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      SQLText := 'SELECT ' + K_CMENDAUBridgeID +
          ' FROM ' + K_CMENDBAllProvidersTable  +
          ' WHERE ' + K_CMENDAUEncLP    + ' = ''' + AEncLoginPassword + '''';
      if AProvSID <> '' then
        SQLText := SQLText + ' and ' + K_CMENDAUBridgeID + ' <> ' + AProvSID;

      SQL.Text := SQLText;

      Filtered := false;
      Open();

      if  RecordCount > 0 then
        Result := K_edFails;
      Close();
    end;
    N_Dump2Str('DB>> EDASACheckLoginPassword fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASACheckLoginPassword ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;
end; // function TK_CMEDDBAccess.EDASACheckLoginPassword

//********************************* TK_CMEDDBAccess.EDASASetOneProviderInfo ***
// Set Provider Info in Stand alone mode
//
//     Parameters
// AProvSID - Provider Code
// APCMSAProviderDBData - pointer to Provider Data
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASASetOneProviderInfo( var AProvSID : string;
                        APCMSAProviderDBData : TK_PCMSAProviderDBData;
                        ASkipFieldsSet : Boolean ) : TK_CMEDResult;
var
  InTrans: Boolean;
  Ind : Integer;
  SQLText : string;
  ProvID : Integer;
  SRProvID: string;
  SQLIDFName : string;

  procedure SetValues();
  begin
    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSetField;
      with FieldList do
      begin
        EDAPutStringFieldValue( Fields[0], APCMSAProviderDBData.AUFirstname );
        EDAPutStringFieldValue( Fields[1], APCMSAProviderDBData.AUSurname );
        EDAPutStringFieldValue( Fields[2], APCMSAProviderDBData.AUTitle );
        EDAPutStringFieldValue( Fields[3], APCMSAProviderDBData.AUMiddle );
        if APCMSAProviderDBData.AUAuthorities <> '' then
          Fields[4].AsInteger := StrToIntDef( APCMSAProviderDBData.AUAuthorities, 2047 );
        if (K_CMEDDBVersion >= 31) and (APCMSAProviderDBData.AUEncodeLP <> '') then
          EDAPutStringFieldValue( Fields[7], APCMSAProviderDBData.AUEncodeLP );
      end;
    end;
  end;

begin
  N_Dump2Str('DB>> EDASASetOneProviderInfo');

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDAUBridgeID
  else
    SQLIDFName := K_CMENDAUID;

  try
    if (AProvSID <> '') and ASkipFieldsSet then
    begin
      ExtDataErrorCode := K_eeDBUpdate;
      with CurSQLCommand1 do
      begin
      // Try to Unlock if Fields Setting is not needed
        Connection := LANDBConnection;
        CommandText := 'UPDATE ' + K_CMENDBAllProvidersTable +
          ' SET ' + K_CMENDAUActRTID + ' =  0' +
          ' WHERE ' + SQLIDFName + ' = ' + AProvSID +
          ' AND ' + K_CMENDAUActRTID + ' = ' + IntToStr(AppRTID);
        Execute;
      end;
      Exit;
    end;

    ExtDataErrorCode := K_eeDBSelect;

    if APCMSAProviderDBData.AUAuthorities = '' then
      APCMSAProviderDBData.AUAuthorities := '2047';
    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      Filtered := false;

      SQLText := 'select ' +
          K_CMENDAUFirstname + ',' +                                // 0
          K_CMENDAUSurname   + ',' + K_CMENDAUTitle + ',' +         // 1,2
          K_CMENDAUMiddle    + ',' + K_CMENDAUAuthorities + ',' +   // 3,4
          K_CMENDAUActRTID   + ',' + K_CMENDAUID;                   // 5,6
      if K_CMEDDBVersion >= 31 then
        SQLText := SQLText + ',' +   K_CMENDAUEncLP;                // 7
      SQLText := SQLText +  ' from ' + K_CMENDBAllProvidersTable;

      if AProvSID = '' then
      begin // Add New
        InTrans := LANDBConnection.InTransaction;

        if not InTrans then
          LANDBConnection.BeginTrans;

        SQL.Text := SQLText + ' where ' + K_CMENDAUID + ' = -1';
        Open;
        ExtDataErrorCode := K_eeDBIns;
        Insert;

        ExtDataErrorCode := K_eeDBSetField;
        SetValues();
        UpdateBatch;
        Close;

        SQL.Text := 'select @@identity';
        Open;
        ProvID := Fields[0].AsInteger;
        SRProvID := Fields[0].AsString;
        AProvSID := SRProvID;
        Close;

        APCMSAProviderDBData.AUIsPMSSync :=FALSE; // Clear PMS SynchFlag for new Provider

        if K_CMEDDBVersion >= 22 then
        begin
          ProvID := -100 - ProvID;
          AProvSID := IntToStr(ProvID);
          with CurSQLCommand1 do
          begin
            Connection := LANDBConnection;
            CommandText := 'UPDATE ' + K_CMENDBAllProvidersTable +
              ' SET ' + K_CMENDAUBridgeID + ' = ' + AProvSID +
              ' WHERE ' + K_CMENDAUID + ' = ' + SRProvID;
            Execute;
          end;
        end;

        if not InTrans then
          LANDBConnection.CommitTrans;

        with ProvidersInfo.R do
        begin
          Ind := ARowCount();
          ASetLength( AColCount(), Ind + 1 );
          PString(PME(0, Ind))^ := AProvSID;
        end;
      end
      else
      begin // Change Existing
        SQL.Text := SQLText + ' where ' + SQLIDFName + ' = ' + AProvSID;
        Open;
        Edit;
        ExtDataErrorCode := K_eeDBSetField;
        SetValues();
        FieldList.Fields[5].AsInteger := 0; // Clear Lock Mark
        UpdateBatch;
        Close;
        Ind := EDAArchUDTabIndexOf( AProvSID, ProvidersInfo );
      end;
    end;

    // Set Values to ProvidersInfo
    with ProvidersInfo.R do
    begin
      PString(PME(1, Ind))^ := APCMSAProviderDBData.AUFirstname;
      PString(PME(2, Ind))^ := APCMSAProviderDBData.AUSurname;
      PString(PME(3, Ind))^ := APCMSAProviderDBData.AUTitle;
      PString(PME(4, Ind))^ := APCMSAProviderDBData.AUAuthorities;
      if APCMSAProviderDBData.AUIsPMSSync then
        PString(PME(5, Ind))^ := '1';
      PString(PME(6, Ind))^ := APCMSAProviderDBData.AUMiddle;
    end;
    N_Dump2Str('DB>> EDASASetOneProviderInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASASetOneProviderInfo ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASASetOneProviderInfo

//********************************************* TK_CMEDDBAccess.EDASASetClearMarkProviderAsDel ***
// Set or Clear Given Provider Marked as Deleted Flag and Unlock
//
//     Parameters
// AProvSID - Provider ID string
// AFlags - ='1' set marked as deleted flag, ='0' - clear marked as deleted flag
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASASetClearMarkProviderAsDel( const AProvSID, AFlags : string ) : TK_CMEDResult;
var
  SQLIDFName : string;
begin
  N_Dump2Str('DB>> EDASASetClearMarkProviderAsDel ID=' + AProvSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;


  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDAUBridgeID
  else
    SQLIDFName := K_CMENDAUID;

  CurDSet1.Connection := LANDBConnection;
  try
    ExtDataErrorCode := K_eeDBUpdate;
    with CurSQLCommand1 do
    begin
    // Try to
      Connection := LANDBConnection;
      CommandText := 'UPDATE ' + K_CMENDBAllProvidersTable +
        ' SET ' + K_CMENDAUActRTID + ' = 0,' +
                  K_CMENDAUFlags + ' = ' + AFlags +
        ' WHERE ' + SQLIDFName + ' = ' + AProvSID +
        ' AND ' + K_CMENDAUActRTID + ' = ' + IntToStr(AppRTID); // Precaution

      Execute;
    end;
    N_Dump2Str('DB>> EDASASetClearMarkProviderAsDel fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASASetClearMarkProviderAsDel ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASASetClearMarkProviderAsDel

//********************************************* TK_CMEDDBAccess.EDASADelProvider ***
// Delete given Provider
//
//     Parameters
// AProvSID - Provider ID string
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASADelProvider( const AProvSID : string  ) : TK_CMEDResult;
var
  SQLIDFName : string;
begin
  N_Dump2Str('DB>> EDASADelProvider ID=' + AProvSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDAUBridgeID
  else
    SQLIDFName := K_CMENDAUID;

  CurDSet1.Connection := LANDBConnection;
  try
    ExtDataErrorCode := K_eeDBUpdate;
    with CurSQLCommand1 do
    begin
    // Try to
      Connection := LANDBConnection;
      CommandText := 'DELETE ' + K_CMENDBAllProvidersTable +
        ' WHERE ' + SQLIDFName + ' = ' + AProvSID +
        ' AND ' + K_CMENDAUActRTID + ' = ' + IntToStr(AppRTID); // Prcaution

      Execute;
    end;
    N_Dump2Str('DB>> EDASADelProvider fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASADelProvider ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASADelProvider
{
//********************************************* TK_CMEDDBAccess.EDASAUpdateProvidersByLinkInfo ***
// Update Providers data by PMS Link Øòàù
//
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAUpdateProvidersByLinkInfo( ) : TK_CMEDResult;
var
  i  : Integer;
begin
  if not (K_uliProviders in UpdatePPLFlagsSet) then
  begin
    N_Dump2Str('DB>> EDASAUpdateProvidersByLinkInfo is skiped by UpdatePPLFlagsSet' );
    Result := K_edFails;
    Exit;
  end;

  N_Dump2Str('DB>> EDASAUpdateProvidersByLinkInfo' );
  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;
    i := ProvidersInfo.R.AColCount;
    if i < 5 then
    begin
      Result := K_edAbsentData;
      N_Dump2Str( format( 'DB>> EDASAUpdateProvidersByLinkInfo >> wrong Fields Count %d < 5', [i] ) );
      Exit;
    end;

    ExtDataErrorCode := K_eeDBUpdate;
    TmpStrings.Clear;
    TmpStrings.Add( '<providers>' );
    with ProvidersInfo.R do
      for i := 1 to ARowCount - 1 do
          TmpStrings.Add( format( '<provider ProvID="%s" ProvFirstname="%s" '+
    'ProvSurname="%s" ProvTitle="%s" ProvAuthorities="%s" />',
               [PString(PME(0, i))^,
                PString(PME(1, i))^,
                PString(PME(2, i))^,
                PString(PME(3, i))^,
                PString(PME(4, i))^] ) );
    TmpStrings.Add( '</providers>' );

    with CurStoredProc1 do
    begin
      Connection := LANDBConnection;
      ProcedureName := 'dba.cms_UpdateProvidersData';
      Parameters.Clear;
      with Parameters.AddParameter do
      begin
        Name := '@xml_data';
        Direction := pdInput;
        DataType := ftString;
        Value := TmpStrings.Text;
      end;
      ExecProc;
    end;

    UpdatePPLFlagsSet := UpdatePPLFlagsSet - [K_uliProviders];
    N_Dump2Str('DB>> EDASAUpdateProvidersByLinkInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAUpdateProvidersByLinkInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAUpdateProvidersByLinkInfo
}


//********************************************* TK_CMEDDBAccess.EDASAUpdateProvidersByLinkInfo ***
// Update Providers data by PMS Link
//
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAUpdateProvidersByLinkInfo( ) : TK_CMEDResult;
var
  i  : Integer;
  FirstNameInd, SurnameInd, TitleInd, ProvFlagsInd, MiddleInd : Integer;
begin
  if not (K_uliProviders in UpdatePPLFlagsSet) then
  begin
    N_Dump2Str('DB>> EDASAUpdateProvidersByLinkInfo is skiped by UpdatePPLFlagsSet' );
    Result := K_edFails;
    Exit;
  end;

  N_Dump2Str('DB>> EDASAUpdateProvidersByLinkInfo' );
  UpdatePPLFlagsSet := UpdatePPLFlagsSet - [K_uliProviders];
  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;
    i := ProvidersInfo.R.AColCount;
    if i < 5 then
    begin
      Result := K_edAbsentData;
      N_Dump2Str( format( 'DB>> EDASAUpdateProvidersByLinkInfo >> wrong Fields Count %d < 5', [i] ) );
      Exit;
    end;

    // Import Provides Data to Import Table
    ExtDataErrorCode := K_eeDBUpdate;

    FirstNameInd := EDAArchUDTabFieldIndex( 'ProviderFirstName', ProvidersInfo );
    SurnameInd := EDAArchUDTabFieldIndex( 'ProviderSurname', ProvidersInfo );
    TitleInd := EDAArchUDTabFieldIndex( 'ProviderTitle', ProvidersInfo );
    ProvFlagsInd := EDAArchUDTabFieldIndex( 'ProviderFlags', ProvidersInfo );
    MiddleInd := EDAArchUDTabFieldIndex( 'ProviderMiddle', ProvidersInfo );

    TmpStrings.Clear;
    TmpStrings.Add( '<providers>' );
    with ProvidersInfo.R do
      for i := 1 to ARowCount - 1 do
          TmpStrings.Add( format( '<provider ProvID="%s" ProvFirstname="%s" '+
    'ProvSurname="%s" ProvTitle="%s" ProvAuthorities="%s" ProvMiddle="%s" />',
               [PString(PME(0, i))^,
                PString(PME(FirstNameInd, i))^,
                PString(PME(SurnameInd, i))^,
                PString(PME(TitleInd, i))^,
                PString(PME(ProvFlagsInd, i))^,
                PString(PME(MiddleInd, i))^] ) );


    TmpStrings.Add( '</providers>' );

    with CurStoredProc1 do
    begin
      Connection := LANDBConnection;
      ProcedureName := 'dba.cms_ImportProvidersData';
      Parameters.Clear;
      with Parameters.AddParameter do
      begin
        Name := '@xml_data';
        Direction := pdInput;
        DataType := ftString;
        Value := TmpStrings.Text;
      end;
      ExecProc;
    end;

    with CurSQLCommand1 do
    begin
    // Update Existing
      Connection := LANDBConnection;
      CommandText :='UPDATE ' + K_CMENDBAllProvidersTable +
                    ' SET ' + K_CMENDAUSurname     + '=' + K_CMENDIUSurname + ',' +
                              K_CMENDAUFirstname   + '=' + K_CMENDIUFirstname + ',' +
                              K_CMENDAUMiddle      + '=' + K_CMENDIUMiddle + ',' +
                              K_CMENDAUTitle       + '=' + K_CMENDIUTitle + ',' +
                              K_CMENDAUAuthorities + '=' + K_CMENDIUAuthorities +
                    ' FROM ' + K_CMENDBImportProvidersTable +
                    ' WHERE ' + K_CMENDAUBridgeID + ' = ' + K_CMENDIUID;
      Execute;

    // Create New
      CommandText :='INSERT INTO ' + K_CMENDBAllProvidersTable +
                    ' (' + K_CMENDAUBridgeID  + ',' + K_CMENDAUSurname + ',' +
                           K_CMENDAUFirstname + ',' + K_CMENDAUMiddle + ',' +
                           K_CMENDAUTitle     + ',' + K_CMENDAUAuthorities + ')' +
                    ' SELECT ' + K_CMENDIUID        + ',' + K_CMENDIUSurname + ',' +
                                 K_CMENDIUFirstname + ',' + K_CMENDIUMiddle + ',' +
                                 K_CMENDIUTitle     + ',' + K_CMENDIUAuthorities +
                    ' FROM ' + K_CMENDBImportProvidersTable +
                    ' WHERE NOT EXISTS (SELECT 1 FROM ' + K_CMENDBAllProvidersTable +
                                       ' WHERE ' + K_CMENDAUBridgeID + ' = ' + K_CMENDIUID + ')';
      Execute;
    end; // with CurSQLCommand1 do

    N_Dump2Str('DB>> EDASAUpdateProvidersByLinkInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAUpdateProvidersByLinkInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAUpdateProvidersByLinkInfo

//********************************************* TK_CMEDDBAccess.EDASAUpdateOneProviderByLinkInfo ***
// Update One Provider data by PMS Link Info
//
// APCLLProvAttrs - Pointer to Command Line Provider Info Attrs
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAUpdateOneProviderByLinkInfo( APCLLProvAttrs : TK_PCMSCLLProviderAttrs ) : TK_CMEDResult;
var
  SID : string;
  RInd, FirstNameInd, SurnameInd, TitleInd, ProvFlagsInd, MiddleInd : Integer;
  PInfo : PString;
  AStr : string;


  function SetValues( AUpdateFlags : Boolean ) : Boolean;
  var
    NewVals : string;
  begin
    Result := FALSE;
    NewVals := '';
    with CurDSet1, APCLLProvAttrs^ do
    begin
      N_Dump2Str( format( 'DB>> Update Provider SetValues FiledCount=%d',
                            [FieldCount] ) );
      ExtDataErrorCode := K_eeDBSetField;

      if (CLLUTitle <> '') and
         (not AUpdateFlags or (Fields[1].AsString <> CLLUTitle)) then
      begin
        NewVals := NewVals + format( ' Title "%s" to "%s"', [Fields[1].AsString, CLLUTitle] );
        EDAPutStringFieldValue( Fields[1], CLLUTitle );
        Result := TRUE;
      end;

      if (CLLUSurname <> '') and
         (not AUpdateFlags or (Fields[2].AsString <> CLLUSurname)) then
      begin
        NewVals := NewVals + format( ' Surname "%s" to "%s"', [Fields[2].AsString, CLLUSurname] );
        EDAPutStringFieldValue( Fields[2], CLLUSurname );
        Result := TRUE;
      end;

      if (CLLUFirstname <> '') and
         (not AUpdateFlags or (Fields[3].AsString <> CLLUFirstname)) then
      begin
        NewVals := NewVals + format( ' Firstname "%s" to "%s"', [Fields[3].AsString, CLLUFirstname] );
        EDAPutStringFieldValue( Fields[3], CLLUFirstname );
        Result := TRUE;
      end;

      if (CLLUAuthorities <> 0) and
         (not AUpdateFlags or (Fields[4].AsInteger <> CLLUAuthorities)) then
      begin
        NewVals := NewVals + format( ' Authorities "%d" to "%d"', [Fields[4].AsInteger, CLLUAuthorities] );
        Fields[4].AsInteger := CLLUAuthorities;
        Result := TRUE;
      end;

      if (CLLUMiddle <> '') and
         (not AUpdateFlags or (Fields[5].AsString <> CLLUMiddle)) then
      begin
        NewVals := NewVals + format( ' Middlename "%s" to "%s"', [Fields[5].AsString, CLLUMiddle] );
        EDAPutStringFieldValue( Fields[5], CLLUMiddle );
        Result := TRUE;
      end;

      if NewVals <> '' then
      begin
        if CMS_LogsCtrlAll then
          N_Dump1Str( format( 'DB>> Update Provider By Link Info %s',
                            [NewVals] ) )
        else
          N_Dump1Str( 'DB>> Update Provider By Link Info' );
      end;
  end;
  end;

begin

  if not (K_uliProviders in UpdatePPLFlagsSet) then
  begin
    N_Dump2Str('DB>> EDASAUpdateOneProviderByLinkInfo is skiped by UpdatePPLFlagsSet' );
    Result := K_edFails;
    Exit;
  end;
  UpdatePPLFlagsSet := UpdatePPLFlagsSet - [K_uliProviders];

  SID := IntToStr(APCLLProvAttrs.CLLUID);
  if APCLLProvAttrs.CLLUID <= 0 then
  begin
    N_Dump2Str('DB>> EDASAUpdateOneProviderByLinkInfo is skiped by CLLUID=' + SID );
    Result := K_edAbsentData;
    Exit;
  end;

  N_Dump2Str('DB>> EDASAUpdateOneProviderByLinkInfo CLLUID=' + SID );
  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;

    ExtDataErrorCode := K_eeDBSelect;

    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      Filtered := false;

      SQL.Text := 'select ' + K_CMENDAUBridgeID + ',' +      //0
                              K_CMENDAUTitle + ',' +         //1
                              K_CMENDAUSurname + ',' +       //2
                              K_CMENDAUFirstname + ',' +     //3
                              K_CMENDAUAuthorities + ',' +   //4
                              K_CMENDAUMiddle +              //5
//                              K_CMENDAUID +                  //5
          ' from ' + K_CMENDBAllProvidersTable +
          ' where ' + K_CMENDAUBridgeID + ' = ' + SID;
      Open;

      if RecordCount = 0 then
      begin // Add New
        N_Dump2Str('DB>> EDASAUpdateOneProviderByLinkInfo Add New');
        Insert;
        ExtDataErrorCode := K_eeDBSetField;
        Fields[0].AsInteger := APCLLProvAttrs.CLLUID;
        SetValues( FALSE );
        UpdateBatch;
        // Get Provider ID for Patient to Provider Linking
//        Close;
//        Open;
//        APCLLProvAttrs.CMSUID := Fields[5].AsInteger;
      end
      else
      begin // Change Existing
        N_Dump2Str('DB>> EDASAUpdateOneProviderByLinkInfo Update');
        Edit;
//        APCLLProvAttrs.CMSUID := Fields[5].AsInteger;
        if SetValues(TRUE) then
          UpdateBatch;
      end;

      with ProvidersInfo.R do
      begin
        if ALength() <= 1 then
        begin
          N_Dump2Str( 'DB>> EDASAUpdateOneProviderByLinkInfo Create New ProvidersInfo Struture' );
          ASetLength( 7, 1 );
          PString(PME(0, 0))^ := 'ProviderID';
          PString(PME(1, 0))^ := 'ProviderFirstName';
          PString(PME(2, 0))^ := 'ProviderSurname';
          PString(PME(3, 0))^ := 'ProviderTitle';
          PString(PME(4, 0))^ := 'ProviderFlags';
          PString(PME(5, 0))^ := 'ProviderSync';
          PString(PME(6, 0))^ := 'ProviderMiddle';
          FirstNameInd := 1;
          SurnameInd := 2;
          TitleInd := 3;
          ProvFlagsInd := 4;
          MiddleInd := 6;
        end
        else
        begin
          N_Dump2Str( 'DB>> EDASAUpdateOneProviderByLinkInfo Use Existing ProvidersInfo Struture' );
          FirstNameInd := EDAArchUDTabFieldIndex( 'ProviderFirstName', ProvidersInfo );
          SurnameInd := EDAArchUDTabFieldIndex( 'ProviderSurname', ProvidersInfo );
          TitleInd := EDAArchUDTabFieldIndex( 'ProviderTitle', ProvidersInfo );
          ProvFlagsInd := EDAArchUDTabFieldIndex( 'ProviderFlags', ProvidersInfo );
          MiddleInd := EDAArchUDTabFieldIndex( 'ProviderMiddle', ProvidersInfo );
        end;


        RInd := EDAArchUDTabIndexOf( SID, ProvidersInfo );
        if RInd = 0 then
        begin
          RInd := ARowCount();
          ASetLength( AColCount(), RInd + 1 );
          PString(PME(0, RInd))^ := SID;
        end;

        N_Dump2Str( format( 'DB>> Update Provider Info FieldCount=%d',
                            [FieldCount] ) );

        PInfo := PString(PME(FirstNameInd, RInd));
        if APCLLProvAttrs.CLLUFirstname <> '' then
          PInfo^ := APCLLProvAttrs.CLLUFirstname
        else
          PInfo^ := EDAGetStringFieldValue(Fields[3]);

        PInfo := PString(PME(SurnameInd, RInd));
        if APCLLProvAttrs.CLLUSurname <> '' then
          PInfo^ := APCLLProvAttrs.CLLUSurname
        else
          PInfo^ := EDAGetStringFieldValue(Fields[2]);

        PInfo := PString(PME(TitleInd, RInd));
        if APCLLProvAttrs.CLLUTitle <> '' then
          PInfo^ := APCLLProvAttrs.CLLUTitle
        else
          PInfo^ := EDAGetStringFieldValue(Fields[1]);

        PInfo := PString(PME(ProvFlagsInd, RInd));
        if APCLLProvAttrs.CLLUAuthorities <> 0 then
          PInfo^ := IntToStr(APCLLProvAttrs.CLLUAuthorities)
        else
        begin
          AStr := Fields[4].AsString;
          if (AStr = '') or (AStr = '0') then
            AStr := '2047';
          if PInfo^ = '' then
            PInfo^ := AStr;
        end;

        PInfo := PString(PME(MiddleInd, RInd));
        if APCLLProvAttrs.CLLUMiddle <> '' then
          PInfo^ := APCLLProvAttrs.CLLUMiddle
        else
          PInfo^ := EDAGetStringFieldValue(Fields[5]);
      end;

      Close;
    end;


    N_Dump2Str('DB>> EDASAUpdateOneProviderByLinkInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAUpdateOneProviderByLinkInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASAUpdateOneProviderByLinkInfo

//******************************* TK_CMEDDBAccess.EDAGetOneProviderHistAttrs ***
// Get Providers History Attrs
//
//     Parameters
// AProvSID - PviderID string
// APCMSAPproviderDBData - pointer to Patient Data
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetOneProviderHistAttrs( const AProvSID : string;
                       APCMProviderHistCapt : PString ) : TK_CMEDResult;
begin
  N_Dump2Str('DB>> EDAGetOnePproviderHistAttrs ID=' + AProvSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  CurDSet1.Connection := LANDBConnection;

  try
    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
      SQL.Text := 'select ' + K_CMENDAHProvCapt +  // 0 1
                 ' from ' + K_CMENDBAllHistProvidersTable +
                 ' where ' + K_CMENDAHProvID + ' = ' + AProvSID;

      Filtered := false;
      Open;
      if RecordCount > 0 then
      begin
        First;
        APCMProviderHistCapt^ := Fields[0].AsString;
      end
      else
        Result := K_edFails;

      Close;
    end;
    N_Dump2Str('DB>> EDAGetOnePproviderHistAttrs fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetOnePproviderHistAttrs ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAGetOnePproviderHistAttrs

//************************************ TK_CMEDDBAccess.EDASAGetPatientsInfo ***
// Get Patients Info in Stand alone mode
//
//     Parameters
// AShowDelFlag - if = TRUE then show marked as deleted flag
// AGetAll      - Get All Patients (without number restrictions)
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAGetPatientsInfo( AShowDelFlag : Boolean; AGetAll : Boolean = FALSE ) : TK_CMEDResult;
var
  i, RCount: Integer;
  SQLText : string;
begin
  N_Dump2Str('DB>> EDASAGetPatientsInfo');

  CurDSet1.Connection := LANDBConnection;
  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;

    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
      if AGetAll then
        SQLText := 'select '
      else
        SQLText := 'select top 10000 ';
//      SQLText := 'select top 30000 ' +

      SQLText := SQLText +
        K_CMENDAPID + ',' + K_CMENDAPCardNum + ',' +          // 0 1
        K_CMENDAPFirstname + ',' + K_CMENDAPSurname + ',' +   // 2 3
        K_CMENDAPTitle + ',' + K_CMENDAPGender + ',' +        // 4 5
        K_CMENDAPDOB + ',' + K_CMENDAPBridgeID + ',' +        // 6 7
        K_CMENDBGTFSAFlags +                                  // 8
        ' from ' + K_CMENDBAllPatientsTable + ',' + K_CMENDBGlobAttrsTable +
        ' where (' + K_CMENDAPFlags;

      if AShowDelFlag then
        SQLText := SQLText + ' & 1) = 1'  // marked as deleted
      else
        SQLText := SQLText + ' & 3) = 0'; // not deleting and not marked as deleted
      SQL.Text := SQLText;
      Filtered := false;

      Open;
      RCount := RecordCount;

      if RCount > 0 then
        Byte(K_CMStandaloneMode) := FieldList.Fields[8].AsInteger and 3;

      N_Dump2Str('DB>> Patients Count=' + IntToStr(RCount));
      with PatientsInfo.R do
      begin
        ASetLength( 8, RCount + 1 );
        PString(PME(0, 0))^ := 'PatientID';
        PString(PME(1, 0))^ := 'PatientCardNumber';
        PString(PME(2, 0))^ := 'PatientFirstName';
        PString(PME(3, 0))^ := 'PatientSurname';
        PString(PME(4, 0))^ := 'PatientTitle';
        PString(PME(5, 0))^ := 'PatientGender';
        PString(PME(6, 0))^ := 'PatientDOB';
        PString(PME(7, 0))^ := 'PatientSync';
        First;
//        with FieldList do
        for i := 1 to RCount do
        begin
{
if Fields[0].AsString = '33' then
N_S := '';
N_S := Fields[1].AsString;
N_S2 := Fields[2].AsString;
N_S2 := Fields[3].AsString;
}
          if K_CMEDDBVersion >= 22 then
            PString(PME(0, i))^ := Fields[7].AsString
          else
            PString(PME(0, i))^ := Fields[0].AsString;

          PString(PME(1, i))^ := Fields[1].AsString;
          if PString(PME(1, i))^ = '' then
            PString(PME(1, i))^ := PString(PME(0, i))^;

          PString(PME(2, i))^ := Fields[2].AsString;
          PString(PME(3, i))^ := Fields[3].AsString;
          PString(PME(4, i))^ := Fields[4].AsString;
          PString(PME(5, i))^ := Fields[5].AsString;
          N_s := Fields[6].AsString;
          if TDateTimeField(Fields[6]).Value = 0 then
            PString(PME(6, i))^ := ''
          else
            PString(PME(6, i))^ := K_DateTimeToStr( TDateTimeField(Fields[6]).Value,
                                    N_WinFormatSettings.ShortDateFormat );
          if Fields[7].AsInteger > 0 then
            PString(PME(7, i))^ := '1'
          else
            PString(PME(7, i))^ := '';
          Next;
        end;
      end;
      Close;
    end;
    N_Dump2Str('DB>> EDASAGetPatientsInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAGetPatientsInfo ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAGetPatientsInfo

//*********************************** TK_CMEDDBAccess.EDASAGetPatientsInfo1 ***
// Get filtered Patients Info in Stand alone mode
//
//     Parameters
// AShowDelFlag - if =0 then skip marked as deleted, =1 show marked as deleted,
//                =2 show both
// AOrderCode - order code:
//   -1 - no order
//    0 - CardNum ASC order
//    1 - CardNum DESC order
//    2 - Surname ASC order
//    3 - Surname DESC order
//    4 - FisrtName ASC order
//    5 - FisrtName DESC order
// ACardNumLike - CardNumber like filter start string
// ASurnameLike - Surname like filter start string
// AFirstnameLike - Firstname like filter start string
// AStartInd - start record based zero index, if = 0 then all records buffer should be resized by all records count
// ACount    - get records number
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAGetPatientsInfo1( AShowDelFlag : Integer; AOrderCode : Integer;
                       const ACardNumLike, ASurnameLike, AFirstnameLike : string;
                       AStartInd : Integer; ACount : Integer ) : TK_CMEDResult;
var
  i, RCount, AllRCount : Integer;
  SQLText : string;
  SQLFilter : string;
  SQLOrder : string;
begin
  N_Dump2Str('DB>> EDASAGetPatientsInfo1');

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  try
    ExtDataErrorCode := K_eeDBSelect;

    SQLFilter := EDAGetPatientsWhereSQL( AShowDelFlag, ACardNumLike, ASurnameLike, AFirstnameLike );
    AllRCount := -1;
    if AStartInd = 0  then
      EDAGetPatientsFilteredCount( SQLFilter, AllRCount );

    with CurDSet1 do
    begin
      SQLOrder := EDAGetPatientsOrderSQL( AOrderCode );

      SQLText := '';
      if ACount > 0 then
        SQLText := ' TOP ' + IntToStr(ACount);
      if AStartInd > 0 then
        SQLText := SQLText + ' START AT ' + IntToStr(AStartInd + 1);

      SQLText := 'select ' + SQLText + ' ' +
        K_CMENDAPID + ',' + K_CMENDAPCardNum + ',' +        // 0 1
        K_CMENDAPFirstname + ',' + K_CMENDAPSurname + ',' + // 2 3
        K_CMENDAPTitle + ',' + K_CMENDAPGender + ',' +      // 4 5
        K_CMENDAPDOB + ',' + K_CMENDAPBridgeID + ',' +      // 6 7
        K_CMENDBGTFSAFlags +                                // 8
        ' from ' + K_CMENDBAllPatientsTable + ',' + K_CMENDBGlobAttrsTable;

      SQL.Text := SQLText + SQLFilter + SQLOrder;
      Filtered := false;
      Open;
      RCount := RecordCount;

      if RCount > 0 then
        Byte(K_CMStandaloneMode) := Fields[8].AsInteger and 3;

      N_Dump2Str('DB>> Patients Count=' + IntToStr(RCount));
      with PatientsInfo.R do
      begin
        if AllRCount >= 0 then
        begin
          ASetLength( 8, AllRCount + 1 );
          PString(PME(0, 0))^ := 'PatientID';
          PString(PME(1, 0))^ := 'PatientCardNumber';
          PString(PME(2, 0))^ := 'PatientFirstName';
          PString(PME(3, 0))^ := 'PatientSurname';
          PString(PME(4, 0))^ := 'PatientTitle';
          PString(PME(5, 0))^ := 'PatientGender';
          PString(PME(6, 0))^ := 'PatientDOB';
          PString(PME(7, 0))^ := 'PatientSync';
        end;
        First;
        for i := 1 + AStartInd to RCount + AStartInd do
        begin
          PString(PME(0, i))^ := Fields[0].AsString;
          PString(PME(1, i))^ := Fields[1].AsString;
          PString(PME(2, i))^ := Fields[2].AsString;
          PString(PME(3, i))^ := Fields[3].AsString;
          PString(PME(4, i))^ := Fields[4].AsString;
          PString(PME(5, i))^ := Fields[5].AsString;
          if TDateTimeField(Fields[6]).Value = 0 then
            PString(PME(6, i))^ := ''
          else
            PString(PME(6, i))^ := K_DateTimeToStr( TDateTimeField(Fields[6]).Value,
                                    N_WinFormatSettings.ShortDateFormat );
          if Fields[7].AsInteger > 0 then
            PString(PME(7, i))^ := '1'
          else
            PString(PME(7, i))^ := '';
          Next;
        end;
      end;
      Close;
    end;
    N_Dump2Str('DB>> EDASAGetPatientsInfo1 fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAGetPatientsInfo1 ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAGetPatientsInfo1

//********************************** TK_CMEDDBAccess.EDASAGetOnePatientInfo ***
// Get Patients Info in Stand alone mode
//
//     Parameters
// APatSID - Patient ID string
// APCMSAPatientDBData - pointer to Patient Data
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAGetOnePatientInfo( const APatSID : string;
                       APCMSAPatientDBData : TK_PCMSAPatientDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult;
var
  SAppRTID : string;
  SQLText : string;
  SQLIDFName : string;
begin
  N_Dump2Str('DB>> EDASAGetOnePatientInfo ID=' + APatSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  SAppRTID := IntToStr(AppRTID);
  CurDSet1.Connection := LANDBConnection;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDAPBridgeID
  else
    SQLIDFName := K_CMENDAPID;

  try
    if not (K_cmsagiSkipLock  in ALockFlags ) then
    begin
      ExtDataErrorCode := K_eeDBUpdate;
      with CurSQLCommand1 do
      begin
      // Try to
        Connection := LANDBConnection;
        CommandText := 'UPDATE ' + K_CMENDBAllPatientsTable +
          ' SET ' + K_CMENDAPActRTID + ' = ' + SAppRTID +
          ' WHERE ' + SQLIDFName + ' = ' + APatSID +
          ' AND ' + K_CMENDAPActRTID + ' = 0';

        Execute;
      end; // with CurSQLCommand1 do
    end; // if not (K_cmsagiSkipLock  in ALockFlags ) then

    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
      SQLText := 'select ' +
        K_CMENDAPActRTID  + ',' + K_CMENDAPFlags + ',' + K_CMENDAPBridgeID;  // 0 1 2
      if not (K_cmsagiLockOnly in ALockFlags) then
        SQLText := SQLText + ',' +
          K_CMENDAPTitle + ',' +                                // 3
          K_CMENDAPGender   + ',' + K_CMENDAPCardNum + ',' +    // 4 5
          K_CMENDAPSurname  + ',' + K_CMENDAPFirstname + ',' +  // 6 7
          K_CMENDAPMiddle   + ',' + K_CMENDAPDOB + ',' +        // 8 9
          K_CMENDAPProvID   + ',' + K_CMENDAPAddr1 + ',' +      // 10 11
          K_CMENDAPAddr2    + ',' + K_CMENDAPSuburb + ',' +     // 12 13
          K_CMENDAPPostCode + ',' + K_CMENDAPState + ',' +      // 14 15
          K_CMENDAPPhone1   + ',' + K_CMENDAPPhone2;            // 16 17

      SQL.Text := SQLText +
        ' from ' + K_CMENDBAllPatientsTable +
        ' where ' + SQLIDFName + ' = ' + APatSID;

      Filtered := false;
      Open;
      if RecordCount > 0 then
      begin
        First;
        with APCMSAPatientDBData^, FieldList do
        begin
          APIsLocked  := Fields[0].AsInteger = AppRTID;
          APDBFlags   := Fields[1].AsInteger and 1;
          APIsPMSSync := Fields[2].AsInteger > 0;

          if not (K_cmsagiLockOnly in ALockFlags) then
          begin
            APTitle     := Fields[3].AsString;
            APGender    := Fields[4].AsString;
            APCardNum   := Fields[5].AsString;
            APSurname   := Fields[6].AsString;
            APFirstname := Fields[7].AsString;
            APMiddle    := Fields[8].AsString;
            APDOB       := TDateTimeField(Fields[9]).Value;
            APProvID    := Fields[10].AsInteger;
            APAddr1     := Fields[11].AsString;
            APAddr2     := Fields[12].AsString;
            APSuburb    := Fields[13].AsString;
            APPostCode  := Fields[14].AsString;
            APState     := Fields[15].AsString;
            APPhone1    := Fields[16].AsString;
            APPhone2    := Fields[17].AsString;
          end;
        end;
      end
      else
        Result := K_edFails;

      Close;
    end;
    N_Dump2Str('DB>> EDASAGetOnePatientInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAGetOnePatientInfo ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAGetOnePatientInfo

//******************************** TK_CMEDDBAccess.EDASACheckPatientCardNum ***
// Check Patient Cardnumber
//
//     Parameters
// APatSID - Patient ID string
// APCMSAPatientDBData - pointer to Patient Data
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASACheckPatientCardNum( const APatSID, AParCardNum : string ) : TK_CMEDResult;
var
  SQLIDFName : string;
begin
  N_Dump2Str('DB>> EDASACheckPatientCardNum ID=' + APatSID);

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDAPBridgeID
  else
    SQLIDFName := K_CMENDAPID;
  try
    ExtDataErrorCode := K_eeDBSelect;                               
    with CurDSet1 do
    begin
      // Check in Patients Table
      SQL.Text := 'select ' + SQLIDFName  +
        ' from ' + K_CMENDBAllPatientsTable +
        ' where ' + K_CMENDAPCardNum + '=''' + AParCardNum + '''';
      Open;
      if (RecordCount > 0) and
         (FieldList.Fields[0].AsString <> APatSID) then
        Result := K_edFails;
      Close;

      if (Result = K_edFails) or
         (K_CMEDDBVersion < 20) then Exit;

      // Check in Deleted Patient Card Numbers Table
      SQL.Text := 'select ' + K_CMENDDPCardNum  +
        ' from ' + K_CMENDBDelPatCardNumsTable +
        ' where ' + K_CMENDDPCardNum + '=''' + AParCardNum + '''';
      Open;
      if RecordCount > 0 then
          Result := K_edFails;
      Close;

    end; // with CurDSet1 do

    N_Dump2Str('DB>> EDASACheckPatientCardNum fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASACheckPatientCardNum ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASACheckPatientCardNum

//********************************** TK_CMEDDBAccess.EDASASetOnePatientInfo ***
// Set Patient Info in Stand alone mode and unlock
//
//     Parameters
// APatSID - Patient ID string
// APCMSAPatientDBData - pointer to Patient Data
// ASkipFieldsSet - unlock patient only
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASASetOnePatientInfo( var APatSID : string;
                       APCMSAPatientDBData : TK_PCMSAPatientDBData;
                       ASkipFieldsSet : Boolean ) : TK_CMEDResult;
var
  InTrans: Boolean;
  Ind : Integer;
  SQLText : string;
  SRPatID, SAppRTID : string;
  SQLIDFName : string;
  PatID, IRCardNum : Integer;

  procedure SetValues();
  begin
    with CurDSet1 do
    begin
      ExtDataErrorCode := K_eeDBSetField;
      with FieldList do
      begin
        EDAPutStringFieldValue( Fields[0], APCMSAPatientDBData.APTitle );
        EDAPutStringFieldValue( Fields[1], APCMSAPatientDBData.APGender );

        if (APatSID = '') or
           ( (APCMSAPatientDBData.APCardNum <> '') and
             (APCMSAPatientDBData.APCardNum <> Fields[2].AsString) ) then
          EDAPutStringFieldValue( Fields[2], APCMSAPatientDBData.APCardNum );

        EDAPutStringFieldValue( Fields[3], APCMSAPatientDBData.APSurname );
        EDAPutStringFieldValue( Fields[4], APCMSAPatientDBData.APFirstname );
        EDAPutStringFieldValue( Fields[5], APCMSAPatientDBData.APMiddle );
        if APCMSAPatientDBData.APDOB > 0 then
          TDateTimeField(Fields[6]).Value := APCMSAPatientDBData.APDOB;
        Fields[7].AsInteger := APCMSAPatientDBData.APProvID;
        EDAPutStringFieldValue( Fields[8], APCMSAPatientDBData.APAddr1 );
        EDAPutStringFieldValue( Fields[9], APCMSAPatientDBData.APAddr2 );
        EDAPutStringFieldValue( Fields[10], APCMSAPatientDBData.APSuburb );
        EDAPutStringFieldValue( Fields[11], APCMSAPatientDBData.APPostCode );
        EDAPutStringFieldValue( Fields[12], APCMSAPatientDBData.APState );
        EDAPutStringFieldValue( Fields[13], APCMSAPatientDBData.APPhone1 );
        EDAPutStringFieldValue( Fields[14], APCMSAPatientDBData.APPhone2 );
      end;
    end;
  end; // procedure SetValues

  procedure DefineAproxCardNum();
  begin
    with CurDSet2 do
    begin
      Connection := LANDBConnection;

      SQL.Text := 'select max(' + K_CMENDAPID + ') from ' + K_CMENDBAllPatientsTable;
      Open;
      IRCardNum := FieldList.Fields[0].AsInteger + 1;
      Close;
    end;
  end; // procedure DefineAproxCardNum

  procedure DefineUniqueCardNum();
  var
    SCardNum : string;
  begin
    while TRUE do
    begin
      SCardNum := IntToStr(IRCardNum);
      with CurDSet2 do
      begin
        Connection := LANDBConnection;

        SQL.Text := 'select ' + K_CMENDAPCardNum +
          ' from ' + K_CMENDBAllPatientsTable +
          ' where ' + K_CMENDAPCardNum  + ' = ''' + SCardNum + '''';
        Open;
        if RecordCount > 0 then
          SCardNum := '';
        Close;
      end;
      if SCardNum <> '' then Break;
      Inc(IRCardNum);
    end;
    APCMSAPatientDBData.APCardNum := SCardNum;
  end; // procedure DefineUniqueCardNum

begin
  N_Dump2Str('DB>> EDASASetOnePatientInfo ID=' + APatSID);

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDAPBridgeID
  else
    SQLIDFName := K_CMENDAPID;

  SAppRTID := IntToStr(AppRTID);

  try
    if (APatSID <> '') and ASkipFieldsSet then
    begin
      ExtDataErrorCode := K_eeDBUpdate;
      with CurSQLCommand1 do
      begin
      // Try to Unlock if Fields Setting is not needed
        Connection := LANDBConnection;
        CommandText := 'UPDATE ' + K_CMENDBAllPatientsTable +
          ' SET ' + K_CMENDAPActRTID + ' =  0' +
          ' WHERE ' + SQLIDFName + ' = ' + APatSID +
          ' AND ' + K_CMENDAPActRTID + ' = ' + SAppRTID;
        Execute;
      end;
      Exit;
    end;

    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
      Connection := LANDBConnection;

      SQLText := 'select ' +
        K_CMENDAPTitle + ',' +                                // 0
        K_CMENDAPGender   + ',' + K_CMENDAPCardNum + ',' +    // 1 2
        K_CMENDAPSurname  + ',' + K_CMENDAPFirstname + ',' +  // 3 4
        K_CMENDAPMiddle   + ',' + K_CMENDAPDOB + ',' +        // 5 6
        K_CMENDAPProvID   + ',' + K_CMENDAPAddr1 + ',' +      // 7 8
        K_CMENDAPAddr2    + ',' + K_CMENDAPSuburb + ',' +     // 9 10
        K_CMENDAPPostCode + ',' + K_CMENDAPState + ',' +      // 11 12
        K_CMENDAPPhone1   + ',' + K_CMENDAPPhone2 + ',' +     // 13 14
        K_CMENDAPActRTID  + ',' + K_CMENDAPID + ',' +         // 15 16
        K_CMENDAPBridgeID +                                   // 17
        ' from ' + K_CMENDBAllPatientsTable;
      if APatSID <> '' then
      begin
        if APCMSAPatientDBData.APCardNum = '' then
        begin
          DefineAproxCardNum();
          DefineUniqueCardNum();
        end;
      // Modify
        SQL.Text := SQLText + ' where ' + SQLIDFName + ' = ' + APatSID +
                    ' AND ' + K_CMENDAPActRTID + ' = ' + SAppRTID;
        Open;
        if RecordCount > 0 then
        begin
          First;
          Edit;
          SetValues();
          FieldList.Fields[15].AsInteger := 0; // Clear Locked Flag
          UpdateBatch;
        end;
        Close;

        Ind := EDAArchUDTabIndexOf( APatSID, PatientsInfo );
      end   // if APatSID <> '' then
      else
      begin // if APatSID = '' then
      // Add New
        InTrans := LANDBConnection.InTransaction;
        if not InTrans then
          LANDBConnection.BeginTrans;

        SQL.Text := SQLText + ' where ' + K_CMENDAPID + ' = -1';
        Filtered := false;
        Open;
        ExtDataErrorCode := K_eeDBIns;
        Insert;

        ExtDataErrorCode := K_eeDBSetField;
        SetValues();
        UpdateBatch;
        Close;

        SQL.Text := 'select @@identity';
        Open;
        PatID := FieldList.Fields[0].AsInteger;
        SRPatID := FieldList.Fields[0].AsString;
        IRCardNum := PatID;
        Close;

        if K_CMEDDBVersion >= 22 then
          PatID := -100 - PatID;


        APatSID := IntToStr(PatID);

        SQLText := '';
        if APCMSAPatientDBData.APCardNum = '' then
        begin
          DefineUniqueCardNum();
           // Set Patient unique Card Number
          SQLText := K_CMENDAPCardNum   + ' = ''' + APCMSAPatientDBData.APCardNum + '''';
        end;
        if K_CMEDDBVersion >= 22 then
        begin
          if SQLText <> '' then
            SQLText := SQLText + ',';
          SQLText := SQLText + K_CMENDAPBridgeID + ' = ' + APatSID;
        end;

        if SQLText <> '' then
          with CurSQLCommand1 do
          begin
            Connection := LANDBConnection;
            CommandText := 'UPDATE ' + K_CMENDBAllPatientsTable +
              ' SET ' + SQLText +
              ' WHERE ' + K_CMENDAPID + ' = ' + SRPatID;
            Execute;
          end;

        if not InTrans then
          LANDBConnection.CommitTrans;

        APCMSAPatientDBData.APIsPMSSync := FALSE; //Clear PMS SynchFlag for new Patient
        // Add Row for New Patient to PatientsInfo
        with PatientsInfo.R do
        begin
          Ind := ARowCount();
          ASetLength( AColCount(), Ind + 1 );
          PString(PME(0, Ind))^ := APatSID;
        end;

      end; // if APatSID = '' then
    end; // with CurDSet1 do

    // Set Values to PatientsInfo
    with PatientsInfo.R do
    begin
      PString(PME(1, Ind))^ := APCMSAPatientDBData.APCardNum;
      PString(PME(2, Ind))^ := APCMSAPatientDBData.APFirstname;
      PString(PME(3, Ind))^ := APCMSAPatientDBData.APSurname;
      PString(PME(4, Ind))^ := APCMSAPatientDBData.APTitle;
      PString(PME(5, Ind))^ := APCMSAPatientDBData.APGender;
      if APCMSAPatientDBData.APDOB = 0 then
        PString(PME(6, Ind))^ := ''
      else
        PString(PME(6, Ind))^ := K_DateTimeToStr( APCMSAPatientDBData.APDOB,
                                        N_WinFormatSettings.ShortDateFormat );
      if APCMSAPatientDBData.APIsPMSSync then
        PString(PME(7, Ind))^ := '1';
    end;
    N_Dump2Str('DB>> EDASASetOnePatientInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASASetOnePatientInfo ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASASetOnePatientInfo

//********************************************* TK_CMEDDBAccess.EDASASetClearPatientDelState ***
// Set Given Patient Deleting Flag and Unlock
//
//     Parameters
// APatSID - Patient ID string
// AFlags  - Flags string: ='2' Set Deleted forever state, ='0' clear Mark as Deleted State
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASASetClearPatientDelState( const APatSID, AFlags : string ) : TK_CMEDResult;
var
  SQLIDFName : string;
begin
  N_Dump2Str('DB>> EDASAPatientSetDeleting ID=' + APatSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  if K_CMEDDBVersion >= 22 then
    SQLIDFName := K_CMENDAPBridgeID
  else
    SQLIDFName := K_CMENDAPID;

  try
    ExtDataErrorCode := K_eeDBUpdate;
    with CurSQLCommand1 do
    begin
    // Try to
      Connection := LANDBConnection;
      CommandText := 'UPDATE ' + K_CMENDBAllPatientsTable +
        ' SET ' + K_CMENDAPActRTID + ' = 0,' +
                  K_CMENDAPFlags + ' = ' + AFlags +
        ' WHERE ' + SQLIDFName + ' = ' + APatSID +
        ' AND ' + K_CMENDAPActRTID + ' = ' + IntToStr(AppRTID); // Precaution

      Execute;
    end;
    N_Dump2Str('DB>> EDASAPatientSetDeleting fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAPatientSetDeleting ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASASetClearPatientDelState
{
//********************************************* TK_CMEDDBAccess.EDASAMarkPatientAsDel ***
// Set Given Patient Marked as Deleted Flag and Unlock
//
//     Parameters
// APatSID - Patient ID string
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAMarkPatientAsDel( const APatSID : string  ) : TK_CMEDResult;
begin
  N_Dump2Str('DB>> EDASAMarkPatientAsDel ID=' + APatSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;


  CurDSet1.Connection := LANDBConnection;
  try
    ExtDataErrorCode := K_eeDBUpdate;
    with CurSQLCommand1 do
    begin
    // Try to
      Connection := LANDBConnection;
      CommandText := 'UPDATE ' + K_CMENDBAllPatientsTable +
        ' SET ' + K_CMENDAPActRTID + ' = 0,' +
                  K_CMENDAPFlags + ' = 1' +
        ' WHERE ' + K_CMENDAPID + ' = ' + APatSID +
        ' AND ' + K_CMENDAPActRTID + ' = ' + IntToStr(AppRTID); // Prcaution

      Execute;
    end;
    N_Dump2Str('DB>> EDASAMarkPatientAsDel fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAMarkPatientAsDel ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAMarkPatientAsDel
}

//********************************************* TK_CMEDDBAccess.EDASAGetPatientSlidesView ***
// Get Given Stand alone Patient Slides from Extenal Data
//
//     Parameters
// APatSID - Patient ID string
// ASlidesArray - Resulting Slides Array
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAGetPatientSlidesView( const APatSID : string; var ASlidesArray : TN_UDCMSArray ): TK_CMEDResult;
var
  i : Integer;
  StudyFlag : Boolean;
  StudyID : Integer;
  SQLText : string;
begin
  N_Dump2Str('DB>> EDASAGetPatientSlidesView for patient ID=' + APatSID);
  // Result := inherited EDAGetCurSlidesSet( CurSlidesSelectAttrs );
  // CurSlidesRoot.ClearChilds();
  for i := 0 to High(ASlidesArray) do
    ASlidesArray[i].Free();

  Result := K_edOK;
  if APatSID = '' then Exit;

  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;
    with CurSlidesDSet do
    begin
      Connection := LANDBConnection;

      SQLText := 'select ' +
                K_CMENDBSTFSlideID + ',' +
                K_CMENDBSTFSlideDTTaken + ',' +
                K_CMENDBSTFSlideThumbnail;
      if K_CMEDDBVersion >= 24 then
        SQLText := SQLText + ',' + K_CMENDBSTFSlideStudyID;

      SQL.Text := SQLText +
                ' from ' + K_CMENDBSlidesTable +
                ' where ' +  K_CMENDBSTFPatID + '=' + APatSID +
                             K_CMEDAGetSlideSelectWhereStr( K_swfSkipAllDel ) +
//                             EDAGetSlideSelectWhereStr( K_swfSkipAllDel ) +
                ' order by ' + K_CMENDBSTFSlideDTCr + ' asc';

      Filtered := false;
      Open;
      i := CurSlidesDSet.RecordCount;
      SetLength(ASlidesArray, i );
      First;
      i := i - 1;
      while not Eof do
      begin
        StudyFlag := (K_CMEDDBVersion >= 24);
        StudyID := 0;
        if StudyFlag then
        begin
          StudyID := Fields[3].AsInteger;
          StudyFlag := StudyID < 0;
        end;

        if not StudyFlag then
        begin
          CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMSlideCI));
          TN_UDCMSlide(CurSlide).CMSStudyID := StudyID;
        end
        else
        begin
          CurSlide := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMStudyCI));
          TN_UDCMStudy(CurSlide).CMSStudySampleID := - StudyID;
//          TN_UDCMStudy(CurSlide).CMSStudySampleID := StudyID;
        end;
        CurSlide.ObjName := Fields[0].AsString;
        CurSlide.P^.CMSDTTaken := TDateTimeField(Fields[1]).Value;
        EDAGetSlideThumbnail(CurSlide);
        ASlidesArray[i] := CurSlide;
        Next();
        Dec(i);
      end;
      Close();
    end;

    N_Dump2Str('DB>> EDASAGetPatientSlidesView fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAGetPatientSlidesView ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSelect;
      Exit;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASAGetPatientSlidesView

//********************************************* TK_CMEDDBAccess.EDASADelOnePatientSlides ***
// Delete Given Patient Slides and Patient if needed
//
//     Parameters
// APatSID - Patient ID string
// Result - Returns operation resulting code
//
function  TK_CMEDDBAccess.EDASADelOnePatientSlides( const APatSID : string ): TK_CMEDResult;
var
  i : Integer;
  SlidesArray : TN_UDCMSArray;
  PatID, DCount : Integer;
  SaveGAMode : Boolean;
  SQLText : string;
begin
  N_Dump2Str('DB>> EDASADelOnePatientSlides for patient ID=' + APatSID);

  Result := K_edOK;
  if APatSID = '' then Exit;

  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;

    // Create Slides to Delete Array
    with CurSlidesDSet do
    begin
      Connection := LANDBConnection;

      SQL.Text := 'select ' + K_CMENDBSTFSlideID + ','
                            + K_CMENDBSTFSlideDTCr + ','
                            + K_CMENDBSTFSlideSysInfo +
                ' from ' + K_CMENDBSlidesTable +
                ' where ' +  K_CMENDBSTFPatID + '=' + APatSID;

      Filtered := false;
      Open;
      i := CurSlidesDSet.RecordCount;
      SetLength(SlidesArray, i );
      First;
      i := 0;
      PatID := StrToInt( APatSID );
      while not Eof do
      begin
        SlidesArray[i] := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1,
            N_UDCMSlideCI));
        with SlidesArray[i], P^ do
        begin
          ObjName := FieldList[0].AsString;
          CMSPatID := PatID;
          CMSDTCreated := TDateTimeField(FieldList[1]).Value;
          K_CMEDAGetSlideSysFieldsData(FieldList[2].AsString, @CMSDB);
        end;
        Next();
        Inc(i);
      end;
      Close();
    end; // with CurSlidesDSet do

    // Try To Delete Patient SLides
    DCount := 0;
    if i > 0 then
    begin
      SaveGAMode := K_CMGAModeFlag;
      K_CMGAModeFlag := TRUE;
      GUISilentFlag := TRUE;
      K_CMSlidesDelete( @SlidesArray[0], i, FALSE, TRUE );
      GUISilentFlag := FALSE;
      K_CMGAModeFlag := SaveGAMode;
      DCount := LockResCount;
      LockResCount := 0;
      N_Dump2Str( format( 'DB>> Del Slides %d of %d', [DCount,i] ));
    end;

    if (i = 0) or (i = DCount) then
    begin // Patient should be deleted
      ExtDataErrorCode := K_eeDBUpdate;
      with CurSQLCommand1 do
      begin
      // Delete Patient Record if all Slides are deleted
        Connection := LANDBConnection;

        SQLText := 'DELETE ' + K_CMENDBAllPatientsTable +
          ' WHERE ' + K_CMENDAPID + ' = ' + APatSID;
        if K_CMEDDBVersion >= 20 then
          SQLText := 'BEGIN ' +
                     ' INSERT INTO ' + K_CMENDBDelPatCardNumsTable +
                     ' (' + K_CMENDDPCardNum + ')' +
                     ' ON EXISTING SKIP ' +
                     ' SELECT ' + K_CMENDAPCardNum +
                     ' FROM ' + K_CMENDBAllPatientsTable +
                     ' WHERE ' + K_CMENDAPID + ' = ' + APatSID + ';' +
                      SQLText  + ' END';
{ Resulting Text
        CommandText := 'BEGIN ' +
         ' INSERT INTO ' + K_CMENDBDelPatCardNumsTable +
         ' ('+K_CMENDDPCardNum+ ')' +
         ' SELECT ' + K_CMENDAPCardNum +
         ' FROM ' + K_CMENDBAllPatientsTable +
         ' WHERE ' + K_CMENDAPID + ' = ' + APatSID + ';' +
         ' DELETE ' + K_CMENDBAllPatientsTable +
         ' WHERE ' + K_CMENDAPID + ' = ' + APatSID + ' END';
}
        CommandText := SQLText;
        Execute;
      end;
      N_Dump2Str( 'DB>> Del Patient' );
    end;
    N_Dump2Str('DB>> EDASADelOnePatientSlides fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASADelOnePatientSlides ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSelect;
      Exit;
    end;
  end;
end; // function  TK_CMEDDBAccess.EDASADelOnePatientSlides

//***************************** TK_CMEDDBAccess.EDASADelAllDelPatientSlides ***
// Delete All Deleted Patients Slides and Patients if needed
//
//     Parameters
// Result - Returns operation resulting code
//
function  TK_CMEDDBAccess.EDASADelAllDelPatientSlides( ): TK_CMEDResult;
var
  i : Integer;
  PatientIDsArray : TN_SArray;
begin
  N_Dump2Str('DB>> EDASADelAllDelPatientSlides' );

  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;

    // Create Slides to Delete Array
    with CurSlidesDSet do
    begin
      SQL.Text := 'select ' + K_CMENDAPID +
                  ' from ' + K_CMENDBAllPatientsTable +
                  ' where ' +  K_CMENDAPFlags + '=2';

      Filtered := false;
      Open;
      i := CurSlidesDSet.RecordCount;
      SetLength(PatientIDsArray, i );
      First;
      i := 0;
      while not Eof do
      begin
        PatientIDsArray[i] := FieldList[0].AsString;
        Next();
        Inc(i);
      end;
      Close();
    end; // with CurSlidesDSet do

    for i := 0 to High(PatientIDsArray) do
      EDASADelOnePatientSlides(PatientIDsArray[i]);

    N_Dump2Str('DB>> EDASADelAllDelPatientSlides fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASADelAllDelPatientSlides ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSelect;
      Exit;
    end;
  end;
end; // function  TK_CMEDDBAccess.EDASADelAllDelPatientSlides
{
//********************************************* TK_CMEDDBAccess.EDASAUpdatePatientsByLinkInfo ***
// Update Patients data by PMS Link Øòàù
//
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAUpdatePatientsByLinkInfo( ) : TK_CMEDResult;
var
  i  : Integer;
  SPatDOB, SPatGender, WStr : string;
  DOB : TDateTime;
begin
  if not (K_uliPatients in UpdatePPLFlagsSet) then
  begin
    N_Dump2Str('DB>> EDASAUpdatePatientsByLinkInfo is skiped by UpdatePPLFlagsSet' );
    Result := K_edFails;
    Exit;
  end;

  N_Dump2Str('DB>> EDASAUpdatePatientsByLinkInfo' );
  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;
//Exit;

    i := PatientsInfo.R.AColCount;
    if i < 7 then
    begin
      Result := K_edAbsentData;
      N_Dump2Str( format( 'DB>> EDASAUpdatePatientsByLinkInfo >> wrong Fields Count %d < 7', [i] ) );
      Exit;
    end;

    ExtDataErrorCode := K_eeDBUpdate;
    TmpStrings.Clear;
    TmpStrings.Add( '<patients>' );
    with PatientsInfo.R do
      for i := 1 to ARowCount - 1 do
      begin
        SPatGender := PString(PME(5, i))^;
        if Length(SPatGender) > 1 then
          SPatGender := Copy( SPatGender, 1, 1 );

        DOB := StrToDateDef( PString(PME(6, i))^, 0, N_WinFormatSettings );
        if DOB <> 0 then
          SPatDOB := K_DateTimeToStr( DOB, 'yyyy"-"mm"-"dd' );

        WStr := format( '<patient PatID="%s" PatCardNum="%s" PatFirstname="%s" '+
                        'PatSurname="%s" PatTitle="%s" PatGender="%s" ',
               [PString(PME(0, i))^,
                PString(PME(1, i))^,
                PString(PME(2, i))^,
                PString(PME(3, i))^,
                PString(PME(4, i))^,
                SPatGender] );
        if DOB <> 0 then
          WStr := format( '%s%s />', [WStr, K_DateTimeToStr( DOB, 'yyyy"-"mm"-"dd' )] )
        else
          WStr := WStr + '/>';
        TmpStrings.Add( WStr );
      end;
    TmpStrings.Add( '</patients>' );
    with CurStoredProc1 do
    begin
      Connection := LANDBConnection;
      ProcedureName := 'dba.cms_UpdatePatientsData';
      Parameters.Clear;
      with Parameters.AddParameter do
      begin
        Name := '@xml_data';
        Direction := pdInput;
        DataType := ftString;
        Value := TmpStrings.Text;
      end;
      ExecProc;
    end;
    UpdatePPLFlagsSet := UpdatePPLFlagsSet - [K_uliPatients];
    N_Dump2Str('DB>> EDASAUpdatePatientsByLinkInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAUpdatePatientsByLinkInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDASAUpdatePatientsByLinkInfo
}
//********************************************* TK_CMEDDBAccess.EDASAUpdateOnePatientByLinkInfo ***
// Update One Patient data by PMS Link Info
//
// ACLLPatAttrs - Command Line Patient Info Attrs
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAUpdateOnePatientByLinkInfo( APCLLPatAttrs : TK_PCMSCLLPatientAttrs ) : TK_CMEDResult;
var
  SID : string;
  RInd, FirstNameInd, SurnameInd, TitleInd, CardNumInd, DOBInd, GenderInd : Integer;
  PInfo : PString;
  WDOB : TDateTime;

  function SetValues( AUpdateFlags : Boolean ) : Boolean;
  var
    NewVals : string;
  begin
    Result := FALSE;
    NewVals := '';
    with CurDSet1, APCLLPatAttrs^ do
    begin
      N_Dump2Str( format( 'DB>> Update Patient SetValues FieldCount=%d',
                            [FieldCount] ) );
      ExtDataErrorCode := K_eeDBSetField;
      if CLLPCardNum = '' then
      begin
        CLLPCardNum := Fields[1].AsString;
        if CLLPCardNum = '' then CLLPCardNum := SID;
      end;

      if not AUpdateFlags or (Fields[1].AsString <> CLLPCardNum) then
      begin
        NewVals := NewVals + format( ' CardNum "%s" to "%s"', [Fields[1].AsString, CLLPCardNum] );
        EDAPutStringFieldValue( Fields[1], CLLPCardNum );
        Result := TRUE;
      end;

      if (CLLPTitle <> '') and
         (not AUpdateFlags or (Fields[2].AsString <> CLLPTitle)) then
      begin
        NewVals := NewVals + format( ' Title "%s" to "%s"', [Fields[2].AsString, CLLPTitle] );
        EDAPutStringFieldValue( Fields[2], CLLPTitle );
        Result := TRUE;
      end;

      if (CLLPSurname <> '') and
         (not AUpdateFlags or (Fields[3].AsString <> CLLPSurname)) then
      begin
        NewVals := NewVals + format( ' Surname "%s" to "%s"', [Fields[3].AsString, CLLPSurname] );
        EDAPutStringFieldValue( Fields[3], CLLPSurname );
        Result := TRUE;
      end;

      if (CLLPFirstname <> '') and
         (not AUpdateFlags or (Fields[4].AsString <> CLLPFirstname)) then
      begin
        NewVals := NewVals + format( ' Firstname "%s" to "%s"', [Fields[4].AsString, CLLPFirstname] );
        EDAPutStringFieldValue( Fields[4], CLLPFirstname );
        Result := TRUE;
      end;

      if (CLLPDOB <> 0) and
         (not AUpdateFlags or (TDateTimeField(Fields[5]).Value <> CLLPDOB)) then
      begin
        NewVals := NewVals + format( ' DOB "%s" to "%s"',
                                [K_DateTimeToStr( TDateTimeField(Fields[5]).Value,
                                              N_WinFormatSettings.ShortDateFormat ),
                                 K_DateTimeToStr( CLLPDOB,
                                              N_WinFormatSettings.ShortDateFormat )] );
        TDateTimeField(Fields[5]).Value := CLLPDOB;
        Result := TRUE;
      end;

      if (CLLPAddr1 <> '') and
         (not AUpdateFlags or (Fields[6].AsString <> CLLPAddr1)) then
      begin
        NewVals := NewVals + format( ' Addr1 "%s" to "%s"', [Fields[6].AsString, CLLPAddr1] );
        EDAPutStringFieldValue( Fields[6], CLLPAddr1 );
        Result := TRUE;
      end;

      if (CLLPAddr2 <> '') and
         (not AUpdateFlags or (Fields[7].AsString <> CLLPAddr2)) then
      begin
        NewVals := NewVals + format( ' Addr2 "%s" to "%s"', [Fields[7].AsString, CLLPAddr2] );
        EDAPutStringFieldValue( Fields[7], CLLPAddr2 );
        Result := TRUE;
      end;

      if (CLLPPostCode <> '') and
         (not AUpdateFlags or (Fields[8].AsString <> CLLPPostCode)) then
      begin
        NewVals := NewVals + format( ' PostCode "%s" to "%s"', [Fields[8].AsString, CLLPPostCode] );
        EDAPutStringFieldValue( Fields[8], CLLPPostCode );
        Result := TRUE;
      end;

      if (CLLPSuburb <> '') and
         (not AUpdateFlags or (Fields[9].AsString <> CLLPSuburb)) then
      begin
        NewVals := NewVals + format( ' Suburb "%s" to "%s"', [Fields[9].AsString, CLLPSuburb] );
        EDAPutStringFieldValue( Fields[9], CLLPSuburb );
        Result := TRUE;
      end;

      if (CLLPState <> '') and
         (not AUpdateFlags or (Fields[10].AsString <> CLLPState)) then
      begin
        NewVals := NewVals + format( ' State "%s" to "%s"', [Fields[10].AsString, CLLPState] );
        EDAPutStringFieldValue( Fields[10], CLLPState );
        Result := TRUE;
      end;

      if (CLLPPhone1 <> '') and
         (not AUpdateFlags or (Fields[11].AsString <> CLLPPhone1)) then
      begin
        NewVals := NewVals + format( ' Phone1 "%s" to "%s"', [Fields[11].AsString, CLLPPhone1] );
        EDAPutStringFieldValue( Fields[11], CLLPPhone1 );
        Result := TRUE;
      end;

      if (CLLPPhone2 <> '') and
         (not AUpdateFlags or (Fields[12].AsString <> CLLPPhone2)) then
      begin
        NewVals := NewVals + format( ' Phone2 "%s" to "%s"', [Fields[12].AsString, CLLPPhone2] );
        EDAPutStringFieldValue( Fields[12], CLLPPhone2 );
        Result := TRUE;
      end;

      if (CLLPGender <> '') and
         (not AUpdateFlags or (Fields[13].AsString <> CLLPGender)) then
      begin
        NewVals := NewVals + format( ' Gender "%s" to "%s"', [Fields[13].AsString, CLLPGender] );
        EDAPutStringFieldValue( Fields[13], CLLPGender );
        Result := TRUE;
      end;
      if NewVals <> '' then
      begin
        if CMS_LogsCtrlAll then
          N_Dump1Str( format( 'DB>> Update Patient By Link Info %s',
                          [NewVals] ) )
        else
          N_Dump1Str( 'DB>> Update Patient By Link Info' );
      end;
    end;
  end;

begin

  if not (K_uliPatients in UpdatePPLFlagsSet) then
  begin
    N_Dump2Str('DB>> EDASAUpdateOnePatientByLinkInfo is skiped by UpdatePPLFlagsSet' );
    Result := K_edFails;
    Exit;
  end;
  UpdatePPLFlagsSet := UpdatePPLFlagsSet - [K_uliPatients];

  SID := IntToStr(APCLLPatAttrs.CLLPID);
  if APCLLPatAttrs.CLLPID <= 0 then
  begin
    N_Dump2Str('DB>> EDASAUpdateOnePatientByLinkInfo is skiped by CLLPID=' + SID );
    Result := K_edAbsentData;
    Exit;
  end;

  N_Dump2Str('DB>> EDASAUpdateOnePatientByLinkInfo CLLPID=' + SID );
  try
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;

    ExtDataErrorCode := K_eeDBSelect;

    with CurDSet1 do
    begin
      Connection := LANDBConnection;
      Filtered := false;

      SQL.Text := 'select ' + K_CMENDAPBridgeID + ',' +   // 0
                              K_CMENDAPCardNum + ',' +    // 1
                              K_CMENDAPTitle + ',' +      // 2
                              K_CMENDAPSurname + ',' +    // 3
                              K_CMENDAPFirstname + ',' +  // 4
                              K_CMENDAPDOB + ',' +        // 5
                              K_CMENDAPAddr1 + ',' +      // 6
                              K_CMENDAPAddr2 + ',' +      // 7
                              K_CMENDAPPostCode + ',' +   // 8
                              K_CMENDAPSuburb + ',' +     // 9
                              K_CMENDAPState + ',' +      //10
                              K_CMENDAPPhone1 + ',' +     //11
                              K_CMENDAPPhone2 + ',' +     //12
                              K_CMENDAPGender + ',' +     //13
                              K_CMENDAPProvID +           //14
          ' from ' + K_CMENDBAllPatientsTable +
          ' where ' + K_CMENDAPBridgeID + ' = ' + SID;
      Open;
      if RecordCount = 0 then
      begin // Add New
        N_Dump2Str('DB>> EDASAUpdateOnePatientByLinkInfo Add New');
        Insert;
        ExtDataErrorCode := K_eeDBSetField;
        Fields[0].AsInteger := APCLLPatAttrs.CLLPID;
        Fields[14].AsInteger := APCLLPatAttrs.CMSPProvID;
        SetValues( FALSE );
        UpdateBatch;
      end
      else
      begin // Change Existing
        N_Dump2Str('DB>> EDASAUpdateOnePatientByLinkInfo Update');
        Edit;
        if SetValues( TRUE ) then
          UpdateBatch;
      end;

      with PatientsInfo.R do
      begin
        if ALength() <= 1 then

        begin
          ASetLength( 7, 1 );
          PString(PME(0, 0))^ := 'PatientID';
          PString(PME(1, 0))^ := 'PatientCardNumber';
          PString(PME(2, 0))^ := 'PatientFirstName';
          PString(PME(3, 0))^ := 'PatientSurname';
          PString(PME(4, 0))^ := 'PatientTitle';
          PString(PME(5, 0))^ := 'PatientGender';
          PString(PME(6, 0))^ := 'PatientDOB';
          CardNumInd := 1;
          FirstNameInd := 2;
          SurnameInd := 3;
          TitleInd := 4;
          GenderInd := 5;
          DOBInd := 6;
        end
        else
        begin
          CardNumInd := EDAArchUDTabFieldIndex( 'PatientCardNumber', PatientsInfo );
          FirstNameInd := EDAArchUDTabFieldIndex( 'PatientFirstName', PatientsInfo );
          SurnameInd := EDAArchUDTabFieldIndex( 'PatientSurname', PatientsInfo );
          TitleInd := EDAArchUDTabFieldIndex( 'PatientTitle', PatientsInfo );
          DOBInd := EDAArchUDTabFieldIndex( 'PatientDOB', PatientsInfo );
          GenderInd := EDAArchUDTabFieldIndex( 'PatientGender', PatientsInfo );
        end;


        RInd := EDAArchUDTabIndexOf( SID, PatientsInfo );
        if RInd = 0 then
        begin
          RInd := ARowCount;
          ASetLength( AColCount(), RInd + 1 );
          PString(PME(0, RInd))^ := SID;
          N_Dump2Str( 'DB>> EDASAUpdateOnePatientByLinkInfo add Patient Info' );
        end;

        N_Dump2Str( format( 'DB>> Update Patient Info FieldCount=%d',
                            [FieldCount] ) );
        PInfo := PString(PME(CardNumInd, RInd));
        if APCLLPatAttrs.CLLPCardNum <> '' then
          PInfo^ := APCLLPatAttrs.CLLPCardNum
        else
          PInfo^ := EDAGetStringFieldValue(Fields[1]);

        PInfo := PString(PME(FirstNameInd, RInd));
        if APCLLPatAttrs.CLLPFirstname <> '' then
          PInfo^ := APCLLPatAttrs.CLLPFirstname
        else
          PInfo^ := EDAGetStringFieldValue(Fields[4]);

        PInfo := PString(PME(SurnameInd, RInd));
        if APCLLPatAttrs.CLLPSurname <> '' then
          PInfo^ := APCLLPatAttrs.CLLPSurname
        else
          PInfo^ := EDAGetStringFieldValue(Fields[3]);

        PInfo := PString(PME(TitleInd, RInd));
        if APCLLPatAttrs.CLLPTitle <> '' then
          PInfo^ := APCLLPatAttrs.CLLPTitle
        else
          PInfo^ := EDAGetStringFieldValue(Fields[2]);

        PInfo := PString(PME(GenderInd, RInd));
        PInfo^ := EDAGetStringFieldValue(Fields[13]);

        WDOB := APCLLPatAttrs.CLLPDOB;
        if WDOB = 0 then
          WDOB := TDateTimeField(Fields[5]).Value;
        PInfo := PString(PME(DOBInd, RInd));
        if WDOB <> 0 then
          PInfo^ := K_DateTimeToStr( WDOB, N_WinFormatSettings.ShortDateFormat );

      end;

      Close;
    end;

    N_Dump2Str('DB>> EDASAUpdateOnePatientByLinkInfo fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDASAUpdateOnePatientByLinkInfo ' + E.Message;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;
end; // end of TK_CMEDDBAccess.EDASAUpdateOnePatientByLinkInfo

//****************************** TK_CMEDDBAccess.EDASAChangePatientBridgeID ***
// Change Patient ID in all DB Tables
//
//     Parameters
// AOldID - Old Patient ID
// ANewID - New Patient ID
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAChangePatientBridgeID( AOldID, ANewID : Integer ): TK_CMEDResult;
var
  SOldID, SNewID : string;
begin
  Result := K_edOK;
  with CurSQLCommand1 do
  begin
    SOldID := IntToStr(AOldID);
    SNewID := IntToStr(ANewID);
    if K_CMSLiRegStatus = K_lrtEnterprise then
    begin // Enterprise Mode

      CommandText := 'UPDATE ' + K_CMENDBSyncFilesQueryTable +
        ' SET '  + K_CMENDBSFQPatID + ' = ' +  SNewID +
        ' WHERE ' + K_CMENDBSFQPatID + ' = ' +  SOldID;
      Execute;

      CommandText := 'UPDATE ' + K_CMENDBSyncFilesQueryHistTable +
        ' SET '  + K_CMENDBSFQHPatID + ' = ' +  SNewID +
        ' WHERE ' + K_CMENDBSFQHPatID + ' = ' +  SOldID;
      Execute;

    end; // if K_CMSLiRegStatus = 2 then

    CommandText := 'UPDATE ' + K_CMENDBSessionsHistTable +
      ' SET '  + K_CMENDBSessionsHTFPatID + ' = ' +  SNewID +
      ' WHERE ' + K_CMENDBSessionsHTFPatID + ' = ' +  SOldID;
    Execute;

    CommandText := 'UPDATE ' + K_CMENDBAllHistPatientsTable +
      ' SET '  + K_CMENDAHPatID + ' = ' +  SNewID +
      ' WHERE ' + K_CMENDAHPatID + ' = ' +  SOldID;
    Execute;

    CommandText := 'UPDATE ' + K_CMENDBSlidesTable +
      ' SET '  + K_CMENDBSTFPatID + ' = ' +  SNewID +
      ' WHERE ' + K_CMENDBSTFPatID + ' = ' +  SOldID;
    Execute;

    CommandText := 'UPDATE ' + K_CMENDBContextsTable +
      ' SET '  + K_CMENDBCTFContID + ' = ' +  SNewID +
      ' WHERE ' + K_CMENDBCTFContID     + ' = ' +  SOldID +
      ' AND '   + K_CMENDBCTFContTypeID + ' = ' + IntToStr(Ord(K_actPatIni));
    Execute;

    CommandText := 'UPDATE ' + K_CMENDBAllPatientsTable +
      ' SET '  + K_CMENDAPBridgeID  + ' = ' +  SNewID +
      ' WHERE ' + K_CMENDAPBridgeID + ' = ' +  SOldID;
    Execute;

  end; // with CurSQLCommand1 do
end; // function TK_CMEDDBAccess.EDASAChangePatientBridgeID

//***************************** TK_CMEDDBAccess.EDASAChangePatientBridgeIDs ***
// Change Patient ID in all DB Tables by Table with AFOldID and AFNewID pairs
//
//     Parameters
// ATableName - table with set of ID pairs
// AFOldID    - field name with Old ID
// AFNewID    - field name with New ID
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDASAChangePatientBridgeIDs( const ATableName, AFOldID, AFNewID : string ): TK_CMEDResult;
begin
  Result := K_edOK;
  with CurSQLCommand1 do
  begin
    if K_CMSLiRegStatus = K_lrtEnterprise then
    begin // Enterprise Mode

      CommandText := 'UPDATE ' + K_CMENDBSyncFilesQueryTable +
        ' SET '  + K_CMENDBSFQPatID + ' = S.' + AFNewID +
        ' FROM ' + ATableName + ' S ' +
        ' WHERE ' + K_CMENDBSFQPatID + ' = S.' + AFOldID;
      Execute;

      CommandText := 'UPDATE ' + K_CMENDBSyncFilesQueryHistTable +
        ' SET '  + K_CMENDBSFQHPatID + ' = S.' + AFNewID +
        ' FROM ' + ATableName + ' S ' +
        ' WHERE ' + K_CMENDBSFQHPatID + ' = S.' + AFOldID;
      Execute;

    end; // if K_CMSLiRegStatus = 2 then

    CommandText := 'UPDATE ' + K_CMENDBSessionsHistTable +
      ' SET '  + K_CMENDBSessionsHTFPatID + ' = S.' + AFNewID +
      ' FROM ' + ATableName + ' S ' +
      ' WHERE ' + K_CMENDBSessionsHTFPatID + ' = S.' + AFOldID;
    Execute;

    CommandText := 'UPDATE ' + K_CMENDBAllHistPatientsTable +
      ' SET '  + K_CMENDAHPatID + ' = S.' + AFNewID +
      ' FROM ' + ATableName + ' S ' +
      ' WHERE ' + K_CMENDAHPatID + ' = S.' + AFOldID;
    Execute;

    CommandText := 'UPDATE ' + K_CMENDBSlidesTable +
      ' SET '  + K_CMENDBSTFPatID + ' = S.' + AFNewID +
      ' FROM ' + ATableName + ' S ' +
      ' WHERE ' + K_CMENDBSTFPatID + ' = S.' + AFOldID;
    Execute;

    CommandText := 'UPDATE ' + K_CMENDBContextsTable +
      ' SET '  + K_CMENDBCTFContID + ' = S.' + AFNewID +
      ' FROM ' + ATableName + ' S ' +
      ' WHERE ' + K_CMENDBCTFContID     + ' = S.' + AFOldID +
      ' AND '   + K_CMENDBCTFContTypeID + ' = ' + IntToStr(Ord(K_actPatIni));
    Execute;

    CommandText := 'UPDATE ' + K_CMENDBAllPatientsTable +
      ' SET '  + K_CMENDAPBridgeID  + ' = S.' + AFNewID +
      ' FROM ' + ATableName + ' S ' +
      ' WHERE ' + K_CMENDAPBridgeID + ' = S.' + AFOldID;
    Execute;
    
  end; // with CurSQLCommand1 do
end; // function TK_CMEDDBAccess.EDASAChangePatientBridgeIDs

//******************************* TK_CMEDDBAccess.EDAGetOnePatientHistAttrs ***
// Get Patients History Attrs
//
//     Parameters
// APatSID - Patient ID string
// APCMSAPatientDBData - pointer to Patient Data
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAGetOnePatientHistAttrs( const APatSID : string;
                       APCMPatientHistDBData : TK_PCMPatientHistDBData ) : TK_CMEDResult;
begin
  N_Dump2Str('DB>> EDAGetOnePatientHistAttrs ID=' + APatSID );

  Result := EDACheckDBConnection(LANDBConnection);
  if Result <> K_edOK then
    Exit;

  CurDSet1.Connection := LANDBConnection;

  try
    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
      SQL.Text := 'select ' + K_CMENDAHPatCapt + ',' + K_CMENDAHPatCN +   // 0 1
                 ' from ' + K_CMENDBAllHistPatientsTable +
                 ' where ' + K_CMENDAHPatID + ' = ' + APatSID;

      Filtered := false;
      Open;
      if RecordCount > 0 then
      begin
        First;
        with APCMPatientHistDBData^ do
        begin
          HPName   := Fields[0].AsString;
          HPCardNum   := Fields[1].AsString;
        end;
      end
      else
        Result := K_edFails;

      Close;
    end;
    N_Dump2Str('DB>> EDAGetOnePatientHistAttrs fin');
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDAGetOnePatientHistAttrs ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
      Result := K_edExDataError;
      ExtDataErrorCode := K_eeDBSetField;
    end;
  end;

end; // end of TK_CMEDDBAccess.EDAGetOnePatientHistAttrs

//************************************** TK_CMEDDBAccess.EDADCMCheckPatient ***
// Check if Patient with given attributes exists
//
//     Parameters
// APatSirname - patient Sirname
// APatFirstName - patient First Name
// APatCardNum  - patient card number (use if <> '')
// APatDOB      - patient DOB (use if <> 0)
// Result - Returns PatientID if patient with given attributes exists or 0
//
function TK_CMEDDBAccess.EDADCMCheckPatient( const APatSirname, APatFirstName, APatCardNum : string; APatDOB : TDate ) : Integer;
var
  FindPatFlag : Boolean;
label LExit;
begin

  N_Dump2Str( format('DB>> EDADCMCheckPatient start %s %s (%s)', [APatSirname, APatFirstName, APatCardNum] ) );

  Result := 0;
//  if K_CMEDDBVersion < 29 then  Exit;

  try
    ExtDataErrorCode := K_eeDBSelect;
    with CurDSet1 do
    begin
      Connection := LANDBConnection;

      // Check in Patients Table
      SQL.Text := 'select ' + K_CMENDAPCardNum  + ',' + K_CMENDAPDOB + ',' + K_CMENDAPBridgeID +  
        ' from ' + K_CMENDBAllPatientsTable +
        ' where ' + K_CMENDAPSurname + '=' + QuotedStr(APatSirname) +
        ' and '   + K_CMENDAPFirstname + '=' + QuotedStr(APatFirstName);
//        ' where ' + K_CMENDAPSurname + '=''' + APatSirname + '''' +
//        ' and '   + K_CMENDAPFirstname + '=''' + APatFirstName + '''';

      Filtered := FALSE;
      Open;
      if (RecordCount = 0) then goto LExit;
      N_Dump2Str('DB>> EDADCMCheckPatient FIO exists');

      Result := 0;
      if APatCardNum <> '' then
      begin // Check Card Num
        First();
        while not EOF do
        begin
          FindPatFlag := Fields[0].AsString = APatCardNum;
          if FindPatFlag then
          begin
            Result := Fields[2].AsInteger;
            goto LExit;
          end;
          Next();
        end;
      end;
      N_Dump2Str( 'DB>> EDADCMCheckPatient absent CardNum' );

      Result := 0;
      if APatDOB <> 0 then
      begin // Check DOB
        First();
        while not EOF do
        begin
          FindPatFlag := TDateTimeField(Fields[1]).Value = APatDOB;
          if FindPatFlag then
          begin
            Result := Fields[2].AsInteger;
            goto LExit;
          end;
          Next();
        end;
      end;

LExit:
      Close;

    end; // with CurDSet1 do

    N_Dump2Str('DB>> EDADCMCheckPatient fin ID=' + IntToStr(Result) );
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDADCMCheckPatient ' + E.Message;
      CurDSet1.Close;
      EDAShowErrMessage(TRUE);
    end;
  end;
end; // function TK_CMEDDBAccess.EDADCMCheckPatient

{
//********************************************* TK_CMEDDBAccess.EDAAddExtraInfoStrings ***
// Add Centaur Extra Info to given Strings
//
//     Parameters
// AMacroStrings - Resultings Strings to add
// Result - Returns operation resulting code
//
function TK_CMEDDBAccess.EDAAddExtraInfoStrings( AMacroStrings: TStrings ) : TK_CMEDResult;
begin
  Result := inherited EDAAddExtraInfoStrings( AMacroStrings );
end; // end of TK_CMEDDBAccess.EDAAddExtraInfoStrings
}
//************************************** TK_CMEDDBAccess.EDAPrintLogoGetDIB ***
// Get print templates Logo DIB
//
//     Parameters
// Result - Returns nil or print logo DIB object
//
function TK_CMEDDBAccess.EDAPrintLogoGetDIB: TN_DIBObj;
var
  VFName: string;
  DBField: TField;
  SCurLocID : string;
  CloseDataSet : Boolean;
  Stream: TStream;
  FStream: TFileStream;
//  RCode : TK_CMEDResult;
  DSize : Integer;

begin
//  Get LogoDIB
  N_Dump2Str( 'DB> EDAPrintLogoGetDIB start' );
  Result := nil;
  DBField := nil;
  Stream := nil;
  CloseDataSet := FALSE;
  SCurLocID := IntToStr(K_CMEDAccess.CurLocID);

  if LogoFileLocID <> K_CMEDAccess.CurLocID then
    LogoFileCRC := 0;

  if LogoFileCRC = 0 then
  begin // Get Logo CRC Info
    N_Dump2Str( 'DB> EDAPrintLogoGetDIB try CRC' );
    EDAGetOneAppContextDBField( IntToStr(Ord(K_actLocPrintLogo)),
                                          SCurLocID, '0',
                                          CurDSet1, DBField );
    CloseDataSet := TRUE;
    if DBField <> nil then
    begin
      try
        N_Dump2Str( 'DB> EDAPrintLogoGetDIB get CRC' );
        Stream := CurDSet1.CreateBlobStream(DBField, bmRead);
        Stream.ReadBuffer(LogoFileCRC, SizeOf(LongWord) );
        LogoFileLocID := K_CMEDAccess.CurLocID;
      except
        on E: Exception do
        begin
          ExtDataErrorCode := K_eeDBBlobRead;
          ExtDataErrorString := 'EDAPrintLogoGetDIB read CRC >> ' + E.Message;
          Stream.Free;
          EDAShowErrMessage(TRUE);
          Exit;
        end;
      end;
    end; // if DBField <> nil then
  end; // if LogFileCRC = 0 then

  if LogoFileCRC <> 0 then
  begin // Get Logo DIB
    VFName := K_ExpandFileName( format('(#WrkFiles#)PrintLogo%s_%u.img', [SCurLocID,LogoFileCRC] ) );

    if not FileExists( VFName ) then
    begin // Get Logo from DB to WrkFiles
      if not CloseDataSet then
        EDAGetOneAppContextDBField( IntToStr(Ord(K_actLocPrintLogo)),
                                             SCurLocID, '0',
                                             CurDSet1, DBField );
      FStream := nil;
      try
        N_Dump2Str( 'DB> EDAPrintLogoGetDIB copy Logo to ' + VFName );
        if Stream = nil then
        begin
          Stream := CurDSet1.CreateBlobStream(DBField, bmRead);
          Stream.Seek( SizeOf(LongWord), soBeginning );
        end;
        DSize := Stream.Size;
        FStream := TFileStream.Create( VFName, fmCreate );
        FStream.CopyFrom( Stream, DSize - SizeOf(LongWord) );
        FStream.Free;
      except
        on E: Exception do
        begin
          ExtDataErrorCode := K_eeDBBlobRead;
          ExtDataErrorString := 'EDAPrintLogoGetDIB copy to file >> ' + E.Message;
          Stream.Free;
          FStream.Free;
          EDAShowErrMessage(TRUE);
          Exit;
        end;
      end; // except
    end; // if not FileExists( VFName ) then
    N_Dump2Str( 'DB> EDAPrintLogoGetDIB from ' + VFName );
    Result := EDAPrintLogoGetDIBByFile( VFName );
  end; // if LogoFileCRC <> 0 then  // end of Get Logo DIB

  Stream.Free;
  if CloseDataSet then
    CurDSet1.Close;
    
  N_Dump2Str( 'DB> EDAPrintLogoGetDIB fin' );
end; // TK_CMEDDBAccess.EDAPrintLogoGetDIB

//********************************** TK_CMEDDBAccess.EDAPrintLogoSetByFile ***
// Set new Logo to print templates by Logo image file
//
//     Parameters
// ALogoFName - name of file with logo image
// Result - Returns nil or new print logo DIB object
//
function TK_CMEDDBAccess.EDAPrintLogoSetByFile( const ALogoFName: string ) : TN_DIBObj;
var
  FNameS, FNameR : string;
  VFile: TK_VFile;
  DSize : Integer;
  EncryptionType : TK_DFEncryptionType; // needed Encryption type

begin
  N_Dump2Str( 'DB> EDAPrintLogoSetByFile start' );

//  Get LogoDIB
  Result := nil;
  K_VFAssignByPath( VFile, ALogoFName );
  DSize := K_VFOpen( VFile );
  if DSize > 0 then
  begin
    DSize := DSize + SizeOf(LongWord);
    if Length(BlobBuf) < DSize then
    begin
      BlobBuf := nil;
      SetLength( BlobBuf, DSize + DSize div 4 );
    end;
    K_VFReadAll( VFile, @BlobBuf[SizeOf(LongWord)] );

    K_RIObj.RIOpenMemory( @BlobBuf[SizeOf(LongWord)], DSize - SizeOf(LongWord) );
    case K_RIObj.RIGetDIB( 0, Result ) of
      rirFails:       LongWord(Result) := 2; // Method Fails
      rirOutOfMemory: LongWord(Result) := 3; // Method Fails because of memory lack
    end;
  end
  else
    LongWord(Result) := 1;

  if LongWord(Result) < 10 then
  begin
    N_Dump1Str( format( 'DB> New Print Logo file "%s" problems', [ALogoFName] ) );
    Exit;
  end;

  N_Dump2Str( 'DB> EDAPrintLogoSetByFile save Logo to DB' );
  Integer(LogoFileCRC) := N_AdlerChecksum( @BlobBuf[SizeOf(LongWord)], DSize - SizeOf(LongWord) );
  PLongWord(@BlobBuf[0])^ := LogoFileCRC;
  EncryptionType := BlobEncParams.DFEncryptionType;

  BlobEncParams.DFEncryptionType := K_dfePlain;
  EDASaveOneAppContext0( CurDSet1, Ord(K_actLocPrintLogo), K_CMEDAccess.CurLocID, 0, @BlobBuf[0], DSize, 0 );
  BlobEncParams.DFEncryptionType := EncryptionType;

  N_Dump2Str( 'DB> EDAPrintLogoSetByFile delete prev from WrkFiles' );
  FNameR := K_ExpandFileName( '(#WrkFiles#)' );
  FNameS := format('PrintLogo%d_', [K_CMEDAccess.CurLocID] );
  K_DeleteFolderFiles( FNameR, FNameS + '*.*' );

  N_Dump2Str( 'DB> EDAPrintLogoSetByFile save new to ' + FNameR );
  FNameR := FNameR + FNameS + format('%u.img',[LogoFileCRC]);
  K_VFAssignByPath( VFile, FNameR );
  K_VFWriteAll( VFile, @BlobBuf[SizeOf(LongWord)], DSize - SizeOf(LongWord) );

  N_Dump2Str( 'DB> EDAPrintLogoSetByFile fin' );
end; // function TK_CMEDDBAccess.EDAPrintLogoSetByFile

//*********************************** TK_CMEDDBAccess.EDAPrintLocMemIniSave ***
// Save MemIni Location Context
//
function TK_CMEDDBAccess.EDAPrintLocMemIniSave : TK_CMEDResult;
begin
  inherited EDAPrintLocMemIniSave();
  // Set saving context
  K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
  K_CMEDADFPLExec.DstIniFile := K_CMEDAMemIniFile;

  Result := EDASaveOneAppMemIniContext(Ord(K_actLocPrintIni), CurLocID, 0, 'LocationPrint|Save');
end; // end of TK_CMEDDBAccess.EDAPrintLocMemIniSave

//********************************** TK_CMEDDBAccess.EDADevicePlatesListAdd ***
// Add Device Plate Info List to DB
//
//     Parameters
// ASL - Device Plates info List
// ATSInd - Start List Strings Index
//
procedure TK_CMEDDBAccess.EDADevicePlatesListAdd( ASL: TStrings; ATSInd: Integer );
var
  i, DInd, PlateCount : Integer;
  SPlateID, SPlateName, SPlateCount, SPlateDT, SClientAppGlobID : string;
  DT : TDateTime;
  AddToTotal : Boolean;
begin
  N_Dump2Str( 'EDADevicePlatesListAdd Start' );
  try
    LANDBConnection.BeginTrans;
    CurDSet1.Connection := LANDBConnection;
    CurDSet1.SQL.Text := 'SELECT ' + K_CMENDDPTID + ',' +
                   K_CMENDDPTName + ',' +
                   K_CMENDDPTCount +
      ' FROM ' + K_CMENDBDevicePlatesTotalUseTable;
    CurDSet1.Filtered := FALSE;
    CurDSet1.Open();

    CurDSet2.Connection := LANDBConnection;
    CurDSet2.SQL.Text := 'SELECT ' + K_CMENDDPCID + ',' +
                   K_CMENDDPCClientID + ',' +
                   K_CMENDDPCUpdateDT +
      ' FROM ' + K_CMENDBDevicePlatesClientUseTable;
    CurDSet2.Filtered := FALSE;
    CurDSet2.Open();

    CurDSet3.SQL.Text := 'select @@identity';
    CurDSet3.Connection := LANDBConnection;
    CurDSet3.Filtered := false;

    SClientAppGlobID := IntToStr(ClientAppGlobID);

    for i := ATSInd to ASL.Count - 1 do
    begin
      if ASL[i] = '' then break;
      SPlateName := ASL.Names[i];
      SPlateCount := ASL.ValueFromIndex[i];
      DInd := Pos( '|', SPlateCount );
      if DInd = 0 then
      begin // Device Plate data error
        N_Dump1Str( 'DevicePlate error data >> ' + ASL[i] );
        Continue;
      end;
      SPlateDT := Copy( SPlateCount, DInd + 1, MaxInt );
      SPlateDT := format('%s-%s-%s %s:%s:%s',
        [Copy(SPlateDT, 1, 4),Copy(SPlateDT, 5, 2),Copy( SPlateDT, 7, 2),
         Copy(SPlateDT, 9, 2),Copy(SPlateDT, 11, 2),Copy( SPlateDT, 13, 2)] );
      DT := K_StrToDateTime( SPlateDT );

      SPlateCount := Copy( SPlateCount, 1, DInd - 1 );
      PlateCount := StrToIntDef( SPlateCount, 0 );
      if PlateCount = 0 then // Device Plate data error
        N_Dump1Str( 'DevicePlate error Count = ' + SPlateCount );

      CurDSet1.Filter := K_CMENDDPTName + ' = ''' + SPlateName + '''';
      CurDSet1.Filtered := TRUE;
      AddToTotal := TRUE;
      if CurDSet1.RecordCount = 0 then
      begin
        CurDSet1.Filtered := FALSE;
        CurDSet1.Insert;
        CurDSet1.Fields[1].AsString := SPlateName;
        CurDSet1.Fields[2].AsInteger := PlateCount;
        CurDSet1.UpdateBatch;

        CurDSet3.Open;
        SPlateID := CurDSet3.Fields[0].AsString;
        CurDSet3.Close();

        AddToTotal := FALSE;
        N_Dump1Str( format( 'DevicePlate Total add >> %s=%s', [SPlateName, SPlateCount] ) );
      end   // if CurDSet1.RecordCount = 0 then
      else  // if CurDSet1.RecordCount > 0 then
        SPlateID := CurDSet1.Fields[0].AsString;

      CurDSet2.Filter := K_CMENDDPCID + ' = ' + SPlateID +
                         ' and ' +
                         K_CMENDDPCClientID + ' = ' + SClientAppGlobID;
      CurDSet2.Filtered := TRUE;
      if CurDSet2.RecordCount = 0 then
      begin
        CurDSet2.Filtered := FALSE;
        CurDSet2.Insert();
        CurDSet2.Fields[0].AsString := SPlateID;
        CurDSet2.Fields[1].AsInteger := ClientAppGlobID;
        TDateTimeField(CurDSet2.Fields[2]).Value := DT;
        CurDSet2.UpdateBatch;
        N_Dump1Str( format( 'DevicePlate Client add >> %s=%s|%s',
                      [SPlateName, SPlateCount, SPlateDT] ) );
      end   // if CurDSet2.RecordCount = 0 then
      else
      begin // if CurDSet2.RecordCount > 0 then
        if DT > TDateTimeField(CurDSet2.Fields[2]).Value then
        begin
          CurDSet2.Edit();
          TDateTimeField(CurDSet2.Fields[2]).Value := DT;
          CurDSet2.UpdateBatch;
          if AddToTotal then
          begin
            CurDSet1.Edit();
            with CurDSet1.Fields[2] do
              AsInteger := AsInteger + PlateCount;
            CurDSet1.UpdateBatch;
          end;
          N_Dump2Str( format( 'DevicePlate Change >> %s=%s|%s',
                      [SPlateName, SPlateCount, SPlateDT] ) );
        end;
        CurDSet2.Filtered := FALSE;
      end; // if CurDSet2.RecordCount > 0 then

      CurDSet1.Filtered := FALSE;

    end; // for i := ATSInd to ASL.Count - 1 do

    CurDSet1.Close();
    CurDSet2.Close();
    LANDBConnection.CommitTrans;
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDADevicePlatesListAdd ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
  N_Dump2Str( 'EDADevicePlatesListAdd fin' );
end; // procedure TK_CMEDDBAccess.EDADevicePlatesListAdd

//******************************* TK_CMEDDBAccess.EDADevicePlateUseCountGet ***
// Get Device Plate Counter
//
//     Parameters
// APlateName - Plate id string
// Result - Returns Plate Counter, if < 0 then Plates Counter is undefined
//
function TK_CMEDDBAccess.EDADevicePlateUseCountGet( const APlateName: string ): Integer;
begin
  N_Dump2Str( 'DB> EDADevicePlateUseCountGet start');
  Result := -1;
  if K_CMEDDBVersion < 42 then Exit;

  try
    CurDSet1.Connection := LANDBConnection;
    CurDSet1.SQL.Text := 'SELECT ' +
                   K_CMENDDPTName + ',' +
                   K_CMENDDPTCount +
      ' FROM ' + K_CMENDBDevicePlatesTotalUseTable +
      ' WHERE ' + K_CMENDDPTName + ' = ''' + APlateName + '''';

    CurDSet1.Filtered := FALSE;
    CurDSet1.Open();
    Result := 0;
    if CurDSet1.RecordCount > 0 then
      Result := CurDSet1.Fields[1].AsInteger;
    CurDSet1.Close();
  except
    on E: Exception do
    begin
      ExtDataErrorString := 'EDADevicePlateUseCountGet ' + E.Message;
      EDAShowErrMessage(TRUE);
    end;
  end;
  N_Dump2Str( 'DB> EDADevicePlateUseCountGet Fin');

end; // function TK_CMEDDBAccess.EDADevicePlateUseCountGet

//******************************* TK_CMEDCSAccess.EDADevicePlateUseCountInc ***
// Increment Device Plate Counter
//
//
//     Parameters
// APlateName - Plate id string
// Result - Returns resulting Plate Counter, if < 0 then Plates Counter is undefined
//
function TK_CMEDDBAccess.EDADevicePlateUseCountInc( const APlateName: string ): Integer;
begin
  N_Dump2Str( 'DB> EDADevicePlateUseCountInc start');
  Result := -1;
  if K_CMEDDBVersion < 42 then Exit;
  TmpStrings.Text := APlateName + '=1|' + K_DateTimeToStr( Now(), 'yyyymmddhhnnss' );
  EDADevicePlatesListAdd( TmpStrings, 0 );
  Result := EDADevicePlateUseCountGet( APlateName );
  N_Dump2Str( 'DB> EDADevicePlateUseCountInc fin');
end; // function TK_CMEDDBAccess.EDADevicePlateUseCountInc

//*************************************** TK_CMEDDBAccess.EDADCMSeriesStart ***
// DICOM Series start
//
procedure TK_CMEDDBAccess.EDADCMSeriesStart;
begin
  N_Dump2Str( 'DB> EDADCMSeriesStart start');
//  K_CMDCMSeriesID := CurSlidesList.Count;  // Current DICOM Series ID
//  K_CMDCMSeriesIDTS  := Now();
  with CurStoredProc1 do
  begin
    Connection := LANDBConnection;
    ProcedureName := 'dba.cms_AddDCMSeries';
    Parameters.Clear;
    with Parameters.AddParameter do
    begin
      Name := '@SeriesID';
      Direction := pdOutput;
      DataType := ftInteger;
    end;
    with Parameters.AddParameter do
    begin
      Name := '@SeriesTS';
      Direction := pdOutput;
      DataType := ftDateTime;
      ExecProc;
      K_CMDCMSeriesIDTS := Value;
    end; // with Parameters.AddParameter do
    K_CMDCMSeriesID := Parameters.ParamValues['@SeriesID'];
  end; // with CurStoredProc1 do
  N_Dump2Str( 'DB> EDADCMSeriesStart fin');
end; // procedure TK_CMEDDBAccess.EDADCMSeriesStart;

//*************************************** TK_CMEDDBAccess.EDADCMSeriesStart ***
// DICOM Series fin
//
procedure TK_CMEDDBAccess.EDADCMSeriesFin;
begin
  N_Dump2Str( 'DB> EDADCMSeriesFin ID=' +IntToStr(K_CMDCMSeriesID) );
  if K_CMDCMSeriesID <> 0 then
  begin
    if K_CMDCMSeriesIDSCount = 0 then
    begin // Remove Current DCM Series Info
      with CurSQLCommand1 do
      begin
        CommandText := 'DELETE FROM ' + K_CMENDBDCMSeriesTable + ' WHERE ' +
                       K_CMENDDCMSRID + ' = ' + IntToStr(K_CMDCMSeriesID);
        Execute;
      end; // with CurSQLCommand1 do
    end; // if K_CMDCMSeriesIDSCount = 0 then
    K_CMDCMSeriesID := 0;   // Current DICOM Series ID
    K_CMDCMSeriesIDSCount := 0;
  end; // if K_CMDCMSeriesID <> 0 then
end; // procedure TK_CMEDDBAccess.EDADCMSeriesFin;


{ *** end of TK_CMEDDBAccess *** }

//******************************************************* K_CMEDASetIniInfo ***
// Add given Ini-info (Ini-file in text represantation) to current MemIni
//
procedure K_CMEDASetIniInfo(const AIniInfo: string);
begin
  if AIniInfo = '' then
    Exit;
  K_CMEDAMemIniStrings.Text := AIniInfo;
  K_CMEDAMemIniFile.SetStrings(K_CMEDAMemIniStrings);
  K_AddMemIni(K_CMEDAMemIniFile, N_CurMemIni);
//  if K_CMEDAMemIniFile.SectionExists(K_FileGPathsIniSection) then
//    K_InitArchInfoByArch(K_CurArchive);
  // K_InitAppDirsList( );

end; // procedure K_CMEDASetIniInfo

//****************************************** K_CMEDAServerClientContextInit ***
// Init Server/Client Context
//
procedure K_CMEDDBSetActualTablesFieldsNames();
begin
  if K_CMEDDBVersion >= 19 then
  begin
//*** Application Client Instances Table
    K_CMENDBGAInstsTable := 'ClientAppInstances';// Application Client Instances Data Table
    K_CMENDBGAInstsTFGlobID := 'CAInstanceID'; // Application Client Instance ID
    K_CMENDBGAInstsTFLocalID:= 'CATypeID';     // Application Client Instance Type ID (is used for CMSFSync identification)
    K_CMENDBGAInstsTFCName  := 'CACompVID';    // Application Client Instance Computer Virtual ID

//*** Active Sessions Data Table
  K_CMENDBAAInstsTable := 'AllActSessions'; // Active Sessions Data Table
    K_CMENDBAAInstsTFGlobID := 'CAInstanceID'; // Active Sessions Data Table Field Name for Session Client Application Instances ID

//*** Sesions History Table
    K_CMENDBSessionsHTFCompID := 'AHClientID'; // Sessions History Table Field Name for Client ID (Application Client Instance ID)

//*** Objects New History Table
    K_CMENDBSlidesNewHistTable := 'AllObjHistory'; // Objects New History Table
    K_CMENDBSlidesNHTFSlideID  := 'AHObjID'; // Objects New History Table Field Name for Object ID

  end;
{
  if K_CMEDDBVersion >= 41 then
  begin
    K_CMENDBSTFSlideLocIDHost := 'DTDB';
  end; // if K_CMEDDBVersion >= 41 then
}
  if not K_CMEDAMSSQL then Exit;

  K_CMENDBSlidesTable    := 'dba.' + K_CMENDBSlidesTable;
  K_CMENDBMTypesTable    := 'dba.' + K_CMENDBMTypesTable;
  K_CMENDBContextsTable  := 'dba.' + K_CMENDBContextsTable;
  K_CMENDBGlobAttrsTable := 'dba.' + K_CMENDBGlobAttrsTable;
  K_CMENDBAAInstsTable   := 'dba.' + K_CMENDBAAInstsTable;
  K_CMENDBACMPDataTable  := 'dba.' + K_CMENDBACMPDataTable;
  K_CMENDBGAInstsTable   := 'dba.' + K_CMENDBGAInstsTable;
  K_CMENDBLockSlidesTable  := 'dba.' + K_CMENDBLockSlidesTable;
  K_CMENDBMediaUniqIDTable := 'dba.' + K_CMENDBMediaUniqIDTable;
  K_CMENDBSlidesHistTable  := 'dba.' + K_CMENDBSlidesHistTable;
  K_CMENDBSlidesNewHistTable := 'dba.' + K_CMENDBSlidesNewHistTable;
  K_CMENDBSessionsHistTable  := 'dba.' + K_CMENDBSessionsHistTable;
  K_CMENDBImportHistTable    := 'dba.' + K_CMENDBImportHistTable;
  K_CMENDBLocsFAccessTable   := 'dba.' + K_CMENDBLocsFAccessTable;
  K_CMENDBLocFilesInfoTable  := 'dba.' + K_CMENDBLocFilesInfoTable;
  K_CMENDBSyncFilesQueryTable := 'dba.' + K_CMENDBSyncFilesQueryTable;
  K_CMENDBSyncFilesHistTable  := 'dba.' + K_CMENDBSyncFilesHistTable;
  K_CMENDBSyncFilesQueryHistTable := 'dba.' + K_CMENDBSyncFilesQueryHistTable;
  K_CMENDBAllHistPatientsTable    := 'dba.' + K_CMENDBAllHistPatientsTable;
  K_CMENDBAllHistProvidersTable   := 'dba.' + K_CMENDBAllHistProvidersTable;
  K_CMENDBAllHistLocationsTable   := 'dba.' + K_CMENDBAllHistLocationsTable;
  K_CMENDBDelMarkedSlidesTable    := 'dba.' + K_CMENDBDelMarkedSlidesTable;
  K_CMENDBCustomerInfoTable       := 'dba.' + K_CMENDBCustomerInfoTable;
  K_CMENDBAllServersTable         := 'dba.' + K_CMENDBAllServersTable;
  K_CMENDBAllPatientsTable        := 'dba.' + K_CMENDBAllPatientsTable;
  K_CMENDBAllProvidersTable       := 'dba.' + K_CMENDBAllProvidersTable;
  K_CMENDBAllLocationsTable       := 'dba.' + K_CMENDBAllLocationsTable;
  K_CMENDBDelPatCardNumsTable     := 'dba.' + K_CMENDBDelPatCardNumsTable;
  K_CMENDBImportPatientsTable     := 'dba.' + K_CMENDBImportPatientsTable;
  K_CMENDBImportProvidersTable    := 'dba.' + K_CMENDBImportProvidersTable;
  K_CMENDBImportLocationsTable    := 'dba.' + K_CMENDBImportLocationsTable;
  K_CMENDBImportLinkIDsTable      := 'dba.' + K_CMENDBImportLinkIDsTable;
  K_CMENDBUpgradeSupportTable     := 'dba.' + K_CMENDBUpgradeSupportTable;
  K_CMENDBAllDevProfileTypesTable := 'dba.' + K_CMENDBAllDevProfileTypesTable;
  K_CMENDBActInstDevProfilesTable := 'dba.' + K_CMENDBActInstDevProfilesTable;
  K_CMENDBAllStudyTemplatesTable  := 'dba.' + K_CMENDBAllStudyTemplatesTable;
end; // procedure K_CMEDDBSetActualTablesFieldsNames

//******************************************* K_CMEDAServerClientContextInit ***
// Init Server/Client Context
//
procedure K_CMEDAServerClientContextInit();
//{$IF SizeOf(Char) = 1}
//const
//  SM_REMOTESESSION = 1000;
//{$IFEND}
begin
  with K_CMSServerClientInfo do
  begin
    K_WTSGetSessionInfo(  @CMSSessionInfo );
//    K_WTSGetSessionInfo(  @CMSSessionInfo );
{ !!! Debug Code
    CMSSessionInfo.WTSClientProtocolType := WTS_PROTOCOL_TYPE_RDP;
    CMSSessionInfo.WTSClientName := CMSSessionInfo.WTSServerCompName;
{}
    CMSClientVirtualName := CMSSessionInfo.WTSClientName;
//    if (CMSClientVirtualName = '') or
//       SameText( CMSClientVirtualName, 'CONSOLE' ) then
    if (CMSSessionInfo.WTSClientProtocolType = WTS_PROTOCOL_TYPE_CONSOLE) or // Real check
       (CMSClientVirtualName = '') then                                      // Debug check
      CMSClientVirtualName := CMSSessionInfo.WTSServerCompName;
  end;

end; // procedure K_CMEDAServerClientContextInit

//********************************************* K_CMEDAccessInit ***
// Init external Data Access Context
//
procedure K_CMEDAccessInit();
var
  StandAloneKeyStr : string;
begin
  N_CM_CompName := K_GetComputerName();
//N_CM_CompName := 'CS567';

  N_SPLTC_CMLogFlags := K_GetTypeCodeSafe('TN_CMLogFlags').DTCode;

  K_CMFilterAttrsClear(@K_CMCurSlideFilterAttrs);
  //K_CMDynIconsSInd := N_CMResForm.MainIcons18.Count;

  // *** Active Instances
  K_CMEDAMultipleInstanceMode := N_MemIniToBool( 'CMS_Main', 'MultipleInstanceMode', false);
  if K_CMVUIMode then K_CMEDAMultipleInstanceMode := true; ////Igor 23102019 Ura
  // *** CMS Design Mode - skips User Confirmations to some dialogs
  K_CMDesignModeFlag := N_MemIniToBool('CMS_Main', 'DesignMode', false);
  N_BoolToMemIni('CMS_Main', 'DesignMode', K_CMDesignModeFlag);

  // *** Demo Mode Attributes
  K_CMDemoModeFlag := N_MemIniToBool('CMS_Main', 'DemoMode', false);
  N_BoolToMemIni('CMS_Main', 'DemoMode', K_CMDemoModeFlag);

  K_CMDemoMaxSlidesCount := N_MemIniToInt('CMS_Main', 'DemoMaxSlidesCount', 0);
  K_CMDemoMaxSlidesWarnCount := Floor(K_CMDemoMaxSlidesCount * 0.9);
  N_IntToMemIni('CMS_Main', 'DemoMaxSlidesCount', K_CMDemoMaxSlidesCount);

  // *** CMS Colors
  K_CMSFrameActiveBGColor     := N_MemIniToInt( 'CMS_Colors', 'ActiveBGColor',      clActiveCaption );
  K_CMSFrameActiveFontColor   := N_MemIniToInt( 'CMS_Colors', 'ActiveFontColor',    clCaptionText );
  K_CMSFrameInactiveBGColor   := N_MemIniToInt( 'CMS_Colors', 'InactiveBGColor',    clInactiveCaption );
  K_CMSFrameInactiveFontColor := N_MemIniToInt( 'CMS_Colors', 'InactiveFontColor',  clInactiveCaptionText );
  K_CMSFrameActivePictBGColor := N_MemIniToInt( 'CMS_Colors', 'ActivePictBGColor',  $C0C0C0 );
  K_CMSStudyThumbBGColor      := N_MemIniToInt( 'CMS_Colors', 'StudyThumbBGColor',  $C0C0C0 );
  K_CMSStudyExportBGColor     := N_MemIniToInt( 'CMS_Colors', 'StudyExportBGColor', $C0C0C0 );

  // *** Studies GUI Modes Attributes
//  K_CMStudySingleOpenGUIModeFlag     := N_MemIniToBool('CMS_Main', 'StudySingleOpendMode',    TRUE );
//  K_CMStudyOpenOnCreateGUIModeFlag   := N_MemIniToBool('CMS_Main', 'StudyOpenOnCreateMode',   TRUE );
//  K_CMStudyAddSlidesGUIModeFlag      := N_MemIniToBool('CMS_Main', 'StudyAddSlidesMode',      FALSE );
//  K_CMStudyOnlyThumbsShowGUIModeFlag := N_MemIniToBool('CMS_Main', 'StudyOnlyThumbsShowMode', FALSE );
  K_CMStudySingleOpenGUIModeFlag     := TRUE;
  K_CMStudyOpenOnCreateGUIModeFlag   := TRUE;
  K_CMStudyAddSlidesGUIModeFlag      := TRUE;
  K_CMD4WSlideStudyOpenFlag          := TRUE;


  // *** Thumbnail Attributes
  K_CMSlideThumbSize := N_MemIniToInt('CMS_Main', 'ThumbnailSize', 200);
  N_IntToMemIni('CMS_Main', 'ThumbnailSize', K_CMSlideThumbSize);

  K_CMSlideThumbQuality := N_MemIniToInt('CMS_Main', 'ThumbnailQuality', 100);
  N_IntToMemIni('CMS_Main', 'ThumbnailQuality', K_CMSlideThumbQuality);

  // *** Miscellaneous Attributes
  K_CMSLiRegCheckBuild := N_MemIniToBool('CMS_Main', 'CheckBuildRegistration', FALSE );

  K_CMTerminateByEDAError := N_MemIniToBool('CMS_Main', 'TerminateByEDAError', FALSE );
  N_BoolToMemIni('CMS_Main', 'TerminateByEDAError', K_CMTerminateByEDAError);

  K_CMRectTypeVObjMinSize := N_MemIniToInt('CMS_Main', 'RectAnnotMinSize', 30);
  N_IntToMemIni('CMS_Main', 'RectAnnotMinSize', K_CMRectTypeVObjMinSize);

  N_MemIniToSPLVal('CMS_Main', 'CMLogFlags', N_CM_LogFlags, N_SPLTC_CMLogFlags);

  K_CMDebVersionModeFlag := N_MemIniToBool('CMS_Main', 'DebVersionMode', FALSE );

  K_CMSCheckMemFreeDIBSize := N_MemIniToInt('CMS_Main',   'MemFreeDIBSize', 150000000 );
  K_CMSCheckMemFreeBufSize := N_MemIniToInt('CMS_Main',   'MemFreeBufSize', 150000000 );
 // Time Delta in minutes / Number minutes in Day
  K_CMSCheckMaxMemFreeTimeDelta := N_MemIniToDbl('CMS_Main', 'MemFreeMaxMinutes', 0 ) / (24 * 60);


  // *** Flashlight Ini Attributes
  K_CMFlashlightIni.CMFLPixSize := N_MemIniToInt('CMS_Main', 'FlashlightIniPixSize',
    100);

  K_CMFlashlightIni.CMFLScaleFactor := N_MemIniToDbl('CMS_Main',
    'FlashlightIniScale', 2);
  N_DblToMemIni('CMS_Main', 'FlashlightIniScale', '%g',
    K_CMFlashlightIni.CMFLScaleFactor);

  K_CMFlashlightIni.CMFLBriFactor := N_MemIniToDbl('CMS_Main',
    'FlashlightIniBriFactor', 0);
  N_DblToMemIni('CMS_Main', 'FlashlightIniBriFactor', '%g',
    K_CMFlashlightIni.CMFLBriFactor);

  K_CMFlashlightIni.CMFLCoFactor := N_MemIniToDbl('CMS_Main',
    'FlashlightIniCoFactor', 3);
  N_DblToMemIni('CMS_Main', 'FlashlightIniCoFactor', '%g',
    K_CMFlashlightIni.CMFLCoFactor);

  K_CMFlashlightIni.CMFLSkipScaleFlag := N_MemIniToInt('CMS_Main',
    'FlashlightIniSkipScale', 0);
  N_IntToMemIni('CMS_Main', 'FlashlightIniSkipScale',
    K_CMFlashlightIni.CMFLSkipScaleFlag);

  K_CMFlashlightIni.CMFLAutoEqualizeFlag := N_MemIniToInt('CMS_Main',
    'FlashlightIniAutoEqualize', 0);
  N_IntToMemIni('CMS_Main', 'FlashlightIniAutoEqualize',
    K_CMFlashlightIni.CMFLAutoEqualizeFlag);

  // *** Media Files Storing Attributes
  K_CMMediaFilesSplitSize := N_MemIniToInt('CMS_Main', 'MediaFilesSplitSize',
    30 * 1024 * 1024);
  N_IntToMemIni('CMS_Main', 'MediaFilesSplitSize', K_CMMediaFilesSplitSize);

  K_CMMediaFilesMinSize := N_MemIniToInt('CMS_Main', 'MediaFilesMinSize',
    10 * 1024);
  N_IntToMemIni('CMS_Main', 'MediaFilesMinSize', K_CMMediaFilesMinSize);

  K_CMImgMaxPixelsSize := Round(N_MemIniToDbl('CMS_Main', 'ImgMaxMegaPixels',
      30) * 1024*1024 );
  K_CMBufMaxCapacity := N_MemIniToInt('CMS_Main', 'BufMaxCapacity', 1000000000);
  K_SBufMaxCapacity := K_CMBufMaxCapacity;

  K_CMMarkAsDelShowFlag := FALSE;

  // Add Current Version Info to Ini for Project Distr *.DOF Set Version Info
  N_IntToMemIni('CMS_Main', 'DOFMajorVer', N_CMVerNumber);
  N_IntToMemIni('CMS_Main', 'DOFRelease', N_CMBuildNumber);
  N_IntToMemIni('CMS_Main', 'DOFBuild', N_CMBuildSNumber);
  N_IntToMemIni('CMS_Main', 'DOFLibVer', K_CMSComLibVer);

  StandAloneKeyStr := N_MemIniToString('CMS_Main', 'StandaloneGUIKey', '');
  K_CMStandaloneGUIMode := (StandAloneKeyStr <> '') and
          ((StandAloneKeyStr = '*') or (K_CMDParams.IndexOf(StandAloneKeyStr) >= 0) );
//  K_CMStandaloneGUIMode := N_MemIniToBool('CMS_Main', 'StandaloneGUIMode', false);
//K_CMStandaloneGUIMode := TRUE;
  K_CMEDAMSSQL := (K_CMDParams.IndexOf('-MSSQL') >= 0); // Use MSSQL flag

  if K_CMDesignModeFlag then
    K_CMD4WPatDocPath := K_ExpandFileName( '(#TmpFiles#)' );

end; // end of K_CMEDAccessInit

//********************************************* K_CMHistoryEventsInit ***
// Init external Data Access Context
//
procedure K_CMHistoryEventsInit();
begin
//*******************************
//  Set Translated Events Texts

  K_CMSHistNCActTexts[0] := K_CML3Form.LLLEV1Acts00.Caption;
  K_CMSHistNCActTexts[1] := K_CML3Form.LLLEV1Acts01.Caption;
  K_CMSHistNCActTexts[2] := K_CML3Form.LLLEV1Acts02.Caption;
  K_CMSHistNCActTexts[3] := K_CML3Form.LLLEV1Acts03.Caption;
  K_CMSHistNCActTexts[4] := K_CML3Form.LLLEV1Acts04.Caption;
  K_CMSHistNCActTexts[5] := K_CML3Form.LLLEV1Acts05.Caption;
  K_CMSHistNCActTexts[6] := K_CML3Form.LLLEV1Acts06.Caption;
  K_CMSHistNCActTexts[7] := K_CML3Form.LLLEV1Acts07.Caption;
  K_CMSHistNCActTexts[8] := K_CML3Form.LLLEV1Acts08.Caption;
  K_CMSHistNCActTexts[9] := K_CML3Form.LLLEV1Acts09.Caption;
  K_CMSHistNCActTexts[10] := K_CML3Form.LLLEV1Acts10.Caption;
  K_CMSHistNCActTexts[11] := K_CML3Form.LLLEV1Acts11.Caption;

  K_CMSHistExpFormatTexts[0] := K_CML3Form.LLLEVExpFormat0.Caption;
  K_CMSHistExpFormatTexts[1] := K_CML3Form.LLLEVExpFormat1.Caption;
  K_CMSHistExpFormatTexts[2] := K_CML3Form.LLLEVExpFormat2.Caption;
  K_CMSHistExpFormatTexts[3] := K_CML3Form.LLLEVExpFormat3.Caption;
  K_CMSHistExpFormatTexts[4] := K_CML3Form.LLLEVExpFormat4.Caption;
  K_CMSHistExpFormatTexts[5] := K_CML3Form.LLLEVExpFormat5.Caption;

  K_CMSHistNCAOther1Texts[0] := K_CML3Form.LLLEVFilterChng0.Caption;
  K_CMSHistNCAOther1Texts[1] := K_CML3Form.LLLEVFilterChng1.Caption;

  K_CMSHistNCAArchTexts[0] := K_CML3Form.LLLEVArch0.Caption;
  K_CMSHistNCAArchTexts[1] := K_CML3Form.LLLEVArch1.Caption;
  K_CMSHistNCAArchTexts[2] := K_CML3Form.LLLEVArch2.Caption;
  K_CMSHistNCAArchTexts[3] := K_CML3Form.LLLEVArch3.Caption;

  K_CMSHistNCADCMTexts[0] := K_CML3Form.LLLEVDCM0.Caption;
  K_CMSHistNCADCMTexts[1] := K_CML3Form.LLLEVDCM1.Caption;

  K_CMSHistCActTexts[0] := K_CML3Form.LLLEV2Acts00.Caption;
  K_CMSHistCActTexts[2] := K_CML3Form.LLLEV2Acts02.Caption;
  K_CMSHistCActTexts[3] := K_CML3Form.LLLEV2Acts03.Caption;
  K_CMSHistCActTexts[4] := K_CML3Form.LLLEV2Acts04.Caption;
  K_CMSHistCActTexts[5] := K_CML3Form.LLLEV2Acts05.Caption;
  K_CMSHistCActTexts[6] := K_CML3Form.LLLEV2Acts06.Caption;
  K_CMSHistCActTexts[7] := K_CML3Form.LLLEV2Acts07.Caption;
  K_CMSHistCActTexts[8] := K_CML3Form.LLLEV2Acts08.Caption;
  K_CMSHistCActTexts[9] := K_CML3Form.LLLEV2Acts09.Caption;
  K_CMSHistCActTexts[10] := K_CML3Form.LLLEV2Acts10.Caption;

  K_CMHistPropActTexts[0] := K_CML3Form.LLLEPropActs00.Caption;
  K_CMHistPropActTexts[1] := K_CML3Form.LLLEPropActs01.Caption;
  K_CMHistPropActTexts[2] := K_CML3Form.LLLEPropActs02.Caption;

  K_CMSHistImgActTexts[0] := K_CML3Form.LLLEVImgChng00.Caption;
  K_CMSHistImgActTexts[1] := K_CML3Form.LLLEVImgChng01.Caption;
  K_CMSHistImgActTexts[2] := K_CML3Form.LLLEVImgChng02.Caption;
  K_CMSHistImgActTexts[3] := K_CML3Form.LLLEVImgChng03.Caption;
  K_CMSHistImgActTexts[4] := K_CML3Form.LLLEVImgChng04.Caption;
  K_CMSHistImgActTexts[5] := K_CML3Form.LLLEVImgChng05.Caption;
  K_CMSHistImgActTexts[6] := K_CML3Form.LLLEVImgChng06.Caption;
  K_CMSHistImgActTexts[7] := K_CML3Form.LLLEVImgChng07.Caption;
  K_CMSHistImgActTexts[8] := K_CML3Form.LLLEVImgChng08.Caption;
  K_CMSHistImgActTexts[9] := K_CML3Form.LLLEVImgChng09.Caption;
  K_CMSHistImgActTexts[10] := K_CML3Form.LLLEVImgChng10.Caption;
  K_CMSHistImgActTexts[11] := K_CML3Form.LLLEVImgChng11.Caption;
  K_CMSHistImgActTexts[12] := K_CML3Form.LLLEVImgChng12.Caption;
  K_CMSHistImgActTexts[13] := K_CML3Form.LLLEVImgChng13.Caption;
  K_CMSHistImgActTexts[14] := K_CML3Form.LLLEVImgChng14.Caption;
  K_CMSHistImgActTexts[15] := K_CML3Form.LLLEVImgChng15.Caption;
  K_CMSHistImgActTexts[16] := K_CML3Form.LLLEVImgChng16.Caption;
  K_CMSHistImgActTexts[17] := K_CML3Form.LLLEVImgChng17.Caption;
  K_CMSHistImgActTexts[18] := K_CML3Form.LLLEVImgChng18.Caption;
  K_CMSHistImgActTexts[19] := K_CML3Form.LLLEVImgChng19.Caption;
  K_CMSHistImgActTexts[20] := K_CML3Form.LLLEVImgChng20.Caption;
  K_CMSHistImgActTexts[21] := K_CML3Form.LLLEVImgChng21.Caption;
  K_CMSHistImgActTexts[22] := K_CML3Form.LLLEVImgChng22.Caption;

  K_CMSHistVObjActTexts[0] := K_CML3Form.LLLEVAnnotChng0.Caption;
  K_CMSHistVObjActTexts[1] := K_CML3Form.LLLEVAnnotChng1.Caption;
  K_CMSHistVObjActTexts[2] := K_CML3Form.LLLEVAnnotChng2.Caption;
  K_CMSHistVObjActTexts[3] := K_CML3Form.LLLEVAnnotChng3.Caption;
  K_CMSHistVObjActTexts[4] := K_CML3Form.LLLEVAnnotChng4.Caption;
  K_CMSHistVObjActTexts[5] := K_CML3Form.LLLEVAnnotChng5.Caption;
  K_CMSHistVObjActTexts[6] := K_CML3Form.LLLEVAnnotChng6.Caption;

  K_CMSHistRDBActTexts[0] := K_CML3Form.LLLEVDBRecover0.Caption;
  K_CMSHistRDBActTexts[1] := K_CML3Form.LLLEVDBRecover1.Caption;
  K_CMSHistRDBActTexts[2] := K_CML3Form.LLLEVDBRecover2.Caption;
  K_CMSHistRDBActTexts[3] := K_CML3Form.LLLEVDBRecover3.Caption;
  K_CMSHistRDBActTexts[4] := K_CML3Form.LLLEVDBRecover4.Caption;
  K_CMSHistRDBActTexts[5] := K_CML3Form.LLLEVDBRecover5.Caption;
  K_CMSHistRDBActTexts[6] := K_CML3Form.LLLEVDBRecover6.Caption;

  K_CMSHistVObjTypeTexts[0] := K_CML3Form.LLLEVAnnotType00.Caption;
  K_CMSHistVObjTypeTexts[1] := K_CML3Form.LLLEVAnnotType01.Caption;
  K_CMSHistVObjTypeTexts[2] := K_CML3Form.LLLEVAnnotType02.Caption;
  K_CMSHistVObjTypeTexts[3] := K_CML3Form.LLLEVAnnotType03.Caption;
  K_CMSHistVObjTypeTexts[4] := K_CML3Form.LLLEVAnnotType04.Caption;
  K_CMSHistVObjTypeTexts[5] := K_CML3Form.LLLEVAnnotType05.Caption;
  K_CMSHistVObjTypeTexts[6] := K_CML3Form.LLLEVAnnotType06.Caption;
  K_CMSHistVObjTypeTexts[7] := K_CML3Form.LLLEVAnnotType07.Caption;
  K_CMSHistVObjTypeTexts[8] := K_CML3Form.LLLEVAnnotType08.Caption;
  K_CMSHistVObjTypeTexts[9] := K_CML3Form.LLLEVAnnotType09.Caption;
  K_CMSHistVObjTypeTexts[10] := K_CML3Form.LLLEVAnnotType10.Caption;
  K_CMSHistVObjTypeTexts[11] := K_CML3Form.LLLEVAnnotType11.Caption;
//
//*******************************
end; // end of K_CMHistoryEventsInit

//***************************************************** K_CMDefineStartMode ***
// Define Start Mode
//
procedure K_CMDefineStartMode();
var
  ProtStr: string;
  i, j, k : Integer;
  IniBuildInfo: string;
  UseExtDB : Boolean;
  StartedAsComServer: Boolean;
  SL : TStringList;
  BoundTS : TDateTime;
begin
  ////////////////////////////////////////
  // Init CMS Build and Release Info
  //
  if not K_CMDesignModeFlag and
     N_MemIniToBool('CMS_Main', 'CheckBuildInfo', false) then
  begin
    IniBuildInfo := N_MemIniToString('CMS_Main', 'BuildInfo', 'CMS-XXXX');
    if N_CMSVersion <> IniBuildInfo then
//      raise Exception.Create('Wrong Build Info. Ini=' + IniBuildInfo + ', Exe=' +
//                              N_CMSVersion);
      raise Exception.Create( format( 'Wrong build version:'#13#10+
                                      '     Needed build version - %s'#13#10+
                                      '%s build version - %s',
                                      [IniBuildInfo, ExtractFileName(Application.ExeName),
                                       N_CMSVersion] ) );
  end
  else
  begin
    N_StringToMemIni('CMS_Main', 'BuildInfo', N_CMSVersion);
    // Save CMS Build Info to Ini
  end;


  /////////////////////////////////////////
  // Check start by D4W Client
  //


  UseExtDB := N_MemIniToBool('CMS_Main', 'UseExtDB', false);
  if UseExtDB then
  begin
///////////////////////////////////////
// Check CMS is started as COM-server
//

//{$WARN SYMBOL_PLATFORM OFF}
//    ProtStr := string(CmdLine);
//{$WARN SYMBOL_PLATFORM ON}
    ProtStr := '';
    if K_CMDParams.Count > 0 then
      ProtStr := K_CMDParams[0];
    // Check CMDL key
    i := Pos( 'Embedding', ProtStr );
    StartedAsComServer := (i >= 2) and
            ((ProtStr[i-1] = '-') or (ProtStr[i-1] = '/'));

    if StartedAsComServer then
      j := 100 * 60 * 5  // wait for 5 minutes
//      j := 100000000  // wait for "New COM-client" event and raise exception if it is not come
//      j := 1000  // wait for "New COM-client" event and raise exception if it is not come
    else
      j := 2;    // wait a little for "New COM-client" event and continue

    N_Dump1Str( format( 'Wait for COM-client %g s', [(j + 1)*(10/1000)] ) );

    // Wait "New COM-client" event Loop
    k := 0;
    for i := 0 to j do
    begin
      k := i;
      Application.ProcessMessages();
      if K_CMD4WAppRunByCOMClient then break;
      Sleep(10);
    end; //  for i := 0 to j do

    N_Dump1Str( format('Wait %d ticks for COM-client start', [k] ) );

    if StartedAsComServer and not K_CMD4WAppRunByCOMClient then
      raise Exception.Create( 'Waiting for COM-client. Timeout elapsed' );
//
// Check CMS is started as COM-server
//////////////////////////////////////
  end;   // if UseExtDB then


//  K_CMStandaloneGUIMode := K_CMStandaloneGUIMode and
//                           not K_CMD4WAppRunByClient; // ??? - may be not needed

  if K_CMD4WAppRunByCOMClient then
  begin
////////////////////////////////////////////
// Wait for COM-client commands to continue
//
    K_CMStandaloneGUIMode := FALSE;
//    N_Dump1Str( 'D4W >> Start waiting for Show GUI command' );
    N_Dump1Str( 'Start waiting COM-client for Show GUI command' );
    BoundTS := Now() + 5.0/(24 * 60);
    while (K_CMSAppStartContext.CMASMode = K_cmamWait) and
          (BoundTS > Now()) do
    begin
    // wait for D4W Current Data Context Setting
      Application.ProcessMessages();
      sleep(10);
    end;

    if K_CMSAppStartContext.CMASMode = K_cmamWait then
    begin
      N_Dump1Str( 'Waiting timeout expired!!!' );
      K_CMD4WAppRunByCOMClient := FALSE; // set finish application flag
    end;

    if not K_CMD4WAppRunByCOMClient then
    begin
      K_CMSAppStartContext.CMASState := K_cmasStop;
      Exit; // finished by Client
    end;

    N_Dump1Str( 'Fin waiting COM-client for Show GUI command' );
//    N_Dump1Str( 'D4W >> Init Continue' );
//
// Wait for COM-client commands to continue
////////////////////////////////////////////
  end // if K_CMD4WAppRunByClient then
  else
  if not UseExtDB then
  begin
////////////////////////////////////////////
// Check Special DEMO Start
//
    N_i := K_CMDParams.IndexOfName( 'WinShowFile' );
    if N_i >= 0 then
    begin
      /////////////////////////////////////////
      // DemoTestFile mode - start file check
      SL := TStringList.Create;
      N_s := K_CMDParams.ValueFromIndex[N_i];
    /////////////////////////////////////////
    // DemoTestFile mode - file check loop
      while TRUE do
      begin
        N_b := FALSE;
        if FileExists(N_s) then
        begin
          SL.LoadFromFile( N_s );
          if SL.Count > 0 then
          begin
            // Check file line start
            N_s1 := SL[0];
            if SameText( N_s1,  'WinShow' ) then
            begin
              N_b := TRUE;
            end
            else
            if SameText( N_s1,  'WinShowModal' ) then
            begin
              K_CMDemoTestModal := TRUE;
              N_b := TRUE;
            end
            else
            if SameText( N_s1,  'WinShowTop' ) then
            begin
              N_b := TRUE;
              K_CMDemoTestTop := TRUE;
            end
            else
            if SameText( N_s1,  'WinShowModalTop' ) then
            begin
              N_b := TRUE;
              K_CMDemoTestModal := TRUE;
              K_CMDemoTestTop := TRUE;
            end;
            // Check file line fin
          end; // if SL.Count > 0 then
        end; // if FileExists(N_s) then

        if N_b then break;
      // wait for Open Mode
        sleep(100);
        Application.ProcessMessages();
      end; // // while TRUE do

      SL.Free;
    // DemoTestFile mode - start file check
    /////////////////////////////////////////
    end; // if N_i >= 0 then
//
// Check Special DEMO Start
////////////////////////////////////////////
  end; // if not UseExtDB then
end; // end of K_CMDefineStartMode

//****************************************** K_CMD4WApplyPatientRuntimeInfo ***
// Apply D4W Patient runtime info
//
procedure K_CMD4WApplyPatientRuntimeInfo();
var
  ColumnInd : Integer;

  function GetColumnAttr( const AColName : string  ) : string;
  begin
    Result := '';
    ColumnInd := K_CMEDAccess.EDAArchUDTabFieldIndex( AColName,
                                          K_CMEDAccess.PatientsInfo, FALSE );
    if ColumnInd < 0 then
      N_Dump2Str( 'DB>> K_CMD4WApplyPatientRuntimeInfo no ' + AColName )
    else
    begin
    // Apply Runtime Info from PatientsInfo
      Result := PString(K_CMEDAccess.PatientsInfo.PDRA.PME(ColumnInd, 1))^;
    // Remove Runtime Info from PatientsInfo
      K_CMEDAccess.PatientsInfo.PDRA.DeleteCols(ColumnInd);
    end;

  end; // function GetColumnAttr

begin
  K_CMD4WPatDocPath := GetColumnAttr( 'PatDocPath' );
  if K_CMD4WPatDocPath <> '' then
  begin
    K_CMD4WPatDocPath := IncludeTrailingPathDelimiter( K_CMD4WPatDocPath );
    if CMS_LogsCtrlAll then
      N_Dump2Str( 'DB>> K_CMD4WApplyPatientRuntimeInfo DocPath=' + K_CMD4WPatDocPath )
    else
      N_Dump2Str( 'DB>> K_CMD4WApplyPatientRuntimeInfo DocPath=????' )
  end;

  K_CMDCMD4WStudyUID := GetColumnAttr( 'DCMStudyUID' );
  if K_CMDCMD4WStudyUID <> '' then
    N_Dump2Str( 'DB>> K_CMD4WApplyPatientRuntimeInfo DCMStudyUID=' + K_CMDCMD4WStudyUID );

end; // procedure K_CMD4WApplyPatientRuntimeInfo

//************************************************* K_CMD4WApplyNewContextInfo ***
// Apply D4W new context info
//
//      Parameters
// Result - Returns Apply Log Info
//
function K_CMD4WApplyNewContextInfo() : string;
begin
  Result := '';
  N_Dump2Str( 'DB>> K_CMD4WApplyNewContextInfo start' );
  if K_CMD4WLocationsInfo <> '' then
  begin
    if K_CMSSetUDTableInfo(K_CMD4WLocationsInfo, K_CMEDAccess.LocationsInfo) and
       (K_CMEDDBVersion >= 21) then
      K_CMEDAccess.UpdatePPLFlagsSet := K_CMEDAccess.UpdatePPLFlagsSet + [K_uliLocations];
    Result := ' Locations';
    K_CMD4WLocationsInfo := '';
  end;
  if K_CMD4WPatientsInfo <> '' then
  begin
    K_CMS_LogsCtrlAll := CMS_LogsCtrlAll;
    if K_CMSSetUDTableInfo(K_CMD4WPatientsInfo, K_CMEDAccess.PatientsInfo) and
       (K_CMEDDBVersion >= 21) then
      K_CMEDAccess.UpdatePPLFlagsSet := K_CMEDAccess.UpdatePPLFlagsSet + [K_uliPatients];
    Result := Result + ' Patients';
    K_CMD4WPatientsInfo := '';
    K_CMD4WApplyPatientRuntimeInfo();
    K_CMS_LogsCtrlAll := TRUE;
  end;
  if K_CMD4WProvidersInfo <> '' then
  begin
    K_CMS_LogsCtrlAll := CMS_LogsCtrlAll;
    if K_CMSSetUDTableInfo(K_CMD4WProvidersInfo, K_CMEDAccess.ProvidersInfo) and
       (K_CMEDDBVersion >= 21)  then
      K_CMEDAccess.UpdatePPLFlagsSet := K_CMEDAccess.UpdatePPLFlagsSet + [K_uliProviders];
    Result := Result + ' Providers';
    K_CMD4WProvidersInfo := '';
    K_CMS_LogsCtrlAll := TRUE;
  end;
  N_Dump2Str( 'DB>> K_CMD4WApplyNewContextInfo fin' );
end; // function K_CMD4WApplyNewContextInfo

//****************************************************** K_CMEDAccessInit11 ***
// Init external Data Access Context
//
procedure K_CMEDAccessInit11();
var
  ProtStr: string;
  i : Integer;
//  DlgType : TMsgDlgType;
//  DlgCapt : string;
  ImgFreeSpaceAvailable, VideoFreeSpaceAvailable, Img3DFreeSpaceAvailable: Int64;
  ImgDrive, VideoDrive, Img3DDrive, CheckDriveName : string;
  UseExtDB : Boolean;
  StartContextSet : TK_CMSGetStartContextSet;
  StartByClineOnly : Boolean;
  RebuildGlobalContextFlag : Boolean;
  CheckImg3DFolder : Boolean;
  New_Connection_Str: string;
{ // Test 3Shape Thumb Load
Slide3D : TN_UDCMSlide;
function Load3ShapeThumbDIB( ) : TN_DIBObj;
var
FName : string;
RetCode : Integer;
ErrStr : string;

begin
FName := N_MemIniToString( 'CMS_Main','Thumb3ShapeFName', '' );
RetCode := K_LoadDIBFromVFileByRI( K_RIObj, FName, Result );
if RetCode = 0 then Exit;
case RetCode of
1: ErrStr := 'is absent';
2: ErrStr := 'has not proper format';
end;
N_Dump1Str( format( ' 3Shape Thumbnail file  "%s"  error >> %s', [FName, ErrStr] ) );

end; // function Load3ShapeThumbDIB
{}

  procedure CheckDriveFreeSpace( AFreeSpace : Int64; ADriveName : string );
  var
    WStr :string;
  begin
    if K_CMDisableDiskFreeSpaceCheck then Exit;
    if AFreeSpace < K_CMSMinServerFreeSpace then
    begin
      TK_CMEDDBAccess(K_CMEDAccess).EDAWarnMinFreeSpace( AFreeSpace, ADriveName );
      K_CMSAppStartContext.CMASState := K_cmasStop;
      N_CM_MainForm.Close();
    end
    else
    begin
      WStr := K_CMEDAccess.EDAPrepFreeSpaceWarnText( AFreeSpace, ADriveName );
      if not K_CMVUIMode then
      begin
        if AFreeSpace < K_CMSLowServerFreeSpace then
        begin
          if mrYes <> K_CMShowMessageDlg1( WStr + K_CML1Form.LLLAppInit1.Caption,
//            'It is highly recommended to free up more space before starting CMS.'#13#10 +
//            '            Do you still want to proceed?',
             mtWarning, [mbYes, mbNo] ) then
          begin
            K_CMSAppStartContext.CMASState := K_cmasStop;
            N_CM_MainForm.Close();
          end;
        end
        else if AFreeSpace < K_CMSNormServerFreeSpace then
        begin
          K_CMShowMessageDlg1( WStr, mtInformation, [mbOK] );
        end
      end; // 
    end
  end; // procedure CheckDriveFreeSpace

begin

//  K_CMEDAccess.DumpSavingContext := TRUE; // DEBUG
  if not K_CMSAppStartContext.CMAInitNotComplete then
  begin
    ////////////////////////////////////////
    // Apply Context from MemIni
    //
    UseExtDB := N_MemIniToBool('CMS_Main', 'UseExtDB', false);
    RebuildGlobalContextFlag := K_CMEDAExtIniFilesToMemIni( not UseExtDB ) > 0;

    K_CMMessageDlgDefaultCaption := N_MemIniToString( 'RegionTexts', 'CMSuiteProductName', K_CMMessageDlgDefaultCaption );

    N_InitOnceAfterIniReady();

    ////////////////////////////////////////
    // Add Start Ini Context from D4W if any
    //
    if RebuildGlobalContextFlag then
    begin
    // Rebuild Global Named File Paths after External IniFiles apply
      K_InitArchInfoByArch(K_CurArchive);
    // Reapply  Common Context
      N_MemIniToSPLVal( 'CMS_Main', 'CMLogFlags', N_CM_LogFlags, N_SPLTC_CMLogFlags );
    end;

    ////////////////////////////////////////
    // Init CLL Ini file Name
    //
    if not K_CMVUIMode then //Ura
      K_CMSCLLIniFName :=  K_ExpandFileName( '(#WrkFiles#)CLL' + K_CMSServerClientInfo.CMSClientVirtualName + '.dat' )
    else
      K_CMSCLLIniFName :=  K_ExpandFileName( '(#WrkFiles#)CLL.dat' );

    ////////////////////////////////////////
    // Init External Data Access and View Edit Context
    //

    //needed if UseExtDB is set by special user ini file for Igor
    UseExtDB := N_MemIniToBool('CMS_Main', 'UseExtDB', false);
    if UseExtDB then
    begin //*** Create DB Access Object
      K_CMEDAccess := TK_CMEDDBAccess.Create;
      K_CMMarkAsDelUseFlag := K_CMEDDBVersion >= 14;
  //TK_CMEDDBAccess(K_CMEDAccess).SaveSlidesAttrsFiles := TRUE; // Debug

      ////////////////////////////////////////////////
      // Customize DB connection by special Config DB
      //
      if K_CMVUIMode then //Ura + Igor
      begin
        New_Connection_Str := 'Driver=' + K_CMVUIDataBaseDriver + ';ServerName=' + K_CMVUICMSDBServerName +';LINKS=TCPIP(HOST=' + //!!!Ura 22.06.20+
        K_CMVUIDataBaseHost + ':' + IntToStr(K_CMVUIDataBasePort) + ');DBN=CMSimg;UID=dba;PWD=sql;';
        N_StringToMemIni( 'CMSDB', 'ConnectionString', New_Connection_Str );
      end; // if K_CMVUIMode then
    end
    else
    begin //*** Create File Archive Access Object
      K_CMEDAccess := TK_CMEDAccess.Create;
      K_CMMarkAsDelUseFlag := FALSE;
    end;

{ // Test 3Shape Thumb Load
Slide3D := K_CMSlideCreateForImg3DObject();
Slide3D.SetThumbnailByDIB( Load3ShapeThumbDIB( ) );
N_Dump1Str('Test 3Shape Thumbnail');
Slide3D.Free;
}

    K_CMEDAccess.ATimer := TTimer.Create(N_CM_MainForm);
    K_CMEDAccess.ATimer.Enabled := FALSE;

    // Set Colorize Attributes
    K_CMColorizeInitData();

    // Set Sharpen/Smoothen Attributes
    K_CMSharpenMax  := N_MemIniToDbl( 'CMS_Main', 'SharpenMax', 1.0 );
  //  K_CMSmoothenMax := 1;
  //  K_CMSmoothenMax := N_MemIniToDbl( 'CMS_Main', 'SmoothenMax', 1.0 );

    /////////////////////////////////////////
    // Init Archive and DB Context
    //
    K_CMEDAccess.EDAInit();
  //  if K_CMSAppStartContext.CMASMode = K_cmasStop then Exit; // Exit if

    ////////////////////////////////////////
    // Call to DB by needs of VirtualUI mode
    //
    if K_CMVUIMode then
    begin
    // Insert call to DB stored procedure
    end; // if K_CMVUIMode then

    if not K_CMUICheckInitResult() then Exit
    else
    if (K_CMSAppStartContext.CMASMode < K_cmamCOMHPUI) and
       (K_CMSLiRegState = K_lrsDBTrial)                and
       N_MemIniToBool('CMS_Main', 'ShowDBTrialWarning', false) then
    begin // Trial period
      N_CM_MainForm.CMMCallActionByTimer(N_CMResForm.aHelpRegistration, FALSE)
    end;

  /////////////////////////////////////////////
  // Global and Instance Context to CurState
    if not (K_CMEDAccess is TK_CMEDDBAccess) then
    begin
      K_CMEDAccess.EDAGlobalMemIniToCurState();
      K_CMEDAccess.EDAGlobal2MemIniToCurState();
    end;

    K_CMEDAccess.EDAInstanceMemIniToCurState();

    if K_CMVUIMode then
    begin
      K_CMVUIScanName := K_CMVUIGetScanCompNameProc(K_CMVUIScanPortNumber, '/?info');  //K_CMVUIScanPortNumber !SIR#26380
      if K_CMVUIScanName <> '' then K_CMEDAccess.EDAGlobal2MemIniToCurState;
    end;
    N_Dump2Str('      GLobal Named File Paths:');
    N_Dump2Strings(K_AppFileGPathsList, 5);
  //
  // Global and Instance Context to CurState
  /////////////////////////////////////////////

    if K_CMEDAccess is TK_CMEDDBAccess then
    begin
      K_CMScanDataLocPath := K_ExpandFileName( '(#WrkFiles#)ClientExchange\' );
    end;


    if not K_CMVUIMode and (K_CMSAppStartContext.CMASMode < K_cmamCOMHPUI) then
      K_SplashScreenCust( K_CMShowEnterprise() );


    ////////////////////////////////////////
    // Apply D4W Current CMS Context
    //
    K_CMSAppStartContext.CMASPSlideFilterAttrs := nil;
  //  PSlideFilterAttrs := nil;

    if K_CMSAppStartContext.CMASMode >= K_cmamCOMWEB then
    begin
      K_CMEDAccess.AccessReady := TRUE;
      K_CMEDAccess.EDAGetSlidesFPathContext();
      K_CMSRebuildCommonRImage();
      K_CMSAppStartContext.CMAInitNotComplete := TRUE;
      Exit;
    end;
  end; // if not K_CMSAppStartContext.CMASAFSMode then

  ///////////////////////////////
  //  Run by D4W CLient
  //
  if K_CMD4WAppRunByCOMClient then
  begin
    if K_CMSAppStartContext.CMASMode < K_cmamCOMWEB then
    begin
      ProtStr := K_CMD4WApplyNewContextInfo();

{
      ProtStr := '';
      if K_CMD4WLocationsInfo <> '' then
      begin
        if K_CMSSetUDTableInfo(K_CMD4WLocationsInfo, K_CMEDAccess.LocationsInfo) and
           (K_CMEDDBVersion >= 21) then
          K_CMEDAccess.UpdatePPLFlagsSet := K_CMEDAccess.UpdatePPLFlagsSet + [K_uliLocations];
        ProtStr := ' Locations';
      end;
      if K_CMD4WPatientsInfo <> '' then
      begin
        if K_CMSSetUDTableInfo(K_CMD4WPatientsInfo, K_CMEDAccess.PatientsInfo) and
           (K_CMEDDBVersion >= 21) then
          K_CMEDAccess.UpdatePPLFlagsSet := K_CMEDAccess.UpdatePPLFlagsSet + [K_uliPatients];
        ProtStr := ProtStr + ' Patients';
      end;
      if K_CMD4WProvidersInfo <> '' then
      begin
        if K_CMSSetUDTableInfo(K_CMD4WProvidersInfo, K_CMEDAccess.ProvidersInfo) and
           (K_CMEDDBVersion >= 21)  then
          K_CMEDAccess.UpdatePPLFlagsSet := K_CMEDAccess.UpdatePPLFlagsSet + [K_uliProviders];
        ProtStr := ProtStr + ' Providers';
      end;
}
    /////////////////////////////////////////////////
    // Update Providers and Locations Data if Needed
      with TK_CMEDDBAccess(K_CMEDAccess) do
      begin
        if (K_CMD4WUpdateInfo = '2') or
           (K_CMD4WUpdateInfo = '3')  then
        begin
        // Update Locations Data
          case EDASAUpdateLocationsByLinkInfo() of
          K_edFails:      N_Dump1Str( 'D4W >> Locations Update - nothing to do');
          K_edAbsentData: N_Dump1Str( 'D4W >> Locations Update - wrong data');
          else
            N_Dump1Str( 'D4W >> Locations Update is done');
          end; // case EDASAUpdateLocationsByLinkInfo() of
        end; // if K_CMD4WUpdateInfo <> '1' then

        if (K_CMD4WUpdateInfo = '1') or
           (K_CMD4WUpdateInfo = '3') then
        begin
        // Update Providers Data
          case EDASAUpdateProvidersByLinkInfo() of
          K_edFails:      N_Dump1Str( 'D4W >> Providers Update - nothing to do');
          K_edAbsentData: N_Dump1Str( 'D4W >> Providers Update  - wrong data');
          else
            N_Dump1Str( 'D4W >> Providers Update is done');
          end; // case EDASAUpdateProvidersByLinkInfo() of
        end; // if K_CMD4WUpdateInfo <> '2' then
      end; // with TK_CMEDDBAccess(K_CMEDAccess) do

      if K_CMSAppStartContext.CMASMode < K_cmamCOMHPUI then
        with K_CMSAppStartContext do
        begin
          CMASPatID := K_CMD4WCNewPatientID;
          CMASProvID := K_CMD4WCNewProviderID;
          CMASLocID := K_CMD4WCNewLocationID;
          K_CMSCLLContextFromEDAPPL( CMASLocID, CMASProvID, CMASPatID );
        end;

      if K_CMD4WUseFilteringInfoFlag then
        K_CMSAppStartContext.CMASPSlideFilterAttrs := @K_CMD4WSlideFilterAttrs;
      K_CMCurUserAccessRights := K_CMEDAccess.EDAGetProviderAccessRights( K_CMSAppStartContext.CMASProvID );
      if not K_CMSCheckStartAccessRights() then
      begin
        K_CMSAppStartContext.CMASState := K_cmasStop;
        N_CM_MainForm.Close();
        Exit;
      end;
    end; // if K_CMSAppStartContext.CMASMode < K_cmamCOMWEB then
  end // if K_CMD4WAppRunByClient then
  //
  // end of Run by D4W CLient
  ///////////////////////////////
  else
  /////////////////////////////////////////////////
  // Apply Link context from URL in virtual UI mode
  //
  if K_CMVUIMode then
  begin
    K_ForceDirPath(K_GetDirPath('WrkFiles')); //Ura
    DeleteFile(K_CMSCLLIniFName); //Ura
    K_CMSCLLContextFromURL();
    N_CM_MainForm.CMMCallActionByTimer(N_CMResForm.aServApplyCLLContext, FALSE);
  end
  else
  begin // Design Start Patient|Provider|Location Context (or Temporary)
    K_CMSAppStartContext.CMASPatID  := N_MemIniToInt('CMS_Main', 'PatientID', 1);
    K_CMSAppStartContext.CMASProvID := N_MemIniToInt('CMS_Main', 'ProviderID', 1);
    K_CMSAppStartContext.CMASLocID  := N_MemIniToInt('CMS_Main', 'LocationID', 1);
  end;
  // PatId, ProvID, LocID

/////////////////////////////////////////
// Check Files Access
//
  if (K_CMEDAccess is TK_CMEDDBAccess) then
  begin
    K_CMEDAccess.EDAGetSlidesFPathContext( K_CMSAppStartContext.CMASLocID );
//    ServAction := nil;
    with TK_CMEDDBAccess(K_CMEDAccess) do
    begin
    // Check Files Access
//        N_Dump1Str( '***** TimeStamp: Before Files Access and FreeSpace Check' ); // Deb time measuring

      CheckImg3DFolder := (K_CMEDDBVersion >= 34)              and
                          ( ((K_CMSLiRegStatus = K_lrtComplex) and
                                     not (limdImg3D in K_CMSLiRegModDisable))
                                        or
                                     K_CMDesignModeFlag );
      i := EDACheckAllFilesAccess( TRUE, TRUE, CheckImg3DFolder,
               K_CML1Form.LLLFileAccessCheck7.Caption,
//                 ' Any operation with the Media Suite objects is impossible.'#13#10 +
//                 '                                         Do you still wish to proceed?',
               K_CML1Form.LLLFileAccessCheck8.Caption,
//                 ' Press Cancel to close CMS.',
               [mbYes, mbNo], mrYes );
      if i < 0 then
      begin
        K_CMSAppStartContext.CMASState := K_cmasStop;
        N_CM_MainForm.Close();
        Exit;
      end;

//        N_Dump1Str( '***** TimeStamp: After Files Access Check' ); // Deb time measuring
      if i = 0 then // Folders Access is OK
      begin
      // Check Files Free Space
        EDAGetImgDiskFreeSpace( ImgFreeSpaceAvailable );
        N_Dump1Str( format( '!!!FreeSpace >> %s >> %s',  [SlidesImgRootFolder, N_DataSizeToString(ImgFreeSpaceAvailable)] ) ); // Deb time measuring
        EDAGetVideoDiskFreeSpace( VideoFreeSpaceAvailable );
        N_Dump1Str( format( '!!!FreeSpace >> %s >> %s',  [SlidesMediaRootFolder, N_DataSizeToString(VideoFreeSpaceAvailable)] ) ); // Deb time measuring
        EDAGetImg3DDiskFreeSpace( Img3DFreeSpaceAvailable );
        N_Dump1Str( format( '!!!FreeSpace >> %s >> %s',  [SlidesImg3DRootFolder, N_DataSizeToString(Img3DFreeSpaceAvailable)] ) ); // Deb time measuring

        ImgDrive := ExtractFileDrive(SlidesImgRootFolder);
        VideoDrive := ExtractFileDrive(SlidesMediaRootFolder);
        Img3DDrive := ExtractFileDrive(SlidesImg3DRootFolder);

        SlidesMediaImgSameDrive := EDACheckFoldersEquality1(
          IncludeTrailingPathDelimiter(ImgDrive), SlidesImgRootFDA,
          IncludeTrailingPathDelimiter(VideoDrive), SlidesMediaRootFDA )
               or
          (ImgFreeSpaceAvailable = VideoFreeSpaceAvailable);

        SlidesImg3DImgSameDrive := EDACheckFoldersEquality1(
          IncludeTrailingPathDelimiter(ImgDrive), SlidesImgRootFDA,
          IncludeTrailingPathDelimiter(Img3DDrive), TRUE )
               or
          (ImgFreeSpaceAvailable = Img3DFreeSpaceAvailable);

//          N_Dump1Str( '***** TimeStamp: After Files FreeSpace Check' ); // Deb time measuring
        if SlidesMediaImgSameDrive and SlidesImg3DImgSameDrive then
        begin
          CheckDriveName := ''
        end
        else
        begin
          CheckDriveName := ImgDrive;
        end;
        // Check Image Files Free Space
        CheckDriveFreeSpace( ImgFreeSpaceAvailable, CheckDriveName );

        if K_CMSAppStartContext.CMASState = K_cmasStop then Exit;
        if not SlidesMediaImgSameDrive then
        begin
          CheckDriveFreeSpace( VideoFreeSpaceAvailable, VideoDrive );
          if K_CMSAppStartContext.CMASState = K_cmasStop then Exit;
        end;

        if not SlidesImg3DImgSameDrive then
        begin
          CheckDriveFreeSpace( Img3DFreeSpaceAvailable, Img3DDrive );
          if K_CMSAppStartContext.CMASState = K_cmasStop then Exit;
        end;
      end; // if i = 0 then // Folders Access is OK
      EDAddInitialMediaTypes();
    end; // with TK_CMEDDBAccess(K_CMEDAccess) do


    if K_CMSDBRecoveryMode then
    begin
      N_CM_MainForm.CMMCallActionByTimer(N_CMResForm.aServDBRecoveryByFiles, FALSE);
      K_CMShowMessageDlg1( K_CML1Form.LLLAppInit13.Caption + ' ' + K_CML1Form.LLLPressOKToContinue.Caption,
//         'Media Suite is started in database recovery mode. Click OK to continue',
                            mtWarning );
      Include( N_CM_MainForm.CMMUICurStateFlags, uicsAllActsDisabled);
    end   // if K_CMSDBRecoveryMode then
    else  // if not K_CMSDBRecoveryMode then
    if K_CMSAppStartContext.CMASMode < K_cmamCOMHPUI then
    begin
      N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServProcessClientTasks, FALSE );
      N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServECacheCheck, FALSE );
      if K_CMEnterpriseModeFlag then
        N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServEModeRemoveLocDelFiles, FALSE );
      if K_CMEDDBVersion >= 14 then
        N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServRemoveMarkAsDelSlides, FALSE );
      if (K_CMEDDBVersion >= 27) and (K_CMSFixStudyDataMode = 1) then
        N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServCreateStudyFiles, FALSE );
      N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServClearImg3DTmpFiles, FALSE  );
    end;  // if not K_CMSDBRecoveryMode then
  end; // if (K_CMEDAccess is TK_CMEDDBAccess) then
//
// end of Check Files Access
/////////////////////////////////////////

/////////////////////////////////////
//  Get CMS Standalone Start Context
//
  if K_CMStandaloneGUIMode then
  begin
  //////////////////////
  //  Standalone start
  //
    K_CMEDAccess.EDASetInstanceState( TRUE, K_CMEDAInstanceStandaloneFlag );
    K_SplashScreenHide();
    N_Dump1Str('***** After SplashScreen Hide 2');
    if not K_CMGetStartContextDlg( [K_gscLocation,K_gscProvider,K_gscPatient] ) then
    begin
      K_CMSAppStartContext.CMASState := K_cmasStop;
      N_CM_MainForm.Close();
      Exit;
    end
    else
    begin
      K_CMCurUserAccessRights := K_CMEDAccess.EDAGetProviderAccessRights( K_CMSAppStartContext.CMASProvID );
      if not K_CMSCheckStartAccessRights() then
      begin
        K_CMSAppStartContext.CMASState := K_cmasStop;
        N_CM_MainForm.Close();
        Exit;
      end;
    end;
  //
  // end of Standalone start
  //////////////////////
  end
  else
  if not K_CMD4WAppRunByCOMClient     and
    (K_CMEDAccess is TK_CMEDDBAccess) and
    (K_CMEDDBVersion >= 21) then
  begin
  ///////////////////////////
  // Check Command Line Link
  //

//K_CMSLinkCommandLineFormatMode := K_cmclfCL2000; // debug Code
    StartByClineOnly := N_MemIniToBool('CMS_Main', 'StartByClientOnly', false);
    if not K_CMVUIMode and
       StartByClineOnly and
       ( (K_CMSLinkCommandLineFormatMode = K_cmclfNone) or  // Command Line Format is not specified
         (K_CMDParams.Count = 0) ) then                     // Command Line is Empty
    begin
      K_CMShowMessageDlg( K_CML1Form.LLLAppInit14.Caption,
//          'Application should be started with command line parameters',
          mtError );
      K_CMSAppStartContext.CMASState := K_cmasStop;
      N_CM_MainForm.Close();
      Exit; // finished by Client
    end;

    if K_CMSLinkCommandLineFormatMode <> K_cmclfNone then
    begin
    // Parse Commnd Line Context
      K_CMSCLLContextFromCommandLine( );

      if (K_CMDBCurCodePage > 0)      and
         (K_CMSCLLAttrs.CodePage > 0) and
         (K_CMSCLLAttrs.CodePage <> K_CMDBCurCodePage) then
      begin // Wrong Command Line Context
        K_CMShowMessageDlg( format( K_CML1Form.LLLAppInit15.Caption + ' ' + K_CML1Form.LLLPressOkToClose.Caption,
//                                    'Media Suite database code page %d does not match link code page %d. Press OK to close Media Suite',
                                    [K_CMDBCurCodePage, K_CMSCLLAttrs.CodePage] ),
                              mtWarning );
        K_CMSAppStartContext.CMASState := K_cmasStop;
        N_CM_MainForm.Close();
        Exit;
      end;

      if K_CMSCLLAttrs.PatientAttrs.CLLPID <> -1 then
      begin
      // Command Line Context is found
//        K_CMUpdateEDAPPLByCLLContext();

        StartContextSet := [];
        if K_CMSCLLAttrs.LocationAttrs.CLLLID = -1 then
          StartContextSet := StartContextSet + [K_gscLocation];

        if K_CMSCLLAttrs.ProviderAttrs.CLLUID = -1 then
          StartContextSet := StartContextSet + [K_gscProvider];

        // Get Start Provider and Location context
        if StartContextSet <> [] then
        begin // Open Select Provider and|or Location Dialog
          K_SplashScreenHide();
          N_Dump1Str('***** After SplashScreen Hide 2');
          if not K_CMGetStartContextDlg( StartContextSet ) then
          begin // Close CMS because of Select Context failing
            K_CMSAppStartContext.CMASState := K_cmasStop;
            N_CM_MainForm.Close();
            Exit;
          end;
        end;
      end
      else
      begin // Wrong Command Line Context
        K_CMShowMessageDlg( K_CML1Form.LLLAppInit16.Caption + ' ' + K_CML1Form.LLLPressOkToClose.Caption,
//          'The patient ID is invalid.',
                              mtWarning );
        K_CMSAppStartContext.CMASState := K_cmasStop;
        N_CM_MainForm.Close();
        Exit;
      end;
    end; // if K_CMSLinkCommandLineFormatMode <> K_cmclfNone then

    Short(K_CMCurUserAccessRights) := -1;
  //
  // end of Check Command Line Link
  //////////////////////////
  end;

  // if K_CMDemoModeFlag and (K_CMEDAccess is TK_CMEDAccess) then
  if not (K_CMEDAccess is TK_CMEDDBAccess) then
  begin
    // Clear Archive Slides View Attributes for Local Archive Mode
    with K_CMEDAccess do
      for i := 0 to ArchSlidesRoot.DirHigh do
        EDAInitSlideViewAttrs(TN_UDCMSlide(ArchSlidesRoot.DirChild(i)));
    N_Dump1Str( 'DB >> AutoRefresh Lag=' + IntToStr(K_CMPatSlidesAutoRefreshLag) );
  end
  else
  if K_CMSAppStartContext.CMASMode < K_cmamCOMHPUI then
  begin
    N_Dump2Str( 'IU >> Auto Check IU start =' + IntToStr(K_CMIURemindeInDays) );
    if (K_CMIURemindeInDays > 0) and
//       (K_CMIURemindeTS + K_CMIURemindeInDays > Now()) then // for debug
       (K_CMIURemindeTS + K_CMIURemindeInDays < Now()) then
      N_CM_MainForm.CMMCallActionByTimer(N_CMResForm.aServLaunchIUAppAuto, FALSE);
  end;

  { !!! Put D4W Commands to Buffer for debug
    K_ExecUICommand( 3, '0', TRUE );
    K_ExecUICommand( 2, 'MediaClearSelection', TRUE );
    K_ExecUICommand( 0, '232', TRUE );
    K_ExecUICommand( 2, 'MediaOpen', TRUE );
    K_ExecUICommand( 3, '0', TRUE );
    { }

{  !!! This code is moved to K_CMEDAccessInit2
  N_CM_MainForm.CMMCallActionByTimer(nil, TRUE); // Activate Timer for K_ExecUICommandsList
}
end; // end of K_CMEDAccessInit11


//********************************************* K_CMEDAccessInit2 ***
// Init external Data Access Context in Interface Form FormShow
//
//      Parameters
// Result - Returns TRUE if application set contex OK, FALSE if set application
//          context fails
//
function K_CMEDAccessInit2() : Boolean;
var
  i : Integer;
  SetContextResult : Integer;

label SetCurContextLoop;

begin
  Result := FALSE;

  N_Dump2Str( 'DB >> K_CMEDAccessInit2 start' );         ////Igor 22102019

  if (K_CMSAppStartContext.CMASState = K_cmasStop) then
  begin
    N_Dump2Str( 'DB >> K_CMEDAccessInit2 fin by K_cmasStop');
    Exit; // precaution
  end;
////////////////////////////////////
//  !!! This code should be placed later -> to K_CMEDAccessInit2
  N_CM_MainForm.CMMCurFMainForm.Caption := K_CMMessageDlgDefaultCaption;
  Application.Title := 'CentaurMediaSuite';

  /////////////////////////////////////////
  // CLear CaptToolBar
  //
  with N_CM_MainForm do
  begin
    if CMMCurCaptToolBar <> nil then // For Old MainForm Compatibility
    for i := 1 to CMMCurCaptToolBar.ButtonCount do
      CMMCurCaptToolBar.Buttons[0].Free;
  end;
//  !!! This code should be placed later
////////////////////////////////////
  if K_CMSAppStartContext.CMASState = K_cmasSkipStartContext then
  begin
    N_Dump2Str( 'DB >> K_CMEDAccessInit2 fin by K_cmasSkipStartContext' );
    N_CM_MainForm.CMMCallActionByTimer( nil, TRUE );
    Exit;
  end;

  ///////////////////////////////////////////
  // Resume all not resumed Patient CopyMove
  if (K_CMEDAccess is TK_CMEDDBAccess) and (K_CMEDDBVersion >= 28) then
  begin
    N_Dump2Str( 'DB >> Try to resume all CopyMove on CMS start');
    K_CMAllPatObjCopyMoveProcResume( 0 );
  end;

SetCurContextLoop: //*****
  SetContextResult := K_CMSetCurSessionContext(K_CMSAppStartContext.CMASPatID, K_CMSAppStartContext.CMASProvID, K_CMSAppStartContext.CMASLocID, K_CMSAppStartContext.CMASPSlideFilterAttrs);
  if SetContextResult = -2 then // SetCurSessionContext because user break
  begin
    N_Dump1Str( format( 'K_CMEDAccessInit2 >> Patient ID=%d is locked by CopyMove.',
                        [K_CMSAppStartContext.CMASPatID] ) );

    if K_CMStandaloneGUIMode and
       K_CMGetStartContextDlg( [K_gscPatient] ) then goto SetCurContextLoop;

    N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServCloseCMS, TRUE );
    Exit;
  end; // if SetContextResult = -2 then

  N_Dump2Str( 'Set State after Archive Init --> PatID=' + IntToStr(K_CMSAppStartContext.CMASPatID) +
              ' ProvID=' + IntToStr(K_CMSAppStartContext.CMASProvID) +
              ' LocID=' + IntToStr(K_CMSAppStartContext.CMASLocID) );

  K_CMSRebuildCommonRImage();

  FreeAndNil(K_CMEDAccess.AllMediaTypes);

  K_CMRebuildSlidesFilterMTypes();

  // Update UI elements by Device Profiles
// Not needed here because it was already called in K_CMSetCurSessionContext(...)
//  N_CM_MainForm.CMMUpdateUIByDeviceProfiles();

  N_CM_MainForm.CMMCallActionByTimer(nil, TRUE); // Activate Timer for K_ExecUICommandsList

  // needed in Demo mode when CMMServActions list is empty to set Ready on Application start
  if not K_CMEDAccess.AccessReady then // set Ready in not DB (in Demo) mode
    K_CMEDAccess.AccessReady := not (K_CMEDAccess is TK_CMEDDBAccess);

  Result := TRUE;

  N_Dump2Str( 'DB >> K_CMEDAccessInit2 fin' );

end; // procedure K_CMEDAccessInit2

//********************************************** K_CMSCheckStartAccessRights ***
// Check User Access Rights to Start CMS
//
function K_CMSCheckStartAccessRights() : Boolean;
begin
  Result := K_uarStart in K_CMCurUserAccessRights;
  if Result then Exit;
  K_CMShowMessageDlg( K_CML1Form.LLLAppInit17.Caption,
//                  'Sorry, you do not have access rights to use the Mediasuite.'#13#10 +
//                  '          Please talk to your system administrator.',
                      mtError );
end; // procedure K_CMSCheckStartAccessRights

//****************************************************** K_CMInitEmbossAttrs ***
// Initialize Emboss Atrributes in given View Attributes
//
//     Parameters
// APImgViewConvData - pointer to all view conversion attributes
// AUNCInit - if TRUE then unconditional initialization will be done
//
procedure K_CMInitEmbossAttrs(APImgViewConvData: TK_PCMSImgViewConvData;
  AUNCInit: Boolean = false);
begin

  with APImgViewConvData^ do
  begin
    if ((VCEmbBase <> 0) or (VCEmbDepth <> 0) or (VCEmbDirAngle <> 0))
      and not AUNCInit then
      Exit;
    // Initialize Emboss Attriutes
    VCEmbDepth := 3;
    VCEmbDirAngle := 45;
    VCEmbRFactor := 10.0;
    VCEmbBase := 128;
  end;

end; // procedure K_CMInitEmbossAttrs

//****************************************** K_CMConvDIBBySlideViewConvData ***
// Convert given DIBObj by given View Attributes
//
//     Parameters
// ADDIBObj - resulting Device Independent Bitmap Object (if nil will be created)
// ASDIBObj - source Device Independent Bitmap Object
// APImgViewConvData - pointer to all view conversion attributes
// APixFmt   - resulting DIB pixel format
// AExPixFmt - resulting DIB extended pixel format
// APEmbDIB1 - pointer to first emboss buffer DIB
//
// If ADDIBObj is nil, it will be created. If ADstDIB exists but have not proper
// attributes (Size and Pixel format) it will be restructed properly. ADstDIB
// cannot be the same object as Self.
//
procedure K_CMConvDIBBySlideViewConvData(var ADDIBObj: TN_DIBObj;
  ASDIBObj: TN_DIBObj; APImgViewConvData: TK_PCMSImgViewConvData;
  APixFmt: TPixelFormat; AExPixFmt: TN_ExPixFmt = epfBMP;
  APEmbDIB1: TN_PDIBObj = nil;
  APIsoMinMax : PInteger = nil; APXLatBCGHist : TN_PIArray = nil;
  APXLatBCGColor : TN_PIArray = nil );
begin
  with APImgViewConvData^ do
  N_Dump2Str( format('!!>> ConvDIBBySlideView FR=%d N=%s BCGLU=%g,%g,%g,%g,%g',
                     [VCFlipRotateAttrs, N_B2S(VCNegateFlag),
                      VCBriFactor,VCCoFactor,VCGamFactor,VCBriMinFactor,VCBriMaxFactor]) );
  N_CMConvDIBBySlideViewConvData( ADDIBObj, ASDIBObj, APImgViewConvData,
          APixFmt, AExPixFmt, APEmbDIB1, APIsoMinMax,
          APXLatBCGHist, APXLatBCGColor );
  Exit;
end; // procedure K_CMConvDIBBySlideViewConvData

//********************************************* K_CMColorizeInitData ***
// Init Colorize Data
//
procedure K_CMColorizeInitData();
var
  CL: TStringList;
//  PL: TStringList;
  i, j: Integer;

begin
//  PL := TStringList.Create;
//  N_CurMemIni.ReadSectionValues('CMSColorPals', PL);
//  if PL.Count = 0 then
//    PL.Add('Hot=#000000, #FF0000, #FFFFFF');
//  SetLength(K_CMColorizePalNames, PL.Count);
//  SetLength(K_CMColorizePalColors, PL.Count);
  SetLength( K_CMColorizePalColors, K_CMSColorizePalettes.Count );
  CL := TStringList.Create;

//  for i := 0 to PL.Count - 1 do
  for i := 0 to K_CMSColorizePalettes.Count - 1 do
  begin
//    K_CMColorizePalNames[i] := PL.Names[i];
//    CL.CommaText := PL.ValueFromIndex[i];
    CL.CommaText := K_CMSColorizePalettes.ValueFromIndex[i];
    SetLength( K_CMColorizePalColors[i], CL.Count );
    for j := 0 to CL.Count - 1 do
      K_CMColorizePalColors[i][j] := N_StrToColor(Trim(CL[j]));
  end;
//  PL.Free;
  CL.Free;
end; // end of K_CMColorizeInitData

//********************************************* K_CMColorizeBuildColors ***
// Build Colors by Colorize Palette Index
//
//     Parameters
// APColors - pointer to resulting colors array start element
// AColorsCount - resulting colors array elements counter
// APalIndex  - colorize palette index
// ASwapRedBlueFlag - swap Red and Blue color bytes
//
procedure K_CMColorizeBuildColors(APColors: PInteger;
  AColorsCount, APalIndex: Integer; ASwapRedBlueFlag: Boolean = false);
var
  PColorPath: PInteger;
  RColorPath, SColorPath: TN_IArray;
  i, L: Integer;
begin
  APalIndex := Min( APalIndex, High(K_CMColorizePalColors) ); // Precaution
  SColorPath := K_CMColorizePalColors[APalIndex];
  L := Length(SColorPath);
  PColorPath := @SColorPath[0];
  if ASwapRedBlueFlag then
  begin
    SetLength(RColorPath, L);
    for i := 0 to L - 1 do
      RColorPath[i] := N_SwapRedBlueBytes(SColorPath[i]);
    PColorPath := @RColorPath[0];
  end;
  K_BuildColorsByColorPath(PColorPath, L, APColors, AColorsCount);

end; // end of procedure K_CMColorizeBuildColors

//********************************************* K_CMEDDBUtilInitData ***
// Initialized DB data utility
//
//     Parameters
// AInitMTypes - init MedeaTypes flag
// Result - Returns TRUE if utility was successfully done
//
// Truncates all multi-records DB Tables and inits Global Attributes Table record fields
//
function K_CMEDDBUtilInitData(AInitMTypes: Boolean): Boolean;
var
  WCMEDDBAccess: TK_CMEDDBAccess;
  MTNum: Integer;
begin
  if K_CMEDAccess is TK_CMEDDBAccess then
    WCMEDDBAccess := TK_CMEDDBAccess(K_CMEDAccess)
  else
    WCMEDDBAccess := TK_CMEDDBAccess.Create;

  Result := false;
  with WCMEDDBAccess do
    if EDACheckDBConnection(LANDBConnection, TRUE) = K_edOK then
    begin
      Result := TRUE;
      EDAClearAllEData();
      if AInitMTypes then
      begin
        EDAddInitialMediaTypes(@MTNum);
        if MTNum > 0 then
          N_Dump2Str(IntToStr(MTNum) + ' initial Media Types are added');
      end;
    end;

  if K_CMEDAccess is TK_CMEDDBAccess then
    Exit;
  WCMEDDBAccess.AppRTID := 0; // for Deactivation Prevent in TK_CMEDDBAccess.Destroy
  WCMEDDBAccess.Free;
end; // end of K_CMEDDBUtilInitData

//********************************************* K_CMEDDBUtilSaveToDB ***
// Save All current patient slides to DB utility
//
//     Parameters
// AReplacePatSlides - replace current Patient DB Slides
// Result - Returns TRUE if utility was successfully done
//
function K_CMEDDBUtilSaveToDB(AReplacePatSlides: Boolean): Boolean;
var
  WCMEDDBAccess: TK_CMEDDBAccess;
  Ind, i: Integer;
begin
  if K_CMEDAccess is TK_CMEDDBAccess then
    WCMEDDBAccess := TK_CMEDDBAccess(K_CMEDAccess)
  else
  begin
    // Current Mode is Local Archive
    WCMEDDBAccess := TK_CMEDDBAccess.Create;
    with WCMEDDBAccess do
    begin
      if AReplacePatSlides then
      begin
        // Delete All Slides in DB
        CurSlidesSelectAttrs := K_CMEDAccess.CurSlidesSelectAttrs;
        EDAGetCurSlidesSet();
        EDADelSlides(nil, 0, FALSE);
        EDASaveSlidesList(nil);

        K_CMEDAccess.EDASaveSlidesList(nil); // Save previous state

        EDAAssign(K_CMEDAccess); // Init new Access Object by Current

        // Set New/ChangedFlags to current slides
        for i := 0 to CurSlidesList.Count - 1 do
          with TN_UDCMSlide(CurSlidesList[i]).P()^ do
          begin
            CMSRFlags := CMSRFlags + [cmsfIsNew];
            if cmsfHasSrcImg in CMSDB.SFlags then
            begin
              CMSDB.SFlags := CMSDB.SFlags - [cmsfHasSrcImg];
              CMSDB.SFlags := CMSDB.SFlags + [cmsfSaveSrcImg];
            end;
            if CMSMediaType > K_CMEDMTypeInitID then
            begin
              // Synchronization Archive Slide MediaType with DB
              Ind := K_CMEDAccess.AllMediaTypes.IndexOfObject
                (TObject(CMSMediaType));
              if Ind >= 0 then
                EDAddNewMediaType(CMSMediaType, AllMediaTypes[Ind])
              else
                CMSMediaType := 0;
            end;
          end;
      end
      else // if AReplacePatSlides then
        EDAAssign(K_CMEDAccess);
    end; // with WCMEDDBAccess do
  end; // end of Local Archive

  Result := false;
  with WCMEDDBAccess do
    if EDACheckDBConnection(LANDBConnection, TRUE) = K_edOK then
    begin
      Result := TRUE;
      EDASaveSlidesList(nil); // Current K_CMEDAccess context is used to access to Slide content
    end;

  if K_CMEDAccess is TK_CMEDDBAccess then
    Exit;
  // Clear Moved to DB Slides From Current
  with K_CMEDAccess do
  begin
    // K_UnDeletedFileNames := UndeletedFileNames.SL;
    for i := CurSlidesList.Count - 1 downto 0 do
    begin
      // Clear Slide MediaFile Name befor deletion
      EDADelSlideMediaFiles(TN_UDCMSlide(CurSlidesList[i]));
      // K_CMDeleteClientMediaFile( TN_UDCMSlide(CurSlidesList[i]), true );
      // EDADelSlide( TN_UDBase(CurSlidesList[i]) );
    end;
    EDADelSlides(TN_PUDCMSlide(@CurSlidesList.List[0]), CurSlidesList.Count, FALSE);

    // K_UnDeletedFileNames := nil;
    EDASaveSlidesList(nil);
  end;

  WCMEDDBAccess.Free;
end; // end of K_CMEDDBUtilSaveToDB

//********************************************************** K_CMSearchSlideByID ***
// Rebuild visible Slides array by given filtering attributes
//
//     Parameters
// APSlide - pointer to start element in Slides array to search
// ASlidesCount - number of Slides in sliades array
// ASlideID - Slide ID to search
// Result - Returns Slide index in Slides array or -1 if Slide is not found
//
function K_CMSearchSlideByID(APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
  const ASlideID: string): Integer;
var
  i: Integer;
begin

  for i := 0 to ASlidesCount - 1 do
  begin
    Result := i;
    if APSlide.ObjName = ASlideID then
      Exit;
    Inc(APSlide);
  end;
  Result := -1;
end; // end of K_CMSearchInSlidesArrayByID

//********************************************** K_ExecUICommand ***
// Execute CMS UI Command
//
//     Parameters
// AComCode - CMS UI Command Code:
//#F
// 0 - Select Media Object in CMS Main Window Thumbnailes Frame (add to selected)
//     AComInfo - string with Media Object ID
// 1 - Unselect Media Object in CMS Main Window Thumbnailes Frame (remove from selected)
//     AComInfo - string with Media Object ID
// 2 - Execute UI Action
//     AComInfo - UI Action Name:
//   MediaClearSelection  - Clear Media Objects Selection in CMS Main Window Thumbnailes Frame
//   MediaOpen            - Open Media Object selected in CMS Main Window Thumbnailes Frame
//   ScrollToSelection    - Scroll Thumbnailes Frame content to Last Selected Item
//   CMSClose             - Close CMS Application (needed for close CMS after Modal Window Close)
//   RemoveCMSClose       - Remove Close CMS Application Request (needed to remove buffered CMSClose command)
// 3 - Set Window State
//    AComInfo - string with Window State Code:
//     -1 - hide,
//      0 - normal,
//      1 - minimized,
//      2 - maximized,
// 4 - Copy/Move Slides from one Patient to another
//    AComInfo - string with 3 comma separated numbers (SrcPatID, DestPatID, ):
//      - given source patient ID
//      - given destination patient ID
//      - copy/move slides mode (=0 means move mode, <> 0 copy mode
// 5 - update Providers and Locations data from link info
//    AComInfo - string with update code:
//      1 - update providers only
//      2 - update locations only
//      <> 1 or 2 - update locations and providers
//#/F
// AComInfo - CMS GUI Command Info
// AUICommandFlags - command flags
//
// Result - Returns function COM resulting code.
//
function K_ExecUICommand( AComCode: Integer; const AComInfo: string;
                          AUICommandFlags : TK_CMUICommandFlags = [] ): HResult;
//function K_ExecUICommand( AComCode: Integer; const AComInfo: string;
//  AToBufFlag: Boolean = FALSE; ALastListCommand : Boolean = FALSE ): HResult;
// AToBufFlag - if TRUE then given command will be save to commands buffer else
// ALastListCommand - last command in buffer commands list flag (needed to CMSClose)

var
  WState: Integer;
  SrcPatID, DstPatID, CopyMode: Integer;
  CopyMoveRes: Integer;
  SL: TStringList;
  AddToBufferFlag : Boolean;

  procedure ChangeSlideSelectState(ASlideID : string; ASetAct: TN_SetStateMode);
  var
    i: Integer;
    SlideInd: Integer;
    Marked: TList;
    Slide : TN_UDCMSlide;
    StudyItem : TN_UDBase;
    Study : TN_UDCMStudy;
    WCount: Integer;
  begin
    N_Dump2Str( format( 'ExecUI >> Start Select=%d By ID =%s', [Ord(ASetAct), ASlideID] ) );
    SlideInd := -1;
    WCount := Length(K_CMCurVisSlidesArray);
    if WCount > 0 then
      // Search in Visible Slides
      SlideInd := K_CMSearchSlideByID(@K_CMCurVisSlidesArray[0], WCount, ASlideID);

    N_Dump2Str( format( 'ExecUI >> Search visible I=%d C=%d', [SlideInd, WCount] ) );

    if (SlideInd = -1) and (ASetAct = ssmMark) and (K_CMEDAccess.CurSlidesList.Count > 0) then
    begin
      // Search in All Slides
      with K_CMEDAccess.CurSlidesList do
      begin
        SlideInd := K_CMSearchSlideByID(TN_PUDCMSlide(@List[0]), Count, ASlideID);
        N_Dump2Str( format( 'ExecUI >> Search All I=%d C=%d', [SlideInd,Count] ) );
      end;


      if SlideInd >= 0 then
      begin  // Slide Exists - in CurSlideList
        Slide := TN_UDCMSlide(K_CMEDAccess.CurSlidesList[SlideInd]);
        StudyItem := Slide.GetStudyItem();
        if (StudyItem <> nil) and K_CMD4WSlideStudyOpenFlag then
        begin
        // Open Slide Study and Select Study Item
          // Select Slide Study by Study ID
          Study := TN_UDCMStudy(StudyItem.Owner.Owner);

          N_Dump2Str( format( 'ExecUI >> Select study ID=%s slide ID=%s',
                              [Study.ObjName, Slide.ObjName] ) );

          if Study.CMSRFrame = nil then
          begin
          // Study is not opened -  Open Study
            N_Dump2Str( 'ExecUI >> Open Study' );
            // Select Study Thumb
            ChangeSlideSelectState( Study.ObjName, ssmMark);
            with N_CMResForm do
              if (Result = S_OK) and aMediaAddToOpened.Enabled then
              // Study is Selected
                aMediaAddToOpenedExecute( aMediaAddToOpened );
          end; // if Study.CMSRFrame = nil Study is not opened

          if Study.CMSRFrame <> nil then
          begin
          // Study is opened
            N_Dump2Str( 'ExecUI >> Study is opened - select Slide' );
            // Add New Item to Selected
            Study.SelectItem( StudyItem );
            Study.CMSRFrame.RedrawAllAndShow();

            with N_CM_MainForm, CMMCurFThumbsDGrid do
            begin
              // Clear Thumbs Selection
              if DGMarkedList.Count > 0 then
              begin
                DGMarkSingleItem( -1 ); // for proper Marked Items order
                DGRFrame.ShowMainBuf();
              end;

              // Set New Action Ability after Selection changing
              CMMFDisableActions(nil);
            end; // with N_CM_MainForm, CMMCurFThumbsDGrid do
          end; // if Study.CMSRFrame <> nil then

          Exit;
        end   // if (StudyItem <> nil) and K_CMD4WSlideStudyOpenFlag then
        else
        begin // if (StudyItem = nil) or not K_CMD4WSlideStudyOpenFlag then
        // Insert Slide to Visible
          N_Dump2Str( 'ExecUI >> Insert slide to visible' );
          SetLength(K_CMCurVisSlidesArray, WCount + 1);
          if WCount > 0 then
            Move( K_CMCurVisSlidesArray[0], K_CMCurVisSlidesArray[1],
                  WCount * SizeOf(TN_UDCMSlide) );
          K_CMCurVisSlidesArray[0] := Slide;

          N_Dump2Str( 'ExecUI >> Set Marked state' );
          with N_CM_MainForm, CMMCurFThumbsDGrid do
          begin
            // Save Selected Slide Inds
            Marked := TList.Create;
            Marked.Assign(DGMarkedList);
            DGNumItems := Length(K_CMCurVisSlidesArray);
            // Number of visible Thumbnails
            N_Dump2Str( format( 'ExecUI >> Rebuild Selection SC=%d MC=%d', [DGNumItems, Marked.Count] ) );
            DGInitRFrame(); // should be called after all CMMFThumbsDGrid fields are set
            for i := 0 to Marked.Count - 1 do
              DGSetItemState(Integer(Marked[i]) + 1, ssmMark);
            Marked.Free;
          end; // with N_CM_MainForm.CMMCurFThumbsDGrid do
          SlideInd := 0;
        end; // if (StudyItem = nil) or not K_CMD4WSlideStudyOpenFlag then
      end; // if SlideInd >= 0 then
    end; // if (SlideInd = -1) and (ASetAct = ssmMark) then

    if SlideInd >= 0 then
    begin
      if N_CM_MainForm.CMMFActiveEdFrame.IfSlideIsStudy then
      begin
        N_Dump2Str( 'ExecUI >> Clear Cur Study Selection' );
      // Clear active Study Selection
        with TN_UDCMStudy(N_CM_MainForm.CMMFActiveEdFrame.EdSlide) do
        begin
          if CMSSelectedCount > 0 then
          begin
            UnSelectAll();
            CMSRFrame.RedrawAllAndShow();
          end;
        end;
      end;

      // Add New Thumb to Selected
      N_CM_MainForm.CMMCurFThumbsDGrid.DGSetItemState(SlideInd, ASetAct);
      N_CM_MainForm.CMMCurFThumbsDGrid.DGSelectItem(SlideInd);
      N_CM_MainForm.CMMCurFThumbsRFrame.RedrawAllAndShow();

      // Set New Action Ability after Selection changing
      N_CM_MainForm.CMMFDisableActions(nil);
    end
    else
      Result := E_INVALIDARG;
  end; // procedure ChangeSlideSelectState

  procedure SaveToBuffer();
  begin
    if K_CMD4WUICommandsList = nil then
      K_CMD4WUICommandsList := TStringList.Create();
    if K_uicInsToBuffer in AUICommandFlags then
      K_CMD4WUICommandsList.InsertObject(0, AComInfo, TObject(AComCode))
    else
      K_CMD4WUICommandsList.AddObject(AComInfo, TObject(AComCode));
    Result := 2; // Server is Buisy
  end; // procedure SaveToBuffer

begin
  Result := S_OK;
{ // Temporary Close
  if AToBufFlag then
    Result := 2; // Server is Buisy
}
  AddToBufferFlag := (K_uicAddToBuffer in AUICommandFlags) or
                     (K_uicInsToBuffer in AUICommandFlags);
  try
//    N_CheckAllExec( 'Start K_ExecUICommand' );
    K_AMSCObj.AMSCheckExec('Start K_ExecUICommand');
    case AComCode of
      0: // Select object Thumbnail
        begin
          // Add to Selected in ThumbFrame
          if AddToBufferFlag then
            SaveToBuffer()
          else
            ChangeSlideSelectState(AComInfo, ssmMark);
        end; // Select object Thumbnail
      1: // UnSelect object Thumbnail
        begin
          // Remove from Selected in ThumbFrame
          if AddToBufferFlag then
            SaveToBuffer()
          else
            ChangeSlideSelectState(AComInfo, ssmUnmark);
        end; // 1: // UnSelect object Thumbnail
      2: // Execute GUI Action
        begin
          // Execute GUI Action
          with N_CMResForm do
            if AComInfo = 'MediaClearSelection' then
            begin
              if AddToBufferFlag then
                SaveToBuffer()
              else
              begin
                if N_CM_MainForm.CMMFActiveEdFrame.IfSlideIsStudy() then
                  aEditStudyClearSelectionExecute(aEditStudyClearSelection);
                aEditClearSelectionExecute(aEditClearSelection);
              end
            end // if AComInfo = 'MediaClearSelection' then
            else if AComInfo = 'MediaOpen' then
            begin
              if AddToBufferFlag then
                SaveToBuffer()
              else if aMediaOpen.Enabled then
                aMediaOpenExecute(aMediaOpen);
            end // if AComInfo = 'MediaOpen' then
            else if AComInfo = 'ScrollToSelection' then
            begin
              if AddToBufferFlag then
                SaveToBuffer()
              else
                with N_CM_MainForm, CMMCurFThumbsDGrid do
                  if DGMarkedList.Count > 0 then
                    DGScrollToItem( Integer(DGMarkedList.Items[DGMarkedList.Count-1]) );
            end // if AComInfo = 'ScrollToSelection' then
            else if (AComInfo = 'CMSClose') then
            begin
              if AddToBufferFlag then
                SaveToBuffer()
              else
              if K_uicLastCommand in AUICommandFlags then
              begin
                K_CMD4WCloseAppByUI := TRUE;
                N_CM_MainForm.CMMFAppClose( '***** D4W >> UI Command ' + AComInfo );
              end;
            end // if (AComInfo = 'CMSClose') then
            else if (AComInfo = 'RemoveCMSClose') then
            begin
              if AddToBufferFlag then
                SaveToBuffer();
            end // if (AComInfo = 'RemoveCMSClose') then
            else if AComInfo = 'AddMediaToOpened' then
            begin
              if AddToBufferFlag then
                SaveToBuffer()
              else if aMediaAddToOpened.Enabled then
                aMediaAddToOpenedExecute( aMediaAddToOpened );
            end // if AComInfo = 'AddMediaToOpened' then
            else
              Result := E_INVALIDARG;
        end; // 2: // Execute UI Action
      3: // Set Window State
        begin
          // Set Window State
          WState := StrToIntDef(AComInfo, -2);
          if WState = -2 then
            Result := E_INVALIDARG
          else
          begin
            if AddToBufferFlag then
              SaveToBuffer()
            else
              with N_CM_MainForm do
                CMMSetWindowState( WState );
          end;
        end; // 3: // Set Window State
      4: // Copy/Move Slides from one Patient to another
        begin
          // Copy/Move Patient Slides
          SL := TStringList.Create;
          SL.CommaText := AComInfo;
          SrcPatID := -1;
          DstPatID := -1;
          CopyMode := -1;
          // Parse Command Parameters
          if SL.Count > 0 then
            SrcPatID := StrToIntDef(SL[0], -1);
          if SL.Count > 1 then
            DstPatID := StrToIntDef(SL[1], -1);
          if SL.Count > 2 then
            CopyMode := StrToIntDef(SL[2], -1);

          // Check Parsing Results
          if SrcPatID = -1 then
          begin
            Result := E_INVALIDARG;
            N_Dump1Str
              ('D4W >> CopyMovePatSlide Wrong Src Patient ID=' + SL[0]);
          end;
          if DstPatID = -1 then
          begin
            Result := E_INVALIDARG;
            N_Dump1Str
              ('D4W >> CopyMovePatSlide Wrong Dest Patient ID=' + SL[1]);
          end;
          if CopyMode = -1 then
          begin
            Result := E_INVALIDARG;
            N_Dump1Str
              ('D4W >> CopyMovePatSlide Wrong CopyMoveMode=' + SL[2]);
          end;
          SL.Free;

          if Result <> E_INVALIDARG then
          begin
            if AddToBufferFlag then
              Result := 2
            else
            begin // if not AddToBufferFlag then
              if K_CMSlidesCopyMoveArchivedCheck(SrcPatID) then
              begin
                // K_CMSlidesCopyMoveLaunchByPat(SrcPatID, DstPatID, CopyMode);
                Result := 10;
              end
              else
              begin // Do CopyMove
                CopyMoveRes := K_CMSlidesCopyMoveByPat(SrcPatID, DstPatID, CopyMode, FALSE);
                if CopyMoveRes = -1 then
                  Result := 3 // CMS works with Source or Destination Patient on this computer (not actual for new CopyMove)
                else if CopyMoveRes = -2 then
                  Result := 4 // Source Patient Slides are used by some CMS Users
                else if CopyMoveRes = -3 then
                  Result := 5;// Copy/Move files error
              end;
            end; // if not AddToBufferFlag then
          end; // if Result <> E_INVALIDARG then
        end; // 4: // Copy/Move Slides from one Patient to another
      5: // Update Data by D4W Link Info
        begin
          K_CMD4WUpdateInfo := AComInfo;
        end  // 5: // Update Data by D4W Link Info
    else // else case AComCode of
      Result := E_INVALIDARG;
    end; // case AComCode of
//    N_CheckAllExec( 'Fin K_ExecUICommand' );
    K_AMSCObj.AMSCheckExec('Fin K_ExecUICommand');
  except
    on E: Exception do
    begin
      N_Dump1Str( 'D4W >> Exec UI Command Exception -> ' + E.Message);
      Result := E_UNEXPECTED;
    end;
  end;
end; // *** end of K_ExecUICommand

//********************************************** K_ExecUICommandsList ***
// Execute CMS buffered UI Commands List
//
procedure K_ExecUICommandsList();
var
  i: Integer;
  ComCode: Integer;
  ComInfo: string;
  DumpInfo: string;
  UICommandFlags : TK_CMUICommandFlags;
//  ExecList: TStringList;
begin
  if K_CMD4WUICommandsList = nil then
    Exit;
  // K_CMD4WSkipWaitApplyDataFlag := TRUE;
  Inc(K_CMD4WWaitApplyDataCount);
{
  ExecList := TStringList.Create;
  ExecList.Assign(K_CMD4WUICommandsList);
  K_CMD4WUICommandsList.Clear;
  with ExecList do
  begin
    for i := 0 to Count - 1 do
    begin
      ComCode := Integer(Objects[i]);
      ComInfo := Strings[i];
      N_Dump1Str('Exec buffered UI Command Code=' + IntToStr(ComCode)
          + ' Info=' + ComInfo +
          ' Res=$' + IntToHex(K_ExecUICommand(ComCode, ComInfo, FALSE, i = Count - 1 ), 8));
    end;
  end;
  ExecList.Free;
}
  i := 0;
  while i < K_CMD4WUICommandsList.Count do
  begin
    ComCode := Integer(K_CMD4WUICommandsList.Objects[i]);
    ComInfo := K_CMD4WUICommandsList[i];
    DumpInfo := 'Exec buffered UI Command Code=' + IntToStr(ComCode) +
                ' Info=' + ComInfo;
    N_Dump2Str( 'Start ' + DumpInfo );
    UICommandFlags := [];
    if i = K_CMD4WUICommandsList.Count - 1 then
      UICommandFlags := [K_uicLastCommand];
    N_Dump1Str( DumpInfo + ' Res=$' +
                IntToHex(K_ExecUICommand(ComCode, ComInfo, UICommandFlags ), 8) );
    Inc(i);
  end;
  // K_CMD4WSkipWaitApplyDataFlag := FALSE;
//  N_Dump2Str( 'K_ExecUICommandsList 1' );
  K_CMD4WUICommandsList.Clear;
//  N_Dump2Str( 'K_ExecUICommandsList 2' );
  Dec(K_CMD4WWaitApplyDataCount);
//  N_Dump2Str( 'K_ExecUICommandsList 3' );
end; // *** end of K_ExecUICommandsList

//********************************************************** K_CMGetViewFilterDumpStr ***
// Get filtering attributes DUmp String
//
//     Parameters
// APFilterAttrs  - pointer to filtering attributes
// Result         - Returns string with dump text
//
function K_CMGetViewFilterDumpStr( APFilterAttrs: TK_PCMSlideFilterAttrs ) : string;
begin
  Result := 'empty';
  if APFilterAttrs = nil then Exit;
  with APFilterAttrs^ do
    Result :=  format( 'TeethFlags=%s  MTypeInd=%d DMode=%d D1=%s D2=%s Open=%d',
    [IntToHex(FATeethFlags,16), FAMediaType, Integer(Byte(FADateMode)),
     K_DateTimeToStr(FADate1, 'dd"/"mm"/"yy'),
     K_DateTimeToStr(FADate2, 'dd"/"mm"/"yy'),
     FAOpenCount] );
end; // end of K_CMGetViewFilterDumpStr

//********************************************************** K_CMRebuildSlidesArrayByFilter ***
// Rebuild visible slides array by given filtering attributes
//
//     Parameters
// APSlides - pointer to source slides array first element
// ASlidesCount - source slides array length
// ASlidesArray   - resulting slides array
// AStudiesCount  - number of leading studies counter
// APFilterAttrs  - pointer to filtering attributes
// AFreeUnusedSlides - if TRUE then unused slides will be free
// Result         - Returns Opened Slides (removed from Visible) Counter
//
function K_CMRebuildSlidesArrayByFilter( APSlides : TN_PUDCMSlide; ASlidesCount : Integer;
  var ASlidesArray: TN_UDCMSArray; out AStudiesCount : Integer;
  APFilterAttrs: TK_PCMSlideFilterAttrs; AFreeUnusedSlides : Boolean = FALSE ) : Integer;
var
  i, CountSlide, CountStudy: Integer;
  WSLide: TN_UDCMBSlide;
//  EdFrame : TN_CMREdit3Frame;
  FSlidesArray: TN_UDCMSArray;
  StudySlides : TN_UDCMSArray;
  IncludeStudy : Boolean;
  SSI : Integer;
  SkipArchivedFlag : Boolean;
  SkipPMTSlides : Boolean;
  PMTStudySampleFlag : Boolean;
begin

  N_Dump2Str( 'View Filter: ' + K_CMGetViewFilterDumpStr(APFilterAttrs) );

  SetLength(ASlidesArray, ASlidesCount);
  SetLength(FSlidesArray, ASlidesCount);
  CountSlide := 0;
  CountStudy := 0;
  AStudiesCount := 0;
  Result := 0;
  K_CMFilterDatesInit( APFilterAttrs );
  SkipArchivedFlag := not K_CMShowArchivedSlidesFlag and
                      (K_CMEDDBVersion >= 41);
  SkipPMTSlides := not K_CMShowPMTStudiesFlag and
                   not K_CMShowPMTStudiesOnlyFlag and
                   (K_CMEDDBVersion >= 41);
{
K_CMShowPMTStudiesFlag : Boolean = FALSE;
K_CMShowPMTStudiesOnlyFlag : Boolean = FALSE;
}
  for i := High(ASlidesArray) downto 0 do
  begin
    WSLide := TN_UDCMBSlide(APSlides^);
    Inc(APSlides);

    if not K_CMMarkAsDelShowFlag and
       (cmsdbfMarkedAsDel in WSLide.CMSDBStateFlags) then
    begin
//      Inc(Result);
      if AFreeUnusedSlides then
        WSLide.UDDelete();
      Continue; // Skip New Marked as Del Slides (Marked by Other Users)
    end;

    if WSLide is TN_UDCMStudy then
    begin
      IncludeStudy := not SkipArchivedFlag;
      if not IncludeStudy then
      begin
        TN_UDCMStudy(WSLide).GetAllSlidesToArray( StudySlides );
        IncludeStudy := Length(StudySlides) = 0;
        if not IncludeStudy then
          for SSI := 0 to High(StudySlides) do
          begin
            IncludeStudy := not StudySlides[SSI].CMSArchived;
            if IncludeStudy then break;
          end;
      end; // if not IncludeStudy then

      // Check show PMT Study mode
      if (K_CMShowPMTStudiesOnlyFlag or SkipPMTSlides) and IncludeStudy then
      begin
        with WSLide.DirChild( K_CMStudyIndSrcSample ) do
        PMTStudySampleFlag := (ObjName = K_CMPMTStudySampleSID) or (ObjName = K_CMPMTStudySampleSID1);
        if (SkipPMTSlides and PMTStudySampleFlag) or
           (K_CMShowPMTStudiesOnlyFlag and not PMTStudySampleFlag) then
          IncludeStudy := FALSE;
      end; // if (K_CMShowPMTStudiesOnlyFlag or SkipPMTSlides)

      if IncludeStudy then
      begin
        ASlidesArray[CountStudy] := TN_UDCMSlide(WSLide);
        Inc(CountStudy);
      end
      else
      begin
        if AFreeUnusedSlides then
          WSLide.UDDelete();
        Continue;
      end;
    end // if WSLide is TN_UDCMStudy then
    else
    begin // if WSLide is TN_UDCMSlide then
      if K_CMShowPMTStudiesOnlyFlag or
         (WSLide.DirChild(K_CMSlideIndStudyItem) <> nil) or
         (TN_UDCMSlide(WSLide).CMSStudyID > 0) then
      begin
      // Mounted Slide or PMTStudiesOnly mode
//        Inc(Result);
        if AFreeUnusedSlides then
          WSLide.UDDelete();
        Continue;
      end
      else
      if not K_CMStudyOnlyThumbsShowGUIModeFlag           and
         (not SkipArchivedFlag or not WSLide.CMSArchived) and
         K_CMSlideCheckByFilter( TN_UDCMSlide(WSLide), APFilterAttrs ) then
      begin
      // Slide checked by filter
        FSlidesArray[CountSlide] := TN_UDCMSlide(WSLide);
        Inc(CountSlide);
      end
      else
      begin
        if cmsfIsOpened in WSLide.P.CMSRFlags then
        begin // Finish Slide Editing
  //        EdFrame := N_CM_MainForm.CMMFFindEdFrame( WSLide );
  //        if EdFrame <> nil then // precaution
  //          EdFrame.EdFreeObjects();
          Inc(Result);
        end;
        if AFreeUnusedSlides then
          WSLide.UDDelete();
      end;
    end;  // if WSLide is TN_UDCMSlide then
  end; // for i := High(ASlidesArray) downto 0 do

  AStudiesCount := CountStudy;
  if CountStudy > 0 then // Order Studies
    N_SortArrayOfElems( @ASlidesArray[0], CountStudy, SizeOf(TN_UDCMSlide),
        K_CMEDAccess.EDASlidesDTakenOrder );

  SetLength(ASlidesArray, CountSlide + CountStudy );

  if CountSlide > 0 then
  begin // Order Slides and Move them after Studies in resulting Array
    N_SortArrayOfElems( @FSlidesArray[0], CountSlide, SizeOf(TN_UDCMSlide),
        K_CMEDAccess.EDASlidesDTakenOrder );
    Move( FSlidesArray[0], ASlidesArray[CountStudy], SizeOf(TN_UDCMSlide) * CountSlide )
  end;


end; // end of K_CMRebuildSlidesArrayByFilter

//********************************************************** K_CMRemoveFromVisSlides ***
// Remove given Slide from visible slides arrya
//
//     Parameters
// ASlide - Removing Slide
//
procedure K_CMRemoveFromVisSlides(ASlide: TN_UDCMSlide);
var
  i, L: Integer;
begin
  L := Length(K_CMCurVisSlidesArray);
  i := K_IndexOfIntegerInRArray(Integer(ASlide),
    PInteger(@K_CMCurVisSlidesArray[0]), L);
  if i >= 0 then
  begin
    // remove slide
    Dec(L);
    if i < L then
      Move(K_CMCurVisSlidesArray[i + 1], K_CMCurVisSlidesArray[i],
        SizeOf(Integer) * (L - i));
    SetLength(K_CMCurVisSlidesArray, L);
  end;
end; // end of K_CMRemoveFromVisSlides

//********************************************************** K_CMDBGetSessionID ***
// Get CMS Session ID
//
//     Parameters
// Result - Returns SessionID string
//
function K_CMDBGetSessionID(): string;
type
  TProcessIdToSessionId = function(dwProcessId: DWORD;
    pSessionId: DWORD): BOOL; stdcall;
var
  ProcessIdToSessionId: TProcessIdToSessionId;
  Lib: THandle;
  SessionId: DWORD;

begin
  Result := '';
  Lib := GetModuleHandle('kernel32');
  if Lib <> 0 then
  begin
    ProcessIdToSessionId := GetProcAddress(Lib, 'ProcessIdToSessionId');
    if Assigned(ProcessIdToSessionId) then
    begin
      ProcessIdToSessionId(GetCurrentProcessId(), DWORD(@SessionId));
      // SessionId := GetCurrentProcessId();
      if SessionId <> 0 then
        Result := format('$%d', [SessionId]); // '$'+ SessionID
    end;
  end;
end; // end of K_CMDBGetSessionID

//****************************************** K_CMDBGetMSSQLConnectionString ***
// Get CMS MSSQL Connection string
//
//     Parameters
// AUserID  - user ID, if not set then 'dba' will be used
// AConInfo - additional connection info
// Result - Returns CMS DB Connection string
//
function K_CMDBGetMSSQLConnectionString( AUserID: string = ''; AConInfo: string = '' ): string;
var
  UserID : string;
begin
// Provider=MSDASQL.1;Password=123456;Persist Security Info=True;User ID=errlog;Data Source=CMS_MSSQL;Extended Properties="DSN=CMS_MSSQL;Description=CMS_MSSQL;UID=errlog;PWD=123456;APP=Architect;WSID=COMP83;DATABASE=CMSimg;Network=DBMSSOCN";App=Ñòåíä CMS
  if AConInfo <> '' then AConInfo := ';App=' + AConInfo;
  if AUserID <> '' then
    UserID := AUserID
  else
    UserID := 'dba';
  Result := format( 'Provider=MSDASQL.1;Password=123456;Persist Security Info=True;User ID=%s;Data Source=CMS_MSSQL%s',
                    [UserID,AConInfo] );
end; // end of K_CMDBGetMSSQLConnectionString

//*********************************************** K_CMDBGetConnectionString ***
// Get CMS DB Connection string
//
//     Parameters
// AConInfo - additional connection info
// Result - Returns CMS DB Connection string
//
function K_CMDBGetConnectionString(AConInfo: string = ''): string;
var
  WCS: string;
  DBF: string;
  DSN: string;
  Props: string;
  EInd, Ind, L, N1, N2: Integer;
//  WExtProp : string;
//  SL : TStringList;
label LExit;
begin
  if K_CMEDAMSSQL then
  begin
    Result := K_CMDBGetMSSQLConnectionString( '', AConInfo );
//    if TRUE then
//    if FALSE then
//      Result := K_CMDBGetMSSQLConnectionString( 'sa' )
//    else
//      Result := K_CMDBGetMSSQLConnectionString( 'dba' );
{
      Result := 'Provider=MSDASQL.1;Password=123456;Persist Security Info=True;User ID=sa;Data Source=CMS_MSSQL'
    else
      Result := 'Provider=MSDASQL.1;Password=123456;Persist Security Info=True;User ID=dba;Data Source=CMS_MSSQL';
}
    Exit;
  end;  

  Result := N_MemIniToString( 'CMSDB', 'ConnectionString', '' );
  if Result = '' then Exit;
{
  WExtProp := '';
  if K_CMSAppStartContext.CMASMode = K_cmamCOMFSAccess then
  begin
    WExtProp := N_MemIniToString('CMSDB', 'ExtProperties', '');
    SL := TStringList.Create;
    SL.Delimiter := ';';
    SL.DelimitedText := WExtProp;
    SL.Values['UID'] := 'cms_ent_view';
    SL.Values['PWD'] := 'cms';
    N_StringToMemIni('CMSDB', 'ExtProperties', SL.DelimitedText );
  end;
}

  DBF := N_MemIniToString( 'CMSDB', 'DBFile', '' );
  WCS := UpperCase(Result);
  if DBF <> '' then
  begin
    // Add DataBaseFile to Connection String from MemIni
    if (Pos('DSN=', WCS) = 0) and
       (Pos('DBF=', WCS) = 0) and
       (Pos('DATABASEFILE=', WCS) = 0) then
    begin
      // add DATABASEFILE to Connection String only if DSN and DBF are not specified
      if Pos('PROVIDER=MSDASQL', WCS) <> 0 then
      begin
        EInd := Length('EXTENDED PROPERTIES="');
        Ind := Pos('EXTENDED PROPERTIES=', WCS);
        EInd := Ind + EInd;
        // Result := Copy( Result, 1, EInd - 1 ) + 'DATABASEFILE=' + DBF + ';' +
        // Copy( Result, EInd, Length(Result) );
        Result := Copy(Result, 1, EInd - 1) + 'DBF=' + DBF + ';' +
                  Copy(Result, EInd, Length(Result));
      end // if Pos('PROVIDER=MSDASQL', WCS) <> 0 then
      else if Pos('PROVIDER=ASAPROV', WCS) <> 0 then
        Result := Result + ';dbf=' + DBF;

      Result := K_StringMListReplace(Result, K_AppFileGPathsList,
        K_ummRemoveMacro);
      WCS := UpperCase(Result);
    end; // if (Pos('DSN=', WCS) = 0) and ...
  end; // if DBF <> '' then

  Props := N_MemIniToString('CMSDB', 'ExtProperties', '');
  if Props <> '' then
  begin // Set Extended Properties from MemIni
    Ind := Pos('EXTENDED PROPERTIES="', WCS);
    if Ind = 0 then // Add Extended Properties
      Result := Result + ';Extended Properties="' + Props + '"'
    else
    begin           // Replace Extended Properties
      Ind := Ind + Length('EXTENDED PROPERTIES="');
      EInd := PosEx('"', WCS, Ind);
      if EInd <> 0 then
        Result := Copy(Result, 1, Ind - 1) + Props + Copy(Result, EInd,
          Length(Result));
    end;
    WCS := UpperCase(Result);
  end; // if Props <> '' then


  if not K_CMVUIMode then //Ura
    AConInfo := AConInfo + K_CMDBGetSessionID()
  else
    AConInfo := AConInfo + '$' + IntToStr(-Abs(StrToIntDef(K_CMVUIURLList.Values['UserID'],0)));   ////Igor+Ura
  if AConInfo <> '' then
  begin // Add Con='' Info to extended properties
    // Add Session ID and RegCode to Connection String EXTENDED PROPERTIES
    Ind := Pos('EXTENDED PROPERTIES="', WCS);
    if Ind = 0 then
      Result := Result + ';Extended Properties="Con=' + AConInfo + '"'
    else
    begin
      EInd := PosEx('"', WCS, Ind + Length('EXTENDED PROPERTIES="'));
      if EInd = 0 then
        goto LExit;
      Result := Copy(Result, 1, EInd - 1) + ';Con=' + AConInfo + Copy(Result,
        EInd, Length(Result));
    end;
  end; // if AConInfo <> '' then

  DSN := N_MemIniToString('CMSDB', 'DSN', '');
  if DSN <> '' then
  begin // Replace ConnectionString DSN from MemIni
    WCS := UpperCase(Result);
    Ind := Pos('DSN=', WCS) + Length('DSN=');
    if Ind > Length('DSN=') then
    begin // Replace only if DSN is specified in ConnectionString
      EInd := Ind;
      L := Length( WCS );
      while (EInd <= L) and (WCS[EInd] <> ';')  and (WCS[EInd] <> '"') do Inc( EInd );

      N1 := Ind - 1;
      Props := '';
      if N1 > 0 then
        Props := Copy(Result, 1, Ind - 1 );
      N2 := L - EInd + 1;
      DBF := '';
      if N2 > 0 then
        DBF := Copy(Result, EInd, N2 + 1 );
      Result := Props + DSN + DBF;
    end; // if Ind > Length('DSN=') then
  end; // if DSN <> '' then

LExit:
{
  if WExtProp <> '' then
    N_StringToMemIni('CMSDB', 'ExtProperties', WExtProp );
}
end; // end of K_CMDBGetConnectionString

//********************************************************* K_CMSlidesImportFromFiles ***
// Import Slides from files
//
//     Parameters
// AImpFilesList - strings with files names to import
// ABasePath     - base path for file names in AImpFilesList
// ASourceDescr  - source description - common to all imported slides:
//                 if '' then imported file name is used as description,
//                 if starts with '##' then other text is format - text pattern
//                 where imported file name should be included ('##imported from %s')
// ASkipedFilesList - will be filled with files which were skiped by some reasons
// ABeforeImportProc - before impot file procedure (needed to show import progress)
// Result - Returns number of imported slides
//
// If ASourceDescr will be '##imported from %s' and slide will be imported from file A1.png
// then slide description will be 'imported from A1.png'.
//
function K_CMSlidesImportFromFilesList( AImpFilesList: TStrings;
                                        const ABasePath : string = '';
                                        const ASourceDescr : string = '';
                                        ASkipedFilesList : TStrings = nil;
                                        ABeforeImportProc : TN_OneStrProcObj = nil ): Integer;
var
  DIBObj: TN_DIBObj;
//  GPCWrapper: TK_GPDIBCodecsWrapper;
//  GPStatus: TStatus;
  i, j, n, ICount: Integer;
  FSlide: TN_UDCMSlide;
  CurFile, CurFrame, CurFExt: string;
//  ISlidesArray: TN_UDCMSArray;
  FDT: TDateTime;
  VideoFExtList: TStringList;
  VideoFileFlag: Boolean;
  SavedCursor: TCursor;
  Stream: TFileStream;
  DIBStoreFormat, SlideDIBStoreFormat: TN_UDDIBDataFormat;
  CheckVideoFolderAccess : Boolean;
  SkipVideoImport : Boolean;
  SlideStream: TStream;
  DIBObjTmp: TN_DIBObj;
  RIRCode : TK_RIResult;
  OutOfMemoryFlag : Boolean;
  RIRCloseNeeded : Boolean;

Label  ImageFileError, OutOfMemoryLastAttempt, OutOfMemoryDlg,
       ContinueImport1, ContinueImport2, ContinueImport3, CreateSlide;

  procedure InitSLideFields( ADICOMFlag: Boolean = false);
  begin
    CurFrame := CurFile;
    if n > 0 then
      CurFrame := CurFile + '[' + IntToStr(i) + ']';
    Inc(Result);
    FSlide.ObjInfo := 'Imported from ' + CurFrame;
    if VideoFileFlag then
      FSlide.ObjAliase := 'Video ' // for Show in Thumbnails Frame in Setting Attributes Form
    else
      FSlide.ObjAliase := 'Image '; // for Show in Thumbnails Frame in Setting Attributes Form
    FSlide.ObjAliase := FSlide.ObjAliase + IntToStr(Result); // for Show in Thumbnails Frame in Setting Attributes Form

    CurFrame := ExtractFileName(CurFrame);
    with FSlide.P()^ do
    begin
      if not ADICOMFlag or (CMSSourceDescr = '') then
      begin
        if ASourceDescr <> '' then
        begin
          if (ASourceDescr[1] = '#') and (ASourceDescr[2] = '#') then
            CMSSourceDescr := format( @ASourceDescr[3], [CurFrame] )
          else
            CMSSourceDescr := ASourceDescr;
        end
        else
          CMSSourceDescr := CurFrame;
      end;
      if not ADICOMFlag then
      begin
        if K_CMVUIMode then CMSDTTaken := CMSDTCreated else CMSDTTaken := FDT; //!!!Ura 27.08.20
      end;
      // if not VideoFileFlag then
      // CMSDB.PixPermm := DIBObj.DIBInfo.bmi.biXPelsPerMeter /1000;
    end;
    K_CMEDAccess.EDAAddSlide(FSlide);
  end; // procedure InitSLideFields

  function AddFileNameToSkiped() : Boolean;
  begin
    Result := ASkipedFilesList <> nil;
    if not Result then Exit;
    ASkipedFilesList.Add(CurFile);
  end; // procedure AddFileNameToSkiped

  function GetDIBDumpStr( ARI : TK_RasterImage ) : string;
  begin
    Result := format(
            'From %s RImage %dx%d create %dx%d PixBits=%d, R=%d',
                       [ARI.ClassName,
                        ARI.RILastImageSize.X, ARI.RILastImageSize.Y,
                        DIBObj.DIBSize.X, DIBObj.DIBSize.Y, DIBObj.DIBInfo.bmi.biBitCount,
                        ARI.RIGetLastNativeErrorCode()] );
  end;

begin
  Result := 0;

  if AImpFilesList = nil then Exit;

  K_GetFreeSpaceProfile();
  N_Dump1Str( '!!!Before Import Files Loop: ' + K_GetFreeSpaceProfileStr('; ', '%.0n') );

  ICount := K_CMDEMOAddConstraint( AImpFilesList.Count );
  if ICount = 0 then Exit;
  VideoFExtList := TStringList.Create;
  VideoFExtList.CaseSensitive := false;
  VideoFExtList.CommaText := N_MemIniToString( 'CMS_Main', 'VideoFileExts', '.avi');

  with K_CMEDAccess do
  begin

    SavedCursor := Screen.Cursor;
    Screen.Cursor := crHourglass;

//    GPCWrapper := TK_GPDIBCodecsWrapper.Create;
    SkipVideoImport := FALSE;
    CheckVideoFolderAccess := EDAVideoFolderAccessPrevCheck();

    OutOfMemoryFlag := FALSE;
//    K_CMSCheckMemConstraints( nil );
    for i := 0 to ICount - 1 do
    begin
      // Selected files Loop

      if ASkipedFilesList = nil then
        N_CM_MainForm.CMMFShowString( format( K_CML1Form.LLLFileImport5.Caption,
//      'Importing media %d object(s) of % d ... Please wait',
                               [i + 1, ICount] ) );

      CurFile := AImpFilesList[i];
      if ABasePath <> '' then
        CurFile := ABasePath + CurFile;
      if Assigned(ABeforeImportProc) then ABeforeImportProc( CurFile );

      N_Dump2Str( 'Importing file "' + CurFile + '"' );

      if not FileExists(CurFile) then
      begin
        if not AddFileNameToSkiped() then
          K_CMShowMessageDlg1( format( K_CML1Form.LLLFileImport1.Caption,
//           'File %s is not found',
             [CurFile] ), mtWarning );
        Continue;
      end;
      FDT := K_GetFileAge( CurFile );


      VideoFileFlag := VideoFExtList.IndexOf(ExtractFileExt(CurFile)) >= 0;
      if VideoFileFlag then
      begin // Video File
        if CheckVideoFolderAccess then
        begin
       // Check Video Folder Access
          CheckVideoFolderAccess := FALSE; // Check only for 1st Video File
//            SkipVideoImport := not EDACheckVideoFolderAccessDlg();
          SkipVideoImport := 0 <> EDACheckAllFilesAccess( FALSE, TRUE, FALSE,
                               K_CML1Form.LLLFileAccessCheck9.Caption
//                               ' Press OK to stop Video data processing.'
                                );
        end;
        if SkipVideoImport then Continue;

        // Video Files
        FSlide := K_CMSlideCreateFromMediaFile(CurFile);
        if FSlide = nil then
        begin
          if not AddFileNameToSkiped() then
            K_CMShowMessageDlg1( format( 'File %s has some problems to import',
                       [CurFile] ), mtWarning );
          Continue;
        end;
        n := 0;
        InitSLideFields();
      end   // end of Video File
      else
      begin // Simple Image File
        if K_CMDICOMNewFlag then
        begin
          CurFExt := ExtractFileExt(CurFile);
          if SameText(CurFExt, '.dcm') or
             SameText(CurFExt, '.dic') or
             SameText(CurFExt, '') then
          begin // DICOM file processing
            DIBObj := nil;
            if 0 = K_CMDCMImportDIB( CurFile, DIBOBj ) then
            begin
              FSlide := K_CMSlideCreateFromDIBObj( DIBObj, nil, nil,
                                               K_CMEDAccess.SlidesDIBFormat );
              InitSLideFields();
              Continue;
            end;
            N_Dump1Str( '!!!Import Files : New DICOM error >> Try Old lib >>' + CurFile );
          end; // end of DICOM
        end; // if K_CMDICOMNewFlag then


//K_GetFreeSpaceProfile();
//N_Dump1Str( '!!!Before Create Stream Profile: ' + K_GetFreeSpaceProfileStr('; ', '%.0n') );
        Stream := TFileStream.Create(CurFile, fmOpenRead + fmShareDenyNone);
        // Import by Raster Image
        DIBStoreFormat := uddfNotDef;
        RIRCloseNeeded := FALSE;

//K_GetFreeSpaceProfile();
//N_Dump1Str( '!!!Before Open Stream Profile: ' + K_GetFreeSpaceProfileStr('; ', '%.0n') );
        RIRCODE := K_RIObj.RIOpenStream( Stream );
//        RIRCODE := K_RIObj.RIOpenFile( CurFile );
//K_GetFreeSpaceProfile();
//N_Dump1Str( '!!!After Open Stream Profile: ' + K_GetFreeSpaceProfileStr('; ', '%.0n') );
        if RIRCODE <> rirOK then
        begin
          if K_RIObj is TK_RIGDIP then
          begin
            if K_RIObj.RIGetLastNativeErrorCode() = Ord(Win32Error) then
            begin // Needed to skip exception while loading from PNG in Vista
              N_Dump1Str( 'GDI+ stream error, try from ' + ExtractFileName(CurFile) );
              RIRCODE := K_RIObj.RIOpenFile( CurFile );
              if rirOK <> RIRCODE then
                goto ImageFileError;
            end
            else
              goto ImageFileError;
          end   // if K_RIObj is TK_RIGDIP
          else
          begin // if not TK_RIGDIP (TK_URI or TN_RIImLib)
            if RIRCODE = rirOutOfMemory then
            begin
              N_Dump1Str('ImportFromFilesList Out Of Memory in RIOpenStream 1' );
              K_CMSCheckMemConstraints( nil, TRUE ); // try to free all
              RIRCODE := K_RIObj.RIOpenStream( Stream );
              if RIRCODE = rirOK then goto ContinueImport1;
              N_Dump1Str( format('ImportFromFilesList Out Of Memory in RIOpenStream 2, MaxFree=%d',
                          [K_FreeSpaceSearchMax( 1000000000, K_FreeSpaceBufCheck )] ) );
              j := 0;
              goto OutOfMemoryDlg;
            end
            else
              N_Dump1Str( Format(
              'Err RIOpenStream %s, R=%d',
                       [K_RIObj.ClassName, K_RIObj.RIGetLastNativeErrorCode()] ));

ImageFileError:
            if not AddFileNameToSkiped() then
              K_CMShowMessageDlg1( format( K_CML1Form.LLLFileImport3.Caption,
//                       'File %s has invalid format',
                         [CurFile] ), mtWarning );
            Stream.Free;
//            if RIRCloseNeeded then
            K_RIObj.RIClose();
            Continue;
          end; // if not TK_RIGDIP (TK_URI or TN_RIImLib)
        end; // if RIRCODE <> rirOK then // RIOpenStream Error

ContinueImport1:
        n := K_RIObj.RIGetImageCount() - 1;

        SlideStream := Stream;
        if n > 0 then
          SlideStream := nil // Slide stream shouldn't be used in multi frame file
        else
          RIRCloseNeeded := TRUE;

        for j := 0 to n do
        begin
          // File Frames Loop

//K_GetFreeSpaceProfile();
//N_Dump1Str( '!!!Before GetDIB Profile: ' + K_GetFreeSpaceProfileStr('; ', '%.0n') );
          DIBObj := nil;
          K_RIObj.RIMaxPixelsCount := K_CMImgMaxPixelsSize;
          RIRCODE := K_RIObj.RIGetDIB( j, DIBObj );
          K_RIObj.RIMaxPixelsCount := 0;
//K_GetFreeSpaceProfile();
//N_Dump1Str( '!!!After GetDIB 1 Profile: ' + K_GetFreeSpaceProfileStr('; ', '%.0n') );

          if RIRCODE <> rirOK then
          begin
            FreeAndNil(DIBObj);

            N_Dump1Str( Format(
              'Err %s RImage %dx%d, R=%d',
                       [K_RIObj.ClassName,
                        K_RIObj.RILastImageSize.X, K_RIObj.RILastImageSize.Y,
                        K_RIObj.RIGetLastNativeErrorCode()] ));
            if RIRCODE = rirOutOfMemory then
            begin
              N_Dump1Str('ImportFromFilesList Out Of Memory in RIGetDIB 1' );
              // Free All Memory and Try again
              K_CMSCheckMemConstraints( nil, TRUE ); // try to free all
//K_GetFreeSpaceProfile();
//N_Dump1Str( '!!!After CheckMemConstraints Profile: ' + K_GetFreeSpaceProfileStr('; ', '%.0n') );
              K_RIObj.RIMaxPixelsCount := K_CMImgMaxPixelsSize;
              RIRCODE := K_RIObj.RIGetDIB( j, DIBObj );
              K_RIObj.RIMaxPixelsCount := 0;
              if RIRCODE = rirOK then goto ContinueImport2;
//K_GetFreeSpaceProfile();
//N_Dump1Str( '!!!After RIGetDIB 2 Profile: ' + K_GetFreeSpaceProfileStr('; ', '%.0n') );
              N_Dump1Str( format('ImportFromFilesList Out Of Memory in RIGetDIB 2, MaxFree=%d',
                          [K_FreeSpaceSearchMax( 1000000000, K_FreeSpaceBufCheck )] ) );
OutOfMemoryLastAttempt:
              if (n = 0) and
                 (K_RIObj is TK_URI) and (TK_URI(K_RIObj).URICur is TN_RIImLib) then
                with TK_URI(K_RIObj) do
                begin // Try GDI+
                  RIClose();
                  RIRCODE := URIAux.RIOpenStream( Stream );
                  if RIRCODE = rirOK then
                  begin
                    URIAux.RIMaxPixelsCount := K_CMImgMaxPixelsSize;
                    RIRCODE := URIAux.RIGetDIB( 0, DIBObj );
                    URIAux.RIMaxPixelsCount := 0;
                    if RIRCODE = rirOK then
                    begin
                      N_Dump1Str( GetDIBDumpStr( URIAux ) );
                      URIAux.RIClose();
                      goto ContinueImport3;
                    end // if RIGetDIB = rirOK then
                  end // if OpenStrem = rirOK then
                  else
                    N_Dump1Str( 'TK_RIGDIP OpenStream error' );

                  N_Dump1Str( format( 'Err RImage TK_RIGDIP R=%d',
                             [URIAux.RIGetLastNativeErrorCode()] ));
                  URIAux.RIClose();
                end; // with TK_URI(K_RIObj) do // Try GDI+

OutOfMemoryDlg:
              if ASkipedFilesList = nil then
                K_CMShowMessageDlg( K_CML1Form.LLLMemory6.Caption,
  //           There is not enough memory to import the object(s).
  // Please close the open image(s) and repeat the import or restart Media Suite.
                                     mtWarning );
              OutOfMemoryFlag := TRUE;
              K_CMOutOfMemoryFlag := TRUE;
//              if RIRCloseNeeded then
//                K_RIObj.RIClose();

              break;
            end // if RIRCODE = rirOutOfMemory then
            else
              goto ImageFileError;

          end; // if RIRCODE <> rirOK then

ContinueImport2: //*****
          if RIRCloseNeeded then
            K_RIObj.RIClose();
          N_Dump1Str( GetDIBDumpStr( K_RIObj ) );
{ This dump is mooved to GetDIBDumpStr
          N_Dump1Str( Format(
            'From %s RImage %dx%d create %dx%d PixBits=%d, R=%d',
                       [K_RIObj.ClassName,
                        K_RIObj.RILastImageSize.X, K_RIObj.RILastImageSize.Y,
                        DIBObj.DIBSize.X, DIBObj.DIBSize.Y, DIBObj.DIBInfo.bmi.biBitCount,
                        K_RIObj.RIGetLastNativeErrorCode()] ));
}
ContinueImport3: //*****
          SlideDIBStoreFormat := DIBStoreFormat;
          if (K_RIObj.RILastImageSize.X <> DIBObj.DIBSize.X) or
             (K_RIObj.RILastImageSize.Y <> DIBObj.DIBSize.Y) then
          begin
          // DIBObj was resampled down by K_RIObj
            SlideStream := nil; // Needed to Skip Image Initial Data Save
            SlideDIBStoreFormat := uddfJPEG; // Set Initial Image Data Save Format - JPEG
          end
          else
          begin
            CurFExt := ExtractFileExt(CurFile);
            if SameText(CurFExt, '.bmp') or
               SameText(CurFExt, '.dcm') or
               SameText(CurFExt, '.dic') or
               SameText(CurFExt, '') then
            begin
              SlideStream := nil; // Needed to Skip Image Initial Data Save
              SlideDIBStoreFormat := K_CMEDAccess.SlidesDIBFormat; // Set Default Initial Image Data Save Format
            end;
          end;

          if (SlideStream = nil) and (n = 0) then
          // Free Memory occupied by Stream - it is not needed now
            FreeAndNil( Stream );

          if SlideStream <> nil then
            SlideStream.Seek(0, soFromBeginning);

          N_s := ChangeFileExt( ExtractFileName( CurFile ), '' );

          if LeftStr( N_s, 2 ) = '!-' then // create new test DIBObj (cur DIBObj is not used)
          begin
            DIBObj.Free;
            DIBObj := N_CreateTestDIB( MidStr( N_s, 3, 100 ) );
            FDT := Now(); // Set Date Taken (it can be seen in under Thumbnails)
            SlideStream := nil; // Needed to Skip Image Initial Data Save
            SlideDIBStoreFormat := K_CMEDAccess.SlidesDIBFormat; // Set Default Initial Image Data Save Format
          end;

          if LeftStr( N_s, 2 ) = '!%' then // create new test DIBObj based upon current DIBObj
          begin
            DIBObjTmp := N_CreateTestDIBFromDIB( MidStr( N_s, 3, 100 ), DIBObj );
            DIBObj.Free;
            DIBObj := DIBObjTmp;
            FDT := Now(); // Set Date Taken (it can be seen in under Thumbnails)
            SlideStream := nil; // Needed to Skip Image Initial Data Save
            SlideDIBStoreFormat := K_CMEDAccess.SlidesDIBFormat; // Set Default Initial Image Data Save Format
          end;

          if not K_CMSCheckMemForSlide1( nil, 0, 1, DIBObj.DIBSize.X, DIBObj.DIBSize.Y ) then
          begin
            N_Dump2Str('ImportFromFilesList Out Of Memory after RIGetDIB' );
            goto OutOfMemoryDlg;
          end;

          FSlide := K_CMSlideCreateFromDIBObj( DIBObj, nil, SlideStream,
                                               SlideDIBStoreFormat );

          InitSLideFields();
        end; // end of File Frames Loop // for j := 0 to n do
        K_RIObj.RIClose();

        Stream.Free;
        if OutOfMemoryFlag then break;
      end; // end of simple image file

    end; // for i := 0 to ICount - 1 do // end Selected files Loop
    K_GetFreeSpaceProfile();
    N_Dump1Str( '!!!After Import Files Loop: ' + K_GetFreeSpaceProfileStr('; ', '%.0n') );
//    GPCWrapper.Free;
//    K_RIObj.RIClear();
//    K_RIObj.RIClose();
    Screen.Cursor := SavedCursor;
    if ASkipedFilesList = nil then
      N_CM_MainForm.CMMFShowString('');

{ !!! 2015-07-06 this code is moved out of K_CMSlidesImportFromFilesList
  to K_CMSlidesImportAndProcessFromFilesList
    // Set Slides Attributes
    if Result > 0 then
      Result := N_CM_MainForm.CMMSetSlidesAttrs( Result, nil,
                             K_CML1Form.LLLCaptHandler10.Caption,
//        'Process Output from Import',
                             [] );
}
  end;

  VideoFExtList.Free;

end; // end of K_CMSlidesImportFromFilesList

//************************************************ K_CMImportFilesSelectDlg ***
// Import Image files select DLG
//
//     Parameters
// AFilesList - TSrings for selected files
// AFilter - filter for open files dialog
// ADialogFlag - bit0= 0 - open Picture Files Dialog, 1 - open Any Files Dialog
//               bit1= 0 - multi select, 1 - skip multi select
// Result - Returns number of imported slides
//
procedure K_CMImportFilesSelectDlg( AFilesList : TStrings; const AFilter : string = '';
                                    ADialogFlag : Integer = 0; ACaption : string = '' );
var
  OpenDialog: TOpenDialog;

label LExit;

begin
  if (ADialogFlag and 1) = 0 then
    OpenDialog := TOpenPictureDialog.Create(Application)
  else
    OpenDialog := TOpenDialog.Create(Application);
  // with OpenDialog, K_CMEDAccess do begin
  with OpenDialog do
  begin

    InitialDir := K_ExpandFileName(N_MemIniToString( 'CMS_Main',
                                                     'LastImportDir', '' ) );
    if not DirectoryExists( InitialDir ) then
      InitialDir := 'c:';
    if AFilter <> '' then
      Filter := AFilter
    else
    begin
      Filter := N_MemIniToString( 'CMS_Main', 'ImportFilter', 'All files (*.*)|*.*' );
      FilterIndex := 1;
    end;
    FileName := '';
    Options := Options + [ofEnableSizing];
    if (ADialogFlag and 2) = 0 then
      Options := Options + [ofAllowMultiSelect];

    if ACaption <> '' then
      Title := ACaption
    else
      Title := 'Import';

    if Execute and (Files.Count > 0) then
      AFilesList.Assign(Files);

    OpenDialog.Free;
  end;

  N_CM_MainForm.CMMCurFMainForm.Refresh(); // To Clear FileOpen Dialog Window
  if AFilesList.Count > 0 then
    N_StringToMemIni( 'CMS_Main', 'LastImportDir', ExtractFilePath(AFilesList[0]) );
end; // end of K_CMImportFilesSelectDlg


//*********************************************** K_CMImportFolderSelectDlg ***
// Import Folder select DLG
//
//     Parameters
// AFolder - on input start folder to select? on output resulting folder
// Result - Returns TRUE if folder was selected
//
function K_CMImportFolderSelectDlg( out AFolder: string; const ACaption : string = '' ) : Boolean;
var
  APath : string;
  APath1 : string;
begin
  APath := K_ExpandFileName(N_MemIniToString( 'CMS_Main',
                                                     'LastImportDir', '' ) );
  if APath <> '' then
  begin
    while not SysUtils.DirectoryExists(APath) do
    begin
      APath1 := APath;
      APath := ExtractFilePath( ExcludeTrailingPathDelimiter(APath) );
      if APath1 = APath then Break;
    end;
  end;

  Result := K_SelectFolder( ACaption, '', APath );
//  Result := K_SelectFolder( SelectCaption, '', APath );
  if not Result then Exit;
  AFolder := APath;
  N_StringToMemIni( 'CMS_Main', 'LastImportDir', IncludeTrailingPathDelimiter(APath) );

end; // end of K_CMImportFolderSelectDlg

//********************************* K_CMSlidesImportAndProcessFromFilesList ***
// Import and process Slides from files list
//
//     Parameters
// AFilesList : TStrings
// Result - Returns number of imported slides
//
function K_CMSlidesImportAndProcessFromFilesList( AFilesList : TStrings ): Integer;
begin
  Result := 0;
  if AFilesList.Count = 0 then Exit;
    Result := K_CMSlidesImportFromFilesList( AFilesList );
    if Result > 0 then
      Result := N_CM_MainForm.CMMSetSlidesAttrs( Result, nil,
                             K_CML1Form.LLLCaptHandler10.Caption,
//        'Process Output from Import',
                             [] );
end; // end of K_CMSlidesImportFromFiles

//********************************************************* K_CMSlidesImportFromFiles ***
// Import Slides from files
//
//     Parameters
// Result - Returns number of imported slides
//
function K_CMSlidesImportFromFiles( ): Integer;
var
//OpenDialog: TOpenPictureDialog;
//WFName: string;
  ImpFiles: TStringList;

label LExit;

begin
  ImpFiles := TStringList.Create;
  K_CMImportFilesSelectDlg( ImpFiles );
  Result := K_CMSlidesImportAndProcessFromFilesList( ImpFiles );
  ImpFiles.Free;
end; // end of K_CMSlidesImportFromFiles

function K_CMSIsDICOMSlide(const AFileName: string): Boolean;
var
  DI: TK_HDCMINST;
  InstanceResult: integer;

  WUInt2: Word;
  WBuf: WideString;
  sz: Integer;
  IsNil: Integer;
const
  BufLeng = 1024;
begin
  Result := False;

  if not FileExists(AFileName) then
    Exit;

  InstanceResult := K_CMDCMCreateIntance(AFileName, DI);

  try
    Result := (InstanceResult = 0); //then
//      Exit;
//
//    with K_DCMGLibW do
//    begin
//      SetLength(WBuf, BufLeng);
//      sz := BufLeng;
//
//      if DLGetValueString(DI, K_CMDCMTSeriesInstanceUid, @WBuf[1], @sz, @isNil) = 0 then
//        Result := not N_WideToString(Copy(WBuf, 1, sz )).Trim.IsEmpty;
//    end;
  finally
    K_DCMGLibW.DLDeleteDcmObject(DI);
  end;
end;

function K_CMSlidesImportDICOM(const AFileName, AInitialDir: string): Boolean;
var
  DI: TK_HDCMINST;
  InstanceResult: integer;

  WUInt2: Word;
  WBuf: WideString;
  sz: Integer;
  IsNil: Integer;

  PixBufLength : Integer;
  IWidth, IHeight: Word;
  IPixFmt: TPixelFormat;
  IExPixFmt: TN_ExPixFmt;
  INumBits: Word;

  IDIB : TN_DIBObj;

  PixBuffer : TN_BArray;

  DIBAtrsRes : Integer;

  UDCMSlide : TN_UDCMSlide;

  FileList: TStringDynArray;

  WinWid, WinCen,
  IntenIntercept, IntenScale: integer;

  Stream: TMemoryStream;
  RIRCode : TK_RIResult;
const
  BufLeng = 1024;

//  procedure Scale16to8bit(lWinCen, lWinWid: integer);
//  // Given a 16-bit input, this generates an 8-bit output, based on user's contrast/brightness settings
//  // Uses integer multiplication for fast computations on old CPUs
//    function RescaleToBuffer(lIn: integer): integer;
//    // converts Hounsfield units to Stored image intensity using Slope and Intercept
//    // Output := (HounsfieldUnit / Slope)-zero_intercpet
//    begin
//      result := round((lIn - IntenIntercept) / IntenScale);
//      // ChayMarch2003
//      // result := round((lIn/gDICOMdata.IntenScale)- gDICOMdata.intenIntercept);
//    end;
//  var
//    lStartTime, lEndTime: DWord;
//    lRngi, lMinVal, lMaxVal, lInt, lInc, lRange, i, lScaleShl10, lSz, min16,
//      max16, lCen, lWid: integer;
//    //lBuff: TN_PBArray;
//    //lBuffx: TN_PBArray;
//  begin
//  {$R-}
//    // TDICOMViewer(Owner).StatusBar.Panels[3].text := 'ax'+inttostr(random(888));
//
//    if PixBuffer = nil then
//      exit;
//
//    // showmessage(floattostr(gDICOMdata.Intenscale));
//    // gDICOMdata.Intenscale := 1;
//
//    lCen := RescaleToBuffer(lWinCen);
//    // showmessage(inttostr(lWinCen));
//    lWid := abs(trunc((lWinWid / IntenScale) / 2));
//    min16 := lCen - lWid;
//    max16 := lCen + lWid;
//    lSz := (IWidth * IHeight);
//    //getmem(lBuffx, lSz { width * height } );
//    lSz := lSz - 1;
//    lRange := (max16 - min16);
//    // TDICOMViewer(Owner).StatusBar.Panels[0].text := inttostr(value)+'tx'+inttostr(random(888));
//    lStartTime := GetTickCount;
//    // value = range
//    if (lRange = 0) or (trunc((1024 / lRange) * 255) = 0) then
//    begin
//      if lWinWid > 1024 then
//      begin
//        for i := 0 to lSz do
//          PixBuffer[i] := 128;
//
//      end
//      else
//      begin
//        for i := 0 to lSz do
//          if PixBuffer[i] < lWinCen then
//            PixBuffer[i] := 0
//          else
//            PixBuffer[i] := 255;
//      end;
//    end
//    else
//    begin
//      lScaleShl10 := trunc((1024 / lRange) * 255);
//      // value = range,Scale = 255/range
//      (*
//        if lSz > 131070  then begin //large image: make a look up table  x2 speedup
//        //Using this code speeds up rescaling slightly, but not well tested...
//        lMinVal := RescaleToBuffer(gImgMin)-1; //gRaw16Min;//
//        lMaxVal := RescaleToBuffer(gImgMax)+1; //gRaw16Max;//
//        lRngi := ROund(lMaxVal-lMinVal);
//        getmem(lBuff, lRngi+1);  //+1 if the only values are 0,1,2 the range is 2, but there are 3 values!
//        //max16 := max16-2;
//        for lInc := (lRngi) downto 0 do begin
//        lInt := lInc+lMinVal; //32 bit math fastest
//        if lInt < min16 then
//        lBuff[lInc] := 0 //0
//        else if lInt > max16 then
//        lBuff[lInc] := 255
//        else
//        lBuff[lInc] :=  (((lInt)-min16) * lScaleShl10)  shr 10;
//        end;
//        lInc := 1;
//        for i := 0 to lSz do
//        lbuffx[i] := lBuff[gBuff16[i]-lMinVal] ;
//        freemem(lBuff);
//        end else *) begin // if lSz -> use look up table for large images
//  {$R-}
//        for i := 0 to lSz do
//        begin
//          if PixBuffer[i] < min16 then
//            PixBuffer[i] := 0
//          else if PixBuffer[i] > max16 then
//            PixBuffer[i] := 255
//          else
//            PixBuffer[i] := (((PixBuffer[i]) - min16) * lScaleShl10) shr 10;
//          // NOTE: integer maths increases speed x7!
//          // lbuff[i] := (Trunc(255*((gBuff16[i])-min16) / (value)));
//        end;
//  {$R+}
//      end; // if lSz ,,large image  .. else ...
//    end; // lRange > 0
//    // self.caption :=('update(ms): '+inttostr(GetTickCount-lStartTime)); //70 ms
//    //SetDimension(g100pctImageHt, g100pctImageWid, 8, lBuffx, false);
//    //DICOMImageRefreshAndSize;
//    //freemem(lBuffx);
//  {$R+}
//  end;
begin
  Result := False;

  if not FileExists(AFileName) then
    Exit;

  N_LoadDIBFromFileByImLib(IDIB, AFileName);

  UDCMSlide := K_CMSlideCreateFromDIBObj(IDIB, nil, nil, uddfNotDef);  //K_CMSlideCreateForImg3DObject(True);
  K_CMSlideInitByCurContext(UDCMSlide);
  Include(UDCMSlide.P()^.CMSDB.SFlags, cmsfIsImg3DObj);
  Include(UDCMSlide.P()^.CMSDB.SFlags, cmsfDICOMStudy);

  if Assigned(UDCMSlide) then
  begin
    K_CMEDAccess.EDAAddSlide( UDCMSlide );

    if K_CMEDAccess.EDASaveSlidesArray(@UDCMSlide, 1) = K_edOK then
    begin
      if AInitialDir.IsEmpty then
        K_CopyFolderFiles(ExtractFilePath(AFileName), TK_CMEDDBAccess(K_CMEDAccess).EDAGetDICOMPath(UDCMSlide))
      else
        A_CopyAll(AInitialDir, TK_CMEDDBAccess(K_CMEDAccess).EDAGetDICOMPath(UDCMSlide));
    end;

    N_CM_MainForm.CMMFRebuildVisSlides();
    N_CM_MainForm.CMMFDisableActions( nil );
    N_CM_MainForm.CMMFSelectThumbBySlide(UDCMSlide);
    //FreeAndNil(IDIB);

  end;
  Result := True;
//  RIRCODE := K_RIObj.RIOpenFile(AFileName);
//
//  try
//    if RIRCode = rirOK then
//    begin
//      RIRCODE := K_RIObj.RIGetDIB( 0, IDIB );
//
//      if RIRCode = rirOK then
//      begin
//        UDCMSlide := K_CMSlideCreateFromDIBObj(IDIB, nil, nil, uddfNotDef);
//        UDCMSlide.P^.CMSDB.SFlags := [];
//
//        if Assigned(UDCMSlide) then
//        begin
//          K_CMEDAccess.EDAAddSlide( UDCMSlide );
//
//          if K_CMEDAccess.EDASaveSlidesArray(@UDCMSlide, 1) = K_edOK then
//          begin
//            if AInitialDir.IsEmpty then
//              K_CopyFolderFiles(ExtractFilePath(AFileName), TK_CMEDDBAccess(K_CMEDAccess).EDAGetDICOMPath(UDCMSlide))
//            else
//              A_CopyAll(AInitialDir, TK_CMEDDBAccess(K_CMEDAccess).EDAGetDICOMPath(UDCMSlide));
//          end;
//
//          N_CM_MainForm.CMMFRebuildVisSlides();
//          N_CM_MainForm.CMMFDisableActions( nil );
//          N_CM_MainForm.CMMFSelectThumbBySlide(UDCMSlide);
//        end;
//      end;
//    end;
//  finally
//    //FreeAndNil(Stream);
//    FreeAndNil(IDIB);
//    K_RIObj.RIClose;
//    //Application.ProcessMessages;
//  end;

//  InstanceResult := K_CMDCMCreateIntance(AFileName, DI);
//
//  if InstanceResult <> 0 then
//    Exit;
//
//  with K_DCMGLibW do
//  begin
//    SetLength(WBuf, BufLeng);
//    sz := BufLeng;
//
//    //if DLGetValueString(DI, K_CMDCMTRescaleIntercept, @WBuf[1], @sz, @isNil) = 0 then
//    //  IntenIntercept := StrToIntDef(N_WideToString(Copy(WBuf, 1, sz )), 0);
//
//    //if DLGetValueString(DI, K_CMDCMTRescaleSlope, @WBuf[1], @sz, @isNil) = 0 then
//    //  IntenScale := StrToIntDef(N_WideToString(Copy(WBuf, 1, sz )), 0);
//
//    //if DLGetValueString(DI, K_CMDCMTWindowCenter, @WBuf[1], @sz, @isNil) = 0 then
//    //  WinCen := N_WideToString(Copy(WBuf, 1, sz )).ToInteger;
//
//    //if DLGetValueString(DI, K_CMDCMTWindowWidth, @WBuf[1], @sz, @isNil) = 0 then
//    //  WinWid := N_WideToString(Copy(WBuf, 1, sz )).ToInteger;
//
//    DIBAtrsRes := K_CMDGetDIBAttrs(DI, PixBufLength, IWidth, IHeight,
//                                   IPixFmt, IExPixFmt, INumBits, N_Dump2Str);
//
//    if DIBAtrsRes = 0 then
//    begin
//      SetLength( PixBuffer, PixBufLength);
//      WUInt2 := DLGetImageData( DI, @PixBuffer[0], PixBufLength);
//      if 0 <>	WUInt2 then
//        N_Dump1Str( 'K_CMDCMImortDIB >> wrong DLGetImageData RCode =' + IntToStr(WUInt2) )
//      else
//      begin
//        IDIB := TN_DIBObj.Create( IWidth, IHeight, IPixFmt, -1, IExPixFmt, INumBits );
//
//        //Scale16to8bit(7500, 2500);
//
//        N_DICOMPixToDIBPix( TN_BytesPtr(@PixBuffer[0]), IDIB );
//        N_CMSTridentDIBAdjust(IDIB);
//
////        UDCMSlide := K_CMSlideCreateFromDIBObj(IDIB, nil, nil, uddfNotDef);
////        //Exclude(UDCMSlide.P^.CMSDB.SFlags, cmsfGreyScale);
////        //Include(UDCMSlide.P^.CMSDB.SFlags, cmsfDICOMObj);
////        UDCMSlide.P^.CMSDB.SFlags := [];
////
////        if Assigned(UDCMSlide) then
////        begin
////          K_CMEDAccess.EDAAddSlide( UDCMSlide );
////
////          if K_CMEDAccess.EDASaveSlidesArray(@UDCMSlide, 1) = K_edOK then
////          begin
////            if AInitialDir.IsEmpty then
////              K_CopyFolderFiles(ExtractFilePath(AFileName), TK_CMEDDBAccess(K_CMEDAccess).EDAGetDICOMPath(UDCMSlide))
////            else
////              A_CopyAll(AInitialDir, TK_CMEDDBAccess(K_CMEDAccess).EDAGetDICOMPath(UDCMSlide));
////          end;
////
////          N_CM_MainForm.CMMFRebuildVisSlides();
////          N_CM_MainForm.CMMFDisableActions( nil );
////          N_CM_MainForm.CMMFSelectThumbBySlide(UDCMSlide);
//        end;
//      end;
//    end;
//
//
//  K_DCMGLibW.DLDeleteDcmObject(DI);
end;

//********************************************************* K_CMSlideWClipboardImport ***
// Import Slide from Windows Clipboard
//
//     Parameters
// Result - Returns TRUE if Image is imported from Clipboard
//
function K_CMSlideWClipboardImport : Boolean;
var
  FSlide: TN_UDCMSlide;
//  ISlidesArray: TN_UDCMSArray;
  SrcDIB: TN_DIBObj;
  PixFmt: Integer;
begin
  Result := FALSE;
  SrcDIB := TN_DIBObj.Create;
  if SrcDIB.LoadFromClipborad() <> 0 then begin
    SrcDIB.Free;
    Exit;
  end;

  PixFmt := (Ord(SrcDIB.DIBExPixFmt) shl 4) + Ord(SrcDIB.DIBPixFmt);
  N_Dump2Str(format('Internal Image created: %dx%d, PixFmt=%X(hex)',
      [SrcDIB.DIBSize.X, SrcDIB.DIBSize.Y, PixFmt]));

  FSlide := K_CMSlideCreateFromDIBObj(SrcDIB, nil);
  FSlide.ObjInfo := 'Imported from Clipboard';
  FSlide.ObjAliase := 'Image'; // for Show in Thumbnails Frame in Setting Attributes Form
  with FSlide.P()^ do
  begin
    CMSSourceDescr := K_CML1Form.LLLCaptHandler15.Caption; // 'Clipboard';
  end;
  K_CMEDAccess.EDAAddSlide(FSlide);

  // Såt Slides Attributes
  Result := 0 < N_CM_MainForm.CMMSetSlidesAttrs( 1, nil,
                           K_CML1Form.LLLCaptHandler11.Caption,
//    'Process Import from Clipboard',
                           [] );

{!!! N_CM_MainForm.CMMSetSlidesAttrs is used
  Result := 0 < K_CMSetSlidesAttrs( 1,
    K_CML1Form.LLLCaptHandler11.Caption,
//    'Process Import from Clipboard',
    FALSE );
}
end; // end of K_CMSlideWClipboardImport

//**************************************** K_CMPrepDICOMProfileSettingsDump ***
// Prepare DICOM Profile Settings Dump
//
//     Parameters
// APDCMAttrs   - pointer to profile DICOM settings
//
function K_CMPrepDICOMProfileSettingsDump( APDCMAttrs : TK_PCMDCMAttrs ) : string;
begin
  Result := '';
  if APDCMAttrs <> nil then
    Result := format( 'DCM=%s DCKV=%gkV DCET=%dms DCTC=%dmA',
              [APDCMAttrs.CMDCMModality,APDCMAttrs.CMDCMKVP,
              APDCMAttrs.CMDCMExpTime,APDCMAttrs.CMDCMTubeCur] );
end; // end of K_CMPrepDICOMProfileSettingsDump

//******************************************* K_CMDumpSlidesProfileSettings ***
// Dump Slides Profile Settings
//
//     Parameters
// AProfMTypeID - profile MediaType ID
// APDCMAttrs   - pointer to profile DICOM settings
//
procedure K_CMDumpSlidesProfileSettings( AProfMTypeID : Integer;
                                         APDCMAttrs : TK_PCMDCMAttrs );
begin
  N_Dump2Str( format( 'SlidesProfileSettings >> MTID=%d %s',
               [AProfMTypeID, K_CMPrepDICOMProfileSettingsDump(APDCMAttrs)] ) );
end; // end of K_CMDumpSlidesProfileSettings

//************************************************* K_CMScanSlidesSaveArray ***
// Save Scanned Slides Array
//
//     Parameters
// ASlidesArray - captured Slides array
// AProcDialogCapt - processing dialog caption
// AShowProcDialogFlag - show processing dialog flag
// AProfMTypeID        - profile MediaType ID
// AShowFormat     - show message format
// APDCMAttrs      - pointer to profile DICOM settings
//
procedure K_CMScanSlidesSaveArray( ASlidesArray : TN_UDCMSArray;
                                   AProcDialogCapt : string;
                                   AShowProcDialogFlag : Boolean;
                                   AProfMTypeID : Integer;
                                   AShowFormat : string;
                                   APDCMAttrs : TK_PCMDCMAttrs );
var
  i, NumCaptured: Integer;
begin

  NumCaptured := Length(ASlidesArray);
  if NumCaptured > 0 then
  begin
    K_CMDumpSlidesProfileSettings( AProfMTypeID, APDCMAttrs );

    Inc(N_CM_MainForm.CMMSkipDisableActionsCount);
    if AShowProcDialogFlag then
    // Set Slides Attributes
      NumCaptured := N_CM_MainForm.CMMSetSlidesAttrs( NumCaptured, APDCMAttrs,
                                    AProcDialogCapt,
                                    [K_ssafSkipProcessDate], AProfMTypeID )
    else
    begin
    // Save Capture Slides
      if APDCMAttrs <> nil then
        for i := 0 to NumCaptured - 1 do
           ASlidesArray[i].SetInitDCMAttrs( APDCMAttrs );
      K_CMEDAccess.EDASaveSlidesArray( @ASlidesArray[0], NumCaptured );
      i := Min( 4, NumCaptured );
      K_CMSMediaOpen( @ASlidesArray[0], i );
//      K_CMEDAccess.LockResCount := 0;
    end;
    Dec(N_CM_MainForm.CMMSkipDisableActionsCount);
    N_CM_MainForm.CMMFRebuildVisSlides();
    K_CMEDAccess.EDASetPatientSlidesUpdateFlag();
  end;

  N_CM_MainForm.CMMFShowStringByTimer( Format( AShowFormat,
//                             ' %d media object(s) acquired',
                                      [NumCaptured] ) );
end; // end of K_CMScanSlidesSaveArray

//****************************************************** K_CMScanSlidesSave ***
// Save Scanned Slides in Current Slides Set
//
//     Parameters
// ASlidesCount    - captured Slides count
// AProcDialogCapt - processing dialog caption
// AProfMTypeID    - profile MediaType ID
// AShowFormat     - show message format
// APDCMAttrs      - pointer to profile DICOM settings
//
procedure K_CMScanSlidesSave( ASlidesCount : Integer;
                              AProcDialogCapt : string;
                              AProfMTypeID : Integer;
                              AShowFormat : string;
                              APDCMAttrs : TK_PCMDCMAttrs );
begin
  if ASlidesCount > 0 then
  begin
    // Set Slides Attributes
    K_CMDumpSlidesProfileSettings( AProfMTypeID, APDCMAttrs );

    ASlidesCount := N_CM_MainForm.CMMSetSlidesAttrs( ASlidesCount,
                                    APDCMAttrs,
                                    AProcDialogCapt,
                                    [K_ssafSkipProcessDate], AProfMTypeID );
    if K_CMD4WAppFinState then Exit; // Application is already finished

    N_CM_MainForm.CMMFRebuildVisSlides();
  end;

  N_CM_MainForm.CMMFShowStringByTimer( Format( AShowFormat,
//                             ' %d media object(s) acquired',
                                      [ASlidesCount] ) );
end; // end of K_CMScanSlidesSave

//********************************************** K_CMScanSlidesSaveFromDIBArray ***
// Create Slides from DIBObjs array
//
//     Parameters
// APDevProfile - pointer to device profile record
// ADIBObjArr - array of DIBObj
// Result - Returns number of created slides
//
function K_CMScanSlidesSaveFromDIBArray( APDevProfile: TK_PCMTwainProfile;
                                         ADIBObjArr : TN_DIBObjArray ): Integer;
var
  DIBsCount : Integer;

begin
  DIBsCount := Length(ADIBObjArr);
  if DIBsCount > 0 then
    Result := K_CMScanSlidesSaveFromDIBArray( APDevProfile, @ADIBObjArr[0], DIBsCount )
  else
    Result := K_CMScanSlidesSaveFromDIBArray( APDevProfile, nil, 0 )
end; // end of K_CMScanSlidesSaveFromDIBArray

//********************************************** K_CMScanSlidesSaveFromDIBArray ***
// Create Slides from DIBObjs array
//
//     Parameters
// APDevProfile - pointer to device profile record
// APDIBObj  - pointer to first DIBObj in array
// ADIBCount - number of DIBs in array
// Result - Returns number of created slides
//
function K_CMScanSlidesSaveFromDIBArray( APDevProfile: TK_PCMTwainProfile;
                                         APDIBObj : TN_PDIBObj;
                                         ADIBCount : Integer ): Integer;
var
  i: Integer;
  FSlide: TN_UDCMSlide;
  CurDevName: string;
  ISlidesArray: TN_UDCMSArray;
  WPDIBObj : TN_PDIBObj;
begin
  Result := 0; // if CMS is already finished
  if not K_CMD4WAppFinState and (ADIBCount > 0) then
  begin
    Result := K_CMDEMOAddConstraint(ADIBCount);
    if (Result > 0)                      and
       (K_CMEDAccess is TK_CMEDDBAccess) and
       K_CMXrayCaptStreamLineMode then
      with TK_CMEDDBAccess(K_CMEDAccess) do
      begin
        // Check Images Folder
        if EDACheckFilesFolderAccess( SlidesImgRootFolder, SlidesImgRootFDA ) <> 0 then
        begin
          K_CMShowMessageDlg1( K_CML1Form.LLLCaptHandler1.Caption,
//                'The Images folder is not accessible. Capture is not possible because images cannot be saved.'#13#10 +
//                'Please check network connection, permission to access the Images folder and start Capture again.',
               mtWarning, [mbOK] );
        end;
      end;
  end; // if not K_CMD4WAppFinState then

  N_CM_MainForm.CMMCurFMainForm.Refresh();
  WPDIBObj := TN_PDIBObj(TN_BytesPtr(APDIBObj) + Result * SizeOf(TN_DIBObj));
  for i := Result to ADIBCount - 1 do // Free rejected DIBObjs
  begin
    WPDIBObj^.Free;
    Inc(WPDIBObj);
  end;

  if (ADIBCount = 0) or (Result = 0) then // skip creating Slides
  begin
    N_Dump2Str('No created Slides');
    K_CMEDAccess.EDAFinCapture();
    Exit;
  end;

//  CurDevName := APDevProfile.CMDPCaption + ' (TWAIN)';
  CurDevName := APDevProfile.CMDPCaption;
  SetLength(ISlidesArray, Result);

  N_Dump2Str(format('Start processing %d Images', [Result]));

  for i := 0 to Result - 1 do
  begin // along all (or only some) acquired Images
    FSlide := K_CMSlideCreateFromDIBObj( APDIBObj^,
                                         @APDevProfile.CMAutoImgProcAttrs );
//         @PCMTwainProfile.CMAutoImgProcAttrs );
    Inc(APDIBObj);
    ISlidesArray[Result - 1 - i] := FSlide;
    FSlide.ObjInfo := 'Captured from ' + CurDevName;
    FSlide.ObjAliase := 'Scan ' + IntToStr(i + 1); // for Show in Thumbnails Frame in Setting Attributes Form

    FSlide.SetAutoCalibrated();
    with FSlide, P()^ do
    begin
      CMSSourceDescr := CurDevName;
      CMSMediaType := APDevProfile.CMDPMTypeID;
      SetInitDCMAttrs( TK_PCMDCMAttrs(@APDevProfile^.CMDPDModality) );
    end;

    K_CMEDAccess.EDAAddSlide(FSlide);
  end; // for i := 0 to Result - 1 do begin // along all (or only some) acquired Images

  if K_CMD4WAppFinState then Exit;

  if K_CMEDAccess is TK_CMEDCSAccess then
  // CMScan captute
    K_CMEDAccess.EDAFinCapture()
  else
    K_CMScanSlidesSaveArray( ISlidesArray,
                           K_CML1Form.LLLCaptHandler12.Caption,
                           not K_CMXrayCaptStreamLineMode,
                           APDevProfile.CMDPMTypeID,
                           K_CML1Form.LLLCaptHandler14.Caption,
                           TK_PCMDCMAttrs(@APDevProfile.CMDPDModality) );
end; // end of K_CMScanSlidesSaveFromDIBArray

//************************************************** K_CMSlidesSaveScanned3 ***
// Save Slides Scanned in Not Modal Mode
//
//     Parameters
// APDevProfile - pointer to device profile record
// ASlidesArray - captured Slides array
// ASkipProfileAttrs - skip profile attrs flag if TRUE
//
procedure K_CMSlidesSaveScanned3( APDevProfile: TK_PCMDeviceProfile;
                                  ASlidesArray : TN_UDCMSArray;
                                  ASkipProfileAttrs : Boolean = FALSE );
var
  NumCaptured: Integer;
  PCMDCMAttrs : TK_PCMDCMAttrs;
begin
  NumCaptured := Length(ASlidesArray);
  N_Dump1Str( format( 'Start K_CMSlidesSaveScanned3 for %d slides from %s',
                      [NumCaptured, APDevProfile.CMDPCaption] ) );

  // Enable CMS UI
  N_CM_MainForm.CMMSetUIEnabled( TRUE );

  if K_CMEDAccess is TK_CMEDCSAccess then
  // CMScan capture
    K_CMEDAccess.EDAFinCapture()
  else
  begin // if not CMScan
//    if K_CMStudyCaptModeState = -1 then
    if K_CMStudyCaptState = K_cmscNon then
    begin
//      K_CMEDAccess.EDADCMSeriesFin();
      PCMDCMAttrs := nil;
      if not ASkipProfileAttrs then
        PCMDCMAttrs := TK_PCMDCMAttrs(@APDevProfile.CMDPDModality);

      K_CMScanSlidesSaveArray( ASlidesArray,
                               format( K_CML1Form.LLLCaptHandler8.Caption, [APDevProfile.CMDPCaption]),
                               not K_CMXrayCaptStreamLineMode,
                               APDevProfile^.CMDPMTypeID,
                               K_CML1Form.LLLCaptHandler14.Caption,
                               PCMDCMAttrs );
      K_CMEDAccess.EDADCMSeriesFin(); // Move after Saving slides for DCMAutoStore
    end
    else
      K_CMStudyCaptFinishByDevice();

    // Exec all uncompleted actions
    if K_CMD4WWaitApplyDataCount = 0 then
    begin
      K_CMD4WApplyBufContext( );
      N_CM_MainForm.CMMCallActionByTimer( nil, TRUE );
    end;
  end; // if K_CMEDAccess is TK_CMEDCSAccess then

  N_Dump2Str( format( 'Fin K_CMSlidesSaveScanned3 for %d slides from %s',
                     [NumCaptured, APDevProfile.CMDPCaption] ) );

end; // end of K_CMSlidesSaveScanned3


//********************************************************** K_CMSlidesExportFilesList ***
// Export given Slides to Files
//
//     Parameters
// APSlides   - slides array start element to email
// APSlidesCount - slides to email counter
// AFilesPath  - Path to Resulting Files
// AFileExt    - files extension
// ASlidesList - Resulting files List
// AMaxWidth  - resulting Image Maximal Width
// AMaxHeight  - resulting Image Maximal Height
// Result - Returns number of exported objects
//
function K_CMSlidesExportFilesList( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                                    const AFilesPath, AFileExt : string;
                                    ASlidesList, AMacroList : TStrings;
                                    AMaxWidth : Integer = 0;
                                    AMaxHeight : Integer = 0 ): Integer;
var
  i: Integer;
//  GPCWrapper: TK_GPDIBCodecsWrapper;
  FName, SFName: string;
  SlideDIB: TN_DIBObj;
//  PSlides0: TN_PUDCMSlide;
  RIEncodingInfo : TK_RIFileEncInfo;
  ExportFlags : TK_CMBSlideExportToDIBFlags;

label Cont;
begin
  K_CMSlidesExportFilesOutOfMemory := 0;
  Result := 0;
  if ASlidesCount = 0 then
    Exit;

  // *** Prepare Mail
//  GPCWrapper := TK_GPDIBCodecsWrapper.Create;
//  GPCWrapper.GPEncQuality := 100;
  K_RIObj.RIClearFileEncInfo( @RIEncodingInfo );
  RIEncodingInfo.RIFileEncType := rietNotDef;
//  RIEncodingInfo.RIEComprQuality := 100;

  // *** Get MacroList
  K_CMEDAccess.EDAGetPatientMacroInfo(-1, AMacroList, TRUE);
  // Prepare MacroList for File Names building
  K_CMSlideEEFNamePrepMacro( AMacroList, AMacroList );

  // *** Prepare Image files and Build Attachments List

  ASlidesList.Clear;
//  PSlides0 := APSlides;
//!!!  K_CMSCheckMemConstraints( nil ); // Free Memory before Slide action MemCheck

  case K_RIObj.RIEncTypeByFileExt( AFileExt ) of
   rietTIF,
   rietPNG: ExportFlags := [K_bsedSkipConvGrey16To8];
  else
    ExportFlags := [];
  end;
  for i := 1 to ASlidesCount do
  begin
    with APSlides^, P()^ do
    begin
      FName := AFilesPath + K_PrepFileName( K_CMSlideEEFNameBuild( AMacroList, APSlides^, i ), '-' );
      if not(cmsfIsMediaObj in CMSDB.SFlags) then
      begin // Simple Image
      // Check Memory for Image Loading if needed
      //!!! check here because MapImage and CurImage are created in EDACheckSlideMedia in ExtDB Mode
        if not K_CMSCheckMemForSlide1( APSlides^ ) then
        begin
          Inc(K_CMSlidesExportFilesOutOfMemory);
          N_Dump1Str( 'ExpFilesList>> K_CMSCheckMemForSlide1 out of memory for ' + FName );
          goto Cont;
        end;

        if (K_CMEDAccess.EDACheckSlideMedia( APSlides^ ) = K_edFails) then
        begin
          N_Dump1Str( 'ExpFilesList>> EDACheckSlideMedia fails for ' + FName );
          goto Cont; // precaution
        end;

        FName := FName + AFileExt;
        SlideDIB := ExportToDIB( ExportFlags, AMaxWidth, AMaxHeight );
        if SlideDIB = nil then
        begin
          Inc(K_CMSlidesExportFilesOutOfMemory);
          N_Dump1Str( 'ExpFilesList>> ExportToDIB out of memory for ' + FName );
          goto Cont;
        end;
//        GPCWrapper.GPSaveDIBObjToFile(SlideDIB, FName);
        if K_RIObj.RISaveDIBToFile( SlideDIB, FName, @RIEncodingInfo ) <> rirOK then
        begin
          N_Dump1Str( format( 'ExpFilesList>> RISaveDIBToFile "%s" fails K_RIObj=%s', [FName, K_RIObj.ClassName] ) );
          SlideDIB.Free;
          goto Cont;
        end
        else
          SlideDIB.Free;
      end
      else
      begin // Media Obj
        SFName := '';
        if not K_CMPrepSlideMediaFile(APSlides^, SFName, TRUE) then
          goto Cont; // precaution
        FName := FName + ExtractFileExt(SFName);
        K_CopyFile(SFName, FName);
      end;
    end;
    ASlidesList.Add(FName);
Cont :
    Inc(APSlides);
  end;
//  GPCWrapper.Free();
  Result := ASlidesList.Count;

end; // end of K_CMSlidesExportFilesList

//********************************************************** K_CMSlidesSaveHistory ***
// Email given slides
//
//     Parameters
// APSlides   - slides array start element to email
// APSlidesCount - slides to email counter
// AHistActionCode - Slides History Action Code
// Result - Returns number of emailed objects or -1 if user abort emailing
//          or -2 if emailing error was detected
//
procedure K_CMSlidesSaveHistory( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                                 AHistActionCode : Integer );
var
  i : Integer;

begin
  with K_CMEDAccess do
  begin
    if K_CMEDAccess is TK_CMEDDBAccess then
      EDASaveSlidesListHistory( APSlides, ASlidesCount, AHistActionCode )
    else
      for i := 0 to ASlidesCount - 1 do
      begin
        EDAAddHistActionToSlideBuffer( APSlides^, AHistActionCode );
        Inc(APSlides);
      end;
  end;
end; // end of K_CMSlidesSaveHistory

//************************************************* K_CMFilesEmailingByMapi ***
// Email given files by Windows MAPI
//
//     Parameters
// ASubject   - email subject
// AFilesList - files paths list to attach
// Result     - Returns TRUE if Email is success fully send, FALSE if some problems are detected
//
function K_CMFilesEmailingByMapi( const ASubject : string; AFilesList : TStrings ): Boolean;
var
  MapiControl: TMapiControl;
  RetCode : Integer;
begin
  Result := FALSE;
  if (AFilesList = nil) or (AFilesList.Count = 0) then
    Exit;

  MapiControl := TMapiControl.Create();
  MapiControl.Subject := ASubject;
  MapiControl.AttachedFiles := AFilesList;
  MapiControl.ShowDialog := TRUE;
  K_CMEDAccess.EDASetInstanceState( TRUE, K_CMEDAInstanceNActiveStateFlag );

  try
    RetCode := MapiControl.Sendmail();
  except
    on E: Exception do
    begin
      RetCode := -1003;
      N_Dump1Str( 'Err>> K_CMFilesEmailingByMapi >> ' + E.Message );
    end;
  end;

  K_CMEDAccess.EDASetInstanceState( FALSE, K_CMEDAInstanceNActiveStateFlag );
  MapiControl.Free;
  if RetCode = 0 then
    Result := TRUE
  else if (RetCode <= -1000) and (RetCode >= -1003) then
    K_CMShowMessageDlg1( K_CML1Form.LLLEmail1.Caption,
//            ' Emailing internal exception',
          mtWarning )
  else if RetCode = 1 then
    N_CM_MainForm.CMMFShowStringByTimer( K_CML1Form.LLLEmail2.Caption ) // ' Emailing was aborted by user'
  else if RetCode = 2 then
    K_CMShowMessageDlg1( K_CML1Form.LLLEmail3.Caption,
//            ' Emailing failure',
          mtWarning )
  else
    K_CMShowMessageDlg1( K_CML1Form.LLLEmail4.Caption,
//            ' Emailing error',
          mtWarning );
end; // end of K_CMFilesEmailingByMapi

//****************************************************** K_CMSlidesEmailing ***
// Email given slides
//
//     Parameters
// APSlides   - slides array start element to email
// APSlidesCount - slides to email counter
// AMaxWidth  - resulting Image Maximal Width
// AMaxHeight  - resulting Image Maximal Height
// Result - Returns number of emailed objects or -1 if user abort emailing
//          or -2 if emailing error was detected
//
function K_CMSlidesEmailing( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                             AMaxWidth : Integer = 0; AMaxHeight : Integer = 0 ): Integer;
var
  MapiControl: TMapiControl;
  ML: TStrings;
  SL: TStringList;
  FPath: string;
  RetCode : Integer;

begin
  Result := 0;
  if ASlidesCount = 0 then
    Exit;

//  K_CMSResampleSlides( APSlides, ASlidesCount );


  // *** Clear previous files
  FPath := K_ExpandFileName('(#TmpFiles#)');

  SL := TStringList.Create;
  ML := K_CMEDAccess.EDAGetProviderMacroInfo();
  Result := K_CMSlidesExportFilesList( APSlides, ASlidesCount,
                                                 FPath, '.jpg', SL, ML,
                                                 AMaxWidth, AMaxHeight );
  if ASlidesCount <> Result then
    N_Dump1Str( format( 'K_CMSlidesEmailing >> %d of %d files are prepare', [Result,ASlidesCount] ) );

  if Result > 0 then
  begin
    N_Dump2Str( 'K_CMSlidesEmailing >> files list:' );
    N_Dump2Strings( SL, 5 );
  end;

  if K_CMSlidesExportFilesOutOfMemory > 0 then
  begin
    K_CMShowMessageDlg( format( K_CML1Form.LLLMemory2.Caption,
//'There is not enough memory to process all images. %d object(s) haven''t been attached.'+
//'        Please close some open image(s) or restart Media Suite if needed.',
                [K_CMSlidesExportFilesOutOfMemory] ), mtWarning );
    K_CMOutOfMemoryFlag := TRUE;
  end;

  K_CMEDAccess.EDAUnlockAllLockedSlides( K_cmlrmOpenLock );
  if Result > 0 then
  begin
    MapiControl := nil;
    try
      MapiControl := TMapiControl.Create();
//      MapiControl.Subject := K_StringMListReplace(K_CMENPTEmailSubject, ML, K_ummRemoveMacro);
      MapiControl.Subject := K_StringMListReplace(K_CML1Form.LLLMPatMailSubject.Caption, ML, K_ummRemoveMacro);
      MapiControl.AttachedFiles := SL;
      SL.Clear;
      MapiControl.Recipients := SL;
      MapiControl.Body := '';
      MapiControl.ShowDialog := TRUE;

      K_CMEDAccess.EDASetInstanceState( TRUE, K_CMEDAInstanceNActiveStateFlag );
      RetCode := MapiControl.Sendmail();
      K_CMEDAccess.EDASetInstanceState( FALSE, K_CMEDAInstanceNActiveStateFlag );
      MapiControl.Free;
      if RetCode > 0 then
        Result := -RetCode
      else if RetCode < 0 then
        Result := RetCode;

      if not K_CMD4WAppFinState then
      begin
        // Save Statistics (History)
        if RetCode = 0 then
          K_CMSlidesSaveHistory( APSlides, ASlidesCount,
             K_CMEDAccess.EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAEmail) ) );
      end;
    except
      on E: Exception do
      begin
        Result := -1003;
        N_Dump1Str( 'Err>> K_CMSlidesEmailing >> ' + E.Message );
        MapiControl.Free;
      end;
    end;
  end;
  SL.Free;

end; // end of K_CMSlidesEmailing

//********************************************************** K_CMSlideExport ***
// Export given slide
//
// ASlide   - slide for export
//
function K_CMSlideExport(ASlide: TN_UDCMSlide): Boolean;
var
  ML: TStrings;
//  GPCWrapper: TK_GPDIBCodecsWrapper;
  FName, FExt, FMedia: string;
  SaveDialog: TSaveDialog;
  SL: TStringList;
  i: Integer;
  // UDMediaObj : TN_UDBase;
  MediaFileFlag: Boolean;
  DialogDone: Boolean;
  SlideDIB: TN_DIBObj;
  ExpFormat: TK_CMSlideHistExpFormat;
  RIEncodingInfo : TK_RIFileEncInfo;
  ExportFlags : TK_CMBSlideExportToDIBFlags;

begin
  Result := false;
  if (ASlide = nil) or
     (K_CMEDAccess.EDACheckSlideMedia( ASlide ) = K_edFails) then
    Exit;

  SaveDialog := TSaveDialog.Create(Application);
  with SaveDialog, ASlide, P()^ do
  begin
    DialogDone := false;

    InitialDir := K_ExpandFileName(N_MemIniToString('CMS_Main',
        'LastExportDir', ''));

    MediaFileFlag := cmsfIsMediaObj in CMSDB.SFlags;
    if not MediaFileFlag then
    begin // Simple Slide
      Filter := N_MemIniToString('CMS_Main', 'ExportFilter',
        'JPEG (*.jpg)|*.jpg');
      FExt := '.jpg';
    end
    else
    begin // Video Slide
      FMedia := '';
      FExt := '.avi'; // precaution for future ChangeFileExt
      DialogDone := not K_CMPrepSlideMediaFile(ASlide, FMedia, TRUE);
      if FMedia <> '' then
        FExt := ExtractFileExt(FMedia);
    end;

    FilterIndex := 1;
    Options := Options + [ofEnableSizing];
    Title := 'Export';

    // *** Get MacroList
    ML := K_CMEDAccess.EDAGetPatientMacroInfo(CMSPatId);

{// !!! Old File Name Build Code
    ML.Add('SlideID=' + ObjName);
    ML.Add('DateTaken=' + K_DateTimeToStr(CMSDTTaken, 'yyyymmdd'));

    FName := K_StringMListReplace(K_CMENPTExportFName, ML, K_ummRemoveMacro);
    FileName := K_PrepFileName( FName + FExt );
{}
{// !!! New File Name Build Code }
    K_CMSlideEEFNamePrepMacro( ML, ML );
    FName := K_CMSlideEEFNameBuild( ML, ASlide, 1 );
    FileName := K_PrepFileName( FName + FExt, '-' );
{}

    while not DialogDone do
    begin
      FileName := ChangeFileExt(FileName, FExt);
      if Execute then
      begin
        N_StringToMemIni( 'CMS_Main', 'LastExportDir', ExtractFilePath(FileName) );
        FName := FileName;
        if not MediaFileFlag then
        begin
          // Simple Image
          // Get File Name extension by Filter
          SL := TStringList.Create;
          FExt := Filter;
          for i := 1 to Length(FExt) do
            if FExt[i] = '|' then
              FExt[i] := Chr($0A);
          SL.Text := FExt;
          FExt := SL[FilterIndex * 2 - 1];
          SL.Delimiter := ';';
          SL.DelimitedText := FExt;
          FExt := Copy(SL[0], 2, 5);
          SL.Free;

          case K_RIObj.RIEncTypeByFileExt( FName ) of
           rietTIF,
           rietPNG: ExportFlags := [K_bsedSkipConvGrey16To8];
          else
            ExportFlags := [];
          end;
          // Image Data Exists
          SlideDIB := ExportToDIB( ExportFlags );
{
          GPCWrapper := TK_GPDIBCodecsWrapper.Create;
          with GPCWrapper do
          begin
            // File Name Correct
            if GPMimeTypeByFileName(FExt) <> GPMimeTypeByFileName(FName) then
              FName := FName + FExt;
            // Save Image
            GPEncQuality := 100;
            GPSaveDIBObjToFile(SlideDIB, FName);
            N_Dump2Str('Export to File "' + FName + '"');
            Free;
          end;
}
          K_RIObj.RIClearFileEncInfo( @RIEncodingInfo );
//          RIEncodingInfo.RICComprQuality := 100;
          if K_RIObj.RIEncTypeByFileExt(FExt) <> K_RIObj.RIEncTypeByFileExt(FName) then
            FName := FName + FExt;
          if K_RIObj.RISaveDIBToFile( SlideDIB, FName, @RIEncodingInfo ) <> rirOK then
            N_Dump1Str( format( 'EMail>> RISaveDIBToFile "%s" fails K_RIObj=%s', [FName, K_RIObj.ClassName] ) );

          SlideDIB.Free;

          FExt := ExtractFileExt(FName);
          ExpFormat := K_shExpImgJPG;
          if SameText(FExt, '.TIF') or SameText(FExt, '.TIFF') then
            ExpFormat := K_shExpImgTIF
          else if SameText(FExt, '.BMP') then
            ExpFormat := K_shExpImgBMP
          else if SameText(FExt, '.BMP') then
            ExpFormat := K_shExpImgPNG;
          if not (K_CMEDAccess is TK_CMEDDBAccess) then
            with K_CMEDAccess do
              EDAAddHistActionToSlideBuffer(ASlide,
                EDABuildHistActionCode(K_shATNotChange,
                  Ord(K_shNCAExportFile), Ord(ExpFormat)));

          DialogDone := TRUE;
          Result := TRUE;
        end
        else if SameText(ExtractFileExt(FName), FExt) then
        begin
          // Media File
          FName := ChangeFileExt(FName, FExt);
          Result := K_CopyFile(FMedia, FName, [K_cffOverwriteNewer]) = 0;
          if not Result then
            K_CMShowMessageDlg( format(
               K_CML1Form.LLLVideoExport.Caption,
//               'Exported Video File %s is absent!!!',
               [FMedia] ), mtWarning) // precaution
          else
          if K_CMEDAccess is TK_CMEDDBAccess then
            with K_CMEDAccess do
              EDAAddHistActionToSlideBuffer(ASlide,
                EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAExportFile)) );

          DialogDone := TRUE;
        end;
      end
      else { User cancelled }
        DialogDone := TRUE;
    end;
  end; // with SaveDialog, ASLide, P()^
  SaveDialog.Free;

end; // end of K_CMSlideExport

//********************************************************** K_CMSlideWClipbordExport ***
// Export given slide to Windows Clipboard
//
// ASlide  - slide for export
// Result  - Returns TRUE if SLide Image is put to Windows Clipboard
//
function K_CMSlideWClipbordExport( ASlide: TN_UDCMSlide ): Boolean;
var
  SlideDIB: TN_DIBObj;
begin
  Result := false;
  // Precaution
  if (ASlide = nil) or
     (K_CMEDAccess.EDACheckSlideMedia( ASlide ) = K_edFails) then
    Exit;

  with ASlide, P()^ do
  begin
    // Precaution
    if cmsfIsMediaObj in CMSDB.SFlags then
      Exit;

    SlideDIB := ExportToDIB( );
    Result := FALSE;
    try
      Result := SlideDIB.SaveToClipborad();
      N_Dump2Str('Put to Clipboard Slide ID=' + ObjName);
    except
      on E: Exception do
      begin
        N_Dump1Str( 'Err>> TN_UDSlide.SaveToClipborad >> ' + E.Message );
      end;
    end;
    SlideDIB.Free;
  end;
end; // end of K_CMSlideWClipbordExport

//********************************************************** K_CMSlidesWClipbordExport ***
// Export given slides to Windows Clipboard
//
// APSlides   - slides array start element to email
// APSlidesCount - slides to email counter
// Result - Returns number of emailed objects or -1 if user abort emailing
//          or -2 if emailing error was detected
//
function K_CMSlidesWClipbordExport( APSlides: TN_PUDCMSlide; ASlidesCount: Integer ): Integer;
var
  SL: TStringList;
  FPath: string;
begin
  Result := 0;
  if ASlidesCount = 0 then
    Exit;

  // *** Clear previous files
  FPath := K_ExpandFileName('(#TmpFiles#)');

  SL := TStringList.Create;
  K_CMEDAccess.TmpStrings.Clear;
//  Result := K_CMSlidesExportFilesList( APSlides, ASlidesCount, FPath, '.bmp', SL,
  Result := K_CMSlidesExportFilesList( APSlides, ASlidesCount, FPath, '.png', SL,
                                            K_CMEDAccess.TmpStrings );
  if Result = 0 then Exit;

  try
    if Result <> N_CopyFNamesToClipboard( SL ) then
    begin
      N_Dump1Str( 'Err>> N_CopyFNamesToClipboard >> Clipboard is locked' );
      Result := 0; // Some error was detected
    end
    else
      N_Dump2Str( format( 'Put to Clipboard %d Slides', [Result] ) );
  except
    on E: Exception do
    begin
      N_Dump1Str( 'Err>> N_CopyFNamesToClipboard >> ' + E.Message );
      Result := 0;
    end;
  end;
  SL.Free;

  if K_CMSlidesExportFilesOutOfMemory > 0 then
  begin
    K_CMShowSoftMessageDlg( format( K_CML1Form.LLLMemory1.Caption,
//'There is not enough memory to process all images. %d object(s) haven''t been put to Clipboard.'+
//'        Please close some open image(s) or restart Media Suite if needed.',
                [K_CMSlidesExportFilesOutOfMemory] ), mtWarning, 10 );
    K_CMOutOfMemoryFlag := TRUE;
  end;
end; // end of K_CMSlidesWClipbordExport

//********************************************************** K_CMSBuildSlidesArrayByList ***
// Build array of slides by given indexes list
//
//     Parameters
// ASlidesArray   - source Slides array
// ASlidesList - list of Slides indexes in source Slides array
// Result - Returns array of Slides get source Slides array by given indexes
//
function K_CMSBuildSlidesArrayByList( ASrcSlidesArray: TN_UDCMSArray;
                                      ASlidesList: TList ): TN_UDCMSArray;
begin
  SetLength(Result, ASlidesList.Count);
  if (ASlidesList.Count > 0) and        // precations
     (Length(ASrcSlidesArray) > 0) then
    K_MoveVectorBySIndex(Result[0], -1, ASrcSlidesArray[0], -1,
      SizeOf(Integer), ASlidesList.Count, PInteger(@ASlidesList.List[0]));
end; // end of K_CMSBuildSlidesArrayByList

//********************************************************** K_CMSlideInitByCurContext ***
// Set current context attributes to new Slide object
//
//     Parameters
// ANSlide - given new Slide Object
//
// Set Slide Created and Modified Atttributes - Date, Provider, Location
//
procedure K_CMSlideInitByCurContext(ANSlide: TN_UDCMBSlide);
begin
  with K_CMEDAccess, TN_UDCMBSlide(ANSlide), P()^ do
  begin
    // CMSDTCreated      := Now();   // Slide DateTime Created
    CMSDTCreated := EDAGetSyncTimestamp(); // Slide DateTime Created
    CMSRFlags := [cmsfIsNew];
    CMSDTMapRootMod := CMSDTCreated; // Slide DateTime MapRoot Modified
    CMSProvIDCreated := CurProvID; // Provider ID Created
    CMSProvIDModified := CurProvID; // Provider ID Modified
    CMSLocIDCreated := CurLocID; // Location ID Created
    CMSLocIDModified := CurLocID; // Location ID Modified
    CMSCompIDCreated := K_CMSServerClientInfo.CMSClientVirtualName;
    CMSCompIDModified := K_CMSServerClientInfo.CMSClientVirtualName;
    CMSLocIDHost := CurLocID; // Host Location ID
    if ANSlide is TN_UDCMSlide then
    begin
      CMSlideECSFlags := [cmssfIsNew];
      CMSDTImgMod := CMSDTCreated; // Slide DateTime Img Modified
      CMSDTPropMod := CMSDTCreated; // Slide DateTime Prop Modified
{
    end
    else
    if ANSlide is TN_UDCMStudy then
    begin
}
    end;
  end; // with Result.P()^ do
end; // end of K_CMSlideInitByCurContext

//********************************************************** K_CMSlidesCopyToClipboard ***
// Copy given Slides to Clipboard
//
//     Parameters
// APSlides   - slides array start element to email
// APSlidesCount - slides to email counter
// Result - Returns real number of slides put to Clipboard
//
function K_CMSlidesCopyToClipboard( APSlides: TN_PUDCMSlide;
                                    ASlidesCount: Integer ): Integer;
{
  var
  i, j, n : Integer;
}
begin

  SetLength(K_CMSlidesClipBoardArray, ASlidesCount);
  if ASlidesCount > 0 then
    Move(APSlides^, K_CMSlidesClipBoardArray[0],
      ASlidesCount * SizeOf(TN_UDCMSlide));
  // K_CMSlidesClipBoardArray := Copy( ASlidesArray );

//  K_CMSResampleSlides( APSlides, ASlidesCount );

  Result := Length(K_CMSlidesClipBoardArray);

  {
    with K_CMSlidesClipboard do begin
    ClearClipboard();

    // Prepare Clipboard DEArray from Slides
    n := Length(ASlidesArray);
    SetLength( DEClipboard, n );
    Result := 0;
    for i := 0 to High(DEClipboard) do begin
    j := K_CMEDAccess.CurSlidesRoot.IndexOfDEField( ASlidesArray[i] );
    if j < 0 then Continue; // Wrong Slide
    K_CMEDAccess.CurSlidesRoot.GetDirEntry( j, DEClipboard[Result] );
    with DEClipboard[Result] do begin
    Child.ClassFlags := Child.ClassFlags or K_SkipDestructBit;
    Parent.ClassFlags := Parent.ClassFlags or K_SkipDestructBit;
    Inc(Result);
    end;
    end;
    SetLength( DEClipboard, Result );


    UpdateVTreesByClipboard( );
    end;
  }
end; // end of K_CMSlidesCopyToClipboard

//********************************************************** K_CMSlidesClose ***
// Close given slides
//
// APSlides   - slides array start element to close
// ASlidesCount - slides to delete counter
// ACloseFlags - Edit Frame Free Objects Flags
// Result - Returns number of closed slides
//
function K_CMSlidesClose( APSlides: TN_PUDCMSlide;
       ASlidesCount: Integer; ACloseFlags : TN_CMRFEdFreeFlags ): Integer;
var
  i: Integer;
  EdFrame: TN_CMREdit3Frame;

begin
  // Close Opened Slides
  Result := 0;
  for i := 0 to ASlidesCount - 1 do // along all Slides to delete
  begin
    if (cmsfIsOpened in APSlides^.P.CMSRFlags) then
    begin
      EdFrame := N_CM_MainForm.CMMFFindEdFrame(APSlides^);
      if EdFrame <> nil then // Editor Frame with Opened SlidesArray[i]
      begin
        EdFrame.EdFreeObjects( ACloseFlags );
        Inc(Result);
      end
      else
        raise Exception.Create(
          'Slide marked as opened has no correspondig EdFrame ID=' +
            APSlides^.ObjName);
    end;
    Inc(APSlides);
  end;
end; // end of K_CMSlidesClose

//********************************************************** K_CMSlidesSetDeleteState ***
// Set Deleted State to given SLides
//
// APSlides   - slides array start element to delete
// ASlidesCount - slides to delete counter
// Result - Returns number of deleted slides
//
function K_CMSlidesSetDeleteState( APSlides: TN_PUDCMSlide;
  ASlidesCount: Integer; AMarkAsDelFlag : Boolean ): Integer;
var
//  i: Integer;
//  PSlides1: TN_PUDCMSlide;
//  EdFrame: TN_CMREdit3Frame;
  FreeFlags : TN_CMRFEdFreeFlags;

begin
  Result := 0;
  if ASlidesCount = 0 then Exit;
  FreeFlags := [cmrfefSkipUnlock,cmrfefSkipSave];
  if AMarkAsDelFlag then
    FreeFlags := [cmrfefSkipUnlock];
  K_CMSlidesClose( APSlides, ASlidesCount, FreeFlags );
  Result := K_CMEDAccess.EDADelSlides(APSlides, ASlidesCount,
                              AMarkAsDelFlag and K_CMMarkAsDelShowFlag );
end; // end of K_CMSlidesSetDeleteState

//********************************************************** K_CMDelSlidesFree ***
// Free Deleted Slides from Deleted List
//
// Is used for Slides that have been deleted by other user (Application Instance)
//
procedure K_CMDelSlidesFree();
var
  i: Integer;
  UDSlide: TN_UDCMSlide;
begin
  with K_CMEDAccess do
  begin
    for i := DelSlidesList.Count - 1 downto 0 do
    begin
      UDSlide := TN_UDCMSlide(DelSlidesList[i]);

      if N_CM_MainForm.CMMStudyLastOpened = TN_UDBase(UDSlide) then
      begin // Clear open context
        N_CM_MainForm.CMMStudyLastOpened := nil;
        N_CM_MainForm.CMMStudyPrevLayout := eflNotDef;
        N_Dump2Str( 'K_CMDelSlidesFree >> Clear Study in Open Context' );
      end;

      UDSlide.UDDelete; // Delete Slide which is not saved in archive
      DelSlidesList.Delete(i);
    end;
  end;
end; // end of K_CMDelSlidesFree

//************************************ K_CMSlidesDelete ***
// Delete given Slides
//
//     Parameters
// APSlides   - slides array start element to delete
// ASlidesCount - slides to delete counter
// AMarkAsDelFlag - if = TRUE only mark as deleted is needed
// AClearNotDelSrcSlides - if = TRUE then not deleted slide objects from Source slides array will be deleted
// APatID - slides owner Patient ID, if APatID=-1 slides of all owners should be deleted)
// Result - Returns number of slides removed from CurSlidesList
//
function K_CMSlidesDelete( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                           AMarkAsDelFlag : Boolean; AClearNotDelSrcSlides : Boolean;
                           APatID: Integer = -1 ): Integer;
var
  LockResultMode: TK_CMEDLockResultMode;
  SInd, i : Integer;
begin
  with K_CMEDAccess do
  begin

    LockResultMode := K_cmlrmDeleteLock;
    if AMarkAsDelFlag then
      LockResultMode := K_cmlrmMarkAsDelLock;
    EDALockSlides(APSlides, ASlidesCount, LockResultMode, APatID);
    // Delete existed Slides and already Deleted (just to clear from CurSlidesSet)
    Result := K_CMSlidesSetDeleteState(@LockResSlides[0], LockResCount, AMarkAsDelFlag );
    K_CMSlidesClipBoardArray := nil; // Clear CMS Slides Clipboard - precaution
    if LockResCount > 0 then
    begin
      if not AMarkAsDelFlag and AClearNotDelSrcSlides then
      begin
      // Clear Deleted Slides in APSlides
        SInd := 0;
        for i := 0 to ASlidesCount - 1 do
        begin
          if APSlides^ <> LockResSlides[SInd] then
            APSlides^.UDDelete()
          else
            Inc(SInd);
          Inc(APSlides);
        end
      end;
      EDAClearDeletedSlides( AMarkAsDelFlag ); // Finish Slides Deletion - instead of EDASaveSlidesList
    end;

    if LockResMarkAsDelCount > 0 then
    begin // Slides Lock Routine detected some already Marked as Deleted Objects - clear
      K_CMSlidesSetDeleteState(@LockResMarkAsDelSlides[0], LockResMarkAsDelCount, TRUE );
      K_CMDelSlidesFree();
    end;
  end;
end; // end of K_CMSlidesDelete

//************************************ K_CMSlidesDeleteExecute ***
// Delete given Slides execute
//
//     Parameters
// APSlides - pointer to slides to delete
// ASlidesCount - slides count to delete
// AMarkAsDelFlag - if =TRUE then only mark as deleted is needed
//
// Delete given slides and do all needed GUI actions
//
procedure K_CMSlidesDeleteExecute( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                                   AMarkAsDelFlag : Boolean );
var
  NumSlides: Integer;
  ExtLockedStr: string;
begin
  with K_CMEDAccess do
  begin
    SkipEDADataCheckInDelProc := TRUE;
    NumSlides := K_CMSlidesDelete( APSlides, ASlidesCount, AMarkAsDelFlag, FALSE, CurPatID );
    ExtLockedStr := '';

    if LockResDelUsedByOtherCount > 0 then
      ExtLockedStr := format(
        K_CML1Form.LLLSlidesDel1.Caption,
//        ' %d Media object(s) have been used by other Media Suite user(s)',
        [LockResDelUsedByOtherCount] );

    if LockResDelNotHostLoc > 0 then
    begin
      if ExtLockedStr <> '' then
        ExtLockedStr := ExtLockedStr + ',';
      ExtLockedStr := format(
        K_CML1Form.LLLSlidesDel2.Caption,
//        ' %d Media object(s) are from another location(s)',
        [LockResDelNotHostLoc] );
    end; // if LockResDelNotHostLoc > 0 then

    if LockResMediaCreatedOnOtherCount > 0 then
    begin
      if ExtLockedStr <> '' then
        ExtLockedStr := ExtLockedStr + ',';
      ExtLockedStr := ExtLockedStr + format(
        K_CML1Form.LLLSlidesDel3.Caption,
//        ' %d Media object(s) were created on other computers',
        [LockResMediaCreatedOnOtherCount] );
    end; // if LockResMediaCreatedOnOtherCount > 0 then

    if LockResMarkAsDelCount > 0 then
    begin
      if ExtLockedStr <> '' then
        ExtLockedStr := ExtLockedStr + ',';
      ExtLockedStr := ExtLockedStr + format(
        K_CML1Form.LLLRestoreDelSlides1.Caption,
//        ' %d Media object(s) have already been deleted by other Media Suite user(s)',
        [LockResMarkAsDelCount] );
    end; // if LockResMarkAsDelCount > 0 then

  end; // with K_CMEDAccess do


  if ExtLockedStr <> '' then
  begin
    K_CMShowMessageDlg(ExtLockedStr, mtInformation);
    ExtLockedStr := ',' + ExtLockedStr;
  end;

  with N_CM_MainForm do
  begin
    CMMFRebuildVisSlides();
//    CMMFDisableActions(nil);
    CMMFShowStringByTimer( format( K_CML1Form.LLLSlidesDel5.Caption,
//     ' %d media object(s) were deleted',
        [NumSlides]) + ExtLockedStr);
    if AMarkAsDelFlag then
      K_CMMarkedAsDeletedCount := K_CMMarkedAsDeletedCount + NumSlides;
    CMMFDisableActions( nil );

  end; // with N_CM_MainForm do
  
  K_CMEDAccess.LockResCount := 0; // Clear LockResCount to prevent AMSC Error
  K_CMEDAccess.SkipEDADataCheckInDelProc := FALSE;
//  K_FormCMSIsodensity.InitIsodensityMode();
end; // end of K_CMSlidesDeleteExecute

//************************************ K_CMSlidesUnDelete ***
// UnDelete given Slides
//
//     Parameters
// APSlides   - slides array start element to delete
// ASlidesCount - slides to delete counter
// Result - Returns number of slides restored from marked as deleted state
//
function K_CMSlidesUnDelete( APSlides: TN_PUDCMSlide; ASlidesCount: Integer ): Integer;
var
  Slides : TN_UDCMSArray;
  i : Integer;
begin
  with K_CMEDAccess do
  begin
    SetLength( Slides, ASlidesCount );
    Result := 0;
    for i := 0 to ASlidesCount - 1 do
    begin
      if cmsdbfMarkedAsDel in APSlides^.CMSDBStateFlags then
      begin
        Slides[Result] := APSlides^;
        Inc(Result);
      end;
      Inc(APSlides);
    end;
    SetLength( Slides, Result );
    if Result = 0 then Exit; //Precaution - nothing to do

    EDALockSlides( @Slides[0], Result, K_cmlrmUnDelLock);
    if Result > LockResCount + LockResDelCount then
    begin
      K_CMShowMessageDlg( format(
          K_CML1Form.LLLSlidesDel2.Caption,
//          ' %d Media object(s) are from another location(s).',
          [Result - LockResCount - LockResDelCount] ), mtInformation);
    end;
    Result := LockResCount;
    if LockResCount = 0 then Exit;
    K_CMSlidesClose( @LockResSlides[0], LockResCount, [cmrfefSkipUnlock,cmrfefSkipSave] );

    EDAUnDeleteSlides( @LockResSlides[0], LockResCount );
    EDAUnlockSlides(@LockResSlides[0], LockResCount, K_cmlrmUnDelLock);

  end;
end; // end of K_CMSlidesUnDelete

//************************************ K_CMSlidesLockForOpen ***
// Lock given Slides for open
//
//     Parameters
// APSlides   - slides array start element to delete
// APSlidesCount - slides to delete counter
// ALockMode - slides lock mode
//
procedure K_CMSlidesLockForOpen( APSlides: TN_PUDCMSlide; ASlidesCount: Integer;
                                 ALockMode: TK_CMEDLockResultMode );
var
//  ExtDeletedStr: string;
  i : Integer;
  WStr : string;
  CurTS, SSFinTS : TDateTime;
  PCMSlide : TN_PCMSlide;
  RefreshNewSlidesCount, RefreshDelSlidesCount, RefreshUpdateSlidesCount : Integer;

begin
  with N_CM_MainForm, K_CMEDAccess do
  begin

    EDALockSlides(APSlides, ASlidesCount, ALockMode, CurPatID);

    if (ALockMode = K_cmlrmEditImgLock)  or
       (ALockMode = K_cmlrmEditPropLock) then
    begin
    // Mark Read Only Slides
      for i := 0 to LockResCount - 1 do
      begin
        if TN_UDCMBSlide(LockResSlides[i]) is TN_UDCMStudy then Continue;
        PCMSlide := LockResSlides[i].P;
        with PCMSlide^ do
        begin
{ // Skip Edit ReadOnly
          Exclude( CMSRFlags, cmsfSkipSlideEdit );
          if ( not (cmsfIsMediaObj in CMSDB.SFlags) or
               (ALockMode = K_cmlrmEditPropLock) )  and
             not (cmsfIsLocked in CMSRFlags) then
            Include( CMSRFlags, cmsfSkipSlideEdit )
}
          CMSRFlags := CMSRFlags - [cmsfSkipChangesSave, cmsfSkipSlideEdit];
          if ( not (cmsfIsMediaObj in CMSDB.SFlags) or
               (ALockMode = K_cmlrmEditPropLock) )     and
             not (cmsfIsLocked in CMSRFlags) then
          begin
            if cmsdbfMarkedAsDel in LockResSlides[i].CMSDBStateFlags then
              Include( CMSRFlags, cmsfSkipSlideEdit )
            else
              Include( CMSRFlags, cmsfSkipChangesSave );
          end;
        end; // PCMSlide^ do
      end; // for i := 0 to LockResCount - 1 do
    end; // if (ALockMode = ...

    // *** Process SkipToOpen Slides
    if LockResSkipOpenCount > 0 then
    begin
      with TK_CMEDDBAccess(K_CMEDAccess) do
      begin
        EDAEMGetFSyncSessionAttrs( );
        CurTS := EDAEMGetFSyncSessionTime( CurTS, SSFinTS );
        if SSFinTS < CurTS then
          SSFinTS := SSFinTS + 1;
        if LockResSkipOpenCount = 1 then
        begin
          if K_CMSlideIconDlg( LockResSkipOpenSlides[0], K_CML1Form.LLLSlidesLock1.Caption, // 'Objects access confirmation',
                format( K_CML1Form.LLLSlidesLock2.Caption,
//                  'The selected object is at the other location.'#13#10 +
//                  'It can be accessed by %s only. Proceed?',
                [K_DateTimeToStr( SSFinTS, 'dd.mm.yyyy hh:nn AM/PM' )] ) ) then
            with TK_CMEDDBAccess(K_CMEDAccess) do
            begin
            // Put Slides to Sync Query
              // Exec Stored Procedure to Add Query Elements
              with CurSQLCommand1 do
              begin
                Connection := LANDBConnection;
                WStr := format( 'cms_SyncFilesQueryAddSlide(%d,%d,%d,%s,1);',
                          [ClientAppGlobID,CurProvID,CurLocID,LockResSkipOpenSlides[0].ObjName] );
                N_Dump1Str( 'DB>> ' + WStr );
                CommandText := 'begin' + Chr($0A) +
                               'select ' + WStr  + Chr($0A) + 'end';
                Execute;
              end;
            end;
        end // if LockResSkipOpenCount = 1 then
        else
        if K_CMSlideIconsDlg( @LockResSkipOpenSlides[0], LockResSkipOpenCount,
              K_CML1Form.LLLSlidesLock1.Caption, // 'Object access confirmation',
              format( K_CML1Form.LLLSlidesLock3.Caption,
//                'The selected objects are at other location(s).'#13#10 +
//                'They can be accessed by %s only. Proceed?'
                [K_DateTimeToStr( SSFinTS, 'dd.mm.yyyy hh:nn AM/PM' )] ) ) then
        begin
        // Put Slides to to Sync Query

          // Prep XML with Slected Slides
          TmpStrings.Clear;
          WStr := '<record LocID="' + IntToStr(CurLocID) + '" SlideID="%s" />';
          for i := 0 to LockResSkipOpenCount - 1 do
            with LockResSkipOpenSlides[i] do
              TmpStrings.Add( format( WStr, [ObjName] ) );

{
          WStr := Copy( StrTextBuf, 1, K_GetStringsToBuf( StrTextBuf, TmpStrings, 0, LockResSkipOpenCount, TRUE, Chr($0A) ) );

          // Exec Stored Procedure to Add Query Lements
          with CurSQLCommand1 do
          begin
            Connection := LANDBConnection;
            N_Dump1Str( 'DB>> cms_SyncFilesQueryAddSlidesList: ' );
            N_Dump1Strings(TmpStrings, 4);
            CommandText := 'begin' + Chr($0A) + 'declare @ls_source long varchar;' + Chr($0A) +
              'set @ls_source = ''<root>' + WStr + '</root>'';' + Chr($0A) +
              'select cms_SyncFilesQueryAddSlidesList('+IntToStr(ClientAppGlobID)+ ',' +
                                                        IntToStr(CurProvID) +',@ls_source);' + Chr($0A) +
              'end';
            Execute;
          end;
}
      // Exec Stored Procedure to Add Query Lements
          WStr := '<root>' +
            Copy( StrTextBuf, 1, K_GetStringsToBuf( StrTextBuf, TmpStrings, 0, TmpStrings.Count, TRUE, Chr($0A) ) )
                + '</root>';
          N_Dump1Str( 'DB>> cms_SyncFilesQueryAddSlidesList: ' );
          N_Dump1Strings(TmpStrings, 4);
          with CurStoredProc1 do
          begin
            Connection := LANDBConnection;
            ProcedureName := 'dba.cms_SyncFilesQueryAddSlidesList';
            Parameters.Clear;
            with Parameters.AddParameter do begin
              Name := '@AppGID';
              Direction := pdInput;
              DataType := ftInteger;
              Value := ClientAppGlobID;
            end;
            with Parameters.AddParameter do begin
              Name := '@UserID';
              Direction := pdInput;
              DataType := ftInteger;
              Value := CurProvID;
            end;
            with Parameters.AddParameter do begin
              Name := '@xml_list';
              Direction := pdInput;
              DataType := ftString;
              Value := WStr;
            end;
            ExecProc;
          end; // with CurStoredProc1 do
        end; // K_CMSlideIconsDlg( @LockResSkipOpenSlides[0] ...
      end; // with TK_CMEDDBAccess(K_CMEDAccess) do
    end; // if LockResSkipOpenCount > 0 then

    if (LockResDelCount > 0) or (LockResMarkAsDelCount > 0) then
    begin
      // If Deleted Slides
      K_CMShowMessageDlg1( format( K_CML1Form.LLLSlidesLock4.Caption,
//            ' %d Media object(s) have been deleted by other Media Suite user(s)',
          [LockResDelCount + LockResMarkAsDelCount]), mtInformation);

      if LockResDelCount > 0 then // Prepare already Ddeleted Slides for clear
        K_CMSlidesSetDeleteState(@LockResDelSlides[0], LockResDelCount, FALSE );
      if LockResMarkAsDelCount > 0 then // Prepare already Marked as Deleted Slides for clear
        K_CMSlidesSetDeleteState(@LockResMarkAsDelSlides[0], LockResMarkAsDelCount, TRUE );
      K_CMDelSlidesFree();

//        CMMFDisableActions(nil);
//        K_FormCMSIsodensity.InitIsodensityMode();
    end; // if LockResDelCount > 0 then

    RefreshNewSlidesCount := 0;
    RefreshDelSlidesCount := 0;
    // *** Update Opened Images View
    if (LockResUpdateOpenImgCount > 0) or
       (LockResUpdateStudyCount > 0) then
    begin
      if LockResUpdateStudyCount > 0 then
      // Refresh CurSlides Set because of some of Opening Studies were updated
        EDARefreshCurSlidesSet( RefreshNewSlidesCount, RefreshDelSlidesCount,
                                RefreshUpdateSlidesCount );
      i := K_CMRefreshOpenedView();
      if i > 0 then
        K_CMShowMessageDlg(format(
            K_CML1Form.LLLSlidesOpen1.Caption,
//            ' %d opened Media object(s) were updated because they have been changed by other Media Suite user(s)',
            [i]), mtInformation);

    end; // if (LockResUpdateOpenImgCount > 0) or (LockResUpdateStudyCount > 0)

    if (LockResDelCount > 0)           or
       (LockResMarkAsDelCount > 0)     or
       (LockResUpdateOpenImgCount > 0) or
       (LockResUpdateStudyCount > 0)   or
       (RefreshNewSlidesCount > 0)     or
       (RefreshDelSlidesCount > 0) then
      CMMFRebuildVisSlides()
    else
    if LockResUpdateThumbCount > 0 then CMMCurFThumbsDGrid.DGInitRFrame();

  end;
end; // end of K_CMSlidesLockForOpen

//********************************************************** K_CMSlidesPasteFromClipboard ***
// Paste Slides from Clipboard with history
//
//     Parameters
// Result - Returns number of slides pasted from Clipboard
//
// Paste wit all history (Original Image, UNDO Buffer ...) Errors!!!
//
function K_CMSlidesPasteFromClipboard(): Integer;
var
  i: Integer;
  NewUObj, UDDataRoot: TN_UDBase;
  SrcSlide: TN_UDCMSlide;
  // UDMedia : TN_UDFile;
  SFName: string;
  HistActCode : Integer;
begin
  Result := Length(K_CMSlidesClipBoardArray);
  HistActCode := K_CMEDAccess.EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCADuplicate));
  for i := 0 to Result - 1 do
  begin
    SrcSlide := K_CMSlidesClipBoardArray[i];
    SFName := '';
    if (cmsfIsMediaObj in SrcSlide.P.CMSDB.SFlags)
      and not K_CMPrepSlideMediaFile(SrcSlide, SFName, false) then
    begin
      // Skip Media Slide with absent File
      Dec(Result);
      Continue;
    end;

    // Init Source Slide Images for Copy
    K_CMEDAccess.EDAGetSlideMapRoot(SrcSlide);
    K_CMEDAccess.EDAGetSlideCurImage(SrcSlide);
    K_CMEDAccess.EDAGetSlideSrcImage(SrcSlide);

    // Copy Slide Tree
    SrcSlide.PrepROIView([K_roiClearRefs]);
    K_SaveTreeToMem(SrcSlide, N_SerialBuf, false, [K_lsfJoinAllSLSR]);
    SrcSlide.PrepROIView([K_roiRestoreIfImage]);
    NewUObj := K_LoadTreeFromMem(N_SerialBuf, [K_lsfJoinAllSLSR]);

    K_CMSlideInitByCurContext(TN_UDCMSlide(NewUObj));

    with TN_UDCMSlide(NewUObj), P()^ do
    begin
      PrepROIView([K_roiRestoreIfImage]);
      CMSSourceDescr := format(  'Media Object (ID %s) duplicate',
                                 [ObjName] );
//      'Media Object (ID ' + ObjName + ') duplicate';
      UDDataRoot := DirChild(K_CMSlideIndCurImg);
      if (UDDataRoot <> nil) and ((UDDataRoot.ObjFlags and K_fpObjSLSRFlag)
          <> 0) then
      begin
        // Slide Stored in Local Archive - Remove Current Image Section
        K_CMEDAccess.EDAGetSlideCurImage(TN_UDCMSlide(NewUObj));
        PutDirChild(K_CMSlideIndCurImg, UDDataRoot.DirChild(0));

        // Slide Stored in Local Archive - Remove Original Image Section
        UDDataRoot := DirChild(K_CMSlideIndSrcImg);
        if (UDDataRoot <> nil) and ((UDDataRoot.ObjFlags and K_fpObjSLSRFlag)
            <> 0) then
        begin
          K_CMEDAccess.EDAGetSlideSrcImage(TN_UDCMSlide(NewUObj));
          PutDirChild(K_CMSlideIndSrcImg, UDDataRoot.DirChild(0));
        end;
      end
      else
      begin
        if SFName <> '' then
        begin
          // Copy Media Data
          SetMediaFileTMPName('');
          AddMediaFile(SFName);
        end;
      end;
    end; // with Result.P()^ do
    if not (K_CMEDAccess is TK_CMEDDBAccess) then
    // Save Statistics to Slides Buffer
      with K_CMEDAccess do
        EDAAddHistActionToSlideBuffer( SrcSlide, HistActCode );
    K_CMEDAccess.EDAAddSlide(NewUObj);
    K_CMEDAccess.SaveSlidesList.Add(NewUObj);
    if TN_UDCMSlide(SrcSlide).CMSUndoBuf <> nil then
      with TN_UDCMSlide(NewUObj) do
      begin
        CMSUndoBuf := TK_CMSUndoBuf.CreateByUNDOBuf
          (TN_UDCMSlide(SrcSlide).CMSUndoBuf);
        CMSUndoBuf.UDCMSlide := TN_UDCMSlide(NewUObj);
      end;
  end;

  // Save Statistics directly to DB
  if K_CMEDAccess is TK_CMEDDBAccess then
    K_CMEDAccess.EDASaveSlidesListHistory( @K_CMSlidesClipBoardArray[0], Result, HistActCode );

  if K_CMEDAccess.SaveSlidesList.Count > 0 then
  begin
    K_CMEDAccess.EDASaveSlidesList(K_CMEDAccess.SaveSlidesList);
    K_CMEDAccess.SaveSlidesList.Clear;
  end;
  // Save after paste

end; // end of K_CMSlidesPasteFromClipboard

//********************************************************** K_CMCopySlideWithoutSrcImg ***
// Copy given Slides from Clipboard without original Image
//
//     Parameters
// ASrcSlide - source slide to copy
// Result - Returns given Slide copy, nil if SLide file is absent or corrupted or
//          1 if out of memory
//
function K_CMCopySlideWithoutSrcImg( ASrcSlide: TN_UDCMSlide ): TN_UDCMSlide;
var
  UDDataRoot: TN_UDBase;
  UDStudyRef: TN_UDBase;
  ImgViewConvData: TK_CMSImgViewConvData;
  CurDIBObj: TN_DIBObj;
  SFName: string;
  MediaFileCopyFlag : Boolean;
begin
    // Init Source Slide Images for Copy
  Result := nil;
  MediaFileCopyFlag := cmsfIsMediaObj in ASrcSlide.P.CMSDB.SFlags;

  if not (TN_UDCMBSlide(ASrcSlide) is TN_UDCMStudy) and
     not MediaFileCopyFlag                          and
     not K_CMSCheckMemForSlide1( ASrcSlide, 1, 3 ) then
  begin
  // Out of memory
    Integer(Result) := 1;
    Exit;
  end;

  SFName := '';
  if (TN_UDCMBSlide(ASrcSlide) is TN_UDCMStudy) or
     ( MediaFileCopyFlag and
       not K_CMPrepSlideMediaFile(ASrcSlide, SFName, false) ) or
     ( not MediaFileCopyFlag and
      (K_CMEDAccess.EDACheckSlideMedia( ASrcSlide ) = K_edFails) )   then
  begin
    // Skip Media Slide with absent File
    Exit;
  end;

  K_CMEDAccess.EDAGetSlideMapRoot(ASrcSlide);
  K_CMEDAccess.EDAGetSlideCurImage(ASrcSlide);

  // Copy Slide Tree without Original Image
  UDDataRoot := ASrcSlide.DirChild(K_CMSlideIndSrcImg);
  if UDDataRoot <> nil then
  begin
    Inc(UDDataRoot.RefCounter);
    ASrcSlide.PutDirChild(K_CMSlideIndSrcImg, nil);
  end;

  UDStudyRef := ASrcSlide.DirChild(K_CMSlideIndStudyItem);
  if UDStudyRef <> nil then
  begin
    Inc(UDStudyRef.RefCounter);
    ASrcSlide.PutDirChild(K_CMSlideIndStudyItem, nil);
  end;

  ASrcSlide.PrepROIView([K_roiClearRefs]);

  K_SaveTreeToMem( ASrcSlide, N_SerialBuf, false, [K_lsfJoinAllSLSR] );

  ASrcSlide.PrepROIView([K_roiRestoreIfImage]);

  if UDDataRoot <> nil then
  begin
    ASrcSlide.PutDirChild(K_CMSlideIndSrcImg, UDDataRoot);
    Dec(UDDataRoot.RefCounter);
  end;

  if UDStudyRef <> nil then
  begin
    ASrcSlide.PutDirChild(K_CMSlideIndStudyItem, UDStudyRef);
    Dec(UDStudyRef.RefCounter);
  end;

  Result := TN_UDCMSlide(K_LoadTreeFromMem(N_SerialBuf, [K_lsfJoinAllSLSR]));


  with Result, P()^, CMSDB do
  begin
    N_Dump1Str( 'Duplicate from SlideID=' + ObjName );

    CMSHist.DeleteElems( 0, -1 ); // Clear Hist Buffer

    if not MediaFileCopyFlag then
    begin

    // Image Data
      SFlags := SFlags - [cmsfHasSrcImg];
      SFlags := SFlags + [cmsfSaveSrcImg];

      UDDataRoot := DirChild(K_CMSlideIndCurImg);
      if (UDDataRoot <> nil) and
         ((UDDataRoot.ObjFlags and K_fpObjSLSRFlag) <> 0) then
      begin
        // Slide Stored in Local Archive - Remove Current Image Section
        K_CMEDAccess.EDAGetSlideCurImage(Result);
        UDDataRoot := UDDataRoot.DirChild(0);
        PutDirChild(K_CMSlideIndCurImg, UDDataRoot);
      end;

      // Apply Flip/Rotate/BriCoGam to Current if needed
      GetImgViewConvData(@ImgViewConvData);
      with ImgViewConvData do
      if (VCCoFactor  <> 0) or
         (VCGamFactor <> 0) or
         (VCBriFactor <> 0) or
         (VCBriMinFactor <> 0) or
         ((VCBriMaxFactor > 0) and
          (VCBriMaxFactor < 100)) or
         VCNegateFlag          or
         (VCFlipRotateAttrs <> 0) then
      begin
      // Apply BriCoGam or FlipRotate to DIB is needed
        VCShowEmboss := false;
        VCShowColorize := false;
        VCShowIsodensity := false;
        CurDIBObj := nil;
        with TN_UDDIB(UDDataRoot) do
        begin
          LoadDIBObj();
          K_CMConvDIBBySlideViewConvData(CurDIBObj, DIBObj, @ImgViewConvData,
            DIBObj.DIBPixFmt, DIBObj.DIBExPixFmt);
          DIBObj.Free;
          DIBObj := CurDIBObj;
          UDData := nil;
          Include( PISP^.CDIBFlagsN, uddfnFreeUDData );
        end;
      end;

      // Clear Slide Image MapRoot Attributes - FlipRotate, BriCoGam, MRFlags (Slide Image MapRoot Flags)
      FillChar(GetPMapRootAttrs()^, SizeOf(TK_CMSMRImgAttrs), 0);
    end
    else
    begin
      // Media File
      if SFName <> '' then
      begin
        // Copy Media Data
        SetMediaFileTMPName('');
        AddMediaFile(SFName);
      end;
    end;
  end;

end; // end of K_CMCopySlideWithoutSrcImg

//********************************************************** K_CMSlidesPasteFromClipboard0 ***
// Paste Slides from Clipboard without original Image
//
//     Parameters
// AProcessMessagesFlag - if TRUE then Application.ProcessMessages will be called after
//                        each duplicated slide
// ANumOutOfMemory - number of out of memory slides
// Result - Returns number of slides pasted from Clipboard
//
function K_CMSlidesPasteFromClipboard0( AProcessMessagesFlag : Boolean; out ANumOutOfMemory : Integer ): Integer;
var
  i: Integer;
  NewUObj: TN_UDBase;
  SrcSlide: TN_UDCMSlide;
  // UDMedia : TN_UDFile;
  SavedCursor: TCursor;
  Last: Integer;
  HistActCode : Integer;
  DupSlides  : TN_UDCMSArray;
begin
  Last := Length(K_CMSlidesClipBoardArray) - 1;
  SavedCursor := Screen.Cursor;
  Screen.Cursor := crHourglass;
  HistActCode := K_CMEDAccess.EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCADuplicate));
  N_CM_MainForm.CMMFShowString( K_CML1Form.LLLDupl1.Caption
//    ' Duplicating media object(s) ... Please wait'
                               );
  Result := 0;
  ANumOutOfMemory := 0;
  if K_CMEDAccess is TK_CMEDDBAccess then
    SetLength( DupSlides, Last + 1 );
  for i := 0 to Last do
  begin
    SrcSlide := K_CMSlidesClipBoardArray[i];

    NewUObj := K_CMCopySlideWithoutSrcImg( SrcSlide );
    if (Integer(NewUObj) < 100) then
    begin
      if Integer(NewUObj) = 1 then
        Inc(ANumOutOfMemory);
      Continue;
    end;


    K_CMSlideInitByCurContext(TN_UDCMSlide(NewUObj));
    TN_UDCMSlide(NewUObj).P.CMSSourceDescr := format(
                        'Media Object (ID %s) duplicate',
                         [SrcSlide.ObjName] );

    // Save Statistics about duplicated Slide to Slide Hist Buffer or
    // save Slide to Duplicated Slides buffer for future Save Statistics directly to DB
    if K_CMEDAccess is TK_CMEDDBAccess then
      DupSlides[Result] := SrcSlide // add Slide to really Duplicated Slides buffer for future use
    else
      with K_CMEDAccess do          // add Statistics to Slide Hist Buffer
        EDAAddHistActionToSlideBuffer( SrcSlide, HistActCode );

    K_CMEDAccess.EDAAddSlide(NewUObj);
    K_CMEDAccess.SaveSlidesList.Add(NewUObj);
    K_CMEDAccess.EDASaveSlidesList(K_CMEDAccess.SaveSlidesList);
    // Save after paste Save by List
    N_CM_MainForm.CMMFShowString( format( K_CML1Form.LLLDupl2.Caption,
//      ' %d of %d done',
                                  [i + 1, Last + 1]));
    if AProcessMessagesFlag then
      Application.ProcessMessages();
    Inc(Result);
  end; //   for i := 0 to Last do

  // Save Statistics about duplicated Slides directly to DB
  if (K_CMEDAccess is TK_CMEDDBAccess) and (Result > 0) then
    K_CMEDAccess.EDASaveSlidesListHistory( @DupSlides[0], Result, HistActCode );

  K_CMEDAccess.SaveSlidesList.Clear;

  Screen.Cursor := SavedCursor;
  if Result = 0 then
    N_CM_MainForm.CMMFShowString('');

end; // end of K_CMSlidesPasteFromClipboard0

//******************************* K_CMSetCurSessionContext ***
// Set current Patient, Provider, Location context
//
//     Parameters
// ANCPatientID   - new Patient ID
// ANCProviderID  - new Provider ID
// ANCLocationID  - new Location ID
// APCMSlideFilterAttrs - pointer to slides filtering attributes
// Result - Returns
//  0 - ECache Check is not needed
//  1 - ECache Check is needed
// -1 - Set context fails because new patient is locked on CMS change context
// -2 - Set context fails because new patient is locked on CMS start
//
function K_CMSetCurSessionContext( ANCPatientID, ANCProviderID, ANCLocationID: Integer;
                                   APCMSlideFilterAttrs: TK_PCMSlideFilterAttrs = nil ): Integer;
var
  ApplicatonStart: Boolean;
  RebuildView: Boolean;
  FilesAreMoving: Boolean;
  NoImageFilesPath: Boolean;
  NoMediaFilesPath: Boolean;
  CheckFSSettingsCode: Integer;
  ML: TStrings;
  PID: PString;
  MesStr: string;
  CMEDResult: TK_CMEDResult;
  ServAction: TAction;
  SlidesIniCRFC: TK_ChangeRootFolderContext; // Slides Change Root Folder Context from Ini-file
  ChangePatient: Boolean;
  ChangeProvider: Boolean;
  ChangeLocation: Boolean;
  ChangePatientOrProvider: Boolean;

  RebuildCurSlidesSetFlag : Boolean;
  NewSlidesCount, DelSlidesCount, UpdateSlidesCount : Integer;

begin
  with K_CMEDAccess do
  N_Dump2Str( format('K_CMSetCurSessionContext start cur Pat=%d Prov=%d Loc=%d', [CurPatID,CurProvID,CurLocID] ) );

  if K_CMDCMUIDPrefix = '' then
    K_CMDCMUIDPrefix := CentaurSoftwareUID + '.' + K_GetDICOMUIDComponentFromGUID31( K_CMEDAccess.EDAGetDBUID() );

  K_CMD4WCNewPatientID := -1; // Clear D4W Client Request Flag
  K_CMD4WSkipCMSAwakeFlag := FALSE; // Clear Skip CMS Awake Flag
  K_CMShowArchivedSlidesFlag := FALSE;

  with K_CMEDAccess do // Application Start
    ApplicatonStart := (CurPatID = -1) and (CurProvID = -1) and (CurLocID = -1);
  RebuildView := false;

  ChangeLocation := ANCLocationID <> K_CMEDAccess.CurLocID;
  ChangeProvider := ANCProviderID <> K_CMEDAccess.CurProvID;
  ChangePatient  := ANCPatientID <> K_CMEDAccess.CurPatID;


  ChangePatientOrProvider := ChangeProvider or ChangePatient;
  Result := 0;
  if ChangePatientOrProvider then
    Result := 1;
  RebuildView := ApplicatonStart or RebuildView or
                 ChangePatientOrProvider or
                 ChangeLocation or
                 ( (APCMSlideFilterAttrs <> nil) and
                   not CompareMem( APCMSlideFilterAttrs,
                                   @K_CMCurSlideFilterAttrs,
                                   SizeOf(TK_CMSlideFilterAttrs ) ) );
//!!  SaveCurrentState();
  if not ApplicatonStart then
  begin
    if RebuildView then
      N_CM_MainForm.CMMFFreeEdFrObjects();

    with K_CMEDAccess do
      if (StateSaveMode = K_cmetContextChange) or RebuildView then
        EDASaveContextsData( [K_cmssSkipSlides] ); // Save previous state
  end;

  // Update PPL data by Link Info (may be needed in EDALockActiveContext1)
  if K_CMEDAccess.UpdatePPLFlagsSet <> [] then
  begin
    TK_CMEDDBAccess(K_CMEDAccess).EDASAUpdateOneLocationByLinkInfo( @K_CMSCLLAttrs.LocationAttrs );
    TK_CMEDDBAccess(K_CMEDAccess).EDASAUpdateOneProviderByLinkInfo( @K_CMSCLLAttrs.ProviderAttrs );
    if K_CMSCLLAttrs.ProviderAttrs.CLLUID <> -1 then
      K_CMSCLLAttrs.PatientAttrs.CMSPProvID := K_CMSCLLAttrs.ProviderAttrs.CLLUID
    else
      K_CMSCLLAttrs.PatientAttrs.CMSPProvID := ANCProviderID;
    TK_CMEDDBAccess(K_CMEDAccess).EDASAUpdateOnePatientByLinkInfo( @K_CMSCLLAttrs.PatientAttrs );
    K_CMSCLLAttrs.PatientAttrs.CLLPID := -1; // Clear Patient ID as flag that K_CMSCLLAttrs are already used
  end;

  if ApplicatonStart or ChangeLocation or ChangePatientOrProvider then
  begin
  // Lock New Active Context
    while K_edFails = K_CMEDAccess.EDALockActiveContext1( ANCPatientID, ANCProviderID, ANCLocationID ) do
    begin
      // Resume uncompleted and wait for executed Patient CopyMove
      if not K_CMAllPatObjCopyMoveResumeAndWait( ANCPatientID ) then
      begin
      // Break by use
        Result := -1;
        if ApplicatonStart then Result := -2;
        N_Dump1Str( 'K_CMSetCurSessionContext >> User break dialog =' + IntToStr(Result) );
        Exit;
      end; // if not K_CMAllPatObjCopyMoveResumeAndWait
    end; // while K_edFails = K_CMEDAccess.EDALockActiveContext1

  end; // if ApplicatonStart or ChangeLocation or ChangePatientOrProvider then

  N_Dump1Str( format( 'SetCurSessionContext >> PatID=%d ProvID=%d LocID=%d',
                      [ANCPatientID, ANCProviderID,ANCLocationID] ) );
  // Set New Context
  RebuildCurSlidesSetFlag := K_CMEDAccess.CurSlidesSelectAttrs.SSPatID <> ANCPatientID;
  CMEDResult := K_CMEDAccess.EDAAppContextToCurState(ANCPatientID, ANCProviderID, ANCLocationID);

  if ApplicatonStart or ChangeLocation then
    K_CMInitMouseMoveRedraw( );

  K_CMEDAccess.EDAGetSlidesFPathContext();

  // Check Files Handling
  FilesAreMoving := CMEDResult = K_edImageFilesMoving;
  K_CMEDAccess.EDAMemIniFilesMovingInfoToCurState(@SlidesIniCRFC);
  if not FilesAreMoving then
  begin
    FilesAreMoving := SlidesIniCRFC.RootFolder <> '';
    if FilesAreMoving then
      K_CMEDAccess.SlidesCRFC := SlidesIniCRFC;
  end;
  CheckFSSettingsCode := K_CMEDAccess.EDACheckFSSettings();

  NoImageFilesPath := (CheckFSSettingsCode and 4) <> 0;
  NoMediaFilesPath := (CheckFSSettingsCode and 3) <> 0;
  if NoImageFilesPath and NoMediaFilesPath and
     (K_CMEDAccess is TK_CMEDDBAccess) then
    TK_CMEDDBAccess(K_CMEDAccess).SlidesMediaImgSameDrive := TRUE;

  with N_CM_MainForm do
  begin
    // Rebuild CMS View
    if RebuildView then
    begin
      N_Dump2Str( 'Rebuild View start' );
      K_CMSlidesClipBoardArray := nil; // Clear Slides from Clipboard
      // CMMFFreeEdFrObjects();
      if not FilesAreMoving and
        (CheckFSSettingsCode = 0) then
      begin
        // Local Archive or Defined Patient
        if ChangePatientOrProvider  then
        begin
          K_CMMarkAsDelShowFlag := FALSE;
          N_CMResForm.aViewDisplayDel.Checked := FALSE;

          K_CMShowArchivedSlidesFlag := FALSE;
          N_CMResForm.aViewDisplayArchived.Checked := FALSE;

          if ChangePatient then K_CMEDAccess.PatSlidesAutoRefreshTS := 0;

        end;
//        K_CMEDAccess.EDAGetCurSlidesSet();
        if RebuildCurSlidesSetFlag then
          K_CMEDAccess.EDAGetCurSlidesSet()
        else
          K_CMEDAccess.EDARefreshCurSlidesSet( NewSlidesCount, DelSlidesCount, UpdateSlidesCount );

////////////////////////////////
// !!! 2013-10-14 obsolete code
//
        if not (K_CMEDAccess is TK_CMEDDBAccess) then
        begin // Special Start Local Archive - may be obsolete!!!
          // if Patient Code was set to -1 - any patient mode
          K_CMEDAccess.CurPatID := K_CMEDAccess.CurSlidesSelectAttrs.SSPatID;
          if K_CMEDAccess.CurPatID = -1 then
          begin
            PID := nil;
            if K_CMEDAccess.PatientsInfo <> nil then
              PID := PString(K_CMEDAccess.PatientsInfo.R.PME(0, 1));
            if PID = nil then
              K_CMShowMessageDlg( //sysout
                 'Local Archive Patient Table Data is absent', {sysout}
                 mtWarning )
            else
            begin
              K_CMEDAccess.CurPatID := StrToIntDef(PID^, -1);
              K_CMEDAccess.CurSlidesSelectAttrs.SSPatID := K_CMEDAccess.CurPatID;
              K_CMEDAccess.EDAGetCurSlidesSet();
            end;
          end; // if K_CMEDAccess.CurPatID = -1 then
        end; // if not (K_CMEDAccess is TK_CMEDDBAccess) then
//
// !!! 2013-10-14 obsolete code
////////////////////////////////


////////////////////////////////
// !!! 2013-10-14 obsolete code
//
        if APCMSlideFilterAttrs = nil then
          K_CMFilterAttrsClear(@K_CMCurSlideFilterAttrs)
        else
          K_CMCurSlideFilterAttrs := APCMSlideFilterAttrs^;
//
// !!! 2013-10-14 obsolete code
////////////////////////////////

      end; // if not FilesAreMoving and (CheckFSSettingsCode = 0) then

      if CMMCurFThumbsRFrame <> nil then
      begin // Not needed for support
        K_CMRebuildSlidesFilterMTypes();
        CMMFRebuildVisSlides();
      end;

      if K_CMGAModeFlag and
        (ChangePatientOrProvider or ChangeLocation) and
         not K_CMGAModeSkipAutoClearFlag then
      begin
        K_CMEDAccess.EDAClearGAMode();
      end;
      N_Dump2Str( 'Rebuild View fin' );
    end; // if RebuildView then
//    N_Dump2Str( 'K_CMSetCurSessionContext 1' );

    K_CMCurUserAccessRights := K_CMEDAccess.EDAGetProviderAccessRights( K_CMEDAccess.CurProvID );
//    K_CMCurUserAccessRights := [K_uarStart];
    if not K_CMSCheckStartAccessRights() then
    begin
      if not K_CMEDAccess.AccessReady then Exit; // Application is started
    end;

    if (K_CMEDAccess is TK_CMEDDBAccess) and (K_CMEDDBVersion >= 13) then
    begin
    // Save History Start CMS and Session Actions
      N_Dump2Str( 'Save Start History start' );
      with K_CMEDAccess do
      begin
        if CurSessionHistID = 0 then
           EDAAddSessionHistRecord(); // Create CurHistSession if relaunch after HRPreview

        if not K_CMEDAccess.AccessReady then // Application is started
          EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                             Ord(K_shNCACMSStart) ) );
        if RebuildView then
        begin
          Sleep(30);  // for time shift between CMSStart and SessionStart event
          EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                             Ord(K_shNCAStartSession) ) );
        end;
      end;
      N_Dump2Str( 'Save Start History fin' );
    end;

    if K_CMSAppStartContext.CMASMode >= K_cmamCOMWEB then // CMS application is started by WEB server - Exit without UI setting by new context
    begin
      N_Dump2Str( 'K_CMSetCurSessionContext fin WO UI setting' );
      Exit;
    end;

    N_Dump2Str( 'Update UI start' );
    if K_CMEDAccess.AccessReady    or    // CMS Application was already started
      not K_CMD4WAppRunByCOMClient or    // CMS application is started now not by D4W Client (as Standalone, DEMO or Desighn Mode)
      (K_CMSAppStartContext.CMASMode = K_cmamCOMVEUI) then // CMS application is started by D4W Client and Session Context was recieved from D4W
//      K_CMD4WSetCurDataContext then   // CMS application is started by by D4W Client and Session Context was recieved from D4W
    begin
//      N_Dump2Str( 'K_CMSetCurSessionContext 2' );
//!!!  move down     ML := K_CMEDAccess.EDAGetPatientMacroInfo();
      if FilesAreMoving or (CheckFSSettingsCode <> 0) then
      begin
        // CMS should be locked (by FilesHandling State or something else)
        ServAction := nil;
        if FilesAreMoving then
        begin
          MesStr := K_CML1Form.LLLSetSessionCont1.Caption;
//            'Files are moving to new location! Wait before process complete.';
//!!! 2013-09-23 - new flag uicsServActsEnable is used instead
//  CurPatID = -1 condition is not used to lock CMS activity
//          K_CMEDAccess.CurPatID := -1; // Is Locked by Files Moving Flag
          Include( CMMUICurStateFlags, uicsAllActsDisabled);
{
          with K_CMEDAccess, SlidesCRFC do
//!!! 2016-02-08 All providers can continue Files Handling
          if CurProvID = OpProvID then
          begin
            // Same Provider Activates CMS - Call Dialog to Continue Operation
            ServAction := N_CMResForm.aServFilesHandling;
            Include(CMMUICurStateFlags, uicsServActsEnable);
          end;
}
          ServAction := N_CMResForm.aServFilesHandling;
          Include(CMMUICurStateFlags, uicsServActsEnable);
        end   // if FilesAreMoving then
        else
        begin // if not FilesAreMoving then
          if NoImageFilesPath then
          begin
            if not NoMediaFilesPath then
              MesStr := K_CML1Form.LLLSetSessionCont2.Caption
//                      'Image Files Folder is undefined!'
            else
              MesStr := K_CML1Form.LLLSetSessionCont3.Caption;
//                      'Image and Video Files Folders are undefined!';
//!!! 2013-09-23 - new flag uicsServActsEnable is used instead
//  CurPatID = -1 condition is not used to lock CMS activity
//            K_CMEDAccess.CurPatID := -1; // Is Locked by No ImageFilesPath Flag
//            ServAction := N_CMResForm.aServFilesHandling;
            CMMUICurStateFlags := CMMUICurStateFlags + [uicsServActsEnable, uicsAllActsDisabled];
          end
          else if NoMediaFilesPath then
          begin
            MesStr := K_CML1Form.LLLSetSessionCont4.Caption;
//                    'Video Files Folder is undefined!';
//!!! 2013-09-23 - new flag uicsServActsEnable is used instead
//  CurPatID = -1 condition is not used to lock CMS activity
//            K_CMEDAccess.CurPatID := -1; // Is Locked by No MediaFilesPath Flag
//            ServAction := N_CMResForm.aServFilesHandling;
            CMMUICurStateFlags := CMMUICurStateFlags + [uicsServActsEnable, uicsAllActsDisabled];
          end;
        end; // if not FilesAreMoving then

        K_CMShowMessageDlg1(MesStr, mtWarning);
        if ServAction <> nil then
          N_CM_MainForm.CMMCallActionByTimer(ServAction, TRUE);

//1        CMMFDisableActions( nil );
      end  // if PatientIsLocked or FilesAreMoving or (CheckFSSettingsCode <> 0) then
      else
      begin
        // CMS is ready to work - set window cation
//        N_Dump2Str( 'K_CMSetCurSessionContext 3' );
        ML := K_CMEDAccess.EDAGetPatientMacroInfo();
        K_CMBuildUICaptionsByCurContext( ML );
//1        CMMFDisableActions( nil );
//0        if not (K_uarStart in K_CMCurUserAccessRights) then
//0          CMMFDisableActions( nil );
      end;
//      N_Dump2Str( 'K_CMSetCurSessionContext 4' );
    end // if K_CMEDAccess.AccessReady or ...
    else
    begin // if K_CMEDAccess.AccessReady else
      // K_CMEDAccess.AccessReady is not ready
      CMMCurFMainForm.Caption := K_CMMessageDlgDefaultCaption;
      Application.Title := K_CMMessageDlgDefaultCaption;
    end;

//    N_Dump2Str( 'K_CMSetCurSessionContext 5' );
    if ChangeProvider then
    begin
      CMMUpdateUIByCTA();
      CMMUpdateUIByFilterProfiles();
    end;

    if K_CMDebVersionModeFlag then
      CMMCurFMainForm.Caption := K_CMSMainFormCaptPref1 + CMMCurFMainForm.Caption;
//                              '[Deb]' + CMMCurFMainForm.Caption;
    if K_CMGAModeFlag then
      CMMCurFMainForm.Caption := K_CMSMainFormCaptPref2 + CMMCurFMainForm.Caption;
//      CMMCurFMainForm.Caption := '[Admin] ' + CMMCurFMainForm.Caption;

    if ChangeProvider or ChangeLocation then
      CMMUpdateUIByDeviceProfiles();

    N_Dump2Str( 'Update UI fin' );

//    N_Dump2Str( 'K_CMSetCurSessionContext 6' );
    CMMFDisableActions( nil );

  end; // with N_CM_MainForm

  K_CMD4WHPNewPatientID    := K_CMEDAccess.CurPatID;  // D4W HP New Patient ID
  K_CMD4WHPNewProviderID   := K_CMEDAccess.CurProvID; // D4W HP New Provider ID
  K_CMD4WHPNewLocationID   := K_CMEDAccess.CurLocID;  // D4W HP New Location ID

  N_Dump2Str( 'K_CMSetCurSessionContext fin' );

end; // end of fumction K_CMSetCurSessionContext

//*********************************************** K_CMSetCurSessionContext1 ***
// Set current Patient, Provider, Location context
//
//     Parameters
// ANCPatientID   - new Patient ID
// ANCProviderID  - new Provider ID
// ANCLocationID  - new Location ID
// APCMSlideFilterAttrs - pointer to slides filtering attributes
// Result - Returns TRUE if ECache Check is Needed
//
procedure K_CMSetCurSessionContext1( ANCPatientID, ANCProviderID, ANCLocationID: Integer;
                                     APCMSlideFilterAttrs: TK_PCMSlideFilterAttrs );
var
  SetContexResult : Integer;
begin
  N_Dump2Str('DB >> New Context Set State PatID=' + IntToStr(ANCPatientID)
      + ' ProvID=' + IntToStr(ANCProviderID) + ' LocID=' + IntToStr(ANCLocationID));
  SetContexResult := K_CMSetCurSessionContext( ANCPatientID, ANCProviderID,
                                               ANCLocationID, APCMSlideFilterAttrs );

  N_Dump2Str( format( 'K_CMSetCurSessionContext1 >> SetContextResult=%d', [SetContexResult] ) );
  with N_CM_MainForm do
    if not (K_uarStart in K_CMCurUserAccessRights) or
       (SetContexResult = -2) then
    begin
      Include( CMMUICurStateFlags, uicsAllActsDisabled);
      if SetContexResult <> -2 then
        N_Dump1Str('K_CMSetCurSessionContext1 >> CMS User Access Rights are absent')
      else
        N_Dump1Str( format( 'K_CMSetCurSessionContext1 >> Patient ID=%d is locked by CopyMove.', [ANCPatientID] ) );
      CMMCallActionByTimer( N_CMResForm.aServCloseCMS, TRUE );
    end
    else
    if (SetContexResult = 1) then
    begin
      Exclude( CMMUICurStateFlags, uicsAllActsDisabled);
      if (K_CMEDAccess is TK_CMEDDBAccess) then
        N_CMResForm.aServECacheCheckExecute( nil );
    end;

  N_Dump2Str('K_CMSetCurSessionContext1 fin');
end; // procedure K_CMSetCurSessionContext1

//******************************* K_CMBuildUICaptionsByCurContext ***
// Rebuild Application and Main Form Captions by current Patient?Provider?Location context
//
procedure K_CMBuildUICaptionsByCurContext( AML : TStrings = nil );
var
  FullInitFlag : Boolean;
  TitleBarPat : string;
begin
  with N_CM_MainForm do
  begin
    FullInitFlag := AML = nil;
    if FullInitFlag then
      AML := K_CMEDAccess.EDAGetPatientMacroInfo();
    K_CMEDAccess.EDAGetProviderMacroInfo(-1, AML, TRUE);
    K_CMEDAccess.EDAGetLocationMacroInfo(-1, AML, TRUE);
    AML.Add( 'RegAppName=' + N_MemIniToString( 'RegionTexts', 'CMSuiteProductName', 'MediaSuite' ) );

//    Application.Title := K_StringMListReplace(K_CMENPTAppTaskBar, AML, K_ummRemoveMacro);
    Application.Title := K_StringMListReplace( K_CML1Form.LLLMPatAppTaskBar.Caption, AML, K_ummRemoveMacro);

//!!!    if CMMCurFMainForm = nil then Exit; // Sometimes if Application Paths Problems then CMMCurFMainForm is not set

    TitleBarPat := K_CML1Form.LLLMPatAppTitleBar.Caption;
    if K_CMShowEnterprise() then
      TitleBarPat := K_CML1Form.LLLMPatAppVIPTitleBar.Caption;
    CMMCurFMainForm.Caption := K_StringMListReplace( TitleBarPat, AML, K_ummRemoveMacro );

    if not FullInitFlag then Exit;

    if K_CMDebVersionModeFlag then
      CMMCurFMainForm.Caption := K_CMSMainFormCaptPref1 + CMMCurFMainForm.Caption;
//      CMMCurFMainForm.Caption := '[Deb]' + CMMCurFMainForm.Caption;
    if K_CMGAModeFlag then
      CMMCurFMainForm.Caption := K_CMSMainFormCaptPref2 + CMMCurFMainForm.Caption;
//      CMMCurFMainForm.Caption := '[Admin] ' + CMMCurFMainForm.Caption;
  end; // with N_CM_MainForm

end; // end of  K_CMBuildUICaptionsByCurContext

//******************************* K_CMRebuildSlidesFilterMTypes ***
// Rebuild Main Form SlidesFilterFrame MediaTypesList
//
procedure K_CMRebuildSlidesFilterMTypes();
begin
  if N_CM_MainForm.CMMCurSlideFilterFrame <> nil then
    N_CM_MainForm.CMMCurSlideFilterFrame.SFInit();
end; // end of  K_CMRebuildSlidesFilterMTypes

{ New Version GUI Devices order is defined by Devices Common List
- from Right to Left
- DropDown Button's List contains Button Self profile

//************************************* K_CMUpdateUIByDeviceProfiles0 ***
// Update Capturing User Interface Menu and ToolBar Items
//
//     Parameters
// ACaptMenuItem - MenuItem to replace elements for Capturing Devices
// AFirstInd     - MenuItem first replacing element index
// ALastInd      - MenuItem last replacing element index, if < 0 then real
// ALastInd = ACaptMenuItem + ALastInd (-1 means last item)
//
procedure K_CMUpdateUIByDeviceProfiles0(ACaptMenuItem: TMenuItem;
  AFirstInd: Integer; ALastInd: Integer = -1);
var
  i, NumItems, CurDynMainImgInd, AllDevCount: Integer;
  NewMenuItem: TMenuItem;
  NewToolButton: TToolButton;
  AddMenuItem: Boolean;
  TmpBitmap: TBitmap;
  UDDevices : TK_UDRArray;
  PCMDevProfListElem : TK_PCMDevProfListElem;
  PUMenu : TPopupMenu;

begin
  with N_CM_MainForm, N_CMResForm do
  begin
    // ***** Delete previous MenuItems in Given MenuItem
    if ALastInd < 0 then
      ALastInd := ACaptMenuItem.Count + ALastInd;
    for i := AFirstInd to ALastInd do
      ACaptMenuItem.Items[AFirstInd].Free;

    // AddMenuItem := ACaptMenuItem.Count = AFirstInd;
    AddMenuItem := TRUE;

    // ***** Delete all Buttons in Capture ToolBar
    NumItems := CMMCurCaptToolBar.ButtonCount;
    for i := 1 to NumItems do
    begin
      CMMCurCaptToolBar.Buttons[0].DropdownMenu.Free();
      CMMCurCaptToolBar.Buttons[0].Free();
    end;

//    K_CMDynIconsSInd := CMMCurSmallIcons.Count;
    // ***** Delete all Dynamic Icons
    for i := MainIcons18.Count - 1 downto K_CMDynIconsSInd do
    begin
      MainIcons18.Delete(i);
      CMMCurBigIcons.Delete(i);
    end;

    CurDynMainImgInd := K_CMDynIconsSInd;

    // ***** Create new GUI Elements by Profiles List
    AllDevCount := K_CMEDAccess.ProfilesList.ALength();
    PUMenu := nil;
    CMMDevGroupTButton := nil;

//    for i := AllDevCount - 1 downto 0 do
    for i := 0 to AllDevCount - 1  do
    begin

      PCMDevProfListElem := TK_PCMDevProfListElem(K_CMEDAccess.ProfilesList.PDE(i));
      UDDevices := TK_UDRArray(PCMDevProfListElem.CMDPLEARef);
      with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
      begin
        if CMDPDelphiAction = nil then
          CMDPDelphiAction := TAction.Create(N_CMResForm);

        with CMDPDelphiAction do
        begin
          Caption := CMDPCaption;
          Hint := 'Capture from ' + CMDPCaption + '|' + 'Capture from ' +
            CMDPCaption;
          ShortCut := TextToShortCut(CMDPShortCut);

          if CMDPDynSIcon = nil then // Static Icon
            ImageIndex := CMDPImageIndex
          else
          begin // Dynamic Icon
            // Add Small Dyn Icon
            with CMDPDynSIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
              MainIcons18.AddMasked(TmpBitmap, DIBTranspColor);
            end;
            // Add Big Dyn Icon
            with CMDPDynBIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
//                MainIcons44.AddMasked(TmpBitmap, DIBTranspColor);
              CMMCurBigIcons.AddMasked(TmpBitmap, DIBTranspColor);
            end;

            ImageIndex := CurDynMainImgInd;
            CMDPImageIndex := CurDynMainImgInd;
            Inc(CurDynMainImgInd);
          end;

          Tag := PCMDevProfListElem.CMDPLEAInd;
          if UDDevices = K_CMEDAccess.TwainProfiles then
            OnExecute := TwainOnExecuteHandler
          else
          if UDDevices = K_CMEDAccess.OtherProfiles then
            OnExecute := OtherOnExecuteHandler
          else
            OnExecute := VideoOnExecuteHandler;

        end;

        NewMenuItem := TMenuItem.Create(CMMCurMainMenu);
        NewMenuItem.Action := CMDPDelphiAction;
        if AddMenuItem then
          ACaptMenuItem.Add(NewMenuItem)
        else
          ACaptMenuItem.Insert(AFirstInd, NewMenuItem);

        if i >= K_CMDevToolButMaxCount - 1 then
//          if i >= K_CMDevToolButMaxCount - 1 then
        begin
          if i = K_CMDevToolButMaxCount - 1 then
          begin
          // ***** Create DropDown Menu for Last ToolButton
            PUMenu := TPopupMenu.Create(N_CM_MainForm);
            PUMenu.Images := MainIcons18;
          end;
        // ***** Add new Item to DropDown Menu for Last ToolButton
          NewMenuItem := TMenuItem.Create(PUMenu);
          NewMenuItem.Action := CMDPDelphiAction;
          PUMenu.Items.Add(NewMenuItem);
          if i = AllDevCount - 1 then
          begin
          // ***** Add DropDown Menu to Last ToolButton
            NewToolButton := TToolButton.Create(CMMCurCaptToolBar);

            CMMDevGroupInd := Min( CMMDevGroupInd, PUMenu.Items.Count - 1 );
            if CMMDevGroupInd > 0 then
              NewToolButton.Action := PUMenu.Items[CMMDevGroupInd].Action
            else
              NewToolButton.Action := PUMenu.Items[0].Action;

            NewToolButton.Parent := CMMCurCaptToolBar;
            NewToolButton.DropdownMenu := PUMenu;
            NewToolButton.Style := tbsDropDown;
            CMMDevGroupTButton := NewToolButton;
          end;
        end
        else
        begin
          // ***** Add new ToolButton to Capture Toolbar
          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);
          NewToolButton.Action := CMDPDelphiAction;
          NewToolButton.Parent := CMMCurCaptToolBar;
        end;

      end; // for i := High(CMTwainProfiles) downto 0 do // along all TWAIN devices

    end; // for i := K_CMEDAccess.ProfilesList.AHigh downto 0 do
  end; // with  N_CM_MainForm, N_CMResForm do

  K_CMUpdateUnUsedShortCuts();

end; // procedure K_CMUpdateUIByDeviceProfiles0
{}

{ New Version GUI Devices order is defined by Devices Common List
- from Left to Right
- DropDown Button's List do not contains Button Self profile
}
{!!! Version with Device limitation - extra devices is set disabled
//************************************* K_CMUpdateUIByDeviceProfiles0 ***
// Update Capturing User Interface Menu and ToolBar Items
//
//     Parameters
// ACaptToolBar  - ToolBar to Replace elements
// ACaptMenuItem - MenuItem to replace elements for Capturing Devices
// AFirstInd     - MenuItem first replacing element index
// ALastInd      - MenuItem last replacing element index, if < 0 then real
// ALastInd = ACaptMenuItem + ALastInd (-1 means last item)
//
procedure K_CMUpdateUIByDeviceProfiles0( ACaptMenuItem: TMenuItem;
  AFirstInd: Integer; ALastInd: Integer = -1);
var
  i, NumItems, CurDynMainImgInd, AllDevCount: Integer;
  NewMenuItem: TMenuItem;
  NewToolButton: TToolButton;
  AddMenuItem: Boolean;
  TmpBitmap: TBitmap;
  UDDevices : TK_UDRArray;
  PCMDevProfListElem : TK_PCMDevProfListElem;
  PUMenu : TPopupMenu;
  UseValidationFlag : Boolean;
begin
  with N_CM_MainForm, N_CMResForm do
  begin
    // ***** Delete previous MenuItems in Given MenuItem
    if ALastInd < 0 then
      ALastInd := ACaptMenuItem.Count + ALastInd;
    for i := AFirstInd to ALastInd do
      ACaptMenuItem.Items[AFirstInd].Free;

    // AddMenuItem := ACaptMenuItem.Count = AFirstInd;
    AddMenuItem := false;

    // ***** Delete all Buttons in Capture ToolBar
    NumItems := CMMCurCaptToolBar.ButtonCount;
    for i := 1 to NumItems do
    begin
      CMMCurCaptToolBar.Buttons[0].DropdownMenu.Free();
      CMMCurCaptToolBar.Buttons[0].Free();
    end;

//    K_CMDynIconsSInd := CMMCurSmallIcons.Count;
    // ***** Delete all Dynamic Icons
    for i := MainIcons18.Count - 1 downto K_CMDynIconsSInd do
    begin
      MainIcons18.Delete(i);
      CMMCurBigIcons.Delete(i);
    end;

    CurDynMainImgInd := K_CMDynIconsSInd;

    // ***** Create new GUI Elements by Profiles List
    AllDevCount := K_CMEDAccess.ProfilesList.ALength();
    PUMenu := nil;
    CMMDevGroupTButton := nil;

    UseValidationFlag := K_CMLimitDevUseTypeNameValidation();

    for i := AllDevCount - 1 downto 0 do
    begin

      PCMDevProfListElem := TK_PCMDevProfListElem(K_CMEDAccess.ProfilesList.PDE(i));
      UDDevices := TK_UDRArray(PCMDevProfListElem.CMDPLEARef);
      with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
      begin
        if CMDPDelphiAction = nil then
          CMDPDelphiAction := TAction.Create(N_CMResForm);

        with CMDPDelphiAction do
        begin
          Caption := CMDPCaption;
          Hint := 'Capture from ' + CMDPCaption + '|' + 'Capture from ' +
            CMDPCaption;
          ShortCut := TextToShortCut(CMDPShortCut);

          if CMDPDynSIcon <> nil then
          else
          begin // Dynamic Icon
            // Add Small Dyn Icon
            with CMDPDynSIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
              MainIcons18.AddMasked(TmpBitmap, DIBTranspColor);
            end;
            // Add Big Dyn Icon
            with CMDPDynBIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
//                MainIcons44.AddMasked(TmpBitmap, DIBTranspColor);
              CMMCurBigIcons.AddMasked(TmpBitmap, DIBTranspColor);
            end;

            CMDPImageIndex := CurDynMainImgInd;
            Inc(CurDynMainImgInd);
          end;

          ImageIndex := CMDPImageIndex

          Tag := PCMDevProfListElem.CMDPLEAInd;


          OnExecute := VideoOnExecuteHandler;
          if UDDevices = K_CMEDAccess.TwainProfiles then
            OnExecute := TwainOnExecuteHandler
          else
          if UDDevices = K_CMEDAccess.OtherProfiles then
            OnExecute := OtherOnExecuteHandler;

          // Set Profile UI element disabled state
          if UseValidationFlag                         and
             (UDDevices <> K_CMEDAccess.VideoProfiles) and
             not K_CMLimitDevValidateTypeName(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd)) then
          begin
            OnExecute := nil;
            Enabled := FALSE;
          end;

        end;

        NewMenuItem := TMenuItem.Create(CMMCurMainMenu);
        NewMenuItem.Action := CMDPDelphiAction;
        if AddMenuItem then
          ACaptMenuItem.Add(NewMenuItem)
        else
          ACaptMenuItem.Insert(AFirstInd, NewMenuItem);

        // Skip Adding ToolButtons if User has not Rights to Capture
        if not (K_uarCapture in K_CMCurUserAccessRights) then Continue;

        // Add Capture Device Buttons to ToolBar

        if i >= K_CMDevToolButMaxCount then
        begin
          if PUMenu = nil then
          begin
          // ***** Create DropDown Menu for Last ToolButton
            PUMenu := TPopupMenu.Create(N_CM_MainForm);
            PUMenu.Images := MainIcons18;
          end;

        // ***** Add new Item to DropDown Menu for Last ToolButton
          NewMenuItem := TMenuItem.Create(PUMenu);
          NewMenuItem.Action := CMDPDelphiAction;
          PUMenu.Items.Insert(0, NewMenuItem);
        end  // if i >= K_CMDevToolButMaxCount then
        else // if i < K_CMDevToolButMaxCount then
        if (PUMenu <> nil) and (i = K_CMDevToolButMaxCount - 1) then
        begin
        // ***** Add DropDown Menu to Last ToolButton
          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);

          NewToolButton.Action := CMDPDelphiAction;

          NewToolButton.Parent := CMMCurCaptToolBar;
          NewToolButton.DropdownMenu := PUMenu;
          NewToolButton.Style := tbsDropDown;
          PUMenu := nil;
        end
        else
        begin // if (i < K_CMDevToolButMaxCount) and ((PUMenu = nil) or (i <> K_CMDevToolButMaxCount - 1))
          // ***** Add new ToolButton to Capture Toolbar
          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);
          NewToolButton.Action := CMDPDelphiAction;
          NewToolButton.Parent := CMMCurCaptToolBar;
        end;

      end; // with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
    end; // for i := K_CMEDAccess.ProfilesList.AHigh downto 0 do
  end; // with  N_CM_MainForm, N_CMResForm do

  K_CMUpdateUnUsedShortCuts();

end; // procedure K_CMUpdateUIByDeviceProfiles0
}
{!!! Version with Device limitation - extra devices is set invisible Varinat 2}
//************************************* K_CMUpdateUIByDeviceProfiles0 ***
// Update Capturing User Interface Menu and ToolBar Items
//
//     Parameters
// ACaptToolBar  - ToolBar to Replace elements
// ACaptMenuItem - MenuItem to replace elements for Capturing Devices
// AFirstInd     - MenuItem first replacing element index
// ALastInd      - MenuItem last replacing element index, if < 0 then real
// ALastInd = ACaptMenuItem + ALastInd (-1 means last item)
//
procedure K_CMUpdateUIByDeviceProfiles0( ACaptMenuItem: TMenuItem;
  AFirstInd: Integer; ALastInd: Integer = -1);
var
  i, NumItems, CurDynMainImgInd, AllDevCount: Integer;
  NewMenuItem: TMenuItem;
  NewToolButton: TToolButton;
  AddMenuItem: Boolean;
  TmpBitmap: TBitmap;
  UDDevices : TK_UDRArray;
  PCMDevProfListElem : TK_PCMDevProfListElem;
  PUMenu : TPopupMenu;
  RInd, RCount : Integer;
  ValidFlags : TN_IArray;

begin
  with N_CM_MainForm, N_CMResForm do
  begin
    // ***** Delete previous MenuItems in Given MenuItem
    if ALastInd < 0 then
      ALastInd := ACaptMenuItem.Count + ALastInd;
    for i := AFirstInd to ALastInd do
      ACaptMenuItem.Items[AFirstInd].Free;

    // AddMenuItem := ACaptMenuItem.Count = AFirstInd;
    AddMenuItem := false;

    // ***** Delete all Buttons in Capture ToolBar
    NumItems := CMMCurCaptToolBar.ButtonCount;
    for i := 1 to NumItems do
    begin
      CMMCurCaptToolBar.Buttons[0].DropdownMenu.Free();
      CMMCurCaptToolBar.Buttons[0].Free();
    end;

//    K_CMDynIconsSInd := CMMCurSmallIcons.Count;
    // ***** Delete all Dynamic Icons
    for i := MainIcons18.Count - 1 downto K_CMDynIconsSInd do
    begin
      MainIcons18.Delete(i);
      CMMCurBigIcons.Delete(i);
    end;

    CurDynMainImgInd := K_CMDynIconsSInd;

    // ***** Create new GUI Elements by Profiles List
    AllDevCount := K_CMEDAccess.ProfilesList.ALength();
    PUMenu := nil;
    CMMDevGroupTButton := nil;
    SetLength( ValidFlags, AllDevCount );
    RCount := AllDevCount;
    if K_CMLimitDevUseTypeNameValidation() then
    begin // Select Valid Profiles
      // Build Valid Profiles Inds
      for i := 0  to High(ValidFlags) do
      begin
        PCMDevProfListElem := TK_PCMDevProfListElem(K_CMEDAccess.ProfilesList.PDE(i));
        UDDevices := TK_UDRArray(PCMDevProfListElem.CMDPLEARef);
        if (UDDevices.ObjName = 'VideoProfiles') or
           K_CMLimitDevValidateTypeName(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd)) then Continue;
        ValidFlags[i] := -1;
        Dec(RCount);
      end; // for i := 0  to High(Inds) do

    end; // if UseInds then

    RInd := RCount - 1;
    N_Dump2Str( 'Rebuild Device UI:' );
    for i := AllDevCount - 1 downto 0 do
    begin

      PCMDevProfListElem := TK_PCMDevProfListElem(K_CMEDAccess.ProfilesList.PDE(i));
      UDDevices := TK_UDRArray(PCMDevProfListElem.CMDPLEARef);
      with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
      begin
        // Icons Should be added to ImageList for All (Valid and not Valid) Profiles
        // It is needed for future not Valid Profiles editing
        if CMDPDynSIcon <> nil then
        begin // Dynamic Icon
          // Add Small Dyn Icon
          with CMDPDynSIcon.DIBObj do
          begin
            TmpBitmap := CreateBitmap(DIBRect);
            MainIcons18.AddMasked(TmpBitmap, DIBTranspColor);
          end;
          // Add Big Dyn Icon
          with CMDPDynBIcon.DIBObj do
          begin
            TmpBitmap := CreateBitmap(DIBRect);
//                MainIcons44.AddMasked(TmpBitmap, DIBTranspColor);
            CMMCurBigIcons.AddMasked(TmpBitmap, DIBTranspColor);
          end;
          CMDPImageIndex := CurDynMainImgInd;
          Inc(CurDynMainImgInd);
        end; // Dynamic Icon

//V1        if  ValidFlags[i] < 0 then Continue; // Skip Controls creation for not valid profile

      // Create Action, MenuItem and ToolBar Button
        if CMDPDelphiAction = nil then
          CMDPDelphiAction := TAction.Create(N_CMResForm);

        with CMDPDelphiAction do
        begin
          Caption := CMDPCaption;
          Hint := 'Capture from ' + CMDPCaption + '|' + 'Capture from ' +
            CMDPCaption;
          ShortCut := TextToShortCut(CMDPShortCut);
          ImageIndex := CMDPImageIndex;

          Tag := PCMDevProfListElem.CMDPLEAInd;
          OnExecute := OtherOnExecuteHandler;
          if UDDevices = K_CMEDAccess.TwainProfiles then
            OnExecute := TwainOnExecuteHandler
          else
          if UDDevices = K_CMEDAccess.OtherProfiles3D then
            OnExecute := Other3DOnExecuteHandler
          else
          if UDDevices = K_CMEDAccess.VideoProfiles then
            OnExecute := VideoOnExecuteHandler;

        end; // with CMDPDelphiAction do

        NewMenuItem := TMenuItem.Create(CMMCurMainMenu);
        NewMenuItem.Action := CMDPDelphiAction;
        if AddMenuItem then
          ACaptMenuItem.Add(NewMenuItem)
        else
          ACaptMenuItem.Insert(AFirstInd, NewMenuItem);

        // Skip Adding ToolButtons if User has not Rights to Capture
//V1        if not (K_uarCapture in K_CMCurUserAccessRights) then Continue;
{//V2}  NewMenuItem.Visible := (ValidFlags[i] = 0);
        N_Dump2Str( format( '     %s >> Used=%s', [CMDPCaption, N_B2S(NewMenuItem.Visible)] ) );
{//V2}  if not (K_uarCapture in K_CMCurUserAccessRights) or (ValidFlags[i] < 0) then Continue;

        // Add Capture Device Buttons to ToolBar

        if RInd >= K_CMDevToolButMaxCount then
        begin
          if PUMenu = nil then
          begin
          // ***** Create DropDown Menu for Last ToolButton
            PUMenu := TPopupMenu.Create(N_CM_MainForm);
            PUMenu.Images := MainIcons18;
          end;

        // ***** Add new Item to DropDown Menu for Last ToolButton
          NewMenuItem := TMenuItem.Create(PUMenu);
          NewMenuItem.Action := CMDPDelphiAction;
          PUMenu.Items.Insert(0, NewMenuItem);
        end  // if i >= K_CMDevToolButMaxCount then
        else // if i < K_CMDevToolButMaxCount then
        if (PUMenu <> nil) and (RInd = K_CMDevToolButMaxCount - 1) then
        begin
        // ***** Add DropDown Menu to Last ToolButton
          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);

          NewToolButton.Action := CMDPDelphiAction;

          NewToolButton.Parent := CMMCurCaptToolBar;
          NewToolButton.DropdownMenu := PUMenu;
          NewToolButton.Style := tbsDropDown;
          PUMenu := nil;
        end
        else
        begin // if (i < K_CMDevToolButMaxCount) and ((PUMenu = nil) or (i <> K_CMDevToolButMaxCount - 1))
          // ***** Add new ToolButton to Capture Toolbar
          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);
          NewToolButton.Action := CMDPDelphiAction;
          NewToolButton.Parent := CMMCurCaptToolBar;
        end;
        Dec(RInd);
      end; // with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
    end; // for i := K_CMEDAccess.ProfilesList.AHigh downto 0 do
  end; // with  N_CM_MainForm, N_CMResForm do

  K_CMUpdateUnUsedShortCuts();

end; // procedure K_CMUpdateUIByDeviceProfiles0
{}
{!!! Version with Device limitation - extra devices is set invisible Varint 1 - icon errors
//************************************* K_CMUpdateUIByDeviceProfiles0 ***
// Update Capturing User Interface Menu and ToolBar Items
//
//     Parameters
// ACaptToolBar  - ToolBar to Replace elements
// ACaptMenuItem - MenuItem to replace elements for Capturing Devices
// AFirstInd     - MenuItem first replacing element index
// ALastInd      - MenuItem last replacing element index, if < 0 then real
// ALastInd = ACaptMenuItem + ALastInd (-1 means last item)
//
procedure K_CMUpdateUIByDeviceProfiles0( ACaptMenuItem: TMenuItem;
  AFirstInd: Integer; ALastInd: Integer = -1);
var
  i, NumItems, CurDynMainImgInd, AllDevCount: Integer;
  NewMenuItem: TMenuItem;
  NewToolButton: TToolButton;
  AddMenuItem: Boolean;
  TmpBitmap: TBitmap;
  UDDevices : TK_UDRArray;
  PCMDevProfListElem : TK_PCMDevProfListElem;
  PUMenu : TPopupMenu;
  Inds : TN_IArray;
  Ind : Integer;
  UseIndsFlag : Boolean;
begin
  with N_CM_MainForm, N_CMResForm do
  begin
    // ***** Delete previous MenuItems in Given MenuItem
    if ALastInd < 0 then
      ALastInd := ACaptMenuItem.Count + ALastInd;
    for i := AFirstInd to ALastInd do
      ACaptMenuItem.Items[AFirstInd].Free;

    // AddMenuItem := ACaptMenuItem.Count = AFirstInd;
    AddMenuItem := false;

    // ***** Delete all Buttons in Capture ToolBar
    NumItems := CMMCurCaptToolBar.ButtonCount;
    for i := 1 to NumItems do
    begin
      CMMCurCaptToolBar.Buttons[0].DropdownMenu.Free();
      CMMCurCaptToolBar.Buttons[0].Free();
    end;

//    K_CMDynIconsSInd := CMMCurSmallIcons.Count;
    // ***** Delete all Dynamic Icons
    for i := MainIcons18.Count - 1 downto K_CMDynIconsSInd do
    begin
      MainIcons18.Delete(i);
      CMMCurBigIcons.Delete(i);
    end;

    CurDynMainImgInd := K_CMDynIconsSInd;

    // ***** Create new GUI Elements by Profiles List
    AllDevCount := K_CMEDAccess.ProfilesList.ALength();
    PUMenu := nil;
    CMMDevGroupTButton := nil;
    SetLength( Inds, AllDevCount );
    UseIndsFlag := K_CMLimitDevUseTypeNameValidation();
    if UseIndsFlag then
    begin // Select Valid Profiles
      Ind := 0;
      // Build Valid Profiles Inds
      for i := 0  to High(Inds) do
      begin
        PCMDevProfListElem := TK_PCMDevProfListElem(K_CMEDAccess.ProfilesList.PDE(i));
        UDDevices := TK_UDRArray(PCMDevProfListElem.CMDPLEARef);
        if (UDDevices.ObjName <> 'VideoProfiles') and
           not K_CMLimitDevValidateTypeName(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd)) then Continue;
        Inds[Ind] := i;
        Inc(Ind);
      end; // for i := 0  to High(Inds) do

      UseIndsFlag := Ind < AllDevCount;
      if UseIndsFlag then
        SetLength( Inds, Ind ); // Clear Inds not used Tail
    end; // if UseInds then

//    for i := AllDevCount - 1 downto 0 do
    for i := High(Inds) downto 0 do
    begin
      Ind := i;
      if UseIndsFlag then
        Ind := Inds[i];

//      PCMDevProfListElem := TK_PCMDevProfListElem(K_CMEDAccess.ProfilesList.PDE(i));
      PCMDevProfListElem := TK_PCMDevProfListElem(K_CMEDAccess.ProfilesList.PDE(Ind));
      UDDevices := TK_UDRArray(PCMDevProfListElem.CMDPLEARef);
      with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
      begin
        if CMDPDelphiAction = nil then
          CMDPDelphiAction := TAction.Create(N_CMResForm);

        with CMDPDelphiAction do
        begin
          Caption := CMDPCaption;
          Hint := 'Capture from ' + CMDPCaption + '|' + 'Capture from ' +
            CMDPCaption;
          ShortCut := TextToShortCut(CMDPShortCut);

          if CMDPDynSIcon = nil then // Static Icon
            ImageIndex := CMDPImageIndex
          else
          begin // Dynamic Icon
            // Add Small Dyn Icon
            with CMDPDynSIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
              MainIcons18.AddMasked(TmpBitmap, DIBTranspColor);
            end;
            // Add Big Dyn Icon
            with CMDPDynBIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
//                MainIcons44.AddMasked(TmpBitmap, DIBTranspColor);
              CMMCurBigIcons.AddMasked(TmpBitmap, DIBTranspColor);
            end;

            ImageIndex     := CurDynMainImgInd;
            CMDPImageIndex := CurDynMainImgInd;
            Inc(CurDynMainImgInd);
          end; // Dynamic Icon

          Tag := PCMDevProfListElem.CMDPLEAInd;
          OnExecute := VideoOnExecuteHandler;
          if UDDevices = K_CMEDAccess.TwainProfiles then
            OnExecute := TwainOnExecuteHandler
          else
          if UDDevices = K_CMEDAccess.OtherProfiles then
              OnExecute := OtherOnExecuteHandler;

        end;

        NewMenuItem := TMenuItem.Create(CMMCurMainMenu);
        NewMenuItem.Action := CMDPDelphiAction;
        if AddMenuItem then
          ACaptMenuItem.Add(NewMenuItem)
        else
          ACaptMenuItem.Insert(AFirstInd, NewMenuItem);

        // Skip Adding ToolButtons if User has not Rights to Capture
        if not (K_uarCapture in K_CMCurUserAccessRights) then Continue;

        // Add Capture Device Buttons to ToolBar

        if i >= K_CMDevToolButMaxCount then
        begin
          if PUMenu = nil then
          begin
          // ***** Create DropDown Menu for Last ToolButton
            PUMenu := TPopupMenu.Create(N_CM_MainForm);
            PUMenu.Images := MainIcons18;
          end;

        // ***** Add new Item to DropDown Menu for Last ToolButton
          NewMenuItem := TMenuItem.Create(PUMenu);
          NewMenuItem.Action := CMDPDelphiAction;
          PUMenu.Items.Insert(0, NewMenuItem);
        end  // if i >= K_CMDevToolButMaxCount then
        else // if i < K_CMDevToolButMaxCount then
        if (PUMenu <> nil) and (i = K_CMDevToolButMaxCount - 1) then
        begin
        // ***** Add DropDown Menu to Last ToolButton
          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);

          NewToolButton.Action := CMDPDelphiAction;

          NewToolButton.Parent := CMMCurCaptToolBar;
          NewToolButton.DropdownMenu := PUMenu;
          NewToolButton.Style := tbsDropDown;
          PUMenu := nil;
        end
        else
        begin // if (i < K_CMDevToolButMaxCount) and ((PUMenu = nil) or (i <> K_CMDevToolButMaxCount - 1))
          // ***** Add new ToolButton to Capture Toolbar
          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);
          NewToolButton.Action := CMDPDelphiAction;
          NewToolButton.Parent := CMMCurCaptToolBar;
        end;

      end; // with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
    end; // for i := K_CMEDAccess.ProfilesList.AHigh downto 0 do
  end; // with  N_CM_MainForm, N_CMResForm do

  K_CMUpdateUnUsedShortCuts();

end; // procedure K_CMUpdateUIByDeviceProfiles0
{}
{ 2014-12-11 Prev Version before Device Limitation
//************************************* K_CMUpdateUIByDeviceProfiles0 ***
// Update Capturing User Interface Menu and ToolBar Items
//
//     Parameters
// ACaptToolBar  - ToolBar to Replace elements
// ACaptMenuItem - MenuItem to replace elements for Capturing Devices
// AFirstInd     - MenuItem first replacing element index
// ALastInd      - MenuItem last replacing element index, if < 0 then real
// ALastInd = ACaptMenuItem + ALastInd (-1 means last item)
//
procedure K_CMUpdateUIByDeviceProfiles0( ACaptMenuItem: TMenuItem;
  AFirstInd: Integer; ALastInd: Integer = -1);
var
  i, NumItems, CurDynMainImgInd, AllDevCount: Integer;
  NewMenuItem: TMenuItem;
  NewToolButton: TToolButton;
  AddMenuItem: Boolean;
  TmpBitmap: TBitmap;
  UDDevices : TK_UDRArray;
  PCMDevProfListElem : TK_PCMDevProfListElem;
  PUMenu : TPopupMenu;

begin
  with N_CM_MainForm, N_CMResForm do
  begin
    // ***** Delete previous MenuItems in Given MenuItem
    if ALastInd < 0 then
      ALastInd := ACaptMenuItem.Count + ALastInd;
    for i := AFirstInd to ALastInd do
      ACaptMenuItem.Items[AFirstInd].Free;

    // AddMenuItem := ACaptMenuItem.Count = AFirstInd;
    AddMenuItem := false;

    // ***** Delete all Buttons in Capture ToolBar
    NumItems := CMMCurCaptToolBar.ButtonCount;
    for i := 1 to NumItems do
    begin
      CMMCurCaptToolBar.Buttons[0].DropdownMenu.Free();
      CMMCurCaptToolBar.Buttons[0].Free();
    end;

//    K_CMDynIconsSInd := CMMCurSmallIcons.Count;
    // ***** Delete all Dynamic Icons
    for i := MainIcons18.Count - 1 downto K_CMDynIconsSInd do
    begin
      MainIcons18.Delete(i);
      CMMCurBigIcons.Delete(i);
    end;

    CurDynMainImgInd := K_CMDynIconsSInd;

    // ***** Create new GUI Elements by Profiles List
    AllDevCount := K_CMEDAccess.ProfilesList.ALength();
    PUMenu := nil;
    CMMDevGroupTButton := nil;
    if AllDevCount > K_CMDevToolButMaxCount then
    begin
    // ***** Create DropDown Menu for Last ToolButton
      PUMenu := TPopupMenu.Create(N_CM_MainForm);
      PUMenu.Images := MainIcons18;
    end;

    for i := AllDevCount - 1 downto 0 do
    begin

      PCMDevProfListElem := TK_PCMDevProfListElem(K_CMEDAccess.ProfilesList.PDE(i));
      UDDevices := TK_UDRArray(PCMDevProfListElem.CMDPLEARef);
      with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
      begin
        if CMDPDelphiAction = nil then
          CMDPDelphiAction := TAction.Create(N_CMResForm);

        with CMDPDelphiAction do
        begin
          Caption := CMDPCaption;
          Hint := 'Capture from ' + CMDPCaption + '|' + 'Capture from ' +
            CMDPCaption;
          ShortCut := TextToShortCut(CMDPShortCut);

          if CMDPDynSIcon = nil then // Static Icon
            ImageIndex := CMDPImageIndex
          else
          begin // Dynamic Icon
            // Add Small Dyn Icon
            with CMDPDynSIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
              MainIcons18.AddMasked(TmpBitmap, DIBTranspColor);
            end;
            // Add Big Dyn Icon
            with CMDPDynBIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
//                MainIcons44.AddMasked(TmpBitmap, DIBTranspColor);
              CMMCurBigIcons.AddMasked(TmpBitmap, DIBTranspColor);
            end;

            ImageIndex := CurDynMainImgInd;
            CMDPImageIndex := CurDynMainImgInd;
            Inc(CurDynMainImgInd);
          end;

          Tag := PCMDevProfListElem.CMDPLEAInd;
          OnExecute := VideoOnExecuteHandler;
          if UDDevices = K_CMEDAccess.TwainProfiles then
            OnExecute := TwainOnExecuteHandler
          else
          if UDDevices = K_CMEDAccess.OtherProfiles then
              OnExecute := OtherOnExecuteHandler;

        end;

        NewMenuItem := TMenuItem.Create(CMMCurMainMenu);
        NewMenuItem.Action := CMDPDelphiAction;
        if AddMenuItem then
          ACaptMenuItem.Add(NewMenuItem)
        else
          ACaptMenuItem.Insert(AFirstInd, NewMenuItem);

        // Skip Adding ToolButtons if User has not Rights to Capture
        if not (K_uarCapture in K_CMCurUserAccessRights) then Continue;

        // Add Capture Device Buttons to ToolBar
        if PUMenu <> nil then
        begin
          if i >= K_CMDevToolButMaxCount then
          begin
          // ***** Add new Item to DropDown Menu for Last ToolButton
            NewMenuItem := TMenuItem.Create(PUMenu);
            NewMenuItem.Action := CMDPDelphiAction;
            PUMenu.Items.Insert(0, NewMenuItem);
          end;

          if i = K_CMDevToolButMaxCount - 1 then
          begin
          // ***** Add DropDown Menu to Last ToolButton
            NewToolButton := TToolButton.Create(CMMCurCaptToolBar);

            NewToolButton.Action := CMDPDelphiAction;

            NewToolButton.Parent := CMMCurCaptToolBar;
            NewToolButton.DropdownMenu := PUMenu;
            NewToolButton.Style := tbsDropDown;
            PUMenu := nil;
          end;
        end
        else
        begin
          // ***** Add new ToolButton to Capture Toolbar
          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);
          NewToolButton.Action := CMDPDelphiAction;
          NewToolButton.Parent := CMMCurCaptToolBar;
        end;

      end; // with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
    end; // for i := K_CMEDAccess.ProfilesList.AHigh downto 0 do
  end; // with  N_CM_MainForm, N_CMResForm do

  K_CMUpdateUnUsedShortCuts();

end; // procedure K_CMUpdateUIByDeviceProfiles0
}
{}

{ New Version GUI Devices order is defined by Devices Common List
- from Left to Right
- DropDown Button's List contains Button Self profile

//************************************* K_CMUpdateUIByDeviceProfiles0 ***
// Update Capturing User Interface Menu and ToolBar Items
//
//     Parameters
// ACaptMenuItem - MenuItem to replace elements for Capturing Devices
// AFirstInd     - MenuItem first replacing element index
// ALastInd      - MenuItem last replacing element index, if < 0 then real
// ALastInd = ACaptMenuItem + ALastInd (-1 means last item)
//
procedure K_CMUpdateUIByDeviceProfiles0(ACaptMenuItem: TMenuItem;
  AFirstInd: Integer; ALastInd: Integer = -1);
var
  i, NumItems, CurDynMainImgInd, AllDevCount: Integer;
  NewMenuItem: TMenuItem;
  NewToolButton: TToolButton;
  AddMenuItem: Boolean;
  TmpBitmap: TBitmap;
  UDDevices : TK_UDRArray;
  PCMDevProfListElem : TK_PCMDevProfListElem;
  PUMenu : TPopupMenu;

begin
  with N_CM_MainForm, N_CMResForm do
  begin
    // ***** Delete previous MenuItems in Given MenuItem
    if ALastInd < 0 then
      ALastInd := ACaptMenuItem.Count + ALastInd;
    for i := AFirstInd to ALastInd do
      ACaptMenuItem.Items[AFirstInd].Free;

    // AddMenuItem := ACaptMenuItem.Count = AFirstInd;
    AddMenuItem := false;

    // ***** Delete all Buttons in Capture ToolBar
    NumItems := CMMCurCaptToolBar.ButtonCount;
    for i := 1 to NumItems do
    begin
      CMMCurCaptToolBar.Buttons[0].DropdownMenu.Free();
      CMMCurCaptToolBar.Buttons[0].Free();
    end;

//    K_CMDynIconsSInd := CMMCurSmallIcons.Count;
    // ***** Delete all Dynamic Icons
    for i := MainIcons18.Count - 1 downto K_CMDynIconsSInd do
    begin
      MainIcons18.Delete(i);
      CMMCurBigIcons.Delete(i);
    end;

    CurDynMainImgInd := K_CMDynIconsSInd;

    // ***** Create new GUI Elements by Profiles List
    AllDevCount := K_CMEDAccess.ProfilesList.ALength();
    PUMenu := nil;
    CMMDevGroupTButton := nil;
    if AllDevCount > K_CMDevToolButMaxCount then
    begin
    // ***** Create DropDown Menu for Last ToolButton
      PUMenu := TPopupMenu.Create(N_CM_MainForm);
      PUMenu.Images := MainIcons18;
    end;

    for i := AllDevCount - 1 downto 0 do
    begin

      PCMDevProfListElem := TK_PCMDevProfListElem(K_CMEDAccess.ProfilesList.PDE(i));
      UDDevices := TK_UDRArray(PCMDevProfListElem.CMDPLEARef);
      with TK_PCMDeviceProfile(UDDevices.PDE(PCMDevProfListElem.CMDPLEAInd))^ do
      begin
        if CMDPDelphiAction = nil then
          CMDPDelphiAction := TAction.Create(N_CMResForm);

        with CMDPDelphiAction do
        begin
          Caption := CMDPCaption;
          Hint := 'Capture from ' + CMDPCaption + '|' + 'Capture from ' +
            CMDPCaption;
          ShortCut := TextToShortCut(CMDPShortCut);

          if CMDPDynSIcon = nil then // Static Icon
            ImageIndex := CMDPImageIndex
          else
          begin // Dynamic Icon
            // Add Small Dyn Icon
            with CMDPDynSIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
              MainIcons18.AddMasked(TmpBitmap, DIBTranspColor);
            end;
            // Add Big Dyn Icon
            with CMDPDynBIcon.DIBObj do
            begin
              TmpBitmap := CreateBitmap(DIBRect);
//                MainIcons44.AddMasked(TmpBitmap, DIBTranspColor);
              CMMCurBigIcons.AddMasked(TmpBitmap, DIBTranspColor);
            end;

            ImageIndex := CurDynMainImgInd;
            CMDPImageIndex := CurDynMainImgInd;
            Inc(CurDynMainImgInd);
          end;

          Tag := PCMDevProfListElem.CMDPLEAInd;
          if UDDevices = K_CMEDAccess.TwainProfiles then
            OnExecute := TwainOnExecuteHandler
          else
          if UDDevices = K_CMEDAccess.OtherProfiles then
            OnExecute := OtherOnExecuteHandler
          else
            OnExecute := VideoOnExecuteHandler;

        end;

        NewMenuItem := TMenuItem.Create(CMMCurMainMenu);
        NewMenuItem.Action := CMDPDelphiAction;
        if AddMenuItem then
          ACaptMenuItem.Add(NewMenuItem)
        else
          ACaptMenuItem.Insert(AFirstInd, NewMenuItem);

        if PUMenu <> nil then
        begin
          if i >= K_CMDevToolButMaxCount - 1 then
          begin
          // ***** Add new Item to DropDown Menu for Last ToolButton
            NewMenuItem := TMenuItem.Create(PUMenu);
            NewMenuItem.Action := CMDPDelphiAction;
            PUMenu.Items.Insert(0, NewMenuItem);
          end;

          if i = K_CMDevToolButMaxCount - 1 then
          begin
          // ***** Add DropDown Menu to Last ToolButton
            NewToolButton := TToolButton.Create(CMMCurCaptToolBar);

            CMMDevGroupInd := Min( CMMDevGroupInd, PUMenu.Items.Count - 1 );
            if CMMDevGroupInd > 0 then
              NewToolButton.Action := PUMenu.Items[CMMDevGroupInd].Action
            else
              NewToolButton.Action := CMDPDelphiAction;

            NewToolButton.Parent := CMMCurCaptToolBar;
            NewToolButton.DropdownMenu := PUMenu;
            NewToolButton.Style := tbsDropDown;
            CMMDevGroupTButton := NewToolButton;
            PUMenu := nil;
          end;
        end
        else
        begin
          // ***** Add new ToolButton to Capture Toolbar
          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);
          NewToolButton.Action := CMDPDelphiAction;
          NewToolButton.Parent := CMMCurCaptToolBar;
        end;

      end; // for i := High(CMTwainProfiles) downto 0 do // along all TWAIN devices

    end; // for i := K_CMEDAccess.ProfilesList.AHigh downto 0 do
  end; // with  N_CM_MainForm, N_CMResForm do

  K_CMUpdateUnUsedShortCuts();

end; // procedure K_CMUpdateUIByDeviceProfiles0
{}
{ Old Version with Devices Separated by it's types
//************************************* K_CMUpdateUIByDeviceProfiles0 ***
// Update Capturing User Interface Menu and ToolBar Items
//
//     Parameters
// ACaptMenuItem - MenuItem to replace elements for Capturing Devices
// AFirstInd     - MenuItem first replacing element index
// ALastInd      - MenuItem last replacing element index, if < 0 then real
// ALastInd = ACaptMenuItem + ALastInd (-1 means last item)
//
procedure K_CMUpdateUIByDeviceProfiles0(ACaptMenuItem: TMenuItem;
  AFirstInd: Integer; ALastInd: Integer = -1);
var
  i, NumItems, CurDynMainImgInd: Integer;
  NewMenuItem: TMenuItem;
  NewToolButton: TToolButton;
  AddMenuItem: Boolean;

  procedure AddProfilesListControls(UDProfile: TK_UDRArray;
    OnExecuteHandler: TNotifyEvent; DisableState: Boolean);
  var
    i: Integer;
    TmpBitmap: TBitmap;
  begin
    with N_CM_MainForm, N_CMResForm do
      for i := UDProfile.AHigh downto 0 do
      begin
        with TK_PCMDeviceProfile(UDProfile.PDE(i))^ do
        begin
          if CMDPDelphiAction = nil then
            CMDPDelphiAction := TAction.Create(N_CMResForm);

          with CMDPDelphiAction do
          begin
            Enabled := not DisableState;
            Caption := CMDPCaption;
            Hint := 'Capture from ' + CMDPCaption + '|' + 'Capture from ' +
              CMDPCaption;
            ShortCut := TextToShortCut(CMDPShortCut);

            if CMDPDynSIcon = nil then // Static Icon
              ImageIndex := CMDPImageIndex
            else
            begin // Dynamic Icon
              // Add Small Dyn Icon
              with CMDPDynSIcon.DIBObj do
              begin
                TmpBitmap := CreateBitmap(DIBRect);
                MainIcons18.AddMasked(TmpBitmap, DIBTranspColor);
              end;
              // Add Big Dyn Icon
              with CMDPDynBIcon.DIBObj do
              begin
                TmpBitmap := CreateBitmap(DIBRect);
//                MainIcons44.AddMasked(TmpBitmap, DIBTranspColor);
                CMMCurBigIcons.AddMasked(TmpBitmap, DIBTranspColor);
              end;

              ImageIndex := CurDynMainImgInd;
              CMDPImageIndex := CurDynMainImgInd;
              Inc(CurDynMainImgInd);
            end;

            Tag := i;
            OnExecute := OnExecuteHandler;
          end;

          NewMenuItem := TMenuItem.Create(CMMCurMainMenu);
          NewMenuItem.Action := CMDPDelphiAction;
          if AddMenuItem then
            ACaptMenuItem.Add(NewMenuItem)
          else
            ACaptMenuItem.Insert(AFirstInd, NewMenuItem);

          NewToolButton := TToolButton.Create(CMMCurCaptToolBar);
          NewToolButton.Action := CMDPDelphiAction;
          NewToolButton.Parent := CMMCurCaptToolBar;

        end; // for i := High(CMTwainProfiles) downto 0 do // along all TWAIN devices

      end;
  end;

begin
  with N_CM_MainForm, N_CMResForm do
  begin
    // ***** Delete previous MenuItems in Given MenuItem
    if ALastInd < 0 then
      ALastInd := ACaptMenuItem.Count + ALastInd;
    for i := AFirstInd to ALastInd do
      ACaptMenuItem.Items[AFirstInd].Free;

    // AddMenuItem := ACaptMenuItem.Count = AFirstInd;
    AddMenuItem := false;

    // ***** Delete all Buttons in Capture ToolBar
    NumItems := CMMCurCaptToolBar.ButtonCount;
    for i := 1 to NumItems do
      CMMCurCaptToolBar.Buttons[0].Free;

//    K_CMDynIconsSInd := CMMCurSmallIcons.Count;
    for i := MainIcons18.Count - 1 downto K_CMDynIconsSInd do
    begin
      MainIcons18.Delete(i);
      CMMCurBigIcons.Delete(i);
    end;

    CurDynMainImgInd := K_CMDynIconsSInd;

    // ***** Add new Video Icons, Menu Items and Buttons in Capture ToolBar
    AddProfilesListControls(K_CMEDAccess.VideoProfiles, VideoOnExecuteHandler,
      false);
    // if K_CMSLiRegStatus then Exit;

    if ((K_CMEDAccess.TwainProfiles.ALength > 0) or
      // Twain Profiles Set is not empty
        (K_CMEDAccess.OtherProfiles.ALength > 0)) and
    // Other Profiles Set is not empty
      (K_CMEDAccess.VideoProfiles.ALength > 0) then
    begin // Video Profiles Set is not empty

      // Add separators to Menu and Toolbar
      NewMenuItem := TMenuItem.Create(CMMCurMainMenu);
      NewMenuItem.Caption := '-';
      if AddMenuItem then
        ACaptMenuItem.Add(NewMenuItem)
      else
        ACaptMenuItem.Insert(AFirstInd, NewMenuItem);

      NewToolButton := TToolButton.Create(CMMCurCaptToolBar);
      NewToolButton.Style := tbsDivider;
      NewToolButton.Width := 8;
      NewToolButton.Parent := CMMCurCaptToolBar;
    end;

    // ***** Add new Other Icons, Menu Items and Buttons in Capture ToolBar
    AddProfilesListControls(K_CMEDAccess.OtherProfiles, OtherOnExecuteHandler,
      K_CMSLiRegStatus = 0);

    // ***** Add new TWAIN Icons, Menu Items and Buttons in Capture ToolBar
    AddProfilesListControls(K_CMEDAccess.TwainProfiles, TwainOnExecuteHandler,
      K_CMSLiRegStatus = 0);

  end; // with  N_CM_MainForm, N_CMResForm do

  K_CMUpdateUnUsedShortCuts();

end; // procedure K_CMUpdateUIByDeviceProfiles0
{ }
{
  //************************************ K_CMUpdateUIByDeviceProfiles0 ***
  // Update Capturing User Interface Menu and ToolBar Items
  //
  //    Parameters
  // ACaptMenuItem - MenuItem to replace elements for Capturing Devices
  // AFirstInd     - MenuItem first replacing element index
  // ALastInd      - MenuItem last replacing element index, if < 0 then real
  //                 ALastInd = ACaptMenuItem + ALastInd (-1 means last item)
  //
  procedure K_CMUpdateUIByDeviceProfiles0( ACaptMenuItem: TMenuItem; AFirstInd : Integer; ALastInd : Integer = -1 );
  var
  i, NumItems, CurDynMainImgInd: integer;
  NewMenuItem : TMenuItem;
  NewToolButton: TToolButton;
  AddMenuItem : Boolean;

  procedure AddProfilesListControls( UDProfile : TK_UDRArray; OnExecuteHandler : TNotifyEvent );
  var
  i : Integer;
  TmpBitmap: TBitmap;
  begin
  with N_CM_MainForm, N_CMResForm do
  for i := UDProfile.AHigh downto 0 do begin
  with TK_PCMDeviceProfile(UDProfile.PDE(i))^ do
  begin
  if CMDPDelphiAction = nil then
  CMDPDelphiAction := TAction.Create( N_CMResForm );

  with CMDPDelphiAction do
  begin
  Caption  := CMDPCaption;
  Hint     := 'Capture from ' + CMDPCaption + '|' + 'Capture from ' + CMDPCaption;
  ShortCut := TextToShortCut( CMDPShortCut );

  if CMDPDynSIcon = nil then // Static Icon
  ImageIndex := CMDPImageIndex
  else begin // Dynamic Icon
  // Add Small Dyn Icon
  with CMDPDynSIcon.DIBObj do
  begin
  TmpBitmap := CreateBitmap( DIBRect );
  MainIcons18.AddMasked( TmpBitmap, DIBTranspColor );
  end;
  // Add Big Dyn Icon
  with CMDPDynBIcon.DIBObj do
  begin
  TmpBitmap := CreateBitmap( DIBRect );
  MainIcons44.AddMasked( TmpBitmap, DIBTranspColor );
  end;

  ImageIndex := CurDynMainImgInd;
  CMDPImageIndex := CurDynMainImgInd;
  Inc(CurDynMainImgInd);
  end;

  Tag := i;
  OnExecute := OnExecuteHandler;
  end;

  NewMenuItem := TMenuItem.Create( MainMenu1 );
  NewMenuItem.Action := CMDPDelphiAction;
  if AddMenuItem then
  ACaptMenuItem.Add( NewMenuItem )
  else
  ACaptMenuItem.Insert( AFirstInd, NewMenuItem );

  NewToolButton := TToolButton.Create( CaptToolBar );
  NewToolButton.Action := CMDPDelphiAction;
  NewToolButton.Parent := CaptToolBar;

  end; // for i := High(CMTwainProfiles) downto 0 do // along all TWAIN devices

  end;
  end;

  begin
  with  N_CM_MainForm, N_CMResForm do
  begin
  //***** Delete previous MenuItems in Given MenuItem
  if ALastInd < 0 then
  ALastInd := ACaptMenuItem.Count + ALastInd;
  for i := AFirstInd to ALastInd do
  ACaptMenuItem.Items[AFirstInd].Free;

  AddMenuItem := ACaptMenuItem.Count = AFirstInd;

  //***** Delete all Buttons in Capture ToolBar
  NumItems := CaptToolBar.ButtonCount;
  for i := 1 to NumItems do
  CaptToolBar.Buttons[0].Free;

  for i := MainIcons18.Count - 1 downto K_CMDynIconsSInd  do begin
  MainIcons18.Delete(i);
  MainIcons44.Delete(i);
  end;

  CurDynMainImgInd := K_CMDynIconsSInd;

  //***** Add new TWAIN Icons, Menu Items and Buttons in Capture ToolBar
  AddProfilesListControls( K_CMEDAccess.TwainProfiles, TwainOnExecuteHandler );

  if (K_CMEDAccess.TwainProfiles.ALength > 0) and          // Twain Profiles Set is not empty
  (K_CMEDAccess.VideoProfiles.ALength > 0)  then begin  // Video Profiles Set is not empty
  // Add separators to Menu and Toolbar
  //      NewMenuItem := TMenuItem.Create( MainMenu1 );
  //      NewMenuItem.Caption := '-';
  //      CaptMenuItem.Insert( 0, NewMenuItem );
  //      CaptMenuItem.Add( NewMenuItem );

  NewToolButton := TToolButton.Create( CaptToolBar );
  NewToolButton.Style := tbsDivider;
  NewToolButton.Width := 8;
  NewToolButton.Parent := CaptToolBar;
  end;

  //***** Add new Video Icons, Menu Items and Buttons in Capture ToolBar
  AddProfilesListControls( K_CMEDAccess.VideoProfiles, VideoOnExecuteHandler );

  //***** Add new Other Icons, Menu Items and Buttons in Capture ToolBar

  if ( (K_CMEDAccess.TwainProfiles.ALength > 0) or         // Twain Profiles Set is not empty
  (K_CMEDAccess.VideoProfiles.ALength > 0) ) and      // Video Profiles Set is not empty
  (K_CMEDAccess.OtherProfiles.ALength > 0)  then begin  // Other Profiles Set is not empty
  // Add separators to Menu and Toolbar
  //      NewMenuItem := TMenuItem.Create( MainMenu1 );
  //      NewMenuItem.Caption := '-';
  //      CaptMenuItem.Insert( 0, NewMenuItem );
  //      CaptMenuItem.Add( NewMenuItem );

  NewToolButton := TToolButton.Create( CaptToolBar );
  NewToolButton.Style := tbsDivider;
  NewToolButton.Width := 8;
  NewToolButton.Parent := CaptToolBar;
  end;

  //***** Add new Other Icons, Menu Items and Buttons in Capture ToolBar
  AddProfilesListControls( K_CMEDAccess.OtherProfiles, OtherOnExecuteHandler );

  end; // with  N_CM_MainForm, N_CMResForm do

  K_CMUpdateUnUsedShortCuts( );

  end; // procedure K_CMUpdateUIByDeviceProfiles0
  { }

//************************************* K_CMUpdateUnUsedShortCuts ***
// Update Unused Shortcauts List K_CMUnUsedShortCuts
//
procedure K_CMUpdateUnUsedShortCuts();
var
  SL: TStringList;
begin
//!!!  if N_CM_MainForm.CMMCurMainMenu = nil then Exit; // Sometimes if Application Paths Problems then CMMCurFMainForm is not set
  if K_CMUnUsedShortCuts = nil then
    K_CMUnUsedShortCuts := TStringList.Create;
  K_CMUnUsedShortCuts.Clear;
  K_CMUnUsedShortCuts.Add( K_CML1Form.LLLShortcutNone.Caption ); // 'None'
  K_BuildAllShortCutsList(K_CMUnUsedShortCuts);
  SL := TStringList.Create;
  K_BuildMenuShortCutsList(N_CM_MainForm.CMMCurMainMenu.Items, SL, TRUE);
  K_ExcludeCorrespondingStrings(K_CMUnUsedShortCuts, SL);
  SL.Free;
end; // end of  K_CMUpdateUnUsedShortCuts

//**************************************************** K_CMInitProfileIcons ***
// Initialize Profile Icons context
//
//     Parameters
// AImgListBig   - resulting ImageList with Big Icons
// AImgListSmall - resulting ImageList with Small Icons
// Result - Returns TRUE if new Saved Icon creation is needed (Icons should
// be selected from Dynamic Icons Set), if Result = FALSE then no Saved
// Icon creation is needed (Icon should be selected from Static Icons Set)
//
function K_CMInitProfileIcons(out AImgListBig, AImgListSmall: TImageList ): Boolean;
begin

  with N_CMResForm do
  begin
    if DynIcons44.Count = 0 then
    begin // Load Dynamic Icons to DynIcons44 and DynIcons18 ImageList if not yet
      N_i := N_AddToImageList(DynIcons44, N_MemIniToString('CMS_Main',
          'IconsBigFName', ''), @K_CMDynTranspColor);
      N_i := N_AddToImageList(DynIcons18, N_MemIniToString('CMS_Main',
          'IconsSmallFName', ''), @K_CMDynTranspColor);
    end;
    Result := DynIcons44.Count > 0;
    if not Result then
    begin
      AImgListBig := N_CM_MainForm.CMMCurBigIcons;
      AImgListSmall := N_CMResForm.MainIcons18;
    end
    else
    begin
      AImgListBig := DynIcons44;
      AImgListSmall := DynIcons18;
    end;
  end; // with N_CMResForm
end; // end of  K_CMInitProfileIcons

//************************************************** K_CMSelectProfileIcons ***
// Select Icon Index and ImageLists with Big and corresponding Small Icons
//
//     Parameters
// AImgListBig   - resulting ImageList with Big Icons
// AImgListSmall - resulting ImageList with Small Icons
// AImgInd       - Icon index in ImageList
// ASaveIconFlag - if =TRUE then new Saved Icon creation is needed (Icon was
// selected from Dynamic Icons Set), if =FALSE then no Saved
// Icon creation is needed (Icon was selected from Static Icons Set)
//
function K_CMSelectProfileIcons(out AImgListBig, AImgListSmall: TImageList;
  out AImgInd: Integer; out ADynIconFlag: Boolean ): Boolean;
var
  IconItemInfo: TN_IconItemInfo;
begin

  with N_CMResForm do
  begin
    if DynIcons44.Count = 0 then
    begin // Load Dynamic Icons to DynIcons44 and DynIcons18 ImageList if not yet
      N_i := N_AddToImageList(DynIcons44, N_MemIniToString('CMS_Main',
          'IconsBigFName', ''), @K_CMDynTranspColor);
      N_i := N_AddToImageList(DynIcons18, N_MemIniToString('CMS_Main',
          'IconsSmallFName', ''), @K_CMDynTranspColor);
    end;


    // ***** Choose from some Static and all Dynamic Icons

    with N_CreateIconSelectionForm( N_CM_MainForm.CMMCurFMainForm, 510, 335 ) do
    begin
      Caption := K_CML1Form.LLLSelectProfileIcons.Caption; // 'Select Device Icon';
      ISFDGrid.DGMarkNormWidth := 3;
      ISFDGrid.DGLItemsByRows := TRUE;

      if DynIcons44.Count = 0 then // Some Static Icons if Dynamic Icons are absent
        ISFAddIconsRange(N_CM_MainForm.CMMCurBigIcons, K_CMDevIconsSInd, K_CMDevIconsFInd)
      else // All Dynamic Icons (Static Icons not used)
        ISFAddIconsRange(DynIcons44, 0, DynIcons44.Count - 1);
      ISFInit();

      Result := ShowModal() = mrOK; // Show Icon Selection Form
      if not Result then
        Exit;

      with ISFDGrid, ISFIconsArray[DGSelectedInd] do
      begin
        IconItemInfo := ISFIconsArray[DGSelectedInd];
        AImgInd := IIIIconInd;
        ADynIconFlag := (IIIImageList <> N_CM_MainForm.CMMCurBigIcons) and
          (IIIImageList <> N_CMResForm.MainIcons18);
        if not ADynIconFlag then
        begin
          AImgListBig := N_CM_MainForm.CMMCurBigIcons;
          AImgListSmall := N_CMResForm.MainIcons18;
        end
        else
        begin
          AImgListBig := DynIcons44;
          AImgListSmall := DynIcons18;
        end;
      end;
    end; // with N_CreateIconSelectionForm( Self ) do
  end; // with N_CMResForm
end; // end of  K_CMSelectProfileIcons

//****************************************** K_CMGetStaticIconByIndex ***
// Get Static Icon Bitmap bu Icon Index in ImageList
//
//     Parameters
// AIconInd - Static Icons Index
// AIconBMP - resulting Icon Bitmap
// ABigIconFlag - if =TRUE then big Icon Bitmap will be get
//
procedure K_CMGetStaticIconByIndex(AIconInd: Integer; AIconBMP: TBitmap;
  ABigIconFlag: Boolean);
var
  IL: TImageList;
begin
  IL := N_CMResForm.MainIcons18;
  if ABigIconFlag then
    IL := N_CM_MainForm.CMMCurBigIcons;
  IL.GetBitmap(AIconInd, AIconBMP);
end; // end of K_CMGetStaticIconByIndex

//****************************************** K_CMGetStaticIconsLists ***
// Get Static Icons ImageLists with Big and corresponding Small Icons
//
//     Parameters
// AImgListBig   - resulting ImageList with Big Icons
// AImgListSmall - resulting ImageList with Small Icons
//
procedure K_CMGetStaticIconsLists(out AImgListBig, AImgListSmall: TImageList);
begin
  with N_CM_MainForm do
  begin
    AImgListBig := CMMCurBigIcons;
    AImgListSmall := N_CMResForm.MainIcons18;
  end;
end;

var
  K_CMButtonCaptions: array[mbYes..mbYesToAll] of string = (
    '&Yes', '&No', 'OK', 'Cancel', '&Abort', '&Retry', '&Ignore', '&All', 'N&o to All',
    'Yes to &All');
//****************************************** K_CMGetMessageDlgTexts ***
// Get message dialog button texts
//
//     Parameters
// AMDButtons - message dialog buttons set
// Result     - Returns array of Dialog buttons texts
//
function K_CMGetMessageDlgTexts( AMDButtons: TMsgDlgButtons = [] ): TN_SArray;
var
  i : Integer;
  B : TMsgDlgBtn;
  LName : string;
begin
  K_SetCurLangGroup( 'TMessageForm' );

  SetLength(Result, Ord(High(TMsgDlgBtn)) - Ord(Low(TMsgDlgBtn)) + 1 );
  i := 0;
  for B := mbYes to mbYesToAll do
  begin
    if B in AMDButtons then
    begin
      LName := '';
      case B of
      mbYes: LName := 'Yes';
      mbNo: LName := 'No';
      mbOK: LName := 'OK';
      mbCancel: LName := 'Cancel';
      mbAbort: LName := 'Abort';
      mbRetry: LName := 'Retry';
      mbIgnore: LName := 'Ignore';
      mbAll: LName := 'All';
      mbNoToAll: LName := 'NoToAll';
      mbYesToAll: LName := 'YesToAll';
      end;
      Result[i] := K_GetCurLangText1( LName + '_c', K_CMButtonCaptions[B] );
      Inc(i);
    end;
  end;
  SetLength(Result, i );
end; // end of K_CMGetMessageDlgTexts

//****************************************** K_CMPrepMessageDlg ***
// Prepare CMS message dialog Form
//
//     Parameters
// AMessage   - message text
// AMDLT      - message dialog type (mtWarning, mtError, mtInformation, mtConfirmation)
// AMDButtons - message dialog buttons set
// ACaption - message window caption
// Result     - Returns message dialog Form
//
function K_CMPrepMessageDlg( const AMessage: string; AMDLT: TMsgDlgType;
               AMDButtons: TMsgDlgButtons = []; ACaption: string = '' ): TForm;
var
  MDButtons: TMsgDlgButtons;
begin
  MDButtons := [mbOK];
  if AMDLT = mtConfirmation then
    MDButtons := [mbYes, mbNo];
  if AMDButtons <> [] then
    MDButtons := AMDButtons;
  Result := CreateMessageDialog(AMessage, AMDLT, MDButtons);
  N_MakeFormVisible2( Result, [rspfMFRect,rspfCenter] );
  with Result do
  begin
    if ACaption <> '' then
      Caption := ACaption
    else
      Caption := K_CMMessageDlgDefaultCaption;
//      Caption := 'Media Suite SQL';
    if K_CMDebVersionModeFlag then
      Caption := K_CMSMainFormCaptPref1 + Caption;
//        Caption := '[Deb]' + Caption;
    FormStyle := fsStayOnTop;
    K_SetFFCompCurLangTexts(Result);
  end;
end; // end of K_CMPrepMessageDlg

//****************************************** K_CMShowSoftMessageDlg ***
// Show CMS message dialog
//
//     Parameters
// AMessage   - message text
// AMDLT      - message dialog type (mtWarning, mtError, mtInformation, mtConfirmation)
// AShowInterval - message window show modal interval in sec
// AOnFormClose - procedure of object to call on dialog form close
// ACaption - message window caption
// ASkipCloseOnDeactivate - if TRUE then dialog form auto close on deactivate will not be done
// Result - Returns Dialog form (for external close)
//
function K_CMShowSoftMessageDlg( const AMessage: string; AMDLT: TMsgDlgType;
                     AShowInterval : Integer;
                     AOnFormClose : TN_ProcObj = nil;
                     ACaption: string = '';
                     ASkipCloseOnDeactivate : Boolean = FALSE ) : TForm;
var
  DlgForm: TForm;
  FCTimer : TK_FormCloseTimer;
  i : Integer;
begin
// Temporary code before proper SIR
//  K_CMShowMessageDlg(AMessage, AMDLT, [], FALSE, ACaption);
//  Exit;

  N_CM_MainForm.CMMFShowStringByTimer( ' ' + AMessage );
  DlgForm := K_CMPrepMessageDlg( AMessage, AMDLT, [], ACaption );
  FCTimer := nil;
  Result := nil;
  try
    if AShowInterval > 0 then
    begin
      FCTimer := TK_FormCloseTimer.CreateByForm( DlgForm, AShowInterval * 1000 );
      FCTimer.FCTOnFormCloseProc := AOnFormClose;
      DlgForm.OnCloseQuery := FCTimer.OnTimerFormCloseQuery;
      if not ASkipCloseOnDeactivate then
        DlgForm.OnDeactivate := FCTimer.OnTimerFormDeactivate;
      for i := 0 to DlgForm.ControlCount - 1 do
        if DlgForm.Controls[i] is TButton then
          TButton(DlgForm.Controls[i]).OnClick := FCTimer.OnTimerFormDeactivate;
    end;
    DlgForm.Show;
    Result := DlgForm;
  except
    FCTimer.Free;
  end;
end; // end of K_CMShowSoftMessageDlg

//****************************************** K_CMShowMessageDlg ***
// Show CMS message dialog
//
//     Parameters
// AMessage   - message text
// AMDLT      - message dialog type (mtWarning, mtError, mtInformation, mtConfirmation)
// AMDButtons - message dialog buttons set
// ASkipLogFlag - if =TRUE then Message will not be dumped even if it's type is Warning or Error
// ACaption - message window caption
// AShowInterval - message window show modal interval in sec
// Result     - Returns message dialog result code (mrOK, mrYes, mrNo, ... )
//
function K_CMShowMessageDlg( const AMessage: string; AMDLT: TMsgDlgType;
  AMDButtons: TMsgDlgButtons = []; ASkipLogFlag: Boolean = false;
  ACaption: string = ''; AShowInterval : Integer = 0 ): Integer;
var
//  MDButtons: TMsgDlgButtons;
  DlgForm: TForm;
  FCTimer : TK_FormCloseTimer;
begin
  if (AMessage <> '') and not ASkipLogFlag  then
    N_Dump1Str(AMessage);
  DlgForm := K_CMPrepMessageDlg( AMessage, AMDLT, AMDButtons, ACaption );
  FCTimer := nil;
  with DlgForm do
    try
      if AShowInterval > 0 then
        FCTimer := TK_FormCloseTimer.CreateByForm( DlgForm, AShowInterval * 1000 );
      BorderIcons := [];
      Result := ShowModal;
      if FCTimer <> nil then
        FCTimer.Enabled := FALSE;
    finally
      FCTimer.Free;
      Release;
    end;
end; // end of K_CMShowMessageDlg

//****************************************** K_CMShowMessageDlg1 ***
// Show CMS message as dialog and as status bar
//
//     Parameters
// AMessage   - message text
// AMDLT      - message dialog type (mtWarning, mtError, mtInformation, mtConfirmation)
// AMDButtons - message dialog buttons set
// Result     - Returns message dialog result code (mrOK, mrYes, mrNo, ... )
//
function K_CMShowMessageDlg1( const AMessage: string; AMDLT: TMsgDlgType;
  AMDButtons: TMsgDlgButtons = []; ACaption: string = ''; AShowInterval : Integer = 0 ): Integer;
begin
  N_CM_MainForm.CMMFShowStringByTimer( ' ' + AMessage );
  Result := K_CMShowMessageDlg(AMessage, AMDLT, AMDButtons, TRUE, ACaption, AShowInterval );
end; // end of K_CMShowMessageDlg1

//****************************************** K_CMShowMessageDlgByTimer ***
// Show CMS message dialog by Timer Event
//
//     Parameters
// AMessage   - message text
// AMDLT      - message dialog type (mtWarning, mtError, mtInformation, mtConfirmation)
// AStartTimer - real start timer flag, if =TRUE then timer will be start, else
//               given Action will only be added to to start by timer list
// AMDButtons - message dialog buttons set
// ASkipLogFlag - if =TRUE then Message will not be dumped even if it's type is Warning or Error
// ACaption - message window caption
// AShowInterval - message window show modal interval in sec
//
procedure K_CMShowMessageDlgByTimer(AMessage: string; AMDLT: TMsgDlgType;
  AStartTimer : Boolean = TRUE;
  AMDButtons: TMsgDlgButtons = []; ASkipLogFlag: Boolean = false;
  ACaption: string = ''; AShowInterval : Integer = 0 );
begin
  K_CMShowMessageDlgText := AMessage;
  K_CMShowMessageDlgType := AMDLT;
  K_CMShowMessageDlgButtons := AMDButtons;
  K_CMShowMessageDlgSkipLog := ASkipLogFlag;
  K_CMShowMessageDlgCaption := ACaption;
  K_CMShowMessageDlgShowInterval := AShowInterval;
  N_CM_MainForm.CMMCallActionByTimer(N_CMResForm.aServShowMessageDlg, AStartTimer );
end; // end of K_CMShowMessageDlgByTimer

//Ura
type U_CMMessageHelper = class(TObject)
  public
    FormToClose: TForm;
    procedure TimerEvent(Sender: TObject);
end;

procedure U_CMMessageHelper.TimerEvent(Sender: TObject);
begin
  (Sender as TTimer).Enabled := false;
  if FormToClose <> nil then FormToClose.Close;
end;

procedure U_CMErrorMessage(AMessage: string; AShowInterval: Integer = 10);
var
  dlg: TForm;
  tmr: TTimer;
  hlp: U_CMMessageHelper;
begin
  dlg := CreateMessageDialog(AMessage,mtError,[mbOK]);
  hlp := U_CMMessageHelper.Create;
  hlp.FormToClose := dlg;
  tmr := TTimer.Create(nil);
  tmr.OnTimer := hlp.TimerEvent;
  tmr.Interval := AShowInterval*1000;
  tmr.Enabled := true;
  dlg.ShowModal;
  tmr.Free;
  hlp.Free;
  dlg.Free;
end;

//********************************************** K_CMSlideSetResolutionByDIB ***
// Set Slide Resolution by given DIB
//
//     Parameters
// APCMSLide - pointer to Slide data record
// ADIBObj - given DIB
//
procedure K_CMSlideSetResolutionByDIB( APCMSLide : TN_PCMSlide; ADIBObj : TN_DIBObj );
var
  RX, RY : Integer;
  RFlags: Word; // Slide State Saved Flags
begin
  RX := ADIBObj.DIBInfo.bmi.biXPelsPerMeter;
  RY := ADIBObj.DIBInfo.bmi.biYPelsPerMeter;
  ADIBObj.CorrectResolution( 0 );
  with APCMSLide^, ADIBObj do
  begin
    RFlags := Word(CMSDB.SFlags);
    with DIBInfo.bmi do
    begin
      if biXPelsPerMeter = 0 then
      begin
        Exclude(CMSDB.SFlags, cmsfAutoCalibrated);
        biXPelsPerMeter := Round(72 * 100 / 2.54);
        biYPelsPerMeter := Round(72 * 100 / 2.54);
      end
      else
        if not (cmsfAutoCalibrated in CMSDB.SFlags) then
          Include(CMSDB.SFlags, cmsfProbablyCalibrated);

//      if biYPelsPerMeter = 0 then
//        biYPelsPerMeter := Round(72 * 100 / 2.54);

      if CMSDB.PixPermm = 0 then
        CMSDB.PixPermm := biXPelsPerMeter / 1000;
      N_Dump1Str( format( 'SlideResolutionByDIB R(%d,%d) F=%d >> R(%d,%d) F=%d ',
                          [RX,RY,RFlags,
                           biXPelsPerMeter, biXPelsPerMeter, Word(CMSDB.SFlags)] ) );
    end;
  end;
end; // procedure K_CMSlideSetResolutionByDIB

//************************************************** K_CMSlideSetAttrsByDIB ***
// Init Slide Attributes by given DIB
//
//     Parameters
// APCMSLide     - pointer to Slide data record
// ADIBObj       - given DIB
// ASkipGreyInit - if =TRUE then skip Grey Image View Attributes - such as Isodensity and Colorise
//
procedure K_CMSlideSetAttrsByDIB( APCMSLide : TN_PCMSlide; ADIBObj : TN_DIBObj;
                                  ASkipGreyInit : Boolean );
begin
  with APCMSLide^, ADIBObj do
  begin
    if CMSDB.PixWidth = 0 then
    begin
      CMSDB.PixWidth := DIBSize.X;
      CMSDB.PixHeight := DIBSize.Y;
    end;

    if DIBPixFmt = pf24bit then // Color24
    begin
      CMSDB.PixBits := 24;
      Exclude( CMSDB.SFlags, cmsfGreyScale );
    end
    else if DIBPixFmt = pfCustom then // epfGray8 or epfGray16
    begin
      Assert((DIBExPixFmt = epfGray8) or (DIBExPixFmt = epfGray16), 'Bad Slide DIBPixFmt1');

      Include(CMSDB.SFlags, cmsfGreyScale);

      if DIBExPixFmt = epfGray8 then
        CMSDB.PixBits := 8
      else // epfGray16
      begin
        CMSDB.PixBits := 15; // a precaution, DIBNumBits should never be zero
        if DIBNumBits <> 0 then
          CMSDB.PixBits := DIBNumBits;
      end;

      if not ASkipGreyInit then
      begin
        CMSDB.ViewAttrs.IsoColor := 255; // Red
        CMSDB.ViewAttrs.IsoRangeFactor := 5; // 5% range
        CMSDB.ViewAttrs.IsoBaseColInt := -1; // Not Def Image Color
      end;
    end
    else // a precaution
      Assert(false, 'Bad Slide DIBPixFmt2!');

    CMSDB.BytesSize := ADIBObj.DIBInfo.bmi.biSizeImage;

    K_CMSlideSetResolutionByDIB( APCMSLide, ADIBObj );
  end; // with APCMSLide^, ADIBObj do

end; // procedure K_CMSlideSetAttrsByDIB

//*********************************** K_CMSlideGetPatientFilesGroupPathSegm ***
// Get MediaFiles and ImageFiles Patient Files Group depended path segment
//
//     Parameters
// APatId - Patient ID
// Result - Returns Patients Group depended path segment for MediaFiles and ImageFiles
//
function K_CMSlideGetPatientFilesGroupPathSegm(APatID: Integer): string;
begin
  Result := format('%.5d\', [(((APatID - 1) div 100) + 1) * 100]);
end; // function K_CMSlideGetPatientFilesGroupPathSegm

//**************************************** K_CMSlideGetPatientFilesPathSegm ***
// Get MediaFiles and ImageFiles Patients Files depended path segment
//
//     Parameters
// APatId - Patient ID
// Result - Returns Patients Files depended path segment for MediaFiles and ImageFiles
//
function K_CMSlideGetPatientFilesPathSegm(APatID: Integer): string;
begin
  Result := K_CMSlideGetPatientFilesGroupPathSegm(APatID) + format
      ('PX_%.3d\', [APatID]);
end; // function K_CMSlideGetPatientFilesPathSegm

//******************************************** K_CMSlideGetFileDatePathSegm ***
// Get MediaFiles and ImageFiles Date depended path segment
//
//     Parameters
// ADT - Slide creation Date
// Result - Returns Patients Files depended path segment for MediaFiles and ImageFiles
//
function K_CMSlideGetFileDatePathSegm( ADTCr: TDateTime ): string;
begin
  Result := K_DateTimeToStr( ADTCr, 'yyyy-mm-dd') + '\';
end; // function K_CMSlideGetFileDatePathSegm

//********************************************** K_CMSlideGetFileIDPathSegm ***
// Get MediaFiles and ImageFiles Slide ID depended path segment
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Patients Files depended path segment for MediaFiles and ImageFiles
//
function K_CMSlideGetFileIDPathSegm( const ASlideID : string ): string;
begin
  Result := Copy('0000000' + ASlideID, Length(ASlideID), 8);
end; // function K_CMSlideGetFileIDPathSegm

//********************************************* K_CMSlideGetImgFilesNamePat ***
// Get Image Files Name Pattern
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide Image Files Name Pattern
//
function K_CMSlideGetImgFilesNamePat( const ASlideID: string ): string;
begin
  Result := 'RF_' + K_CMSlideGetFileIDPathSegm( ASlideID ) + '*.cmi';
end; // function K_CMSlideGetImgFilesNamePat

//******************************************** K_CMSlideGetDCMAttrsFileName ***
// Get DCM Attrs File Name
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide DCM Attrs File Name
//
function K_CMSlideGetDCMAttrsFileName(const ASlideID: string ): string;
begin
  Result := 'AF_' + K_CMSlideGetFileIDPathSegm( ASlideID ) + '.cmd';
end; // function K_CMSlideGetDCMAttrsFileName

//********************************************** K_CMSlideGetCurImgFileName ***
// Get Current Image File Name
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide Current Image File Name
//
function K_CMSlideGetCurImgFileName(const ASlideID: string ): string;
begin
  Result := 'RF_' + K_CMSlideGetFileIDPathSegm( ASlideID ) + '.cmi';
end; // function K_CMSlideGetCurImgFileName

//********************************************** K_CMSlideGetSrcImgFileName ***
// Get Original Image File Name
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide Original Image File Name
//
function K_CMSlideGetSrcImgFileName(const ASlideID: string ): string;
begin
  Result := 'RF_' + K_CMSlideGetFileIDPathSegm( ASlideID ) + 'r.cmi';
end; // function K_CMSlideGetSrcImgFileName

//******************************************* K_CMSlideGetMediaFileNamePref ***
// Get Media File Name Prefix
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide Original Image File Name
//
function K_CMSlideGetMediaFileNamePref(const ASlideID: string ): string;
begin
  Result := 'MF_' + K_CMSlideGetFileIDPathSegm( ASlideID );
end; // function K_CMSlideGetMediaFileNamePref

//*********************************************** K_CMSlideGetAttrsFileName ***
// Get Attributes File Name
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide Attributes File Name
//
function K_CMSlideGetAttrsFileName(const ASlideID: string ): string;
begin
  Result := 'AF_' + K_CMSlideGetFileIDPathSegm( ASlideID ) + '.cma';
end; // function K_CMSlideGetCurImgFileName

//**************************************************** K_CMStudyGetFileName ***
// Get Current Image File Name
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide Current Image File Name
//
function K_CMStudyGetFileName( const AStudyID: string ): string;
begin
  Result := 'SF_' + K_CMSlideGetFileIDPathSegm( AStudyID ) + '.cma';
end; // function K_CMStudyGetFileName

//********************************************* K_CMSlideGetImg3DFolderName ***
// Get 3D Image Folder Name
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide 3D Image Folder Name
//
function K_CMSlideGetImg3DFolderName(const ASlideID: string ): string;
begin
  Result := '3F_' + K_CMSlideGetFileIDPathSegm( ASlideID ) + '\';
end; // function K_CMSlideGetImg3DFolderName

//******************************************* K_CMSlideGetArchThumbFileName ***
// Get Archive Thumbnail File Name
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide Archive Thumbnail File Name
//
function K_CMSlideGetArchThumbFileName(const ASlideID: string ): string;
begin
  Result := 'TM_' + K_CMSlideGetFileIDPathSegm( ASlideID ) + '.dat';
end; // function K_CMSlideGetArchThumbFileName

//****************************************************** K_CMParseFilesPath ***
// Parse Images or Video Files Path
//
//     Parameters
// ASlideId - Slide ID
// Result - Returns Slide Original Image File Name
//
function K_CMParseFilesPath( var FPath: string ): Boolean;
begin
  Result := TRUE;
  if FPath <> '' then
  begin
    FPath := IncludeTrailingPathDelimiter(FPath);
    Result := FPath[1] = '!';
    if not Result then
      Result := FPath[1] = '>';
    if Result then
      FPath := Copy(FPath, 2, Length(FPath) - 1);
  end;
end; // function K_CMParseFilesPath


//**************************************************** K_CMGetMediaFileName ***
// Get Given Media Object File Name  given Slide Media File by ShellExecute
//
//     Parameters
// ANSlide - slide with media file
//
// !!!!!!!!! not used now
function K_CMGetMediaFileName(ANSlide: TN_UDCMSlide): string;
var
  UDMedia: TN_UDCompBase;
begin
  Result := '';
  // Old Slide Structure with TN_UDFile as file name Container
  // UDMedia := ANSlide.GetMediaObj();
  UDMedia := ANSlide.GetMapRoot();
  if (UDMedia = nil) or not(UDMedia is TN_UDFile) then
    Exit; // precaution
  Result := TN_UDFile(UDMedia).GetFullFileName;
end; // end of K_CMGetMediaFileName

//************************************************** K_CMPrepSlideMediaFile ***
// Prepare Media Slide File
//
//     Parameters
// ANSlide - slide with media file
// AFName  - slide media file name (if <> '' then warning dialog with given file name will be shown)
// AShowDialog - if TRUE then dialog window with user warning will be shown
// Result  - Returns TRUE if AFName on input is empty string and slide media file name exists.
//
// If on input AFName is not empty string then only Warning will be shown.
// If on input AFName is empty string then on output AFName will contain slide media file name
// and Result will be TRUE if file exists, else Warning will be shown.
//
function K_CMPrepSlideMediaFile(ANSlide: TN_UDCMSlide; var AFName: string;
  AShowDialog: Boolean): Boolean;
var
  WarnStr: string;
  MediaFilesStoringMode: Integer;
  RPath, SPath, TMPFName, FName, FPref, JoinFName, ClientFName, FileExt: string;
  SlideMediaShouldBeJoined: Boolean;
  SlideMediaShouldBeCopied: Boolean;
  MFStream: TFileStream;

  procedure CheckLocalFName();
  begin
    with TK_CMEDDBAccess(K_CMEDAccess) do
    begin
      AFName := SlidesClientMediaRootFolder + SPath + FPref + FileExt;
      Result := FileExists(AFName);
      ClientFName := AFName;
    end;
  end;

  procedure CheckServerFName();
  begin
    with TK_CMEDDBAccess(K_CMEDAccess) do
    begin
      RPath := K_ExpandFileName('(#TmpFiles#)' + SPath);
      AFName := RPath + FPref + FileExt;
      Result := FileExists(AFName);
      if not Result then
      begin
        // Try to Get From Server
        TMPFName := AFName;
        RPath := SlidesMediaRootFolder + SPath;
        AFName := RPath + FPref + FileExt;
        Result := K_edOK = EDAPathOrFileExists(AFName, SlidesMediaRootFDA,
          false);
        if not Result then
        begin
          // Dynamic Split Control
          FName := RPath + FPref + '_0.mfp';
          SlideMediaShouldBeJoined := K_edOK = EDAPathOrFileExists(FName,
            SlidesMediaRootFDA, false);
        end
        else
          SlideMediaShouldBeCopied := not SlidesMediaRootFDA;
      end;
    end;
  end;

begin
  Result := false;
  MediaFilesStoringMode := K_CMMediaFilesStoringMode;
  if not(K_CMEDAccess is TK_CMEDDBAccess) then
    MediaFilesStoringMode := 0;
  with ANSlide, P()^ do
  begin
    SPath := GetFilesPathSegm();
    FPref := GetMediaFileNamePref('');
    SlideMediaShouldBeJoined := false;
    SlideMediaShouldBeCopied := false;
    FileExt := CMSDB.MediaFExt;
    with TK_CMEDDBAccess(K_CMEDAccess) do
    begin
      if MediaFilesStoringMode = 0 then
      begin
        // Only Client
        CheckLocalFName();
        if not Result and (K_CMEDAccess is TK_CMEDDBAccess) and
          (SlidesMediaRootFolder <> '') then
        begin
          CheckServerFName();
          if K_CMSServerClientInfo.CMSClientVirtualName = CMSCompIDCreated then
            JoinFName := ClientFName
          else
            JoinFName := TMPFName;
        end;
      end  // if MediaFilesStoringMode = 0 then
      else if MediaFilesStoringMode = 1 then
      begin
        // Only Server
        CheckServerFName();
        JoinFName := TMPFName;
      end //  if MediaFilesStoringMode = 1 then
      else
      begin // if MediaFilesStoringMode > 1 then
        // Server and Client
        CheckLocalFName();
        if not Result then
        begin
          CheckServerFName();
          if K_CMSServerClientInfo.CMSClientVirtualName = CMSCompIDCreated then
            JoinFName := ClientFName
          else
            JoinFName := TMPFName;
        end;
      end;  // if MediaFilesStoringMode > 1 then

      if not Result then
      begin
        if SlideMediaShouldBeJoined then
        begin
          FName := ExtractFilePath(AFName) + FPref; // Create Server Name Prefix
          AFName := JoinFName;
          Result := K_ForceFilePath(JoinFName);
          if Result then
          begin
            MFStream := TFileStream.Create(JoinFName, fmCreate);
            Result := EDAJoinFilesToMediaStream(MFStream, FName,
              SlidesMediaRootFDA) = K_edOK;
            MFStream.Free;
          end;
        end
        else if SlideMediaShouldBeCopied then
        begin
          Result := K_edOK = EDACopyFileFromServer(AFName, JoinFName, SlidesMediaRootFDA);
          AFName := JoinFName;
        end;

        if not Result and ((MediaFilesStoringMode = 1)) and
          (K_CMSServerClientInfo.CMSClientVirtualName = CMSCompIDCreated) and
          (SlidesClientMediaRootFolder <> '') then
        begin
          // Try to use Client if file is absent on Server
          FName := AFName; // save Server File Name for Diagnostic
          CheckLocalFName();
          if not Result then
            AFName := FName; // Rstore Server File Name for Diagnostic
        end;
      end; // if not Result then
    end; // with TK_CMEDDBAccess(K_CMEDAccess) do
  end; // with ANSlide, P()^ do

  if Result then
    Exit;
  with ANSlide.P^ do
  begin
    WarnStr := format(
           K_CML1Form.LLLPrepVideoFile1.Caption,
//           'Video File %s is inaccessible!',
           [AFName] );
    if K_CMSServerClientInfo.CMSClientVirtualName <> CMSCompIDCreated then
      WarnStr := WarnStr + #13#10 + format(
                              K_CML1Form.LLLPrepVideoFile2.Caption,
//                              'May be it is allocated on computer %s',
                              [CMSCompIDCreated] );
    if not AShowDialog then
      N_Dump1Str( WarnStr )
    else
      K_CMShowMessageDlg1(WarnStr, mtWarning);
  end;
end; // end of K_CMPrepSlideMediaFile

//******************************************************* K_CMOpenMediaFile ***
// Open given Slide Media File by ShellExecute
//
//     Parameters
// ANSlide - slide with media file
//
procedure K_CMOpenMediaFile(ANSlide: TN_UDCMSlide);
var
  FName: string;
  WarnStr: string;
//  DisableActionsFlag : Boolean;
  SavedCursor: TCursor;
  OpenFileFlag : Boolean;

label LExit;
begin
  FName := '';
  OpenFileFlag := K_CMPrepSlideMediaFile(ANSlide, FName, TRUE);
  N_Dump2Str( 'Open Video ' + FName );
  if not OpenFileFlag then Exit;

  SavedCursor := Screen.Cursor;
  Screen.Cursor := crHourglass;

  N_CM_MainForm.CMMSetUIEnabled( FALSE );
{
  DisableActionsFlag := not (uicsAllActsDisabled in N_CM_MainForm.CMMUICurStateFlags);
  if DisableActionsFlag then
  begin
    // Disable CMS UI
    Include( N_CM_MainForm.CMMUICurStateFlags, uicsAllActsDisabled);
    N_CM_MainForm.CMMFDisableActions( nil );
    N_AppSkipEvents := TRUE;
    K_CMD4WSkipCloseUI := TRUE;
  end;
}
  if not K_CMVUIMode then
  begin
  // Try to Open
    WarnStr := '';
    K_ShellExecute('Open', FName, -1, @WarnStr);
    if WarnStr = '' then
      goto LExit;

    // Fail to Open
    WarnStr := WarnStr + ' while ' + FName + ' is opened';
    N_Dump1Str(WarnStr);

    // Try to Play
    WarnStr := '';
    K_ShellExecute('Play', FName, -1, @WarnStr);
    if WarnStr = '' then
      goto LExit;

    // Fail to Play
    WarnStr := WarnStr + ' while ' + FName + ' is played';
    Screen.Cursor := SavedCursor;
    K_CMShowMessageDlg(WarnStr, mtWarning); {sysout}
  end
  else
  begin // Special case for Virtual UI mode
    Screen.Cursor := SavedCursor;
    K_CMShowMessageDlg( 'To play this video export it before please.', mtInformation); {sysout}
  end;

LExit:
  N_CM_MainForm.CMMSetUIEnabled( TRUE );
  Screen.Cursor := SavedCursor;

end; // end of K_CMOpenMediaFile

//*********************************************** K_CMDeleteClientMediaFile ***
// Delete given Slide Media File
//
//     Parameters
// ANSlide - slide with media file
// AOnlyFileNameClear - if TRUE then only Slide MediaFile name will be cleared
//
procedure K_CMDeleteClientMediaFile(ANSlide: TN_UDCMSlide;
  AOnlyFileNameClear: Boolean = false);
var
  FName: string;
begin
  with ANSlide, P()^ do
  begin
    if not(cmsfIsMediaObj in CMSDB.SFlags) then
      Exit;
    FName := GetMediaFileClientName();
    with K_CMEDAccess do
    begin
      if AOnlyFileNameClear then
        CMSDB.MediaFExt := ''
      else
      if FName <> '' then
      begin
        if K_DeleteFile(FName) then
        begin
          if (K_CMMediaFilesStoringMode <> 1) and
             K_StrStartsWith( SlidesClientMediaRootFolder, FName) then
            EDARemovePathFolders0(FName, SlidesClientMediaRootFolder)
          else
          if K_CMEDAccess is TK_CMEDDBAccess then
            with TK_CMEDDBAccess(K_CMEDAccess) do
              if K_StrStartsWith( SlidesMediaRootFolder, FName) then
                EDARemovePathFolders1( FName, SlidesMediaRootFolder, SlidesMediaRootFDA)
          else
            N_Dump1Str('!!! No folders to remove for file ' + FName );
        end; // if K_DeleteFile(FName) then
      end; // if FName <> '' then
    end; // with K_CMEDAccess do
  end; // with ANSlide, P()^ do
end; // end of K_CMDeleteClientMediaFile

//*********************************************** K_CMSCheckMemConstraints0 ***
// Check Slides Total Memory Size
//
//     Parameters
// ASlide - slide which needes image data loading and should not be unload
// AUnloadAll - if TRUE try to unload all possible DIBs
// Result - Returns TRUE if AllSlides Save is Needed
//
// If Slides Total Memory Size is larger than given maximal size then some
// Slides should be unloaded from memory until minimal memory size
// should be reached. Given slide and edited slides should not be unloaded
//
function K_CMSCheckMemConstraints0( ASlide: TN_UDCMSlide; AUnloadAll : Boolean ): Boolean;
var
  NSlides: TN_UDCMSArray;
  NCount: Integer;
  CSlide: TN_UDCMSlide;
  TotalSize: UInt4;
  SlideSize: UInt4;
  i, SkipMemFreeCount: Integer;
  PSkipMemFree: PInteger;
  UDDIB: TN_UDDIB;
  UDFree: TN_UDBase;
  LocalDBMode: Boolean;
  SaveSlidesIsNeeded: Boolean;
  FreeObjInd: Integer;
  WAppRTID: Integer;
  WSlideID: string;
  PCMSlide : TN_PCMSlide;

  procedure TryToRemoveImage( AImgType: string);
  var
    WStr : string;
  begin
    if UDFree = nil then
      Exit;

    if not LocalDBMode or (UDFree.Owner <> CSlide) then
    begin
      WStr := format( 'CheckMem Free ID=%s %s', [CSlide.ObjName, AImgType] );
      if UDDIB.DIBObj <> nil then
      begin
        SlideSize := UInt4(UDDIB.DIBObj.DIBInfo.bmi.biSizeImage);
        TotalSize := TotalSize - SlideSize;
        N_Dump2Str( format( '%s DIB Size=%d', [WStr, SlideSize]) );
      end;
      if UDDIB.UDData <> nil then
      begin
        SlideSize := UInt4( Length(UDDIB.UDData) );
        TotalSize := TotalSize - SlideSize;
        N_Dump2Str( format( '%s UDData Size=%d', [WStr, SlideSize]) );
      end;
      if UDFree.Owner = CSlide then
        // Free in Ext DB Mode
        UDFree.Owner.PutDirChild(FreeObjInd, nil) // Clear Child in Sybase Mode
      else
      begin
        // Free in Self DB Mode
        K_CMEDAccess.EDASlideDIBToFile( UDFree.Owner );
{ // Old Free UDDIB Code
        if (UDFree.Owner.ClassFlags and K_ChangedSLSRBit) <> 0 then
          K_SaveCurArchiveSection(UDFree.Owner);
        UDFree.Owner.RemoveDirEntry(0); // Remove Section Child
}
      end;
    end
    else
      raise Exception.Create('Slide ' + CSlide.ObjName + AImgType + ' is without section' );
  end;


label LExit;

begin

  Result := false;
  if K_CMImgStartMemFreeSize <= 0 then
    Exit; // Memory Constraints are not set

  ///////////////////////////////////////////////////
  // Calculate Total Memory Size of Loaded Images
  // and build then array of slides NSlides
  // that can be unloaded from memory
  //
  NCount := 0;
  SetLength(NSlides, K_CMEDAccess.CurSlidesList.Count);
  TotalSize := 0;
  N_Dump2Str( format( 'CheckMem Start NumAll=%d',
      [Length(NSlides)]) );

  PSkipMemFree := nil;
  SkipMemFreeCount := Length(K_CMSlidesToSkipMemFree);
  if SkipMemFreeCount > 0 then
    PSkipMemFree := PInteger(@K_CMSlidesToSkipMemFree[0]);

  for i := 0 to High(NSlides) do
  begin

    CSlide := TN_UDCMSlide(K_CMEDAccess.CurSlidesList[i]);
    if (TN_UDCMBSlide(CSlide) is TN_UDCMStudy) or
       (cmsfIsMediaObj in CSlide.P.CMSDB.SFlags) then Continue;

    SlideSize := 0;
    UDDIB := CSlide.GetMapImage(TRUE);
    if (UDDIB <> nil) and (UDDIB.DIBObj <> nil) then
      SlideSize := UDDIB.DIBObj.DIBInfo.bmi.biSizeImage;

    UDDIB := CSlide.GetCurrentImage(TRUE,TRUE);
    if UDDIB <> nil then begin
      if UDDIB.DIBObj <> nil then
        SlideSize := SlideSize + UDDIB.DIBObj.DIBInfo.bmi.biSizeImage;
      if UDDIB.UDData <> nil then
        SlideSize := SlideSize + UInt4(Length(UDDIB.UDData));
    end;

    UDDIB := CSlide.GetSourceImage(TRUE,TRUE);
    if UDDIB <> nil then begin
      if UDDIB.DIBObj <> nil then
        SlideSize := SlideSize + UDDIB.DIBObj.DIBInfo.bmi.biSizeImage;
      if UDDIB.UDData <> nil then
        SlideSize := SlideSize + UInt4(Length(UDDIB.UDData));
    end;

    TotalSize := TotalSize + SlideSize;

    if (CSlide = ASlide) or (SlideSize = 0) or
      (cmsfIsOpened in CSlide.P.CMSRFlags) then
      Continue;
    // (N_CM_MainForm.CMMFFindEdFrame( CSlide ) <> nil) then Continue;

    // Skip Slides from special Skip List
    if (PSkipMemFree <> nil) and (K_IndexOfIntegerInRArray(Integer(CSlide),
        PSkipMemFree, SkipMemFreeCount) >= 0) then
      Continue;

    NSlides[NCount] := CSlide;
    Inc(NCount);
  end;

  if not AUnloadAll and ((NCount > 0) and (TotalSize < K_CMImgStartMemFreeSize)) then
    Exit;

  //////////////////////////////////////////////
  // Unload unused Images from memory
  //
  WAppRTID := -1;
  LocalDBMode := not(K_CMEDAccess is TK_CMEDDBAccess);
  if not LocalDBMode then
    WAppRTID := TK_CMEDDBAccess(K_CMEDAccess).AppRTID;
  WSlideID := '*';
  if ASlide <> nil then
    WSlideID := ASlide.ObjName;

  N_Dump2Str(format(
      'CheckMem NumAll=%d NumToFree=%d TotalOccupied=%u Slide=%s ActRTID=%d',
      [Length(NSlides), NCount, TotalSize, WSlideID, WAppRTID]));

  for i := 0 to NCount - 1 do
  begin
    CSlide := NSlides[i];
    PCMSlide := CSlide.P;

    SaveSlidesIsNeeded := (cmsfIsNew in PCMSlide.CMSRFlags);
    Result := Result or SaveSlidesIsNeeded;

    if SaveSlidesIsNeeded then
      Continue; // Slide Saving is Needed - skip Remove from memory is

    // *** Free Slide Source Image
    UDDIB := CSlide.GetSourceImage(TRUE,TRUE);
    UDFree := UDDIB;
    FreeObjInd := K_CMSlideIndSrcImg;
    TryToRemoveImage( ' SrcImg' );
    if not AUnloadAll and (TotalSize <= K_CMImgStopMemFreeSize) then
      goto LExit; // Needed Memory size is reached

    SaveSlidesIsNeeded := CSlide.CMSUndoBuf <> nil;
    if SaveSlidesIsNeeded then
    begin
      CSlide.CMSUndoBuf.UBSetSlideChangeDataFlags();
      SaveSlidesIsNeeded := cmsfCurImgChanged in PCMSlide.CMSRFlags;
    end;
    Result := Result or SaveSlidesIsNeeded;
    if SaveSlidesIsNeeded then
      Continue; // Slide Image Saving is Needed - skip Remove from memory

    // *** Free Slide Current Image
    UDDIB := CSlide.GetCurrentImage(TRUE,TRUE);
    UDFree := UDDIB;
    FreeObjInd := K_CMSlideIndCurImg;
    TryToRemoveImage( ' CurImg' );

    if not AUnloadAll and (TotalSize <= K_CMImgStopMemFreeSize) then
      goto LExit; // Needed Memory size is reached

    // *** Free Slide Temporary Image
    UDDIB := CSlide.GetMapImage(TRUE);
    if UDDIB = nil then
      Continue;

    SaveSlidesIsNeeded := ((CSlide.CMSUndoBuf <> nil) and
                           (cmsfMapRootChanged in PCMSlide.CMSRFlags)) or
                          (cmsfIsPrinting in PCMSlide.CMSRFlags);
    Result := Result or SaveSlidesIsNeeded;
    if SaveSlidesIsNeeded then
      Continue; // Slide Image Saving is Needed - skip Remove from memory

    SlideSize := UDDIB.DIBObj.DIBInfo.bmi.biSizeImage;
    TotalSize := TotalSize - SlideSize;
    CSlide.ClearMapImage();
    N_Dump2Str( format(
        'CheckMem Free ID=%s MapImg Size=%d', [CSlide.ObjName, SlideSize]) );

    if not AUnloadAll and (TotalSize <= K_CMImgStopMemFreeSize) then
      goto LExit; // Needed Memory size is reached
  end;

LExit :
  if NCount > 0 then
    N_Dump2Str(format(
        'ResultMem TotalSize=%u ActRTID=%d', [TotalSize, WAppRTID]));

//  K_CMImgCurMemSize := TotalSize;

end; // end of K_CMSCheckMemConstraints0

//*********************************************** K_CMSCheckMemConstraints1 ***
// Check Slides Total Memory Size
//
//     Parameters
// ASlide - slide which needes image data loading and should not be unload
// AUnloadAll - if TRUE try to unload all possible DIBs
// Result - Returns TRUE if AllSlides Save is Needed
//
// If Slides Total Memory Size is larger than given maximal size then some
// Slides should be unloaded from memory until minimal memory size
// should be reached. Given slide and edited slides should not be unloaded
//
procedure K_CMSCheckMemConstraints1(ASlide: TN_UDCMSlide; AUnloadAll : Boolean );
var
  OtherCount: Integer;
  AllSlides: TN_UDCMSArray;
  OpenedCount: Integer;
  OpenedSlides: TN_UDCMSArray;
  OpeningCount: Integer;
  OpeningSlides: TN_UDCMSArray;
  NewCount: Integer;
  NewSlides: TN_UDCMSArray;
  FMCount : Integer;
  ClosingCount : Integer;
  ClosingSlides: TN_UDCMSArray;
  CSlide: TN_UDCMSlide;
  TotalSize: UInt4;
  SlideSize: UInt4;
  i, SkipMemFreeCount: Integer;
  PSkipMemFree: PInteger;
  UDDIB: TN_UDDIB;
  UDFree: TN_UDBase;
  LocalDBMode: Boolean;
  FreeObjInd: Integer;
  WAppRTID: Integer;
  WSlideID: string;
  PCMSlide : TN_PCMSlide;
  FreeCount: Integer;

  procedure RemoveUDImage( AImgType: string);
  var
    WStr : string;
  begin
    if UDFree = nil then
      Exit;

    if not LocalDBMode or (UDFree.Owner <> CSlide) then
    begin
      WStr := format( 'CheckMem Free ID=%s%s', [CSlide.ObjName, AImgType] );
      if UDDIB.DIBObj <> nil then
      begin
        SlideSize := UInt4(UDDIB.DIBObj.DIBInfo.bmi.biSizeImage);
        TotalSize := TotalSize - SlideSize;
        N_Dump2Str( format( '%s DIB Size=%d', [WStr, SlideSize]) );
      end;
      if UDDIB.UDData <> nil then
      begin
        SlideSize := UInt4( Length(UDDIB.UDData) );
        TotalSize := TotalSize - SlideSize;
        N_Dump2Str( format( '%s UDData Size=%d', [WStr, SlideSize]) );
      end;

      // Remove TN_UDDIB from Memory
      Inc(FreeCount);
      if UDFree.Owner = CSlide then
        // Free in Ext DB Mode
        UDFree.Owner.PutDirChild(FreeObjInd, nil) // Clear Child in Sybase Mode
      else
        // Free in Self DB Mode
        K_CMEDAccess.EDASlideDIBToFile( UDFree.Owner );
    end
    else
      raise Exception.Create('Slide ' + CSlide.ObjName + AImgType + ' is without section' );
  end; // RemoveUDImage


  function FreeSlidesOriginalImage(  APSlide: TN_PUDCMSlide; ASlideCount : Integer ) : Boolean;
  var i : Integer;
  begin
    Result := FALSE;
    for i := 0 to ASlideCount - 1 do
    begin
      Result := not AUnloadAll and (TotalSize <= K_CMImgStopMemFreeSize);
      if Result then break; // Needed Memory size is reached

      // *** Free Slide Original Image
      CSlide := APSlide^;
      PCMSlide := CSlide.P;
      if not LocalDBMode or
         not (cmsfSaveSrcImg in PCMSlide.CMSDB.SFlags) then
      begin
        UDDIB := CSlide.GetSourceImage(TRUE,TRUE);
        UDFree := UDDIB;
        FreeObjInd := K_CMSlideIndSrcImg;
        RemoveUDImage( ' SrcImg' );
      end;

      Inc(APSlide);
    end;
  end;

  function FreeSlidesCurrentImage(  APSlide: TN_PUDCMSlide; ASlideCount : Integer; ASkipOpened : Boolean ) : Boolean;
  var i : Integer;
  begin
    Result := FALSE;
    for i := 0 to ASlideCount - 1 do
    begin
      Result := not AUnloadAll and (TotalSize <= K_CMImgStopMemFreeSize);
      if Result then break; // Needed Memory size is reached
      // *** Free Slide Original Image
      CSlide := APSlide^;
      PCMSlide := CSlide.P;
      if ( not LocalDBMode or
           not ((cmsfCurImgChanged in PCMSlide.CMSRFlags) or
                (cmsfIsNew         in PCMSlide.CMSRFlags) ) ) and
         ( not ASkipOpened                          or
           not (cmsfIsOpened in PCMSlide.CMSRFlags) ) then
      begin
        UDDIB := CSlide.GetCurrentImage(TRUE,TRUE);
        UDFree := UDDIB;
        FreeObjInd := K_CMSlideIndCurImg;
        RemoveUDImage( ' CurImg' );
      end;
      Inc(APSlide);
    end;
  end;

  function FreeSlidesMapImage(  APSlide: TN_PUDCMSlide; ASlideCount : Integer; ASkipOpened : Boolean ) : Boolean;
  var i : Integer;
  begin
    Result := FALSE;
    for i := 0 to ASlideCount - 1 do
    begin
      Result := not AUnloadAll and (TotalSize <= K_CMImgStopMemFreeSize);
      if Result then break; // Needed Memory size is reached
      // *** Free Slide Map (Temporary) Image
      CSlide := APSlide^;
      PCMSlide := CSlide.P;
      UDDIB := CSlide.GetMapImage(TRUE);
      if UDDIB <> nil then
      begin
//        if not (cmsfIsPrinting in PCMSlide.CMSRFlags) and // is Used in Current Print Preview Page
//           ((CSlide.CMSUndoBuf = nil) or (cmsfMapRootChanged in PCMSlide.CMSRFlags)) then
//            CSlide.DirChild(K_CMSlideIndThumbnail)

//        if not (cmsfIsPrinting in PCMSlide.CMSRFlags) and         // is Used in Current Print Preview Page
//           (CSlide.DirChild(K_CMSlideIndThumbnail) <> nil) then   // Slide Thumbnail is not created - actual while ImportImage after convertion
//         may be is not needed - because each importing slide is stored immediately before memory swaping

//        if not (cmsfIsPrinting in PCMSlide.CMSRFlags) then   // Slide Thumbnail is not created - actual while ImportImage after convertion
        if not (cmsfIsPrinting in PCMSlide.CMSRFlags) and // is Used in Current Print Preview Page
           ( not ASkipOpened                          or
             not (cmsfIsOpened in PCMSlide.CMSRFlags) ) then
        begin
          N_Dump2Str( format(
              'CheckMem Free MapImg start ID=%s', [CSlide.ObjName]) );
          SlideSize := UInt4(UDDIB.DIBObj.DIBInfo.bmi.biSizeImage);
          TotalSize := TotalSize - SlideSize;
          CSlide.ClearMapImage();
          Inc(FreeCount);
          N_Dump2Str( format(
              'CheckMem Free ID=%s MapImg Size=%d', [CSlide.ObjName, SlideSize]) );
        end;
      end;
      Inc(APSlide);
    end;
  end;

label LExit;

begin

  if K_CMImgStartMemFreeSize <= 0 then
    Exit; // Memory Constraints are not set

  /////////////////////////////////////////////////
  // Calculate Total Memory Size of Loaded Images
  // and build then array of slides AllSlides
  // that can be unloaded from memory
  //
  OtherCount := 0;
  SetLength(AllSlides, K_CMEDAccess.CurSlidesList.Count);
  OpenedCount := 0;
  SetLength(OpenedSlides, K_CMEDAccess.CurSlidesList.Count);
  NewCount := 0;
  SetLength(NewSlides, K_CMEDAccess.CurSlidesList.Count);

  TotalSize := 0;
  N_Dump2Str( format( 'CheckMem Start NumAll=%d',
      [Length(AllSlides)]) );

  PSkipMemFree := nil;
  SkipMemFreeCount := Length(K_CMSlidesToSkipMemFree);
  if SkipMemFreeCount > 0 then
    PSkipMemFree := PInteger(@K_CMSlidesToSkipMemFree[0]);
  OpeningCount := 0;
  SetLength(OpeningSlides, SkipMemFreeCount);

  FMCount := Length(K_CMSlidesToMemFree);
  SetLength( ClosingSlides, FMCount );
  ClosingCount := 0;

  LocalDBMode := not (K_CMEDAccess is TK_CMEDDBAccess);

  for i := 0 to High(AllSlides) do
  begin
    // Skip Studies and Video
    CSlide := TN_UDCMSlide(K_CMEDAccess.CurSlidesList[i]);
    PCMSlide := CSlide.P;
    if (TN_UDCMBSlide(CSlide) is TN_UDCMStudy) or
       (cmsfIsMediaObj in PCMSlide.CMSDB.SFlags) then Continue;

    SlideSize := 0;
    UDDIB := CSlide.GetMapImage(TRUE);
    if (UDDIB <> nil) and (UDDIB.DIBObj <> nil) then
      SlideSize := UDDIB.DIBObj.DIBInfo.bmi.biSizeImage;

    UDDIB := CSlide.GetCurrentImage(TRUE,TRUE);
    if UDDIB <> nil then begin
      if UDDIB.DIBObj <> nil then
        SlideSize := SlideSize + UDDIB.DIBObj.DIBInfo.bmi.biSizeImage;
      if UDDIB.UDData <> nil then
        SlideSize := SlideSize + UInt4(Length(UDDIB.UDData));
    end;

    UDDIB := CSlide.GetSourceImage(TRUE,TRUE);
    if UDDIB <> nil then begin
      if UDDIB.DIBObj <> nil then
        SlideSize := SlideSize + UDDIB.DIBObj.DIBInfo.bmi.biSizeImage;
      if UDDIB.UDData <> nil then
        SlideSize := SlideSize + UInt4(Length(UDDIB.UDData));
    end;

    TotalSize := TotalSize + SlideSize;

    // Skip Current Active and Empty Slides
    if (CSlide = ASlide) or (SlideSize = 0) then
      Continue;

    // Skip Closing
    if (FMCount > 0) and
       (K_IndexOfIntegerInRArray(Integer(CSlide),
                   PInteger(@K_CMSlidesToMemFree[0]), FMCount) >= 0) then
    begin
      ClosingSlides[ClosingCount] := CSlide;
      Inc(ClosingCount);
      Continue;
    end;

    // Add Slides to Opening from special Skip List - before Open Loop Start
    if (SkipMemFreeCount > 0) and (ASlide = nil) and
       (K_IndexOfIntegerInRArray(Integer(CSlide),
                                 PSkipMemFree, SkipMemFreeCount) >= 0) then
    begin
      OpeningSlides[OpeningCount] := CSlide;
      Inc(OpeningCount);
      Continue; // Opening Slide should not be included to Opened
    end;

    // Add Slides to Opened
    if cmsfIsOpened in PCMSlide.CMSRFlags then
    begin
      OpenedSlides[OpenedCount] := CSlide;
      Inc(OpenedCount);
      Continue;
    end;

    // Add Slides to New
    if cmsfIsNew in PCMSlide.CMSRFlags then
    begin
      NewSlides[NewCount] := CSlide;
      Inc(NewCount);
      Continue;
    end;

    AllSlides[OtherCount] := CSlide;
    Inc(OtherCount);
  end;

  if not AUnloadAll and (TotalSize < K_CMImgStartMemFreeSize) then
    Exit;

  WAppRTID := -1;
  if not LocalDBMode then
    WAppRTID := TK_CMEDDBAccess(K_CMEDAccess).AppRTID;

  WSlideID := '*';
  if ASlide <> nil then
    WSlideID := ASlide.ObjName;

  ///////////////////////////////////////////
  // Store to K_CMSlidesToMemFree Opened Slides
  // which will be closed during MediaOpen Action
  //
  if (SkipMemFreeCount > 0) and (OpenedCount > 0) and (ASlide = nil) then
  begin
    K_CMSlidesToMemFree := Copy( OpenedSlides, 0, OpenedCount );
    ClosingCount := OpenedCount;
    ClosingSlides := K_CMSlidesToMemFree;
    OpenedCount := 0;
  end;

  N_Dump2Str( format(
      'CheckMem All=%d Opened=%d Opening=%d Closing=%d New=%d Other=%d ' + #13#10 +
      '               TotalOccupied=%u SkipSlide=%s FreeAll=%s ActRTID=%d',
      [Length(AllSlides), OpenedCount, OpeningCount, ClosingCount, NewCount, OtherCount,
       TotalSize, WSlideID, N_B2S(AUnloadAll), WAppRTID] ) );

  if OpenedCount + OpeningCount + ClosingCount + NewCount + OtherCount = 0 then Exit;

  //////////////////////////////////////////////
  // Unload unused Images from memory
  //

  FreeCount := 0;

// 1 //////////////////////////////////////////
//  Free Original DIBs in Other, Opened, Closing and Opening
//
// Free Priority 1
  if OtherCount > 0 then
  begin
    N_Dump2Str( 'CheckMem Start Other Original Free' );
    if FreeSlidesOriginalImage( @AllSlides[0], OtherCount ) then goto LExit;
  end;

// Free Priority 2
 if ClosingCount > 0 then
  begin
    N_Dump2Str( 'CheckMem Start Closing Original Free' );
    if FreeSlidesOriginalImage( @ClosingSlides[0], ClosingCount ) then goto LExit;
  end;

// Free Priority 3
  if OpenedCount > 0 then
  begin
    N_Dump2Str( 'CheckMem Start Opened Original Free' );
    if FreeSlidesOriginalImage( @OpenedSlides[0], OpenedCount ) then goto LExit;
  end;

// Free Priority 4
  if OpeningCount > 0 then
  begin
    N_Dump2Str( 'CheckMem Start Opening Original Free' );
    if FreeSlidesOriginalImage( @OpeningSlides[0], OpeningCount ) then goto LExit;
  end;
//
// end of Free Original DIBs
/////////////////////////////

// 2 //////////////////////////////
//  Free Other Map and Current DIBs
//
  if OtherCount > 0 then
  begin
// Free Priority 5
    N_Dump2Str( 'CheckMem Start Other Map Free' );
    if FreeSlidesMapImage( @AllSlides[0], OtherCount, FALSE ) then goto LExit;

// Free Priority 6
    N_Dump2Str( 'CheckMem Start Other Current Free' );
    if FreeSlidesCurrentImage( @AllSlides[0], OtherCount, FALSE ) then goto LExit;
  end;
//
// end of Free Other DIBs
///////////////////////////

// 3 //////////////////////////////////////////////////////
//  Free Closing Map and Current (During MediaOpen action)
//
  if ClosingCount > 0 then
  begin
// Free Priority 7
    N_Dump2Str( 'CheckMem Start Closing Map Free' );
    if FreeSlidesMapImage( @ClosingSlides[0], ClosingCount, FALSE ) then goto LExit;

// Free Priority 8
    N_Dump2Str( 'CheckMem Start Closing Current Free' );
    if FreeSlidesCurrentImage( @ClosingSlides[0], ClosingCount, FALSE ) then goto LExit;
  end
  else
//
//  Free Closing DIBs
//////////////////////

// 4 ////////////////////////////////////////////////////////
//  Free New Map, Original, Current (if New then no Opening)
//
  if NewCount > 0 then
  begin
// Free Priority 7
    N_Dump2Str( 'CheckMem Start New Map Free' );
    if FreeSlidesMapImage( @NewSlides[0], NewCount, FALSE ) then goto LExit;

// Free Priority 8
    N_Dump2Str( 'CheckMem Start New Original Free' );
    if FreeSlidesOriginalImage( @NewSlides[0], NewCount ) then goto LExit;

// Free Priority 9
    N_Dump2Str( 'CheckMem Start New Current Free' );
    if FreeSlidesCurrentImage( @NewSlides[0], NewCount, FALSE ) then goto LExit;
  end;
//
//  Free New DIBs
///////////////////

// 5 //////////////////////////////////////////////////////
//  Free Opening Map and Current (During MediaOpen action)
//  Skip already Opened from Opening List
//
  if OpeningCount > 0 then
  begin
// Free Priority 9
    N_Dump2Str( 'CheckMem Start Opening Map Free' );
    if FreeSlidesMapImage( @OpeningSlides[0], OpeningCount, TRUE ) then goto LExit;

// Free Priority 10
    N_Dump2Str( 'CheckMem Start Opening Current Free' );
    if FreeSlidesCurrentImage( @OpeningSlides[0], OpeningCount, TRUE ) then goto LExit;
  end;
//
//  Free Opening DIBs
//////////////////////

LExit :
  if FreeCount > 0 then
    N_Dump2Str(format(
        'ResultMem TotalSize=%u ActRTID=%d', [TotalSize, WAppRTID]));
//    N_Dump2Str( format( 'ResultMem MinSize=%u TotalOccupied=%u MaxSize%u ActRTID=%d',
//                        [K_CMImgStopMemFreeSize,TotalSize,K_CMImgMaxMemSize,WAppRTID] ) );

//  K_CMImgCurMemSize := TotalSize;

end; // end of K_CMSCheckMemConstraints1

//************************************************ K_CMSCheckMemConstraints ***
// Check Slides Total Memory Size
//
//     Parameters
// ASlide - slide which needes image data loading and should not be unload
// AUnloadAll - if TRUE try to unload all possible DIBs
// Result - Returns TRUE if AllSlides Save is Needed
//
// If Slides Total Memory Size is larger than given maximal size then some
// Slides should be unloaded from memory until minimal memory size
// should be reached. Given slide and edited slides should not be unloaded
//
function K_CMSCheckMemConstraints( ASlide: TN_UDCMSlide; AUnloadAll : Boolean = FALSE ): Boolean;
//var
//  CurMinMemSize : UInt4; // Debug
begin
  if K_CMSCheckMemConstraintsUseECacheMode then
  begin
//    CurMinMemSize := K_CMImgStopMemFreeSize;  // Debug
//    K_CMImgStopMemFreeSize := 1;              // Debug
    K_CMSCheckMemConstraints1( ASlide, AUnloadAll );
//    K_CMImgStopMemFreeSize := CurMinMemSize;  // Debug
    Result := FALSE;
  end
  else
    Result := K_CMSCheckMemConstraints0( ASlide, AUnloadAll );
end; // end of K_CMSCheckMemConstraints

//***************************************************** K_CMSSetUDTableInfo ***
// Set CMS text info to IDB Table
//
//     Parameters
// AText  - info text
// AUDTable - IDB info table
// Result - Returns TRUE if proper CMS text info is given
//
function K_CMSSetUDTableInfo(AText: string; AUDTable: TK_UDRArray): Boolean;
var
  StrMatr: TN_ASArray;
  SL: TStrings;
  i, j, RCount, CCount: Integer;
label LExit;
begin

  SL := TStringList.Create;
  N_ReplaceEQSSubstr( AText, '"', Char($01) );
  SL.Text := AText;
  K_LoadSMatrFromStrings( StrMatr, SL, smfTab );
  N_ReplaceEQSSubstrInSMatr( StrMatr, Char($01), '"' );

  Result := false;

  RCount := Length(StrMatr);
  if RCount <= 1 then
  begin
    N_Dump1Str( 'D4W >> Info Error' );
    if K_CMS_LogsCtrlAll then
      N_Dump1Strings( SL, 5 );
    goto LExit;
  end;

  CCount := Length(StrMatr[0]);
  if CCount = 0 then goto LExit;

  with AUDTable.R do
  begin
    ASetLength(CCount, RCount);
    for i := 0 to RCount - 1 do
      for j := 0 to CCount - 1 do
        PString(PME(j, i))^ := StrMatr[i][j];
  end;
  N_Dump2Str( 'D4W Info applied >> ' + AUDTable.ObjName );
  SL.Clear;
  N_SaveSMatrToStrings2( StrMatr, SL, smfCSV );
  if K_CMS_LogsCtrlAll then
    N_Dump2Strings( SL, 5 );
  Result := TRUE;
LExit:
  SL.Free;
  Exit;
end; // *** end of K_CMSSetUDTableInfo

//************************************************ K_CMInitAutoImgProcAttrs ***
// Init Image Auto Processing Attributes
//
//    Parameters
// APCMAutoImgPAttrs - pointer to Auto Image Processing Attributes
// Result  - Returns TRUE if atributes are changed by initialization
//
function K_CMInitAutoImgProcAttrs( APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs ): Boolean;
begin
  Result := FALSE;
  with APCMAutoImgPAttrs^ do
  begin
    if (K_aipfNoiseReduction in CMAIPFlags) then
    begin
      CMAIPFlags := CMAIPFlags - [K_aipfNoiseReduction];
      CMAIPFlags := CMAIPFlags + [K_aipfNRSelf];
      CMAINRThreshold1 := 0.55;
      Result := TRUE
    end;
    if K_aipfSSConv in CMAIPFlags then
    begin
      CMAIPFlags := CMAIPFlags - [K_aipfSSConv];
      if CMAIPSSFactor >= 0 then
      begin
        CMAIPFlags := CMAIPFlags + [K_aipfSmooth];
        CMAISmoothPower := CMAIPSSFactor;
        Result := TRUE
      end
      else
      begin
        CMAIPFlags := CMAIPFlags + [K_aipfSharp];
        CMAISharpPower := -CMAIPSSFactor;
        Result := TRUE
      end;
      CMAIPSSFactor := 0;
    end;
    if CMAIMedianDepth = 0 then    // To prevent AutoBound
      CMAIMedianDepth := 5;
    if CMAIDespeckleDepth = 0 then // To prevent AutoBound
      CMAIDespeckleDepth := 5;
  end;
end; // function K_CMInitAutoImgProcAttrs

//***************************************** K_CMGetAutoImgProcAttrsDumpText ***
// Get Image Auto Processing Attributes Dump Text
//
//    Parameters
// APCMAutoImgPAttrs - pointer to Auto Image Processing Attributes
// Result - Returns Dump Text
//
function K_CMGetAutoImgProcAttrsDumpText( APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs ) : string;
begin
  Result := '';
  if APCMAutoImgPAttrs = nil then Exit;
  with APCMAutoImgPAttrs^ do
    Result := format('UFilter  Flags=$%.3x Ang=%d Bri=%g Co=%g Gam=%g LL=%g LU=%g Res=%g ' +
                       ' NRT=%g MD=%d DD=%d SMP=%g SMD=%d SHP=%g SHD=%d',
                       [LongWord(CMAIPFlags), CMAIPAngl, CMAIPBriFactor,
                        CMAIPCoFactor, CMAIPGamFactor, CMAIBriLLFactor, CMAIBriULFactor,
                        CMAIPResolution, CMAINRThreshold1, CMAIMedianDepth, CMAIDespeckleDepth,
                        CMAISmoothPower, CMAISmoothDepth, CMAISharpPower, CMAISharpDepth]);
end; // procedure K_CMGetAutoImgProcAttrsDumpText


//****************************************************** N_HistFindLLULPar2 ***
// Find ALL (Lower Limit) and AUL (Upper Limit) Variant #2 with integer parametr
//
//     Parameters
// AHistValues - given Histogramm Values
// AIntPar     - given integer parametr ( 0-exclude both (peaks and valleys), 1-exclude only peaks)
// ALL         - calculated Lower Limit (on output)
// AUL         - calculated Upper Limit (on output)
//
procedure N_HistFindLLULPar2XX( AHistValues: TN_IArray; AIntPar: Integer; out AML, ALL, AUL, AMU: integer );
var
  HNZVals, HNZInds : TN_IArray;
  CoefMean, Coef, CoefSum, CoefNum, CoefMinVal, CoefPeak{, CoefPeakCut} : Double;
  SumAll, ThresholdSum, MaxNum, MinVal, MaxVal, MaxInd : Integer;
begin
  N_Dump2Str( 'N_HistFindLLULPar2 start, AIntPar=' + IntToStr(AIntPar) );

  N_HistRemoveZeros2( AHistValues, HNZVals, HNZInds ); // Remove Zero Values

  if Length(HNZVals) = 0 then
  begin
    AML := 0;
    ALL := 0;
    AUL := High(AHistValues);
    AMU := AUL;
    Exit;
  end;
  AML := HNZInds[0];
  AMU := HNZInds[High(HNZInds)];

  CoefMean   := 0.6;   // Smoothing LineComb Coef
  Coef       := 0.9;   // MinMax Value Search Coef - Part of previous Histogram Element
  CoefSum    := 0.01;  // Area Treshold Coef - Part of All Histogram
  CoefNum    := 0.2;   // Histogram End Mounts Maximal Width Coef - Part of All Histogram elements number
  CoefMinVal := 0.075; // Value Treshold Coef - Part of Maximal Histogram Element
  CoefPeak   := 1.75;  // Peak Value Detect Coef - Part of previous Histogram Element

//  N_BrighHistToFile( HNZVals, 'C:\!Atmp\Hist2_1.txt', 'After remove zeros' );
  N_HistRemovePeaks1( HNZVals, CoefPeak ); // Remove Peak Values
//  N_BrighHistToFile( HNZVals, 'C:\!Atmp\Hist2_2.txt', Format( 'CoefPeak = %.3f', [CoefPeak] ) );

  N_HistSmooth1( HNZVals, CoefMean ); // Smooth Values

// Calc MaxVal and MaxInd - Max Value in HNZVals excluding some inteval on both ends
//  MaxVal := N_HistMiddleMax1( HNZVals );
  MaxInd := N_HistMiddleMax2( HNZVals, 5, 0.2 );
  MaxVal := HNZVals[MaxInd];

  SumAll := SumInt( HNZVals );
  ThresholdSum := Round( SumAll*CoefSum );
  MaxNum := Max(1, Round(Length(HNZVals) * CoefNum) );
  MinVal := Max(1, Round(CoefMinVal * MaxVal) );
//  MinVal := Min(MinVal, Round(2 * ThresholdSum / MaxNum) );

  if AIntPar = 1 then MinVal := 0;

  N_HistFindLLUL( HNZVals, Coef, ThresholdSum, MaxNum, MinVal, ALL, AUL );

//  N_BrighHistToFile( HNZVals, 'C:\!Atmp\Hist2_3.txt',
//    Format( 'CoefMean=%.3f, SumAll=%d, Coef=%.2f, ThresholdSum=%d, MaxNum=%d, MinVal=%d *** ALL=%d, AUL=%d',
//             [CoefMean,SumAll,Coef,ThresholdSum,MaxNum,MinVal,ALL,AUL] ) );

// Restore original LL/UL Values
// ( conv indexes in HNZVals array to indexes in AHistValues array)

  ALL := HNZInds[ALL];
  AUL := HNZInds[AUL];
end; // function N_HistFindLLULPar2

//************************************************ K_CMDumpAutoImgProcAttrs ***
// Dump Image Auto Processing Attributes
//
//    Parameters
// APCMAutoImgPAttrs - pointer to Auto Image Processing Attributes
//
procedure K_CMDumpAutoImgProcAttrs( APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs );
begin
  with APCMAutoImgPAttrs^ do
    N_Dump2Str( K_CMGetAutoImgProcAttrsDumpText(APCMAutoImgPAttrs) );
end; // procedure K_CMDumpAutoImgProcAttrs

//********************************** K_CMFlipRotateNegateByAutoImgProcAttrs ***
// Convert Slide Flip|Rotate|Negate flags set by Auto Image Processing Attributes
//
//    Parameters
// ADIBObj         - Slide Image DIBObj
// APCMSMRImgAttrs - pointer to SLide MapRoot attributes
// APCMAutoImgPAttrs - pointer to Auto Image Processing Attributes
// ACurFlipRotateAttrs - Slide General Flip|Rotate|Negate Flags from Auto Image Processing Attributes Flip|Rotate|Negate Flags
// Result - Returns TRUE if Slide MapRoot was changed
//
function K_CMFlipRotateNegateByAutoImgProcAttrs( ADIBObj : TN_DIBObj;
                          APCMSMRImgAttrs : TK_PCMSMRImgAttrs;
                          APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs;
                          out ACurFlipRotateAttrs : Integer ) : Boolean;
var
  WrkLLFactor, WrkULFactor : FLoat;
  HistValues : TN_IArray;
  ILL, IUL : Integer;

begin
  Result := FALSE;
  with APCMAutoImgPAttrs^, APCMSMRImgAttrs^ do
  begin
    ACurFlipRotateAttrs := 0;
    if CMAIPAngl <> 0 then
    begin
      MRFlipRotateAttrs := N_RotateFRFlags(MRFlipRotateAttrs, 90 * CMAIPAngl);
      ACurFlipRotateAttrs := N_RotateFRFlags(0, 90 * CMAIPAngl);
      Result := TRUE;
    end;
    if K_aipfFlipHor in CMAIPFlags then
    begin
      MRFlipRotateAttrs := MRFlipRotateAttrs xor N_FlipHorBit;
      ACurFlipRotateAttrs := ACurFlipRotateAttrs xor N_FlipHorBit;
      Result := TRUE;
    end;
    if K_aipfFlipVert in CMAIPFlags then
    begin
      MRFlipRotateAttrs := MRFlipRotateAttrs xor N_FlipVertBit;
      ACurFlipRotateAttrs := ACurFlipRotateAttrs xor N_FlipVertBit;
      Result := TRUE;
    end;

    if (K_aipfNegate in CMAIPFlags) then
    begin
      // Negate
      if K_smriNegateImg in MRImgFlags then
        MRImgFlags := MRImgFlags - [K_smriNegateImg]
      else
        MRImgFlags := MRImgFlags + [K_smriNegateImg];
      Result := TRUE;
    end;
    if (K_aipfCo in CMAIPFlags) and (CMAIPCoFactor <> MRCoFactor) then
    begin
      MRCoFactor := CMAIPCoFactor; // Image Contrast Correction Factor
      Result := TRUE;
    end;
    if (K_aipfGam in CMAIPFlags) and (CMAIPGamFactor <> MRGamFactor) then
    begin
      MRGamFactor := CMAIPGamFactor; // Image Gamma Correction Factor
      Result := TRUE;
    end;
    if (K_aipfBri in CMAIPFlags) and (CMAIPBriFactor <> MRBriFactor) then
    begin
      MRBriFactor := CMAIPBriFactor; // Image Brightness Correction Factor
      Result := TRUE;
    end;
    if (K_aipfLLUL in CMAIPFlags) then
    begin
      WrkLLFactor := CMAIBriLLFactor;
      WrkULFactor := CMAIBriULFactor;
      if K_aipfAutoLLUL in CMAIPFlags then
      begin
      // Recalc WrkLLFactor and WrkLUFactor
        ADIBObj.CalcBrighHistNData( HistValues );
//        N_HistFindLLUL1( HistValues, ILL, IUL );
        if K_aipfAutoLLULPower in CMAIPFlags then
          N_HistFindLLULXX2( CMAIAutoLLULPower, HistValues, ILL, IUL )
        else
          N_HistFindLLUL11( HistValues, ILL, IUL );
        WrkLLFactor := ILL / High(HistValues) * 100;
        WrkULFactor := IUL / High(HistValues) * 100;

      // Correct LL/LU to Initial Values if needed
        if (WrkLLFactor = 0) and (WrkULFactor = 100) then
          WrkULFactor := 0;
      end;
      if WrkLLFactor <> MRBriMinFactor then
      begin
        MRBriMinFactor := WrkLLFactor; // Image Brightness Convertion Minimal Factor
        Result := TRUE;
      end;
      if WrkULFactor <> MRBriMaxFactor then
      begin
        MRBriMaxFactor := WrkULFactor; // Image Brightness Convertion Maximal Factor
        Result := TRUE;
      end;
    end;
  end;
end; // function K_CMFlipRotateNegateByAutoImgProcAttrs

//******************************************* K_CMConvDIBByAutoImgProcAttrs ***
// Convert DIBObj by Auto Image Processing Attributes
//
//    Parameters
// ASrcDIBObj      - Source DIBObj
// ADstDIBObj      - Destination DIBObj
// APCMSMRImgAttrs - pointer to SLide MapRoot attributes
// APCMAutoImgPAttrs - pointer to Auto Image Processing Attributes
// ASlidePixpermm - Slide resolution in Pixels per mm
// Result - Returns TRUE if Slide MapRoot was changed
//
procedure K_CMConvDIBByAutoImgProcAttrs( ASrcDIBObj: TN_DIBObj; out ADstDIBObj: TN_DIBObj;
                          APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs;
                          ASlidePixpermm : Float );
var
  SrcSM, DstSM: TN_SMatrDescr;
  SDIB : TN_DIBObj;
  DDIB : TN_DIBObj;
  MatrSize : Integer;
  NewDIB   : TN_DIBObj;
  NewDIB1  : TN_DIBObj;
  ApertureWidth : Integer;
  NRCoefs: TN_FArray;
  ANRMatr1, ANRMatr2 : TN_BArray;
  PrevDIBNumBits : Integer;
  Coef1, Coef2 : Double;

  procedure PrepDIBSBeforeConversion();
  begin
    if SrcSM.SMDPBeg = ASrcDIBObj.PRasterBytes then
    begin
      if NewDIB = nil then
        NewDIB := TN_DIBObj.Create(ASrcDIBObj);
      DstSM.SMDPBeg := NewDIB.PRasterBytes;
      DDIB := NewDIB;
    end
    else
    begin
      if NewDIB1 = nil then
        NewDIB1 := TN_DIBObj.Create(NewDIB);
      DDIB := NewDIB1;
      DstSM.SMDPBeg := NewDIB1.PRasterBytes;
    end;
  end; // procedure PrepDIBSBeforeConversion

  procedure PrepDIBSAfterConversion();
  begin
    if SrcSM.SMDPBeg = NewDIB.PRasterBytes then
    begin
      SDIB := NewDIB1;
      NewDIB1 := NewDIB;
      NewDIB := SDIB;
    end
    else
      SDIB := NewDIB;

    SrcSM.SMDPBeg := NewDIB.PRasterBytes;
    SrcSM.SMDNumBits := NewDIB.DIBNumBits;
    if NewDIB1 <> nil then
      DstSM.SMDPBeg := NewDIB1.PRasterBytes;
  end; // procedure PrepDIBSAfterConversion

  procedure Conv2SMAverageFast1();
  var
    SrcSM1, DstSM1: TN_SMatrDescr;
    AApRadius : Integer;
  begin
    AApRadius := ApertureWidth shr 1;
    if SrcSM.SMDElSize <= 2 then // monochrome pixels
      N_Conv2SMAverageFast1( @SrcSM, @DstSM, AApRadius, fbmNotFill )
    else // Color pixels
    begin
      N_ConvSMatrDescr( @SrcSM, @SrcSM1, 0 );
      N_ConvSMatrDescr( @DstSM, @DstSM1, 0 );
      N_Conv2SMAverageFast1( @SrcSM1, @DstSM1, AApRadius, fbmNotFill ); // conv Red bytes

      N_ConvSMatrDescr( @SrcSM, @SrcSM1, 1 );
      N_ConvSMatrDescr( @DstSM, @DstSM1, 1 );
      N_Conv2SMAverageFast1( @SrcSM1, @DstSM1, AApRadius, fbmNotFill ); // conv green bytes

      N_ConvSMatrDescr( @SrcSM, @SrcSM1, 2 );
      N_ConvSMatrDescr( @DstSM, @DstSM1, 2 );
      N_Conv2SMAverageFast1( @SrcSM1, @DstSM1, AApRadius, fbmNotFill ); // conv blue bytes
    end; // else // Color pixels
  end; // procedure Conv2SMAverageFast1


begin

  with APCMAutoImgPAttrs^ do
  begin
    NewDIB1 := nil;
    NewDIB := nil;


  ///////////////////////
  //  Prepare Source DIB
  //
    SDIB := ASrcDIBObj;

    ////////////////////////////////
    // Convert to grey, or to 8 bit
    if (K_aipfConvToGrey in CMAIPFlags) and (SDIB.DIBExPixFmt = epfBMP) then
    begin // Convert to grey
      NewDIB := TN_DIBObj.Create(ASrcDIBObj, 0, pfCustom, -1, epfGray8);
      ASrcDIBObj.CalcGrayDIB(NewDIB);
      SDIB := NewDIB;
    end
    else
    if (K_aipfConvTo8 in CMAIPFlags) and (SDIB.DIBExPixFmt = epfGray16) then
    begin // Convert 16 to 8
      NewDIB := TN_DIBObj.Create( ASrcDIBObj, ASrcDIBObj.DIBRect, pfCustom, epfGray8 );
      SDIB := NewDIB;
    end;
    SDIB.PrepSMatrDescr( @SrcSM, @MatrSize );
    DstSM := SrcSM;
  //
  // end of Prepare Source DIB
  ///////////////////////

///////////////////////////////////////////////////////////////
// AutoContrast and AutoEqualize can amplify the image noise
// so it should be done before image noise filtering
///////////////////////////////////////////////////////////////
    if ((SDIB.DIBExPixFmt = epfGray8) or (SDIB.DIBExPixFmt = epfGray16)) and
       ((K_aipfSmooth in CMAIPFlags) or (K_aipfSharp in CMAIPFlags)) then
    begin
  /////////////////////
  // AutoContrast
      if K_aipfAutoContrast in CMAIPFlags then
      begin
        // Auto Contrast
        PrepDIBSBeforeConversion();
        PrevDIBNumBits := SDIB.DIBNumBits;
        if PrevDIBNumBits > 8 then
          SDIB.DIBNumBits := 16;

        SDIB.CalcMaxContrastDIB( DDIB );

        SDIB.DIBNumBits := PrevDIBNumBits;

        PrepDIBSAfterConversion();
      end;

  /////////////////////
  // AutoEqualize
      if K_aipfEqualize in CMAIPFlags then
      begin
        // Auto Equalize

// 2014-12-23 is removed from here but saved in similar code in TN_CMResForm.aToolsAutoEqualizeExecute
//        PrepDIBSBeforeConversion();
//        SDIB.CalcMaxContrastDIB( DDIB );
//        PrepDIBSAfterConversion();

        PrepDIBSBeforeConversion();

        // Prepare CalcEqualizedDIB parameter
        // K_CMAIEqualizeMin <= Coef1 <= K_CMAIEqualizeMax
        //            0.0001 <= Coef1 <= 1

        Coef1 := Min( 1, CMAIEqualizePower ); // precaution for temporary case when 0 <= CMAIEqualizePower <= 11
        if Coef1 = K_CMAIEqualizeSpec then
          Coef1 := K_CMAIEqualizeMax;

        // 1 <= Coef2 <= 3
        Coef2 := 1 + 2 * Coef1;
        SDIB.CalcEqualizedDIB( DDIB, 30, Coef2 );
//        SDIB.CalcEqualizedDIB( DDIB, 30, 3.0);

        PrepDIBSAfterConversion();
      end;

    end; // if (SDIB.DIBExPixFmt = epfGray8) or (SDIB.DIBExPixFmt = epfGray16) then

  /////////////////////
  // Median
    if (K_aipfMedian in CMAIPFlags) and
       ((SDIB.DIBExPixFmt = epfGray8) or (SDIB.DIBExPixFmt = epfGray16)) then
    begin
      ApertureWidth := CMAIMedianDepth;
      if ApertureWidth <= 0 then
        ApertureWidth := K_CMSelectFilterApertureByResolution( ASlidePixpermm, 2 );
      PrepDIBSBeforeConversion();
      N_Conv2SMMedianHuang( @SrcSM, @DstSM, ApertureWidth );
      PrepDIBSAfterConversion();
    end;

  /////////////////////
  // Despeckle
    if K_aipfDespeckle in CMAIPFlags then
    begin
      ApertureWidth := CMAIDespeckleDepth;
      if ApertureWidth <= 0 then
        ApertureWidth := K_CMSelectFilterApertureByResolution( ASlidePixpermm, 3 );

      PrepDIBSBeforeConversion();

      N_Conv2SMby2DCleaner( @SrcSM, @DstSM, ApertureWidth, 0.4 );
      PrepDIBSAfterConversion();
    end;

  /////////////////////
  // Noise Reduction
    if (K_aipfNRSelf in CMAIPFlags) and
       ((SDIB.DIBExPixFmt = epfGray8) or (SDIB.DIBExPixFmt = epfGray16)) then
    begin
      N_CalcGaussMatr( NRCoefs, 5, 2.0/sqrt(2), 1 );

      if Length(ANRMatr1) < MatrSize then
      begin
        SetLength(ANRMatr1, MatrSize);
        SetLength(ANRMatr2, MatrSize);
      end;
      PrepDIBSBeforeConversion();
      N_Conv3SMPrepNR1(@SrcSM, @ANRMatr1[0], @ANRMatr2[0], @NRCoefs[0], 5 );

      N_Conv3SMDoNR1( @SrcSM, @DstSM, @ANRMatr1[0], @ANRMatr2[0],
                                   @NRCoefs[0], 5, CMAINRThreshold1 * 2, 1.1 );
      PrepDIBSAfterConversion();
    end;

  /////////////////////
  // Smooth
    if (K_aipfSmooth in CMAIPFlags) then
    begin
      PrepDIBSBeforeConversion();
      ApertureWidth := CMAISmoothDepth;
      if ApertureWidth <= 0 then
        ApertureWidth := K_CMSelectFilterApertureByResolution( ASlidePixpermm, 1 );

      Conv2SMAverageFast1();

      N_Conv3SMLinComb( @SrcSM, DstSM.SMDPBeg, DstSM.SMDPBeg, CMAISmoothPower );
      PrepDIBSAfterConversion();
    end;

  /////////////////////
  // Sharp
    if (K_aipfSharp in CMAIPFlags) then
    begin
      PrepDIBSBeforeConversion();
      ApertureWidth := CMAISharpDepth;
      if ApertureWidth <= 0 then
        ApertureWidth := K_CMSelectFilterApertureByResolution( ASlidePixpermm, 1 );

      Conv2SMAverageFast1();

      N_Conv3SMLinComb( @SrcSM, DstSM.SMDPBeg, DstSM.SMDPBeg, - CMAISharpPower * K_CMSharpenMax );
      PrepDIBSAfterConversion();
    end;

{ !!! should be done before all filters - Karpenkov 2015-08-27
///////////////////////////////////////////////////////////////
// AutoContrast and AutoEqualize can amplify the image noise
// so it should be done after image noise filtering
///////////////////////////////////////////////////////////////
    if (SDIB.DIBExPixFmt = epfGray8) or (SDIB.DIBExPixFmt = epfGray16) then
}
    if ((SDIB.DIBExPixFmt = epfGray8) or (SDIB.DIBExPixFmt = epfGray16)) and
       not ((K_aipfSmooth in CMAIPFlags) or (K_aipfSharp in CMAIPFlags)) then
    begin
  /////////////////////
  // AutoContrast
      if K_aipfAutoContrast in CMAIPFlags then
      begin
        // Auto Contrast
        PrepDIBSBeforeConversion();
        PrevDIBNumBits := SDIB.DIBNumBits;
        if PrevDIBNumBits > 8 then
          SDIB.DIBNumBits := 16;

        SDIB.CalcMaxContrastDIB( DDIB );

        SDIB.DIBNumBits := PrevDIBNumBits;

        PrepDIBSAfterConversion();
      end;

  /////////////////////
  // AutoEqualize
      if K_aipfEqualize in CMAIPFlags then
      begin
        // Auto Equalize

// 2014-12-23 is removed from here but saved in similar code in TN_CMResForm.aToolsAutoEqualizeExecute
//        PrepDIBSBeforeConversion();
//        SDIB.CalcMaxContrastDIB( DDIB );
//        PrepDIBSAfterConversion();

        PrepDIBSBeforeConversion();

        // Prepare CalcEqualizedDIB parameter
        // K_CMAIEqualizeMin <= Coef1 <= K_CMAIEqualizeMax
        //            0.0001 <= Coef1 <= 1

        Coef1 := Min( 1, CMAIEqualizePower ); // precaution for temporary case when 0 <= CMAIEqualizePower <= 11
        if Coef1 = K_CMAIEqualizeSpec then
          Coef1 := K_CMAIEqualizeMax;

        // 1 <= Coef2 <= 3
        Coef2 := 1 + 2 * Coef1;
        SDIB.CalcEqualizedDIB( DDIB, 30, Coef2 );
//        SDIB.CalcEqualizedDIB( DDIB, 30, 3.0);

        PrepDIBSAfterConversion();
      end;

    end; // if (SDIB.DIBExPixFmt = epfGray8) or (SDIB.DIBExPixFmt = epfGray16) then

    NewDIB1.Free();
    ADstDIBObj := SDIB;
  end;
end; // procedure K_CMConvDIBByAutoImgProcAttrs

//***************************************** K_CMSlideConvByAutoImgProcAttrs ***
// Convert Slide Image by Auto Image Processing Attributes
//
//    Parameters
// ASlide - SLide to Convert
// APCMAutoImgPAttrs - pointer to Auto Image Processing Attributes
// ARFVectorScale - MapImage current vector scale factor for flashlight objects
// Result  - Returns Save Slide State Flags Set
//
function K_CMSlideConvByAutoImgProcAttrs( ASlide : TN_UDCMSlide;
             APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs;
             ARFVectorScale : Float ): TK_CMSlideSaveStateFlags;
var
  CurDIB, TmpDIB: TN_DIBObj;
  CurImage: TN_UDDIB;
{
  SharpMatr: TN_BArray;
  SharpDepth : Integer;
  SSConvFactor : Double;
}
  CurFlipRotateAttrs : Integer;
  PCMSMRImgAttrs : TK_PCMSMRImgAttrs;
  WB : Boolean;

{
  WrkLLFactor, WrkULFactor : FLoat;
  HistValues : TN_IArray;
  ILL, IUL : Integer;
}
  PCMSlide : TN_PCMSlide;
begin

  K_CMInitAutoImgProcAttrs( APCMAutoImgPAttrs );
  K_CMDumpAutoImgProcAttrs( APCMAutoImgPAttrs );
  PCMSMRImgAttrs := ASlide.GetPMapRootAttrs();
  with ASlide, APCMAutoImgPAttrs^{, GetPMapRootAttrs()^} do
  begin

    Result := [];
    CurImage := ASlide.GetCurrentImage();
    CurDIB := CurImage.DIBObj;
    PCMSlide := ASlide.P();
    K_CMConvDIBByAutoImgProcAttrs( CurDIB, TmpDIB, APCMAutoImgPAttrs,
                                   PCMSlide.CMSDB.PixPermm );

    with PCMSlide^ do
      if ( not (cmsfGreyScale in CMSDB.SFlags) and
           ((TmpDIB.DIBExPixFmt = epfGray8) or (TmpDIB.DIBExPixFmt = epfGray16)) ) or
         ( CMSDB.PixBits <> TmpDIB.DIBNumBits ) then
      begin
        K_CMSlideSetAttrsByDIB( PCMSlide, TmpDIB, FALSE );
        Result := Result + [cmssfAttribsChanged];
      end;
{
    if (K_aipfConvToGrey in CMAIPFlags) and (CurDIB.DIBExPixFmt = epfBMP) then
    begin
      with PCMSlide^ do
      begin
        Include( CMSDB.SFlags, cmsfGreyScale );

        // Convert Slide Info Attrs
        if TmpDIB.DIBExPixFmt = epfGray8 then
          CMSDB.PixBits := 8
        else
          CMSDB.PixBits := 16;
        CMSDB.BytesSize := (CMSDB.PixBits shr 3) * CMSDB.PixWidth * CMSDB.PixHeight;

        // Init Isodensity Attrs
        CMSDB.IsoColor := 255; // Red
        CMSDB.IsoRangeFactor := 5; // 5% range
        CMSDB.IsoBaseColInt := -1; // Not Def Image Color
      end;
      Result := Result + [cmssfAttribsChanged];
    end;
}

    if CurDIB <> TmpDIB then
    begin
    // Set New  DIB and Free Source DIB
      Result := [cmssfCurImgChanged];
      CurDIB.Free;
      CurDIB := TmpDIB;
      CurImage.DIBObj := CurDIB;
    end;

    if (K_aipfEqualize in CMAIPFlags) and
       ((CurDIB.DIBExPixFmt = epfGray8) or
        (CurDIB.DIBExPixFmt = epfGray16)) then
    begin
      WB := FALSE;
      with PCMSMRImgAttrs^ do
      begin
        if MRCoFactor <> 0 then
        begin
          MRCoFactor  := 0;
          WB := TRUE;
        end;
        if MRGamFactor <> 0 then
        begin
          MRGamFactor  := 0;
          WB := TRUE;
        end;
        if MRBriFactor <> 0 then
        begin
          MRBriFactor  := 0;
          WB := TRUE;
        end;
      end;
      if WB then
        Result := Result + [cmssfMapRootChanged];
    end; //    if (K_aipfAutoEqualize in CMAIPFlags) and
         //       (CurDIB.DIBExPixFmt = epfGray8) then


    if K_CMFlipRotateNegateByAutoImgProcAttrs( CurDIB, PCMSMRImgAttrs,
                                               APCMAutoImgPAttrs, CurFlipRotateAttrs ) then
      Result := Result + [cmssfMapRootChanged];

    if Result = [] then Exit;

    // Rebuild Map Image by new Current Image
    RebuildMapImageByDIB( );

    if CurFlipRotateAttrs <> 0 then
    // Slide Vector Objects Convertion is needed
      AffConvVObjects( CurFlipRotateAttrs, ARFVectorScale );

  end; // with ASlide, APCMAutoImgPAttrs^ do
end; // function K_CMSlideConvByAutoImgProcAttrs

//***************************************** K_CMGetUIHintByAutoImgProcAttrs ***
// Get UI Hint for given Auto Image Processing Attributes
//
//    Parameters
// APCMAutoImgPAttrs - pointer to Auto Image Processing Attributes
// Result  - Returns UI Hint build by Auto Image Processing Attributes
//
function K_CMGetUIHintByAutoImgProcAttrs(
             APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs ): string;
var
  WStr : string;
  CurRes : string;
  CurFlipRotateAttrs : Integer;

  procedure AddResElement( const AText : string );
  begin
    if Result <> '' then
      Result := Result + ', ';
    Result := Result + AText;
  end;
begin

  K_CMInitAutoImgProcAttrs( APCMAutoImgPAttrs );
  with APCMAutoImgPAttrs^ do
  begin
    Result := '';
    if K_aipfConvToGrey in CMAIPFlags then
      AddResElement( 'Convert to grey' );

    if K_aipfConvTo8 in CMAIPFlags then
      AddResElement( 'Convert to 8 bit' );

    if (K_aipfSmooth in CMAIPFlags) and  (CMAISmoothPower <> 0) then
      AddResElement( 'Smooth' );

    if K_aipfMedian in CMAIPFlags then
      AddResElement( 'Median' );

    if K_aipfDespeckle in CMAIPFlags then
      AddResElement( 'Despeckle' );

    if (K_aipfNoiseReduction in CMAIPFlags) or
       (K_aipfNRSelf in CMAIPFlags) then
      AddResElement( 'Noise Reduction' );

    if (K_aipfSharp in CMAIPFlags) and  (CMAISharpPower <> 0) then
      AddResElement( 'Sharp' );

    if  K_aipfAutoContrast in CMAIPFlags then
      AddResElement( 'Auto Contrast' );

    if K_aipfEqualize in CMAIPFlags then
      AddResElement( 'Equalize' );

    if (K_aipfNegate in CMAIPFlags) then
      AddResElement( 'Negate' );

    if (K_aipfSSConv in CMAIPFlags) and  (CMAIPSSFactor <> 0) then
    begin
      if CMAIPSSFactor > 0 then
        WStr := 'Smooth'
      else
        WStr := 'Sharp';
      AddResElement( WStr );
    end;

    CurFlipRotateAttrs := 0;
    CurRes := Result;
    if CMAIPAngl <> 0 then
    begin
      case CMAIPAngl of
      1: WStr := '90°';
      2: WStr := '180°';
      3: WStr := '270°';
      end;
      CurFlipRotateAttrs := N_RotateFRFlags(0, 90 * CMAIPAngl);
      AddResElement( 'Rotate by ' + WStr );
    end;
    if K_aipfFlipHor in CMAIPFlags then
    begin
      CurFlipRotateAttrs := CurFlipRotateAttrs xor N_FlipHorBit;
      AddResElement( 'Flip Horisontally' );
    end;

    if K_aipfFlipVert in CMAIPFlags then
    begin
      CurFlipRotateAttrs := CurFlipRotateAttrs xor N_FlipVertBit;
      AddResElement( 'Flip Vertically' );
    end;
    if CurFlipRotateAttrs = 0 then
      Result := CurRes;


    if (K_aipfCo in CMAIPFlags) and (CMAIPCoFactor <> 0) then
    begin
      if CMAIPCoFactor < 0 then
        WStr := 'Decrease Contrast'
      else
        WStr := 'Increase Contrast';
      AddResElement( WStr );
    end;

    if (K_aipfGam in CMAIPFlags) and (CMAIPGamFactor <> 0) then
      AddResElement( 'Change gamma correction' );

    if (K_aipfBri in CMAIPFlags) and (CMAIPBriFactor <> 0) then
    begin
      if CMAIPBriFactor < 0 then
        WStr := 'Decrease Brightness'
      else
        WStr := 'Increase Brightness';
      AddResElement( WStr );
    end;

    if (K_aipfLLUL in CMAIPFlags) then
    begin
      if (K_aipfAutoLLUL in CMAIPFlags) then
        WStr := 'Auto LL/UL'
      else
      if (CMAIBriLLFactor > 0) or
         ((CMAIBriULFactor > 0) and (CMAIBriULFactor < 100)) then
        WStr := 'Change LL/UL';
      AddResElement( WStr );
    end;
  end; // with APCMAutoImgPAttrs^ do
end; // function K_CMGetUIHintByAutoImgProcAttrs

//*********************************************** K_CMSlideCreateFromDIBObj ***
// Create TN_UDCMSlide Object from given DIBObj
//
//    Parameters
// ADIBObj           - given Device Independent Bitmap Object for slide creation
// APCMAutoImgPAttrs - pointer to AutoImage Processing Attributes
// AImportFName      - import file name for saving Image initial file data
// AStream           - Image Source File Stream
// ADIBStoreFormat   - First Time Image DIB Store Format
// ASkipThumbCreate  - if TRUE then skip thumbnail creation
// Result            - Returns created TN_UDCMSlide object
//
// If ADIBObj = NIL or cannot be converted to proper format then empty 100x100 slide will be created.
//
function K_CMSlideCreateFromDIBObj( var ADIBObj: TN_DIBObj;
             APCMAutoImgPAttrs: TK_PCMAutoImgProcAttrs; AStream: TStream = nil;
             ADIBStoreFormat: TN_UDDIBDataFormat = uddfNotDef;
             ASkipThumbCreate : Boolean = FALSE ) : TN_UDCMSlide;
var
  RGBDiff: Double;
  CurDIB, TmpDIB, SrcDIB: TN_DIBObj;
  CurImage, SrcImage: TN_UDDIB;
  MapRoot: TN_UDCompVis;
  Grey16AndRIFormat : Boolean;
  PCDIBN: TN_PCDIBN;
  CurFlipRotateAttrs : Integer;
  WF : Float;
  WI : Integer;
  AddDEMOMark : Boolean;
  ChangeSrcDIB : Boolean;
  PCMSMRImgAttrs : TK_PCMSMRImgAttrs;
  PCMSlide : TN_PCMSlide;
  UDDataAddInfo : TN_UDDataAddInfo;
  UDDataSize : Integer;

begin
  N_Dump2Str( 'K_CMSlideCreateFromDIBObj >> start' );
  Result := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMSlideCI));
  PCMSlide := Result.P();
  K_CMSlideInitByCurContext(Result);

  with PCMSlide^ do
  begin
    Include(CMSDB.SFlags, cmsfSaveSrcImg);
    CMSDB.DUnits := TN_CMSlideDUnits(N_MemIniToInt('VObjAttrs', 'DistanceUnits', 0));
    CMSDTTaken := CMSDTCreated; // Slide DateTime Created
    CMSPatId := K_CMEDAccess.CurPatID; // Current Patient ID
  end; // with Result.P()^ do

  ChangeSrcDIB := FALSE;
  if ADIBObj = nil then //  Create Empty "New" DIB
    CurDIB := TN_DIBObj.Create( 100, 100, pfCustom, $D0D0D0, epfGray8 )
  else // Check ADIBObj
  begin                 //  Use given ADIBObj
  // Check ADIBObj format and convert if needed
    with ADIBObj do
    N_Dump2Str( format( 'K_CMSlideCreateFromDIBObj >> DIB %dx%d PixFmt=%d ExPixFmt=%d NumBits=%d',
                  [DIBSize.X,DIBSize.Y,Ord(DIBPixFmt),Ord(DIBExPixFmt),DIBNumBits] ) );

    if ADIBObj.DIBExPixFmt = epfBMP then
    begin
      // Ordinary Color DIB
      if (ADIBObj.DIBPixFmt = pf24bit) then
        TmpDIB := ADIBObj
      else // convert to pf24bit
      begin
        N_Dump2Str( 'K_CMSlideCreateFromDIBObj convert to pf24bit start' );
        TmpDIB := TN_DIBObj.Create( ADIBObj, 0, pf24bit );
        TmpDIB.DIBOCanv.DrawPixDIB( ADIBObj, TmpDIB.DIBRect, ADIBObj.DIBRect );
        FreeAndNil( ADIBObj );
        N_Dump2Str( 'K_CMSlideCreateFromDIBObj convert to pf24bit' );
        ChangeSrcDIB := TRUE;
      end;

      // Check if TmpDIB should be converted to Gray format
      RGBDiff := TmpDIB.GetMaxRGBDif( 0 );

      if RGBDiff <= 0 then // Convert TmpDIB to Gray CurDIB
      begin
        N_Dump2Str( 'K_CMSlideCreateFromDIBObj convert to Grey8 start' );
        CurDIB := TN_DIBObj.Create( TmpDIB, 0, pfCustom, -1, epfGray8 );
        TmpDIB.CalcGrayDIB( CurDIB );
        FreeAndNil( TmpDIB );
        N_Dump2Str( 'K_CMSlideCreateFromDIBObj convert to Grey8' );
//        ChangeSrcDIB := TRUE;
      end
      else // do not convert, CurDIB will be colored
        CurDIB := TmpDIB;

    end  // if ADIBObj.DIBExPixFmt = epfBMP then
    else
    begin // ADIBObj is Gray8 (nothing to do), Gray16 (conv if needed) or Color48 (conv to Gray8 or 16)

      // if real BitDepth is not given, assume it = 16 for all epfGray16 and epfColor48 images - Precaution
      if (ADIBObj.DIBNumBits = 0) and
         ((ADIBObj.DIBExPixFmt = epfGray16) or
          (ADIBObj.DIBExPixFmt = epfColor48)) then ADIBObj.DIBNumBits := 16;


      CurDIB := ADIBObj;

      if K_CMSSkip16bitMode then // all 16 bit images should be converted to 8 bit
      begin

        if ADIBObj.DIBExPixFmt = epfGray16 then // conv to Gray8
        begin
//          CurDIB := N_CreateGray8DIBFromGray16( ADIBObj );
          N_Dump2Str( 'K_CMSlideCreateFromDIBObj Grey16 >> Grey8 start' );
          CurDIB := TN_DIBObj.Create( ADIBObj, ADIBObj.DIBRect, pfCustom, epfGray8 );
          FreeAndNil( ADIBObj );
          N_Dump2Str( 'K_CMSlideCreateFromDIBObj Grey16 >> Grey8' );
          ChangeSrcDIB := TRUE;
        end // if ADIBObj.DIBExPixFmt = epfGray16 then // conv to Gray8
        else
        if ADIBObj.DIBExPixFmt = epfColor48 then // conv to Color24
        begin
          N_Dump2Str( 'K_CMSlideCreateFromDIBObj Color48 >> Color24 (Skip16bitMode) start' );
          CurDIB := TN_DIBObj.Create( ADIBObj, ADIBObj.DIBRect, pf24bit, epfBMP );
          FreeAndNil( ADIBObj );
          N_Dump2Str( 'K_CMSlideCreateFromDIBObj Color48 >> Color24' );
          ChangeSrcDIB := TRUE;
        end; // if ADIBObj.DIBExPixFmt = epfColor48 then // conv to Color24

      end else // Gray16 images are OK, but Color48 is still not supported by CMS
      begin
        if ADIBObj.DIBExPixFmt = epfColor48 then // conv to Color24
        begin
          N_Dump2Str( 'K_CMSlideCreateFromDIBObj Color48 >> Color24 start' );
          CurDIB := TN_DIBObj.Create( ADIBObj, ADIBObj.DIBRect, pf24bit, epfBMP );
          FreeAndNil( ADIBObj );
          N_Dump2Str( 'K_CMSlideCreateFromDIBObj Color48 >> Color24' );
          ChangeSrcDIB := TRUE;
        end; // if ADIBObj.DIBExPixFmt = epfColor48 then // conv to Color24
      end; // else // 16 bit images are OK

//      CurDIB.ReduceNumBits();

    end; // ADIBObj is Gray8 (nothing to do), Gray16 (conv if needed) or Color48 (conv to Gray8 or 16)
  end; // else // Check ADIBObj

  SrcDIB := nil;
  if APCMAutoImgPAttrs <> nil then
  begin
    // *** Auto Image Processing -  Covert DIB
    K_CMInitAutoImgProcAttrs( APCMAutoImgPAttrs );
    K_CMDumpAutoImgProcAttrs( APCMAutoImgPAttrs );
    with APCMAutoImgPAttrs^ do
    begin
    // Set DIB Resolution
      with CurDIB.DIBInfo.bmi, PCMSlide^ do
        if CMAIPResolution > 0 then
        begin
          // Set profile calibration
          Include(CMSDB.SFlags, cmsfAutoCalibrated);
          biXPelsPerMeter := Round(CMAIPResolution * 100 / 2.54);
          biYPelsPerMeter := biXPelsPerMeter;
        end
        else if CMAIPResolution < 0 then
        begin
          // Set uncalibrated State
          biXPelsPerMeter := 0;
          biYPelsPerMeter := 0;
        end; // use device calibration else
    end; // with APCMAutoImgPAttrs^ do

    K_CMSlideSetResolutionByDIB( PCMSlide, CurDIB );

    K_CMConvDIBByAutoImgProcAttrs( CurDIB, TmpDIB, APCMAutoImgPAttrs,
                                   PCMSlide.CMSDB.PixPermm );
    if CurDIB <> TmpDIB then
    begin
      SrcDIB := CurDIB;
      CurDIB := TmpDIB;
    end;

  end; // if APCMAutoImgPAttrs <> nil
  // ***** Now CurDIB is OK and can be used as Slide's DIB

  // Calc Auto Numbits for Gray16
  if CurDIB.DIBExPixFmt = epfGray16 then
    CurDIB.DIBNumBits := Max( CurDIB.CalcMinNeededNumBits(), 9 );

  with CurDIB.DIBInfo.bmi do
    MapRoot := Result.CreateMapRoot( biWidth, biHeight );

  // ***** Create MapImage Component:
  // - prepare ArchFileName
  // - create MapImage obj
  // - assign ASrcDIBObj to it
  // - save MapImage if needed
  // - View and Edit NewSlide properties if needed
  CurImage := N_CreateUDDIB(N_CMDIBURect, [], '', 'CurImg');
  CurImage.DIBObj := CurDIB;
  AddDEMOMark := K_CMDEMOAddMarkToDIB(CurDIB);
  with CurImage, PISP()^ do
  begin
    CDIBJPEGQuality := 100;
    Grey16AndRIFormat := (CurDIB.DIBExPixFmt = epfGray16) and
                           (ADIBStoreFormat < uddfDIBSer0);
    if (AStream <> nil) and
       not AddDEMOMark  and
       not ChangeSrcDIB then
    begin
      // Save Initial File UDData
      CDIBFlagsN := [uddfnUseUDData]; // Skip Free Initial UDData
      UDDataSize := AStream.Size;
      // Prepare Additional Info
      if PrepUDDataAddInfo( @UDDataAddInfo ) then
        UDDataSize := UDDataSize + SizeOf(TN_UDDataAddInfo);
      SetLength(UDData, UDDataSize);
      AStream.Read(UDData[0], AStream.Size);
      // Save UDData Additional Info
      if UDDataSize > AStream.Size then
        move( UDDataAddInfo, UDData[AStream.Size], SizeOf(TN_UDDataAddInfo) );
    end
    else
      CDIBFlagsN := [uddfnUseUDData,uddfnFreeUDData];

    // Set DIBData store Format
    if ADIBStoreFormat > uddfNotDef then
      CDIBDataFormat := ADIBStoreFormat
    else
      CDIBDataFormat := K_CMEDAccess.SlidesDIBFormat;

    if Grey16AndRIFormat then
      CDIBDataFormat := uddfDIBSer1;

{ !!! 2015-07-13
    else if ADIBStoreFormat > uddfNotDef then
    begin
      // prepare UDData creation attributes
      CDIBFlagsN := [uddfnUseUDData, uddfnFreeUDData];
      CDIBDataFormat := ADIBStoreFormat;
      if Grey16AndRIFormat then
        CDIBDataFormat := uddfDIBSer1;
//      CreateUDDataFromDIBObj();
    end;

    if CDIBDataFormat = uddfNotDef then
    begin
      CDIBDataFormat := K_CMEDAccess.SlidesDIBFormat;
      if Grey16AndRIFormat then
        CDIBDataFormat := uddfDIBSer1;
    end;

    if CDIBFlagsN = [] then // May be if not needed
      CDIBFlagsN := [uddfnUseUDData,uddfnFreeUDData];
}

  end; // with CurImage, PISP()^ do

  // MapImage.SaveDIBObj(); // is needed in uddfUseFile and in uddfUseBArray modes
  Result.PutDirChildSafe(K_CMSlideIndCurImg, CurImage);

  if SrcDIB <> nil then
  begin
    SrcImage := N_CreateUDDIB(N_CMDIBURect, [], '', 'SrcImg');
    SrcImage.DIBObj := SrcDIB;
    SrcImage.UDData := Copy(CurImage.UDData);
    PCDIBN := CurImage.PISP();

    with SrcImage.PISP^ do
    begin
      CDIBFlagsN := PCDIBN.CDIBFlagsN;
      CDIBDataFormat := PCDIBN.CDIBDataFormat;
      CDIBJPEGQuality := PCDIBN.CDIBJPEGQuality;
    end;

    Result.PutDirChildSafe(K_CMSlideIndSrcImg, SrcImage);

    with PCMSlide^.CMSDB do
      SFlags := SFlags + [cmsfHasSrcImg,cmsfSaveSrcImg];
  end;

  CurFlipRotateAttrs := 0;
  if APCMAutoImgPAttrs <> nil then
  begin
    // *** Auto Image Processing - Set MapRoot Attrs
    PCMSMRImgAttrs := Result.GetPMapRootAttrs();
    K_CMFlipRotateNegateByAutoImgProcAttrs( CurDIB, PCMSMRImgAttrs,
                                            APCMAutoImgPAttrs, CurFlipRotateAttrs );
    // 2018-01-15
    // Make image real FlipRotate pixels if needed
    // done for Study Sample Position Auto FlipRotate functionality
    // here CurFlipRotateAttrs = PCMSMRImgAttrs.MRFlipRotateAttrs
    if CurFlipRotateAttrs <> 0 then
    begin
      // Real FlipRotate DIB pixels
      CurDIB.FlipAndRotate( CurFlipRotateAttrs );
      // Clear Slide FlipRotateAttrs
      PCMSMRImgAttrs.MRFlipRotateAttrs := 0;
    end;

    if SrcDIB <> nil then
      Include( PCMSMRImgAttrs.MRImgFlags, K_smriRestoreSrcImg );
  end;

  Result.SetAttrsByCurImgParams(FALSE);

  if CurFlipRotateAttrs >= 4 then // Rotate +-90
    with MapRoot.PCCS()^, PCMSlide^.CMSDB do
    begin
      WF := SRSize.X;
      SRSize.X  := SRSize.Y;
      SRSize.Y  := WF;
      WI        := PixWidth;
      PixWidth  := PixHeight;
      PixHeight := WI;
    end;

  if not ASkipThumbCreate then
    Result.CreateThumbnail();

  if K_CMDCMSeriesID > 0 then
  begin
    if K_CMEDDBVersion >= 46 then
      PCMSlide^.CMDCMSerID  := K_CMDCMSeriesID
    else
      PCMSlide^.CMSDB.DCMSerID := K_CMDCMSeriesID;
    Inc(K_CMDCMSeriesIDSCount);
    N_Dump2Str( 'K_CMSlideCreateFromDIBObj >> set DCMSeriesID=' + IntToStr(K_CMDCMSeriesID) );
  end;

  N_Dump2Str( 'K_CMSlideCreateFromDIBObj >> fin' );

end; // function K_CMSlideCreateFromDIBObj

//***************************************** K_CMSlideCreateFromDeviceDIBObj ***
// Create TN_UDCMSlide Object from given DIBObj captured from device
//
//    Parameters
// ADIBObj - given Device Independent Bitmap Object for slide creation
// APDevProfile - pointer to device profile record
// ADIBNumber - captured DIB number in series (1 based)
// ADevResolution - device resolution in DPI
// ASkipAutoCalibrated - skip change Slide state from ProbablyCalibrated to AutoCalibrated
// Result  - Returns created TN_UDCMSlide object
//
function  K_CMSlideCreateFromDeviceDIBObj( var ADIBObj: TN_DIBObj;
                     APDevProfile : TK_PCMDeviceProfile;
                     ADIBNumber : Integer; ADevResolution : Float;
                     ASkipAutoCalibrated : Boolean = FALSE ): TN_UDCMSlide;
begin
  Result := N_CMCreateCalibratedSlide( ADIBObj, TK_PCMOtherProfile(APDevProfile), ADevResolution );

  with Result, P()^ do
  begin
    CMSSourceDescr := APDevProfile^.CMDPCaption;
    Result.ObjInfo := 'Captured from ' + CMSSourceDescr;
    Result.ObjAliase := 'Scan ' + IntToStr( ADIBNumber );
    CMSMediaType := APDevProfile^.CMDPMTypeID;
    SetInitDCMAttrs( TK_PCMDCMAttrs(@APDevProfile^.CMDPDModality) );
  end; // with Result.P()^ do
  if not ASkipAutoCalibrated then Result.SetAutoCalibrated();
  K_CMEDAccess.EDAAddSlide(Result, FALSE, ADIBNumber );
end; // function K_CMSlideCreateFromDeviceDIBObj

//****************************************** K_CMSlideReplaceByDeviceDIBObj ***
// Replace TN_UDCMSlide Object by new created from given DIBObj captured from device
//
//    Parameters
// AUDSlide - on input replacing Slide on output new Slide object
// ADIBObj - given Device Independent Bitmap Object for slide creation
// APDevProfile - pointer to device profile record
// ADIBNumber - captured DIB number in series
// ADevResolution - device resolution in DPI
// ASkipAutoCalibrated - skip change Slide state from ProbablyCalibrated to AutoCalibrated
// Result  - Returns created TN_UDCMSlide object
//
function  K_CMSlideReplaceByDeviceDIBObj( var AUDSlide : TN_UDCMSlide;
                     var ADIBObj : TN_DIBObj;
                     APDevProfile : TK_PCMDeviceProfile;
                     ADIBNumber : Integer; ADevResolution : Float;
                     ASkipAutoCalibrated : Boolean = FALSE ) : TN_UDCMSlide;
begin
  if AUDSlide <> nil then
  begin
    K_CMEDAccess.EDAClearSlideECache( AUDSlide );
    K_CMEDAccess.CurSlidesList.Remove( AUDSlide );
    AUDSlide.UDDelete();

  end;
//  if K_CMStudyCaptModeState = 0 then
  if K_CMStudyCaptState >= K_cmscOK then
    K_FormCMStudyCapt.ReplaceLastSlideMode := TRUE;
  Result := K_CMSlideCreateFromDeviceDIBObj( ADIBObj, APDevProfile, ADIBNumber,
                                             ADevResolution, ASkipAutoCalibrated );
  AUDSlide := Result;
end; // function K_CMSlideReplaceByDeviceDIBObj

//******************************************** K_CMSlideCreateFromMediaFile ***
// Create TN_UDCMSlide Object from given Media Object File Name
//
//     Parameters
// AMediaFName - Media Object File Name
// Result  - Returns created TN_UDCMSlide object
//
// If ADIBObj = NIL then empty slide 100x100 will be created.
//
function K_CMSlideCreateFromMediaFile(const AMediaFName: string): TN_UDCMSlide;
begin
  Result := K_CMSlideCreateForMediaObject(ExtractFileExt(AMediaFName));
  if Result.AddMediaFile(AMediaFName) <> 0 then FreeAndNil(Result);
end; // function K_CMSlideCreateFromMediaFile

//******************************************* K_CMSlideCreateForMediaObject ***
// Create TN_UDCMSlide Object for Media Object
//
//     Parameters
// AMediaFExt - Fedia Object File Extension
// Result  - Returns created TN_UDCMSlide object
//
function K_CMSlideCreateForMediaObject(const AMediaFExt: string): TN_UDCMSlide;
begin
  Result := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMSlideCI));
  K_CMSlideInitByCurContext(Result);
  with Result, P()^ do
  begin
    InitSelfName(); // Needed for Video Capture in CMScan
    Include(CMSDB.SFlags, cmsfIsMediaObj);
    CMSDTTaken := CMSDTCreated; // Slide DateTime Created
    CMSPatId := K_CMEDAccess.CurPatID; // Current Patient ID
    SetMediaFileTMPName(AMediaFExt);
  end; // with Result.P()^ do
end; // function K_CMSlideCreateForMediaObject

//******************************************* K_CMSlideCreateForImg3DObject ***
// Create TN_UDCMSlide Object for 3D Image Object
//
//     Parameters
// Result  - Returns created TN_UDCMSlide object
//
// Prepare slide fields including temporary Path in Files Storage
//
function K_CMSlideCreateForImg3DObject( ASkipImg3DPath : Boolean = FALSE ): TN_UDCMSlide;
begin
  Result := TN_UDCMSlide(K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMSlideCI));
  K_CMSlideInitByCurContext(Result);
  with Result, P()^ do
  begin
    InitSelfName(); // Needed for Video Capture in CMScan
    Include(CMSDB.SFlags, cmsfIsImg3DObj);
    CMSDTTaken := CMSDTCreated; // Slide DateTime Created
    CMSPatId := K_CMEDAccess.CurPatID; // Current Patient ID
    if ASkipImg3DPath then Exit; // Skip Img3D path for Dev3D object
    // Create Tmp Folder for 3D Image Files storing before real save
    CMSDB.MediaFExt := format( '%s%sTMP_%s\',
                      [TK_CMEDDBAccess(K_CMEDAccess).SlidesImg3DRootFolder,
                       Result.GetFilesPathSegm(),
                       K_DateTimeToStr( CMSDTCreated, 'hhnnsszzz' )] );
  end; // with Result.P()^ do
end; // function K_CMSlideCreateForImg3DObject

//****************************************************** K_CMSAddCloneChild ***
// Add New Child Object created from given Pattern Object
//
//     Parameters
// AUDRoot       - given Root Object
// AUDChildPat   - given New Child Pattern Object
// AInsBeforeAll - insert befire all Flag
// ALocUDRoot    - Local UDRoot (for example Slide, needed if Measure Annotation Text is added)
// Result - Returns new Child Object Subtree Root
//
function K_CMSAddCloneChild(AUDRoot, AUDChildPat: TN_UDBase;
  AInsBeforeAll: Boolean; ALocUDRoot: TN_UDBase = nil): TN_UDBase;
var
  SavedRPath: string;
  i, Ind: Integer;
begin
  // Create Pattern SubTree Clone
  if ALocUDRoot <> nil then
  begin
    SavedRPath := ALocUDRoot.RefPath;
    ALocUDRoot.RefPath := 'S@:';
    K_UDCursorGet('S@:').SetRoot(ALocUDRoot);
  end;
  K_SaveTreeToMem(AUDChildPat, N_SerialBuf);
  Result := K_LoadTreeFromMem(N_SerialBuf);
  if ALocUDRoot <> nil then
    ALocUDRoot.RefPath := SavedRPath;

  // Add New Child
  if AInsBeforeAll then
  begin
    Ind := 0;
    for i := 0 to AUDRoot.DirHigh do
    begin
      if AUDRoot.DirChild(i).ObjName[1] <> Result.ObjName[1] then
        break;
      Ind := i + 1;
    end;
    AUDRoot.InsOneChild(Ind, Result);
    AUDRoot.AddChildVNodes(Ind);
  end
  else
    AUDRoot.AddOneChildV(Result);
  AUDRoot.SetUniqChildName(Result);
end; // function K_CMSAddCloneChild

//************************************************ K_CMSVObjSetDefaultAttrs ***
// Set given Drawing Component Default Attributes
//
//     Parameters
// AUDVobj     - given Drawing Component Object
//
procedure K_CMSVObjSetDefaultAttrs(AUDVObj: TN_UDCompVis);
var
  PUPC, PUP: TN_POneUserParam;
  UDCommonAttrs: TN_UDCompBase;
  PC: PInteger;
begin

  UDCommonAttrs := TN_UDCompBase(K_CMEDAccess.ArchMLibRoot.DirChildByObjName
      ('CommonAttrs'));

  // Set LineWidth from Common Attrs
  // PUP := N_GetUserParPtr( AUDVObj.R, 'LineWidth' );
  PUP := K_CMGetVObjPAttr(AUDVObj, 'LineWidth');
  if PUP <> nil then
  begin
    PUPC := N_GetUserParPtr(UDCommonAttrs.R, 'LineWidth');
    if PUPC <> nil then
      PFloat(PUP.UPValue.P)^ := PFloat(PUPC.UPValue.P)^;
  end;

  // Set Color from Common Attrs
  // PUP := N_GetUserParPtr( AUDVObj.R, 'MainColor' );
  PUP := K_CMGetVObjPAttr(AUDVObj, 'MainColor');
  if PUP <> nil then
  begin
    PUPC := N_GetUserParPtr(UDCommonAttrs.R, 'MainColor');
    if PUPC <> nil then
    begin
      PC := PInteger(PUP.UPValue.P);
      PC^ := PColor(PUPC.UPValue.P)^;
      K_CMChangeVObjSelectedColor(AUDVObj, PC^);
    end;
  end;
  {
    // Set Flashlight CoFactor from Common Attrs
    //  PUP := N_GetUserParPtr( AUDVObj.R, 'CoFactor' );
    PUP := K_CMGetVObjPAttr( AUDVObj, 'CoFactor' );
    if PUP <> nil then begin
    PUPC := N_GetUserParPtr( UDCommonAttrs.R, 'FlashlightCoFactor' );
    if PUPC <> nil then
    PFloat(PUP.UPValue.P)^ := PFloat(PUPC.UPValue.P)^;
    end;

    // Set Flashlight BriFactor from Common Attrs
    //  PUP := N_GetUserParPtr( AUDVObj.R, 'BriFactor' );
    PUP := K_CMGetVObjPAttr( AUDVObj, 'BriFactor' );
    if PUP <> nil then begin
    PUPC := N_GetUserParPtr( UDCommonAttrs.R, 'FlashlightBriFactor' );
    if PUPC <> nil then
    PFloat(PUP.UPValue.P)^ := PFloat(PUPC.UPValue.P)^;
    end;
  }
end; // procedure K_CMSVObjSetDefaultAttrs

//************************************************** K_CMSVObjNAngleRebuild ***
// Rebuild Normal Angle Appearance Components
//
//     Parameters
// ALineComp - Normal Angle Polyline
// AArcComp  - Angle Arc Line
// ATextComp - Angle Text
// APTextBP  - pointer to previous Calculate Text Base Point
// Result    - Returns value of new Text Base Point for next routine call;
//
function K_CMSVObjNAngleRebuild(ALineComp: TN_UDPolyline; AArcComp: TN_UDArc;
  ATextComp: TN_UDParaBox; APTextBP: PFPoint): TFPoint;
var
  PVP, P1, P2: PFPoint;
  Ang1, Ang2 { , Angw } : Double;
  BP: TFPoint;
begin

  with ALineComp, PSP.CPolyline.CPCoords do
  begin
    P1 := P(0);
    PVP := P(1);
    P2 := P(2);
    Ang1 := N_SegmAngle(UDPBufPixCoords[1], UDPBufPixCoords[0]);
    if Ang1 < 0 then
      Ang1 := 360 + Ang1;
    Ang2 := N_SegmAngle(UDPBufPixCoords[1], UDPBufPixCoords[2]);
    if Ang2 < 0 then
      Ang2 := 360 + Ang2;
  end;

  with AArcComp.PSP^, CCompBase, CCoords, CArc do
  begin
    BPCoords := PVP^;
    CArcBegAngle := Ang1;
    CArcEndAngle := Ang2;
    CBSkipSelf := 0;
    {
      if CArcBegAngle > CArcEndAngle then begin
      Angw := CArcBegAngle;
      CArcBegAngle := CArcEndAngle;
      CArcEndAngle := Angw;
      end;
    }
  end; // with AArcComp.PSP^, CCompBase, CCoords, CArc do

  with ATextComp.PSP^, CCompBase,
    TN_POneTextBlock(CParaBox.CPBTextBlocks.P())^, CCoords, BPCoords do
  begin
    Result.X := (P1.X + P2.X) * 0.5;
    Result.Y := (P1.Y + P2.Y) * 0.5;

    if APTextBP = nil then
      BP := BPCoords
    else if Integer(APTextBP) < 10 then
      BP := Result
    else
      BP := APTextBP^;

    X := X + Result.X - BP.X;
    Y := Y + Result.Y - BP.Y;
    CBSkipSelf := 0;
    // Build Segment Lehth Text
    Ang1 := Ang2 - Ang1;
    if Ang1 < 0 then
      Ang1 := 360 + Ang1;
    OTBMText := format('%.1f°', [Ang1]);
  end; // with ATextComp.PSP^, CCompBase, ...

end; // procedure K_CMSVObjNAngleRebuild

//************************************************** K_CMSVObjFAngleRebuild ***
// Rebuild Free Angle Appearance Components
//
//     Parameters
// ALineComp1 - Free Angle Polyline1
// ALineComp2 - Free Angle Polyline2
// AArcComp  - Angle Arc Line
// ATextComp - Angle Text
// APTextBP  - pointer to previous Calculate Text Base Point
// Result    - Returns value of new Text Base Point for next routine call;
//
function K_CMSVObjFAngleRebuild(ALineComp1, ALineComp2,
  ALineComp3: TN_UDPolyline; AArcComp: TN_UDArc; ATextComp: TN_UDParaBox;
  APTextBP: PFPoint): TFPoint;
var

  PFP: PFPoint;
  VP, P1, P2, P3, P4: TFPoint;
  Ang1, Ang2, Angle: Double;
  IsParallel: Boolean;
  BP: TFPoint;
  d31x, d43x, d21x, d31y, d43y, d21y: Double;
  Alfa, Beta, Znam: Double;
Label PrepATextComp;
begin

  with ALineComp2.PSP.CPolyline.CPCoords do
  begin
    P1 := PFPoint(P(0))^;
    P2 := PFPoint(P(1))^;
  end;

  with ALineComp3.PSP.CPolyline.CPCoords do
  begin
    P3 := PFPoint(P(0))^;
    P4 := PFPoint(P(1))^;
  end;

  d31x := P3.X - P1.X;
  d43x := P4.X - P3.X;
  d21x := P2.X - P1.X;

  d31y := P3.Y - P1.Y;
  d43y := P4.Y - P3.Y;
  d21y := P2.Y - P1.Y;

  Znam := (d43x * d21y - d43y * d21x);

  IsParallel := Abs(Znam) < 1.0e-10;

  if IsParallel then
  begin
    Angle := 0;
    ALineComp1.PSP()^.CCompBase.CBSkipSelf := 1;
    AArcComp.PSP()^.CCompBase.CBSkipSelf := 1;
    goto PrepATextComp;
  end;

  Beta := (d31y * d21x - d31x * d21y) / Znam;

  VP.X := P3.X + Beta * d43x;
  VP.Y := P3.Y + Beta * d43y;

  // ***** Calc Alfa so that:
  // VP.X := P1.X + Alfa*d21x;
  // VP.Y := P1.Y + Alfa*d21y;

  if Abs(d21x) > 1.0e-10 then
    Alfa := (VP.X - P1.X) / d21x
  else if Abs(d21y) > 1.0e-10 then
    Alfa := (VP.Y - P1.Y) / d21y
  else
    Alfa := 0;

  with ALineComp1.PSP^, CCompBase, CPolyline.CPCoords do
  begin
    // Build Dashed Line
    CBSkipSelf := 0;
    PFP := P(0);
    if Alfa < 0.5 then
      PFP^ := P1
    else
      PFP^ := P2;

    PFPoint(P(1))^ := VP;

    PFP := P(2);
    if Beta < 0.5 then
      PFP^ := P3
    else
      PFP^ := P4;
  end;

  with ALineComp2 do
  begin
    if Alfa < 0.5 then
      Ang1 := N_SegmAngle(UDPBufPixCoords[0], UDPBufPixCoords[1])
    else
      Ang1 := N_SegmAngle(UDPBufPixCoords[1], UDPBufPixCoords[0]);
    if Ang1 < 0 then
      Ang1 := 360 + Ang1;
  end;

  with ALineComp3 do
  begin
    if Beta < 0.5 then
      Ang2 := N_SegmAngle(UDPBufPixCoords[0], UDPBufPixCoords[1])
    else
      Ang2 := N_SegmAngle(UDPBufPixCoords[1], UDPBufPixCoords[0]);
    if Ang2 < 0 then
      Ang2 := 360 + Ang2;
  end;

  with AArcComp.PSP^, CCompBase, CCoords, CArc do
  begin
    BPCoords := VP;
    // CArcEnvRect := FRect( VP.X-5, VP.Y-5, VP.X+5, VP.Y+5 );
    CArcBegAngle := Ang1;
    CArcEndAngle := Ang2;
    CBSkipSelf := 0;
  end; // with AArcComp.PSP^, CCompBase, CCoords, CArc do begin

  Angle := Ang2 - Ang1;
  if Angle < 0 then
    Angle := 360 + Angle;

  if (Angle < 1.5) or (Angle > 358.5) then // skip drawing ALineComp1 and AArcComp
  begin
    ALineComp1.PSP()^.CCompBase.CBSkipSelf := 1;
    AArcComp.PSP()^.CCompBase.CBSkipSelf := 1;
  end;

PrepATextComp : // *****************************

  with ATextComp.PSP^, CCompBase,
    TN_POneTextBlock(CParaBox.CPBTextBlocks.P())^, CCoords, BPCoords do
  begin
    Result.X := (P1.X + P2.X + P3.X + P4.X) * 0.25;
    Result.Y := (P1.Y + P2.Y + P3.Y + P4.Y) * 0.25;

    if APTextBP = nil then
      BP := BPCoords
    else if Integer(APTextBP) < 10 then
      BP := Result
    else
      BP := APTextBP^;

    X := X + Result.X - BP.X;
    Y := Y + Result.Y - BP.Y;

    CBSkipSelf := 0;
    OTBMText := format('%.1f°', [Angle]);
    // N_Dump2Str( OTBMText ); // debug

  end; // with ATextComp.PSP^, CCompBase,

end; // procedure K_CMSVObjFAngleRebuild

//***************************************************** K_CMSVObjCheckShift ***
// Check Component Pixel Shift in Raster Frame Logical Rectangle
//
//     Parameters
// ARFLogFramePRect - Raster Frame RFLogFramePRect
// ACompPixRect - shifted Component pixel rectangle
// APixShiftX - on input given X pixel shift on output resulting X pixel shift
// APixShiftY - on input given Y pixel shift on output resulting Y pixel shift
// AOutsideShift - if =TRUE Component should be shifted outside given rectangle
// AInsidePosGapX - component mimimal inside X position if AOutsideShift=TRUE
// AInsidePosGapY - component mimimal inside Y position if AOutsideShift=TRUE
//
procedure K_CMSVObjCheckShift(ARFLogFramePRect: TRect; ACompPixRect: TRect;
  var APixShiftX, APixShiftY: Integer; AOutsideShift: Boolean;
  AInsidePosGapX, AInsidePosGapY: Integer);
var
  CurPixRect: TRect;
  RectCompRes: Integer;
begin

  { with ARFrame, AComp do } begin
    // Check VObject Rextangle Shift
    CurPixRect := N_RectShift(ACompPixRect, APixShiftX, APixShiftY);
    RectCompRes := N_RectCheckPos(CurPixRect, ARFLogFramePRect);

    if not AOutsideShift and (CurPixRect.Right - CurPixRect.Left <=
        ARFLogFramePRect.Right - ARFLogFramePRect.Left) then
    begin
      // Component Width is less then RFrame LogPixelRect Width
      if (RectCompRes and $10) <> 0 then
        APixShiftX := APixShiftX - CurPixRect.Left
      else if (RectCompRes and $40) <> 0 then
        APixShiftX := APixShiftX + ARFLogFramePRect.Right - CurPixRect.Right;
    end
    else
    begin
      // Component Width is larger then then RFrame LogPixelRect Width
      if ((RectCompRes and $10) <> 0) and
        (CurPixRect.Right <= ARFLogFramePRect.Left + AInsidePosGapX) then
        APixShiftX := APixShiftX - CurPixRect.Right + AInsidePosGapX
      else if ((RectCompRes and $40) <> 0) and
        (CurPixRect.Left >= ARFLogFramePRect.Right - AInsidePosGapX) then
        APixShiftX := APixShiftX + ARFLogFramePRect.Right - CurPixRect.Left -
          AInsidePosGapX;
    end;
    // bit0(001) - ARect1.Left   <= ARect2.Left
    // bit1(002) - ARect1.Top    <= ARect2.Top
    // bit2(004) - ARect1.Right  >= ARect2.Right
    // bit3(008) - ARect1.Bottom >= ARect2.Bottom
    //
    // bit4(010) - ARect1.Left   <  ARect2.Left
    // bit5(020) - ARect1.Top    <  ARect2.Top
    // bit6(040) - ARect1.Right  >  ARect2.Right
    // bit7(080) - ARect1.Bottom >  ARect2.Bottom

    if not AOutsideShift and
    // Component Height is less then RFrame LogPixelRect Height
      (CurPixRect.Bottom - CurPixRect.Top <= ARFLogFramePRect.Bottom -
        ARFLogFramePRect.Top) then
    begin
      if (RectCompRes and $20) <> 0 then
        APixShiftY := APixShiftY - CurPixRect.Top
      else if (RectCompRes and $80) <> 0 then
        APixShiftY := APixShiftY + ARFLogFramePRect.Bottom - CurPixRect.Bottom;
    end
    else
    begin
      // Component Height is larger then then RFrame LogPixelRect Height
      if ((RectCompRes and $20) <> 0) and
        (CurPixRect.Bottom <= ARFLogFramePRect.Top +
          AInsidePosGapY) then
        APixShiftY := APixShiftY - CurPixRect.Bottom + AInsidePosGapY
      else if ((RectCompRes and $80) <> 0) and
        (CurPixRect.Top >= ARFLogFramePRect.Bottom - AInsidePosGapY) then
        APixShiftY := APixShiftY + ARFLogFramePRect.Bottom - CurPixRect.Top -
          AInsidePosGapY;
    end;

  end
end; // procedure K_CMSVObjCheckShift

//************************************************* K_CMSVObjTextPosRebuild ***
// Rebuild Text Component Position in given Raster Frame Logical rectangle
//
//     Parameters
// ARFrame - Raster Frame to Draw
// AComp   - Text Component
// ARebuildFlags - rebuild position Flags Set
//
procedure K_CMSVObjTextPosRebuild(ARFrame: TN_Rast1Frame; AComp: TN_UDCompVis;
  ARebuildFlags: TK_CMSVObjTextPosRebuildFlags);
var
  APixShiftX, APixShiftY: Integer;
  FShift: TFPoint;
  // BP : TFPoint;

begin
  if not(cmtpfSkipStartRedraw in ARebuildFlags) then
    ARFrame.RedrawAll();

  APixShiftX := 0;
  APixShiftY := 0;

  if (cmtpfVertCenter in ARebuildFlags) or (cmtpfHorCenter in ARebuildFlags) then
  begin
    with AComp, PSP.CCoords, CompOuterPixRect do
    begin
      FShift.X := (Left + Right) / 2;
      FShift.Y := (Top + Bottom) / 2;
      FShift := N_AffConvF2FPoint(FShift, TN_UDCompVis(Owner).CompP2U);
      // BP := BPCoords;
      // BP := FShift;
      if cmtpfVertCenter in ARebuildFlags then
        BPCoords.Y := 2 * BPCoords.Y - FShift.Y;
      if cmtpfHorCenter in ARebuildFlags then
        BPCoords.X := 2 * BPCoords.X - FShift.X;
    end;
    ARFrame.RedrawAll();
    K_CMSVObjCheckShift(ARFrame.RFLogFramePRect, AComp.CompOuterPixRect,
        APixShiftX, APixShiftY, false, 25, 15);
  end
  else
    K_CMSVObjCheckShift(ARFrame.RFLogFramePRect, AComp.CompOuterPixRect,
      APixShiftX, APixShiftY, TRUE, 25, 15);

  if (APixShiftX <> 0) or (APixShiftY <> 0) then
  begin
    with AComp, PSP.CCoords do
    begin
      FShift := N_AffConvF2FPoint(BPCoords, TN_UDCompVis(Owner).CompU2P);
      FShift.X := FShift.X + APixShiftX;
      FShift.Y := FShift.Y + APixShiftY;
      BPCoords := N_AffConvF2FPoint(FShift, TN_UDCompVis(Owner).CompP2U);
    end;
    if not(cmtpfSkipFinalShow in ARebuildFlags) then
      ARFrame.RedrawAll();
  end;

  if not(cmtpfSkipFinalShow in ARebuildFlags) then
    ARFrame.ShowMainBuf();

end; // procedure K_CMSVObjTextPosRebuild

//********************************************* K_CMVobjTextAttrsFromMemIni ***
// Set given Text Annotation attributes from given MemIni Section
//
//     Parameters
// ASectName - given name of IniFile Section
// AUDTextComp - given Text Component
// AImgHeight - Image Height, needed if FontRSize attribute is not defined
// Result - Returns TRUE if FontRSize attribute was defind
//
function  K_CMVobjTextAttrsFromMemIni( const ASectName : string; AUDTextComp : TN_UDBase; AImgHeight : Integer ) : Boolean;
var
  PUP: TN_POneUserParam;
  PFont: TN_PNFont;
  POneTextBlock: TN_POneTextBlock;
  FText : string;
  FontRSize : Double;
begin
  Result := FALSE;
  PUP := K_CMGetVObjPAttr(AUDTextComp, 'MainColor');
  if PUP <> nil then
    with PUP.UPValue do
      PColor(P)^ := N_StrToColor( N_MemIniToString( ASectName, 'TextColor',
                                      N_ColorToHTMLHex(PColor(P)^) ) );

  POneTextBlock := TN_UDParaBox(AUDTextComp).PSP.CParaBox.CPBTextBlocks.P();
  with POneTextBlock^ do
    PFont := K_GetPVRArray(OTBNFont).P();
  if PFont <> nil then
  begin
    N_MemIniToSPLVal( ASectName, 'Font', PFont^, N_SPLTC_NFont );

    PUP := K_CMGetVObjPAttr(AUDTextComp, 'FontRSize');
    if PUP <> nil then
    begin
      FontRSize := N_MemIniToDbl( ASectName, 'FontRSize', -1 );
      if FontRSize = -1 then
      begin
        if AImgHeight > 0 then
          FontRSize := PFont^.NFLLWHeight / AImgHeight
        else
          FontRSize := K_CMVobjTextFontIniRSize;
        Result := TRUE;
      end;
      with PUP.UPValue do
        PDouble(P)^ := FontRSize;
    end;
  end;

  FText := N_MemIniToString( ASectName, 'Text', '' );
  if FText = '' then Exit;

  POneTextBlock^.OTBMText := K_StrDecodeFromIniFileValue( FText );

end; // end of K_CMVobjTextAttrsFromMemIni


//************************************************* K_CMVobjCTAAttrsFromCTA ***
// Set given Text Annotation attributes from given Text Annotation
//
//     Parameters
// AUDSrcTextComp - source Text Component
// AUDTextComp - given Text Component
//
procedure K_CMVobjCTAAttrsFromCTA( AUDSrcTextComp, AUDTextComp : TN_UDBase );
var
  PUPS, PUP: TN_POneUserParam;
  PFontS, PFont: TN_PNFont;
  POneTextBlockS, POneTextBlock: TN_POneTextBlock;

begin
  PUP := K_CMGetVObjPAttr(AUDTextComp, 'MainColor');
  if PUP <> nil then
  begin
    PUPS := K_CMGetVObjPAttr(AUDSrcTextComp, 'MainColor');
    if PUPS <> nil then
      PColor(PUP.UPValue.P)^ :=  PColor(PUPS.UPValue.P)^;
  end;

  POneTextBlock := TN_UDParaBox(AUDTextComp).PSP.CParaBox.CPBTextBlocks.P();
  POneTextBlockS := TN_UDParaBox(AUDSrcTextComp).PSP.CParaBox.CPBTextBlocks.P();
  with POneTextBlock^ do
    PFont := K_GetPVRArray(OTBNFont).P();
  if PFont <> nil then
  begin
    with POneTextBlockS^ do
      PFontS := K_GetPVRArray(OTBNFont).P();
    if PFontS <> nil then
      PFont^ := PFontS^;
  end;

  POneTextBlock^.OTBMText := POneTextBlockS^.OTBMText;

  PUP := K_CMGetVObjPAttr(AUDTextComp, 'FontRSize');
  if PUP <> nil then
  begin
    PUPS := K_CMGetVObjPAttr(AUDSrcTextComp, 'FontRSize');
    if PUPS <> nil then
      PDouble(PUP.UPValue.P)^ :=  PDouble(PUPS.UPValue.P)^;
  end;

end; // end of K_CMVobjCTAAttrsFromCTA

//************************************************* K_CMVobjSetFontSizeAuto ***
// Set given Text Annotation Font Size by FontRSize
//
//     Parameters
// AUDTextComp - given Text Component
// AImgHeight - Image Height
//
procedure K_CMVobjSetFontSizeAuto( AUDTextComp : TN_UDBase; AImgHeight : Integer );
var
  PUP: TN_POneUserParam;
  PFont: TN_PNFont;
  POneTextBlock: TN_POneTextBlock;
//  FontRSize : Double;
begin
  POneTextBlock := TN_UDParaBox(AUDTextComp).PSP.CParaBox.CPBTextBlocks.P();
  with POneTextBlock^ do
    PFont := K_GetPVRArray(OTBNFont).P();
  if PFont <> nil then
  begin
    PUP := K_CMGetVObjPAttr(AUDTextComp, 'FontRSize');
//    FontRSize := 0.035;
    if PUP <> nil then
      PFont.NFLLWHeight := PDouble(PUP.UPValue.P)^ * AImgHeight;
//      FontRSize := PDouble(PUP.UPValue.P)^;
//    PFont.NFLLWHeight := FontRSize * AImgHeight;
  end;
end; // end of K_CMVobjSetFontSizeAuto

//************************************************ K_CMVobjCTAAttrsToMemIni ***
// Save given Text Annotation attributes to given MemIni Section
//
//     Parameters
// ATSectName - given target section name
// ASSectName - given source section name
// AUDTextComp - given Text Component
// ASaveAddAttrs - if TRUE then save ShortCut and Caption from AUDTextComp ObjInfo and ObjAliase
// Result - Returns TRUE if attributes are changed
//
function K_CMVobjCTAAttrsToMemIni( const ATSectName, ASSectName : string; AUDTextComp : TN_UDBase;
                                   ASaveAddAttrs : Boolean ) : Boolean;
var
  PUP: TN_POneUserParam;
  PFont: TN_PNFont;
  POneTextBlock: TN_POneTextBlock;
  WStr, NStr, SSName : string;

  procedure SetNewValue( const AName : string );
  var
    Changed : Boolean;
  begin
    WStr := N_MemIniToString( SSName, AName, '' );
    Changed := NStr <> WStr;
    if Changed then
      N_StringToMemIni( ATSectName, AName, NStr );
    Result := Result or Changed;
  end; // procedure SetNewValue

begin
  // Save Current Color and Font to Text annotation attrs in MemIni
  SSName := ASSectName;
  if SSName = '' then
    SSName := ATSectName;

  Result := FALSE;
  PUP := K_CMGetVObjPAttr(AUDTextComp, 'MainColor');
  if PUP <> nil then
  begin
    NStr := N_ColorToHTMLHex(PColor(PUP.UPValue.P)^);
    SetNewValue( 'TextColor' );
  end;

  POneTextBlock := TN_UDParaBox(AUDTextComp).PSP.CParaBox.CPBTextBlocks.P();
  with POneTextBlock^ do
    PFont := K_GetPVRArray(OTBNFont).P();
  if PFont <> nil then
  begin
    NStr := K_SPLValueToString(  PFont^, TK_ExprExtType(Int64(N_SPLTC_NFont)), [] );
    SetNewValue( 'Font' );
  end;

  PUP := K_CMGetVObjPAttr(AUDTextComp, 'FontRSize');
  if PUP <> nil then
    with PUP.UPValue do
      N_DblToMemIni( ATSectName, 'FontRSize', '%g', PDouble(P)^ );

  NStr := K_StrEncodeToIniFileValue(POneTextBlock^.OTBMText);
  SetNewValue(  'Text' );

  if ASaveAddAttrs then
  begin
    NStr :=  AUDTextComp.ObjInfo;
    SetNewValue(  'ShortCut' );

    NStr :=  AUDTextComp.ObjAliase;
    SetNewValue(  'Caption' );
  end;

  if Result then
    N_StringToMemIni( ATSectName, 'TS', format( '%g', [Now()] ) ); // Change TimeStamp
end; // end of K_CMVobjCTAAttrsToMemIni

//********************************************* K_CMVobjCTAGetMemIniContext ***
// Get Customizable Text Annotation MemIni Context by given CTA index
//
//     Parameters
// ACTAInd - index of CTA (1..6)
// ACTAUse - resulting code:
//#F
//   0 - CTA is not used (if ACTAInd <= 0)
//   1 - global context is actual,
//   2 - local context is actual,
//   3 - local and global contexts exist, but global is actual
//   4 - local and global contexts exist, but local is actual
// 100 - no actual context,
//#/F
// Result - Returns name of local IniFile Section corresponding to given CTA index
//
function K_CMVobjCTAGetMemIniContext( ACTAInd : Integer; out ACTAUse : Integer ) : string;
var
  GCTAText, CTAText : string;
begin
  ACTAUse := 0;
  Result := '';
  if ACTAInd < 1 then Exit; // precaution

// Prepare Customizable Annotation Context
  Result := 'VObjCTA' + IntToStr(ACTAInd);
  GCTAText := N_MemIniToString( 'G' + Result, 'TS', '' );
  CTAText := N_MemIniToString( Result, 'TS', '' );
  if (GCTAText = '') and (CTAText = '') then   // First CTA Use
    ACTAUse := 100
  else
  if (GCTAText <> '') and (CTAText = '') then  // Use Global CTA
    ACTAUse := 1
  else
  if (GCTAText = '') and ( CTAText <> '' ) then // Use Local CTA
    ACTAUse := 2
  else
  // if (GCTAText <> '') and (CTAText <> '') then
  begin                                          // Select Local or Global CTA
    ACTAUse := 3;

//    if ( StrToFloat( K_ReplaceCommaByPoint(GCTAText) ) <=
//         StrToFloat( K_ReplaceCommaByPoint(CTAText) ) ) or
    if ( StrToFloat( N_ReplaceDecSepByPoint(GCTAText) ) <=
         StrToFloat( N_ReplaceDecSepByPoint(CTAText) ) ) or
       N_MemIniToBool( Result, 'UseLocal', FALSE ) then
      ACTAUse := 4;
  end;
end; // function K_CMVobjCTAGetMemIniContext

//************************************************** K_CMVobjInitDotTextPos ***
// Init Dot Text Component position by Font Relative Height
//
//     Parameters
// AUDDotComp  - given Dot Text Component
// AFontHeight - Font Height
// ASlidePixWidth - Slide width in pixels
// ASlidePixHeight - Slide height in pixels
//
procedure K_CMVobjInitDotTextPos( AUDDotComp : TN_UDBase; ABPX, ABPY : Float;
                                  ASlidePixWidth, ASlidePixHeight : Integer ) ;
begin
//            with TextComp.PSP^, CCompBase, CCoords, CParaBox,
//                 TN_PNFont(K_GetPVRArray(TN_POneTextBlock(CPBTextBlocks.P()).OTBNFont).P())^ do

  with TN_UDParaBox(AUDDotComp).PSP^, CCoords, CParaBox,
        TN_PNFont(K_GetPVRArray(TN_POneTextBlock(CPBTextBlocks.P()).OTBNFont).P())^ do
  begin
    BPCoords.X := ABPX + 0.3 * 0.75 * NFLLWHeight * 100 / ASlidePixWidth;
    BPCoords.Y := ABPY - NFLLWHeight * 100 / ASlidePixHeight;
    K_CMVobjSetDotSizeByFontHeight( AUDDotComp.Owner, NFLLWHeight );
  end;
end; // end of K_CMVobjInitDotTextPos

//****************************************** K_CMVobjSetDotSizeByFontHeight ***
// Set Dot anotation size by given Font Height
//
//     Parameters
// AUDDotComp  - given Dot Root Component
// AFontHeight - Dot Text Font Height
// Result - Returns size of Dot Selected Sign in pixels
//
function K_CMVobjSetDotSizeByFontHeight( AUDDotComp : TN_UDBase; AFontHeight : Float ) : Float;
var
  PUP: TN_POneUserParam;
  DS : Float;
begin
  // Line Width
  PUP := K_CMGetVObjPAttr( AUDDotComp, 'LineWidth' );
  DS := Max( 3, AFontHeight * 0.2 );
  PFloat(PUP.UPValue.P)^ := DS;
  //Sign Size
  Result := DS * 1.5;
  PUP := K_CMGetVObjPAttr( AUDDotComp, 'SignSize' );
  PFPoint(PUP.UPValue.P)^ := FPoint(Result,Result);
end; // end of K_CMVobjSetDotSizeByFontHeight

//**************************************************** K_CMDEMOAddMarkToDIB ***
// Add DEMO mark to given DIB if DEMO Mode
//
//     Parameters
// ADIBObj - given DIBObj
//
function K_CMDEMOAddMarkToDIB( ADIBObj: TN_DIBObj ) : Boolean;
var
  OrConst, MinHistInd, MaxHistInd, TDSize, NeededNumBits, RealNumBits: Integer;
  HistData: TN_IArray;
  TextDIB: TN_DIBObj;
  MaskDIB: TN_DIBObj;
  DrawSM, MaskSM: TN_SMatrDescr;
begin
  Result := FALSE;
  if not K_CMDemoModeFlag or
     N_CMSkipImgDEMOLabel then Exit;

  Result := TRUE;
  TDSize := 1000;
  TextDIB := TN_DIBObj.Create(TDSize, TDSize, pf24bit, 0);
  N_DebSetNFont(TextDIB.DIBOCanv, Round(0.45 * TDSize), 1, 45);

  TextDIB.DIBOCanv.SetFontAttribs( $FFFFFF ); // any color is OK except 0
  // N_SetFontSmoothing( false );
  TextDIB.DIBOCanv.DrawPixString( Point(Round(-0.125 * TDSize),
                                  Round(0.625 * TDSize)), 'DEMO');
  // N_SetFontSmoothing( true );

//TextDIB.SaveToBMPFormat( K_ExpandFileName( '(#WrkFiles#)TextDIB.bmp' ) );

  MaskDIB := TN_DIBObj.Create ( ADIBObj.DIBSize.X, ADIBObj.DIBSize.Y, pfCustom, 0, epfGray8 );
  with MaskDIB do
    N_StretchRect(DIBOCanv.HMDC, DIBRect, // Draw initial Image
      TextDIB.DIBOCanv.HMDC, TextDIB.DIBRect, SRCCOPY); //
//MaskDIB.SaveToBMPFormat( K_ExpandFileName( '(#WrkFiles#)MaskDIB.bmp' ) );

//ADIBObj.SaveToBMPFormat( K_ExpandFileName( '(#WrkFiles#)SrcDIB.bmp' ) );
  ADIBObj.PrepSMatrDescr( @DrawSM );
  MaskDIB.PrepSMatrDescr( @MaskSM );

  NeededNumBits := ADIBObj.DIBNumBits;
  if ADIBObj.DIBExPixFmt = epfGray16 then // ajust NeededNumBits if needed
  begin
    ADIBObj.CalcBrighHistNData( HistData, nil, @MinHistInd, @MaxHistInd, nil, 16 );
    RealNumBits := max( 9, Ceil( Log2( MaxHistInd + 1 ) ) );

    if NeededNumBits > RealNumBits then
      NeededNumBits := RealNumBits;
  end; // if ADIBObj.DIBExPixFmt = epfGray16 then // ajust NeededNumBits if needed

  OrConst := $3F3F3F;
  if ADIBObj.DIBExPixFmt = epfGray16 then // ajust OrConst if needed to make same color for Gray16 and Gray8 images
  begin
    OrConst := OrConst shr (24-NeededNumBits);
  end;

  N_Draw2SMbyMask1( @DrawSM, @MaskSM, OrConst, 1 ); // OR Mode
//ADIBObj.SaveToBMPFormat( K_ExpandFileName( '(#WrkFiles#)ResDIB.bmp' ) );
//  Draw By Mask
{ !!! previous Code
  with ADIBObj do
    N_StretchRect(DIBOCanv.HMDC, DIBRect, // Draw initial Image
      TextDIB.DIBOCanv.HMDC, TextDIB.DIBRect, SRCPAINT); //
}
  MaskDIB.Free;
  TextDIB.Free;
end; // end of K_CMDEMOAddMarkToDIB

//*************************************************** K_CMDEMOAddConstraint ***
// Check add new slide number constraint if DEMO Mode
//
//     Parameters
// ACount - Number of Slides to add
// Result - Returns number of added slides (in Demo version Result <= ACount)
//
function K_CMDEMOAddConstraint(ACount: Integer = 1): Integer;
var
  CurNumber: Integer;
begin
  Result := ACount;
  if Result = 0 then
    Exit;
  if not K_CMDemoModeFlag or (K_CMDemoMaxSlidesCount = 0) then
    Exit;

  Result := Max(0, Min(Result,
      K_CMDemoMaxSlidesCount - K_CMEDAccess.CurSlidesList.Count));
  CurNumber := K_CMEDAccess.CurSlidesList.Count;

  if Result = 0 then
    K_CMShowMessageDlg(format(
          K_CML1Form.LLLDemoConstraints1.Caption,
//          'You have already created %d Media Objects.' + #13#10 +
//          'You are not allowed to create more Media Objects.',
          [K_CMDemoMaxSlidesCount]), mtWarning)
  else if CurNumber + Result >= K_CMDemoMaxSlidesWarnCount then
    K_CMShowMessageDlg(format(
          K_CML1Form.LLLDemoConstraints2.Caption,
//          'You have already created %d Media Objects.' + #13#10 +
//          'You are allowed to create only %d Media Objects.',
          [CurNumber, K_CMDemoMaxSlidesCount]), mtWarning);
end; // end of K_CMDEMOAddConstraint

//***************************************************** K_CMSPCAddCOMServer ***
// Add given string to CMS Log if cmpfCOMServer flag is set
//
//     Parameters
// AStr - given string
//
procedure K_CMSPCAddCOMServer(AStr: string);
begin
  N_Dump2Str(AStr);
end; // procedure K_CMSPCAddCOMServer

//********************************************************** K_CMSPCAddVObj ***
// Add given string to CMS Log if cmpfVObjMain flag is set
//
//     Parameters
// AStr - given string
//
procedure K_CMSPCAddVObj(AStr: string);
begin
  N_Dump2Str(AStr);
end; // procedure K_CMSPCAddVObj

//***************************************************** K_CMSPCAddVObjEvent ***
// Add given string and Event Info to CMS Log if cmpfVObjEvents flag is set
//
//     Parameters
// AStr - given string
// ARFAction - RFA Action Object
//
procedure K_CMSPCAddVObjEvent(AStr: string; ARFAction: TN_RFrameAction);
const
  CHTypeNames: array [0 .. Ord(htOthers)] of string = ('htNotDef',
    'htMouseDown', 'htMouseMove', 'htMouseUp', 'htMouseWheel',
    'htDblClick', 'htKeyDown', 'htKeyUp', 'htOthers');
  CMButtonNames: array [0 .. Ord(mbMiddle)] of string = ('mbLeft', 'mbRight',
    'mbMiddle');
var
  EventInfo: string;
begin
  if not(cmpfVObjEvents in N_CM_LogFlags) then
    Exit;
  with ARFAction, ActGroup.RFrame do
  begin
    EventInfo := ' >> ' + CHTypeNames[Ord(CHType)] + ' ShiftState=$' + IntToHex
      (PWORD(@CMKShift)^, 4);

    if (CHType = htKeyUp) or (CHType = htKeyDown) then
      EventInfo := EventInfo + ' Key=' + IntToStr(CKey.CharCode)
    else
      EventInfo := EventInfo + format(' MX,MY=%d,%d', [CMPos.X, CMPos.Y]);
    N_Dump2Str(Parent.Name + '.' + ActName + ': ' + AStr + EventInfo);
  end;
end; // procedure K_CMSPCAddVObjEvent

//********************************************** K_CMSFlashlightCalcSrcRect ***
// Calculate and set Self.CDRSrcRect and Self.CDRXLATInts fields
//
//     Parameters
// AFlashLightRootComp - Flashlight Root component
// ARFScale            - current show RasterFarme vector scale factor
// APixSize            - Flashlight Needed Pixel Size
//
procedure K_CMSFlashlightCalcSrcRect( AFlashLightRootComp: TN_UDCompVis;
                                      ARFScale: Float; APixSize: TPoint );
var
  MinHistInd, MaxHistInd, { CentrInd, } NewMin, NewMax: Integer;
  FScale, FBriFactor, FCoFactor: Float;
  MidPixPoint: TPoint;
  BrighHistValues: TN_IArray;
  DInd, CDInd: Integer;
begin
  with AFlashLightRootComp, PSP.CCoords,
  // !! Old         TN_UDDIBRect(DirChild(0)).PSP.CDIBRect,
  TN_UDDIBRect(DirChild(1)).PSP.CDIBRect, CDRSrcUDDIB.DIBObj do
  begin

    // if PInteger(N_GetUserParPtr( R, 'SkipScaleFlag' ).UPValue.P)^ = 0 then
    // FScale := PFloat(N_GetUserParPtr( R, 'ScaleFactor' ).UPValue.P)^
    // else
    // FScale := 1;

    if PInteger(K_CMGetVObjPAttr(AFlashLightRootComp,
        'SkipScaleFlag').UPValue.P)^ = 0 then
      FScale := PFloat(K_CMGetVObjPAttr(AFlashLightRootComp,
          'ScaleFactor').UPValue.P)^
    else
      FScale := 1;

    FScale := FScale * ARFScale;
    if APixSize.X <> 0 then
    begin
      APixSize.X := Round(APixSize.X / FScale);
      APixSize.Y := Round(APixSize.Y / FScale);
    end
    else
      APixSize := N_RectSize(CDRSrcRect);

    MidPixPoint.X := Round(DIBRect.Right * (BPCoords.X + SRSize.X / 2) / 100);
    MidPixPoint.Y := Round(DIBRect.Bottom * (BPCoords.Y + SRSize.Y / 2) / 100);
    CDRSrcRect := N_RectMake( MidPixPoint, Point(Round(APixSize.X),
                              Round(APixSize.Y)), N_05DPoint );

    // if (PInteger(N_GetUserParPtr( R, 'AutoEqualizeFlag' ).UPValue.P)^ <> 0) then // and
    if (PInteger(K_CMGetVObjPAttr(AFlashLightRootComp,
          'AutoEqualizeFlag').UPValue.P)^ <> 0) then // and
    // (DIBExPixFmt = epfGray8) then // temporary only only for 8 bit graysacale images
    begin
      CalcBrighHistNData(BrighHistValues, @CDRSrcRect, @MinHistInd,
        @MaxHistInd, nil, 8);

      // FBriFactor := PFloat(N_GetUserParPtr( R, 'BriFactor' ).UPValue.P)^;
      FBriFactor := PFloat(K_CMGetVObjPAttr(AFlashLightRootComp,
          'BriFactor').UPValue.P)^;
      // FCoFactor  := PFloat(N_GetUserParPtr( R, 'CoFactor' ).UPValue.P)^;
      FCoFactor := PFloat(K_CMGetVObjPAttr(AFlashLightRootComp,
          'CoFactor').UPValue.P)^;

      CDInd := 127 - ((MinHistInd + MaxHistInd) div 2);
      DInd := (255 - MaxHistInd + MinHistInd) div 2;
      DInd := Round(Int(DInd * FBriFactor / 100));
      DInd := DInd + CDInd;
      NewMax := MaxHistInd + DInd;
      NewMin := MinHistInd + DInd;
      FCoFactor := (FCoFactor - 1) / 49;
      NewMax := NewMax + Round(Int((255 - NewMax) * FCoFactor));
      NewMin := NewMin - Round(Int(NewMin * FCoFactor));
      {
        //*** Calc (NewMin, NewMax) - needed new brightnes range
        //    FCoFactor >= 1.0, -100.0 <= FBriFactor <= 100.0

        CentrInd := ( MinHistInd + MaxHistInd ) div 2;

        NewMin := N_ClipBy0255( CentrInd - (CentrInd-MinHistInd)*FCoFactor );
        NewMax := N_ClipBy0255( CentrInd + (MaxHistInd-CentrInd)*FCoFactor );

        NewMin := N_ClipBy0255( NewMin + 2.55*FBriFactor );
        NewMax := N_ClipBy0255( NewMax + 2.55*FBriFactor );
      }
      // N_IAdd( Format( 'orig=%d,%d  new=%d,%d' , [MinHistInd,MaxHistInd,NewMin, NewMax] )); // debug

      if CDRXLATInts = nil then
        CDRXLATInts := K_RCreateByTypeCode(Ord(nptInt), 256);

      N_SetXLATFragm(PInteger(CDRXLATInts.P()), MinHistInd, MaxHistInd,
        NewMin, NewMax);

    end
    else // AutoEqualizeFlag is not checked
      FreeAndNil(CDRXLATInts);

  end; // with ...

end; // procedure K_CMSFlashlightCalcSrcRect

// ********** TN_UDCMBSlide class methods  **************

//**************************************************** TN_UDCMBSlide.Create ***
//
constructor TN_UDCMBSlide.Create;
begin
  inherited Create;
//  N_CheckAllAdd(Self, CheckConsistency); // Add Element to Objects Control List
  K_AMSCObj.AMSCheckObjAdd(Self, CheckConsistency); // Add Element to Objects Control List
end; // end_of constructor TN_UDCMBSlide.Create

//*************************************************** TN_UDCMBSlide.Destroy ***
// Add SlideId to special Array N_CM_DelSlidesId in OnePat Child mode
//
destructor TN_UDCMBSlide.Destroy;
begin
//  N_Dump2Str( format( 'TN_UDCMBSlide.Destroy >> Name=%s Aliase=%s Info=%s', [ObjName, ObjAliase, ObjInfo] ) );
  FreeAndNil(CMSlideECFStream);
  inherited;
//  N_CheckAllRemove(Self); // Remove Element from Objects Control List
  K_AMSCObj.AMSCheckObjRemove(Self); // Remove Element from Objects Control List
end; // end_of destructor TN_UDCMBSlide.Destroy

//********************************************************* TN_UDCMBSlide.P ***
// Return Typed Pointer to Self Record
//
function TN_UDCMBSlide.P(): TN_PCMSlide;
begin
  Result := nil;
  if Self = nil then
    Exit;
  if ObjLiveMark <> N_ObjLiveMark then
    raise TK_UDBaseConsistency.Create('TN_UDCMSlide.P Consistency Error');
  Result := TN_PCMSlide(R.P());
end; // function TN_UDCMBSlide.P

//****************************************** TN_UDCMBSlide.CheckConsistency ***
// Check Slide consistency
//
//     Parameters
// APObj - pointer to Self
// ACheckPar - check level
// Result - Returns error string
//
function TN_UDCMBSlide.CheckConsistency( APObj: Pointer; ACheckPar: Integer): string;
var
  CheckInfo : string;
begin
  Result := '';
  if Self = nil then
  begin
    Result := 'Slide is nil';
    Exit;
  end;
  try
    if ObjLiveMark <> N_ObjLiveMark then
    begin
      CheckInfo := 'is not alive';
      Result := 'Is not alive SlideID=' + ObjName;
      Exit;
    end;
    if APObj <> Self then
    begin
      CheckInfo := 'List Check';
      CheckInfo := 'List Check SelfID=' + ObjName;
      Result := format( 'List CheckID=%s <> SelfID=%s', [TN_UDBase(APObj).ObjName, ObjName] ); ;
      Exit;
    end;
  except
    Result := 'Slide check Except >> ' + CheckInfo;
  end;
end; // function TN_UDCMBSlide.CheckConsistency

//********************************************** TN_UDCMBSlide.GetThumbnail ***
// Get Thumbnail DIB Object
//
//     Parameters
// Result - Returns Self Thumbnail DIB Object or nil if Thumbnail is absent
//
function TN_UDCMBSlide.GetThumbnail(): TN_UDDIB;
begin
  Result := nil;
  if Self = nil then
    Exit;
  if ObjLiveMark <> N_ObjLiveMark then
    raise TK_UDBaseConsistency.Create(
      'TN_UDCMSlide.GetThumbnail Consistency Error');
  Result := TN_UDDIB(DirChild(K_CMSlideIndThumbnail));
  if Result.DIBObj = nil then
    Result.LoadDIBObj(); // Skip Convertion to Grey
end; // function TN_UDCMBSlide.GetThumbnail

//******************************************* TN_UDCMBSlide.GetThumbnailBMP ***
// Get Thumbnail BMP to given buffer (resize ABuf if needed)
//
//     Parameters
// ABuf       - Thumbnail buffer (TN_BArray)
// AThumbSize - number of Data bytes in ABuf
//
procedure TN_UDCMBSlide.GetThumbnailBMP(var ABuf: TN_BArray;
  out AThumbSize: Integer);
var
  Thumb: TN_UDDIB;
begin
  Thumb := GetThumbnail();
  if Thumb = nil then
    Thumb := CreateThumbnail();

  AThumbSize := Thumb.DIBObj.SaveToBArrayBMP(ABuf);
end; // procedure TN_UDCMBSlide.GetThumbnailBMP

//***************************************** TN_UDCMBSlide.SetThumbnailByDIB ***
// Create Thumbnail, based upon given AThumbDIBObj, and replace existing Thumbnail or
// (if absent) add it as Self zero Child and return it
//
function TN_UDCMBSlide.SetThumbnailByDIB(AThumbDIBObj: TN_DIBObj): TN_UDDIB;
begin
  Result := TN_UDDIB(DirChild(K_CMSlideIndThumbnail));
  if Result = nil then
  begin
    Result := K_CMBSlideCreateThumbnailUDDIB( AThumbDIBObj );
    if Result = nil then Exit;
    PutDirChildSafe(K_CMSlideIndThumbnail, Result);
  end
  else
  begin
    Result.DIBObj.Free;
    Result.DIBObj := AThumbDIBObj;
    Result.UDData := nil;
  end;

end; // function TN_UDCMBSlide.SetThumbnailByDIB

//***************************************** TN_UDCMBSlide.SetThumbnailByBMP ***
// Create Thumbnail, based upon given AMemPtrBMP, and replace existing Thumbnail or
// (if absent) add it as Self zero Child and return it
//
function TN_UDCMBSlide.SetThumbnailByBMP(AMemPtrBMP: Pointer): TN_UDDIB;
var
  ThumbDIBObj: TN_DIBObj;
begin
  Result := nil;
  if AMemPtrBMP = nil then
    Exit; // Thumbnail is not given

  ThumbDIBObj := TN_DIBObj.Create();
  ThumbDIBObj.LoadFromMemBMP(AMemPtrBMP);

  Result := SetThumbnailByDIB(ThumbDIBObj); // ThumbDIBObj should not be freed
end; // function TN_UDCMBSlide.SetThumbnailByBMP

//*********************************** TN_UDCMBSlide.GetFilesPatientPathSegm ***
// Get MediaFiles and ImageFiles full Slide Patient depended path segment
//
//     Parameters
// Result - Returns Slide depended path segment for MediaFiles and ImageFiles
//
function TN_UDCMBSlide.GetFilesPatientPathSegm(): string;
begin
  with P()^ do
  begin
    Result := K_CMSlideGetPatientFilesPathSegm(CMSPatId);
  end;
end; // function TN_UDCMBSlide.GetFilesPatientPathSegm

//****************************************** TN_UDCMBSlide.GetFilesPathSegm ***
// Get MediaFiles and ImageFiles Slide depended path segment
//
//     Parameters
// Result - Returns Slide depended path segment for MediaFiles and ImageFiles
//
function TN_UDCMBSlide.GetFilesPathSegm(): string;
begin
  with P()^ do
  begin
    Result := GetFilesPatientPathSegm() + K_CMSlideGetFileDatePathSegm(CMSDTCreated);
  end;
end; // function TN_UDCMBSlide.GetFilesPathSegm

//****************************************** TN_UDCMBSlide.GetIDForFileName ***
// Get Current Slide ID for File Name Creation
//
//     Parameters
// Result - Returns Slide Current ID for File Name Creation
//
function TN_UDCMBSlide.GetIDForFileName(): string;
begin
  Result := K_CMSlideGetFileIDPathSegm( ObjName );
end; // function TN_UDCMBSlide.GetIDForFileName

//******************************** TN_UDCMBSlide.CheckSlideInsideGetMapRoot ***
// Check Slide inside GetMapRoot Method
//
procedure TN_UDCMBSlide.CheckSlideInsideGetMapRoot;
begin
  if Self = nil then Exit;
  if ObjLiveMark <> N_ObjLiveMark then
    raise TK_UDBaseConsistency.Create(
      'TN_UDCMBSlide.GetMapRoot Consistency Error');
end; // function TN_UDCMBSlide.CheckSlideInsideGetMapRoot

//************************************************* TN_UDCMSlide.GetMapRoot ***
// Get Base Slide MapRoot
//
//     Parameters
// Result - Returns Base Slide MapRoot
//
function TN_UDCMBSlide.GetMapRoot( ): TN_UDCompVis;
begin
  CheckSlideInsideGetMapRoot();

  Result := nil;
  if Self = nil then  Exit;
end; // function TN_UDCMBSlide.GetMapRoot


//**************************************** TN_UDCMBSlide.CMSlideAddCurState ***
// Add to given strings current state params
//
//     Parameters
// AStrings - given strings
// AIndent  - number of spaces to add before all strings
//
// Used to dump Slide info for debug purpose
//
procedure TN_UDCMBSlide.CMSlideAddCurState(AStrings: TStrings; AIndent: Integer);
var
  Prefix: string;
  PCMSlide: TN_PCMSlide;
begin
  Prefix := DupeString(' ', AIndent + 2);
  with AStrings do
  begin
    if Self = nil then
    begin
      AStrings.Add(Prefix + 'Self = nil');
      Exit;
    end
    else if ObjLiveMark <> N_ObjLiveMark then
    begin
      Add(Prefix + 'Slide is not alive');
      Exit;
    end;

    try
      Add(Prefix + 'ID: ' + ObjName + ', ' + ObjInfo);
      PCMSlide := P;
      Add(Prefix + 'Fields: ' + K_SPLValueToString(PCMSlide^,
                                                   K_GetTypeCode('TN_CMSlide')));

    except
      on E: Exception do
      begin
        Add(Prefix + ' Except:' + E.Message);
      end;
    end;
    Add('');

  end; // with AStrings do
end; // procedure TN_UDCMBSlide.CMSlideAddCurState

//*********************************************** TN_UDCMBSlide.ECacheClear ***
// Clear slide ECache files
//
procedure TN_UDCMBSlide.ECacheClear( ADumpRTID : Integer );
begin

end; // procedure TN_UDCMBSlide.ECacheClear

// ********** TN_UDCMSlide class methods  **************

//***************************************************** TN_UDCMSlide.Create ***
//
constructor TN_UDCMSlide.Create;
begin
  inherited Create;
  ClassFlags := (ClassFlags and $FFFFFF00) or N_UDCMSlideCI;
  ImgInd := 103;
end; // end_of constructor TN_UDCMSlide.Create

//**************************************************** TN_UDCMSlide.Destroy ***
// Slide Destructor
//
destructor TN_UDCMSlide.Destroy;
begin
  CMSUndoBuf.Free;
  with P^ do
  if (K_CMDCMSeriesID <> 0) and
     ((CMDCMSerID = K_CMDCMSeriesID) or (CMSDB.DCMSerID = K_CMDCMSeriesID)) then  // Dec Series Slides created counter
  begin
    if K_CMDCMSeriesIDSCount > 0 then
      Dec(K_CMDCMSeriesIDSCount)
    else
      N_Dump1Str( 'DB >> TN_UDCMSlide.Destroy DCMSeriesIDSCount=0' );
  end;
  inherited;
end; // end_of destructor TN_UDCMSlide.Destroy

//******************************************* TN_UDCMSlide.CheckConsistency ***
// Check Slide consistency
//
//     Parameters
// APObj - pointer to Self
// ACheckPar - check level
// Result - Returns error string
//
function TN_UDCMSlide.CheckConsistency( APObj: Pointer;
  ACheckPar: Integer): string;
var
  CheckInfo: string;
  WStr: string;
  UDDIB : TN_UDDIB;
begin
  Result := inherited CheckConsistency( APObj, ACheckPar );
  if (Result <> '') or (ACheckPar = 0) then
    Exit;
  // Continue Check
  try
    CheckInfo := ' Slide Fields';
    WStr := K_SPLValueToString(P^, K_GetTypeCode('TN_CMSlide'));
    if ACheckPar < 2 then
      Exit;
    CheckInfo := ' Slide MapRootFields';
    WStr := K_SPLValueToString(GetPMapRootAttrs()^, K_GetTypeCode('TK_CMSMRImgAttrs'));

    UDDIB := GetCurrentImage( TRUE, TRUE );
    if (UDDIB <> nil) and (UDDIB.PSP.CDIBN.CDIBDataFormat = uddfNotDef) then
      Result := 'SlideID=' + ObjName + ' CurImg.CDIBDataFormat = uddfNotDef';
    UDDIB := GetSourceImage( TRUE, TRUE );
    if (UDDIB <> nil) and (UDDIB.PSP.CDIBN.CDIBDataFormat = uddfNotDef) then
      Result := 'SlideID=' + ObjName + ' SrcImg.CDIBDataFormat = uddfNotDef';

  except
    on E: Exception do
    begin
      Result := 'Slide check Except >> SlideID=' + ObjName + CheckInfo;
    end;
  end;
end; // function TN_UDCMSlide.CheckConsistency

//************************************************* TN_UDCMSlide.PascalInit ***
// Init self (should be always called after create)
//
procedure TN_UDCMSlide.PascalInit();
begin
  with P()^ do
  begin

  end; // with P()^ do
end; // procedure TN_UDCMSlide.PascalInit

//****************************************** TN_UDCMSlide.InitViewAutoScale ***
// Finush Slide Check Wait Image Processing State
//
//     Parameters
// Result - Returns TRUE if proccessing image wait state is On
//
procedure TN_UDCMSlide.InitViewAutoScale();
begin
  with GetMapRoot.PCCS()^.SRSize, Screen do
    CMSScaleFontFactor := Max(X / Width, Y / Height);
end; // procedure TN_UDCMSlide.InitViewAutoScale;

//************************************************ TN_UDCMSlide.PrepROIView ***
// Prepare Slide ROI Components View
//
//     Parameters
// APrepFlags - control ROI references clear or restore
// Result     - Returns TRUE if proccessing image wait state is On
//
procedure TN_UDCMSlide.PrepROIView(APrepFlags: TK_CMSSlideROIPrepFlags);
var
  MapRootMeasures: TN_UDBase;
  h, i: Integer;
  UDVObj: TN_UDBase;
  MapImage: TN_UDBase;
  SetResult: Boolean;
begin
  if cmsfIsMediaObj in P.CMSDB.SFlags then
    Exit; // precaution
  MapRootMeasures := GetMeasureRoot();
  h := MapRootMeasures.DirHigh;
  MapImage := nil;
  if not(K_roiClearRefs in APrepFlags) then
  begin
    MapImage := GetMapImage(K_roiRestoreIfImage in APrepFlags);
    if MapImage = nil then
      Exit;
  end;

  for i := 0 to h do
  begin
    UDVObj := MapRootMeasures.DirChild(i);
    with UDVObj do
    begin
      if ObjName[1] <> 'Z' then
        break;
      // !! Old      SetResult := K_SetUDRefField( TN_UDBase(TN_UDDIBRect(DirChild(0)).PISP^.CDRSrcUDDIB),
      SetResult := K_SetUDRefField( TN_UDBase(TN_UDDIBRect(DirChild(1)).PISP^.CDRSrcUDDIB), MapImage, TRUE );
      if not SetResult and not(K_roiDoneAll in APrepFlags) then
        break;
    end;
  end;
end; // procedure TN_UDCMSlide.PrepROIView;

//************************************* TN_UDCMSlide.SetAttrsByCurImgParams ***
// Return some Image Params
//
//     Parameters
// ASkipGreyInit - if =TRUE then skip Grey Image View Attributes - such as Isodnsity and Colorise
//
procedure TN_UDCMSlide.SetAttrsByCurImgParams(ASkipGreyInit : Boolean );
var
  UDDIB: TN_UDDIB;
begin
  UDDIB := GetCurrentImage(TRUE);
  if UDDIB = nil then
    Exit;
  K_CMSlideSetAttrsByDIB( P(), UDDIB.DIBObj, ASkipGreyInit );
end; // function TN_UDCMSlide.SetAttrsByCurImgParams

//***************************************** TN_UDCMSlide.GetImgFilesNamePat ***
// Get Image Files Name Pattern
//
//     Parameters
// Result - Returns Slide Image Files Name Pattern
//
function TN_UDCMSlide.GetImgFilesNamePat(const APath: string): string;
begin
  Result := APath + K_CMSlideGetImgFilesNamePat( ObjName );
end; // function TN_UDCMSlide.GetImgFilesNamePat

//****************************************** TN_UDCMSlide.GetCurImgFileName ***
// Get Current Image File Name
//
//     Parameters
// Result - Returns Slide Current Image File Name
//
function TN_UDCMSlide.GetCurImgFileName(const APath: string): string;
begin
  Result := APath + K_CMSlideGetCurImgFileName( ObjName );
end; // function TN_UDCMSlide.GetCurImgFileName

//****************************************** TN_UDCMSlide.GetSrcImgFileName ***
// Get Original Image File Name
//
//     Parameters
// Result - Returns Slide Original Image File Name
//
function TN_UDCMSlide.GetSrcImgFileName(const APath: string): string;
begin
  Result := APath + K_CMSlideGetSrcImgFileName( ObjName );
end; // function TN_UDCMSlide.GetSrcImgFileName

//******************************************* TN_UDCMSlide.GetMediaFileName ***
// Get Media File Name Prefix
//
//     Parameters
// Result - Returns Slide Original Image File Name
//
function TN_UDCMSlide.GetMediaFileNamePref(const APath: string): string;
begin
  Result := APath + K_CMSlideGetMediaFileNamePref( ObjName );
end; // function TN_UDCMSlide.GetMediaFileNamePref

//******************************************* TN_UDCMSlide.GetAttrsFileName ***
// Get Attrs File Name
//
//     Parameters
// Result - Returns Slide Current Image File Name
//
function TN_UDCMSlide.GetAttrsFileName(const APath: string): string;
begin
  Result := APath + K_CMSlideGetAttrsFileName( ObjName );
end; // function TN_UDCMSlide.GetAttrsFileName

//******************************************* TN_UDCMSlide.GetMediaFileName ***
// Get Media File Name
//
//     Parameters
// Result - Returns Slide Original Image File Name
//
function TN_UDCMSlide.GetMediaFileName(const APath: string): string;
begin
  with P()^ do
    Result := GetMediaFileNamePref(APath) + CMSDB.MediaFExt;
end; // function TN_UDCMSlide.GetSrcImgFileName

//************************************* TN_UDCMSlide.GetMediaFileClientName ***
// Get Media File Client Name
//
//     Parameters
// ANSlide - slide with media file
//
function TN_UDCMSlide.GetMediaFileClientName(): string;
//var
//  UDMedia: TN_UDCompBase;
begin
  Result := K_CMEDAccess.EDAGetMediaFileClientName( Self );
end; // end of TN_UDCMSlide.GetMediaFileClientName

//**************************************** TN_UDCMSlide.SetMediaFileTMPName ***
// Create TN_UDCMSlide Object for Media Object
//
//     Parameters
// AMediaFExt - Fedia Object File Extension
// AForceDir  - Force Path for TMP Media File
// Result  - Returns created TN_UDCMSlide object
//
procedure TN_UDCMSlide.SetMediaFileTMPName( const AMediaFExt: string );
begin
  K_CMEDAccess.EDASetSlideMediaFileTMPName( Self, AMediaFExt );
end; // function TN_UDCMSlide.SetMediaFileTMPName

//*********************************************** TN_UDCMSlide.AddMediaFile ***
// Add new Media Object File to Media Slide
//
//     Parameters
// ASrcMediaFName - source Media Object File Name
// Result - Returns N_GetVideoFileInfo result code (=0 - OK)
//
function TN_UDCMSlide.AddMediaFile(const ASrcMediaFName: string) : Integer;
var
  VFInfo: TN_VideoFileInfo;
  MediaFName: string;
begin
  // Get MediaFile Info
  FillChar(VFInfo, SizeOf(VFInfo), 0);
//  VFInfo.VFINumDIBs := 0;
  Result := N_GetVideoFileInfo( ASrcMediaFName, @VFInfo );
  with P()^ do
  begin
    CMSDB.PixBits := 24;
    if Result <> 0 then
    begin
      CMSDB.BytesSize := N_GetFileSize( ASrcMediaFName );
      N_Dump1Str( format( 'VideoFileInfo ErrCode=%d %s VFIIError=%d VFISError=%s',
                    [Result,ASrcMediaFName,VFInfo.VFIIError,VFInfo.VFISError] ) );
      Exit;
    end;

    CMSDB.PixWidth := VFInfo.VFIFrameWidth;
    CMSDB.PixHeight := VFInfo.VFIFrameHeight;
//    CMSDB.PixBits := 24;
    CMSDB.BytesSize := VFInfo.VFIFileSize;
    CMSDB.MDuration := VFInfo.VFIDuration;
    MediaFName := GetMediaFileClientName();
    if ASrcMediaFName <> MediaFName then
      K_CopyFile(ASrcMediaFName, MediaFName);
  end; // with Result.P()^ do
  CreateThumbnail();

end; // function TN_UDCMSlide.AddMediaFile

//***************************************** TN_UDCMSlide.GetImg3DFolderName ***
// Get 3D Image Folder Name
//
//     Parameters
// APath - 3D images base path
// Result - Returns Slide 3D Image Folder Name
//
function TN_UDCMSlide.GetImg3DFolderName(const APath: string): string;
begin
  Result := APath + K_CMSlideGetImg3DFolderName( Self.ObjName );
end; // function TN_UDCMSlide.GetImg3DFolderName

//********************************************* TN_UDCMSlide.GetDCMFileName ***
// Get DCM Attrs File Name
//
//     Parameters
// Result - Returns Slide Current Image File Name
//
function TN_UDCMSlide.GetDCMFileName(const APath: string): string;
begin
  Result := APath + K_CMSlideGetDCMAttrsFileName( ObjName );
end; // function TN_UDCMSlide.GetDCMFileName

//******************************************** TN_UDCMSlide.CreateThumbnail ***
// Create Self Thumbnail, and replace existing Thumbnail or
//
//     Parameters
// Result - Returns TN_UDDIB with Thumbnail
//
// (if absent) add it as Self zero Child and return it
//
function TN_UDCMSlide.CreateThumbnail(): TN_UDDIB;
var
  SkipSelf: Byte;
  PSkipSelf: PByte;
  ThumbDIBObj: TN_DIBObj;
  VFThumbPar: TN_VFThumbParams;
  Thumb3DFile : string;
  RIRCODE : TK_RIResult;
  FStream : TFileSTream;
  UDMapRoot : TN_UDCompVis;
begin
  with P()^ do
  if cmsfIsMediaObj in CMSDB.SFlags then
  begin // Video Thumbnail
    VFThumbPar.VFTPThumbSize := K_CMSlideThumbSize;
    VFThumbPar.VFTPMainBordWidth := 12;
    VFThumbPar.VFTPBlackBordWidth := 1;
    VFThumbPar.VFTPWhiteWholesWidth := 8;
    // ThumbDIBObj := N_GetVideoFileThumb( TN_UDFile(MapRoot).GetFullFileName, @VFThumbPar );
    ThumbDIBObj := N_GetVideoFileThumb(GetMediaFileClientName(), @VFThumbPar);
  end  // if cmsfIsMediaObj in CMSDB.SFlags then
  else
  if cmsfIsImg3DObj in CMSDB.SFlags then
  begin // Img3D Thumbnail
    ThumbDIBObj := nil;
    if CMSDB.MediaFExt <> '' then
    begin
      Thumb3DFile := CMSDB.MediaFExt + K_CMS3DImgResFolder + K_CMS3DImgResThumbFile;
      if FileExists( Thumb3DFile ) then
      begin
        FStream := TFileSTream.Create( Thumb3DFile, fmOpenRead, fmShareDenyNone );
        RIRCODE := K_RIObj.RIOpenStream( FStream );
        if (K_RIObj is TK_RIGDIP) and (RIRCODE <> rirOK) then
        begin
          if K_RIObj.RIGetLastNativeErrorCode() = Ord(Win32Error) then
          begin
            N_Dump2Str( 'CreateThumbnail GDI+ stream error, try from ' + ExtractFileName(Thumb3DFile) );
            RIRCODE := K_RIObj.RIOpenFile( Thumb3DFile );
          end;
        end;


        if RIRCODE <> rirOK then
          N_Dump1Str( format( 'RImage %s LoadError Res=%d from %s',
              [K_RIObj.ClassName, K_RIObj.RIGetLastNativeErrorCode(),Thumb3DFile] ) )
//          raise Exception.Create( format( 'RImage %s LoadError Res=%d from %s',
//              [K_RIObj.ClassName, K_RIObj.RIGetLastNativeErrorCode(),Thumb3DFile] ) );
        else
        begin
          RIRCODE := K_RIObj.RIGetDIB( 0, ThumbDIBObj );
          if RIRCODE <> rirOK then
            N_Dump1Str( format( 'RImage %s GetDIB %dx%d Error Res=%d from %s',
                                [K_RIObj.ClassName,
                                 K_RIObj.RILastImageSize.X,K_RIObj.RILastImageSize.Y,
                                 K_RIObj.RIGetLastNativeErrorCode(),Thumb3DFile] ) )
//            raise Exception.Create( format( 'RImage %s GetDIB %dx%d Error Res=%d from %s',
//                                [K_RIObj.ClassName,
//                                 K_RIObj.RILastImageSize.X,K_RIObj.RILastImageSize.Y,
//                                 K_RIObj.RIGetLastNativeErrorCode(),Thumb3DFile] ) );
        end;
        K_RIObj.RIClose();
        FStream.Free;
      end // if FileExists( Thumb3DFile ) then
    end // if CMSDB.MediaFExt <> '' then
    else
      N_Dump1Str( 'CreateThumbnail Img3D Empty Tmp Path' );

    if ThumbDIBObj = nil then
    begin
      ThumbDIBObj := K_CMBSlideCreateThumbnailDIBByAspect( 0.75 );
//    ThumbDIBObj.DIBOCanv.SetBrushAttribs( $EEEEEE ); // light grey background
      ThumbDIBObj.DIBOCanv.SetBrushAttribs( $0); // Black
      ThumbDIBObj.DIBOCanv.DrawPixFilledRect( ThumbDIBObj.DIBRect );
    end;
    // Draw 3D marker
    ThumbDIBObj.DIBOCanv.SetFontAttribs ( $1414FF );
    ThumbDIBObj.DIBOCanv.DrawPixString( Point( 20, 20 ), '3D' );
  end   // if cmsfIsImg3DObj in CMSDB.SFlags then
  else
  begin // Image Object
    UDMapRoot := GetMapRoot();
    PSkipSelf := GetPMeasureRootSkipSelf();
    SkipSelf := PSkipSelf^;
    PSkipSelf^ := 0;
    ThumbDIBObj := K_CMBSlideCreateThumbnailDIBByMapRoot( UDMapRoot );
    PSkipSelf^ := SkipSelf;
  end;  // Image Object

  Result := SetThumbnailByDIB(ThumbDIBObj);
  // Include( P().CMSRFlags, cmsfThumbChanged );
end; // procedure TN_UDCMSlide.CreateThumbnail

//************************************************* TN_UDCMSlide.GetMapRoot ***
// Get Slide MapRoot
//
//     Parameters
// ASkipLoadFlag - if =TRUE then slide MapRoot object shoud not be loaded
// Result - Returns Slide MapRoot
//
// Prepare all needed MapRoot objects including MapImage
//
function TN_UDCMSlide.CreateMapRoot( AWidth, AHeight : Integer ): TN_UDCompVis;
begin
  // ***** Create MapRoot Component
  Result := N_CreateMapRoot2(N_CMDIBURect, Point(AWidth, AHeight), catSize, 'MapRoot');

  with Result, PSP.CCompBase, PCCS()^ do
  begin
    // for printing only
    CBFlags1 := [cbfSelfSizeUnits];
    CurFreeFlags := [cffFullAspSize];
  end;

  Result.AddOneChildV(K_CreateUDByRTypeName('TK_CMSMRImgAttrs')).ObjName :=
    'ViewAttrs'; // Img View Attrs
  PutDirChildSafe(K_CMSlideIndMapRoot, Result);

end; // function TN_UDCMSlide.CreateMapRoot

//************************************************* TN_UDCMSlide.GetMapRoot ***
// Get Slide MapRoot
//
//     Parameters
// ASkipLoadFlag    - if =TRUE then slide MapRoot object shoud not be loaded
// ASkipMapImgBuild - if =TRUE then Slide MapImage shouldn/t be Built
// ASkipCurImgLoad  - if =TRUE then Slide CurImage shouldn/t be Loaded
// Result - Returns Slide MapRoot
//
// Prepare all needed MapRoot objects including MapImage
//
{
function TN_UDCMSlide.GetMapRoot( ASkipLoad: Boolean = false;
                                  ASkipMapImgBuild: Boolean = false;
                                  ASkipCurImgLoad: Boolean = false): TN_UDCompVis;
}
function TN_UDCMSlide.GetMapRoot(): TN_UDCompVis;
var
  MapImg: TN_UDBase;
  CurImg: TN_UDBase;
begin
  Result := inherited GetMapRoot();
//  CheckSlideInsideGetMapRoot();
//  Result := nil;
  if Self = nil then  Exit;

  // Load Map SubTree (without MapImage if needed)

//  if K_CMEDAccess.EDAGetSlideMapRoot(Self, ASkipLoad, ASkipCurImgLoad) <> K_edOK then
  if K_CMEDAccess.EDAGetSlideMapRoot( Self,
            K_gmrfSkipMapRootLoad in K_UDCMSlideGetMapRootFlags,
            K_gmrfSkipCurImgLoad in K_UDCMSlideGetMapRootFlags ) <> K_edOK then
  begin
    PutDirChild(K_CMSlideIndMapRoot, nil);
    Exit;
  end;

  Result := TN_UDCompVis(DirChild(K_CMSlideIndMapRoot));
//  if (Result = nil) or (TN_UDBase(Result) is TN_UDFile) or ASkipMapImgBuild then
  if (Result = nil)                   or
     (TN_UDBase(Result) is TN_UDFile) or
     (K_gmrfSkipMapImgBuild in K_UDCMSlideGetMapRootFlags) then
    Exit;

  // Return if MapImage Exists
  MapImg := Result.DirChild(K_CMSlideMRIndMapImg);
//  if ASkipLoad or ((MapImg <> nil) and (MapImg is TN_UDDIB)) then
  if (K_gmrfSkipMapRootLoad in K_UDCMSlideGetMapRootFlags) or
     ((MapImg <> nil) and (MapImg is TN_UDDIB)) then
    Exit;

  // Get Current Image
  CurImg := GetCurrentImage();

  if CurImg = nil then
    raise Exception.Create('Slide ID=' + ObjName + ' has no Current Image!');
  // Assert( CurImg <> nil, 'Slide ID=' + ObjName + ' has no Current Image!' );

  // Prepare Map Image
  MapImg := N_CreateUDDIB(N_CMDIBURect, [], '', 'MapImg');
  MapImg.ClassFlags := MapImg.ClassFlags + K_SkipSelfSaveBit;
  // !!! Get MapRoot to Result again because MapRoot object may be rebuild during GetCurrentImage();
  Result := TN_UDCompVis(DirChild(K_CMSlideIndMapRoot));

  Result.PutDirChildSafe(K_CMSlideMRIndMapImg, MapImg);
  PrepROIView([]);

  // Do All Needed Image View conversions
  if not CMSSkipMemFree4MapImage then
    K_CMSCheckMemConstraints(Self);

  RebuildMapImageByDIB(TN_UDDIB(CurImg).DIBObj);
  CMSSkipMemFree4MapImage := FALSE;
end; // function TN_UDCMSlide.GetMapRoot

//******************************************* TN_UDCMSlide.GetPMapRootAttrs ***
// Get Pointer to Slide View conversion Attributes
//
//     Parameters
// Result - Returns Pointers to View conversion Attributes
//
function TN_UDCMSlide.GetPMapRootAttrs(): TK_PCMSMRImgAttrs;
var
  UDVAttrs: TK_UDRArray;
begin
  Result := nil;
  if Self = nil then
    Exit;
  if ObjLiveMark <> N_ObjLiveMark then
    raise TK_UDBaseConsistency.Create(
      'TN_UDCMSlide.GetPMapRootAttrs Consistency Error');
  if K_CMEDAccess.EDAGetSlideMapRoot(Self, FALSE, TRUE) <> K_edOK then
    Exit;
  UDVAttrs := TK_UDRArray(DirChild(K_CMSlideIndMapRoot));
  if (UDVAttrs = nil) or (TN_UDBase(UDVAttrs) is TN_UDFile) then
    Exit;
  UDVAttrs := TK_UDRArray(UDVAttrs.DirChild(K_CMSlideMRIndAttrs));
  Assert(UDVAttrs <> nil, 'View conversion attributes are absent');
  Result := UDVAttrs.R.P;
end; // function TN_UDCMSlide.GetPMapRootAttrs

//******************************************** TN_UDCMSlide.GetCurrentImage ***
// Get Current Image DIB Object
//
//     Parameters
// ASkipLoad - if =TRUE then slide current image shoud not be loaded from External Storage
// ASkipLoadDIB - if =TRUE then slide current image DIBObj shoud not be loaded from UDData
// Result - Returns Self Current Image DIB Object or nil if Current Image  is not loaded
//
function TN_UDCMSlide.GetCurrentImage( ASkipLoad: Boolean = FALSE;
                                       ASkipLoadDIB : Boolean = FALSE ): TN_UDDIB;
begin
//Self.ObjFlags := Self.ObjFlags or K_fpObjTVChecked;
//Self.ObjFlags := Self.ObjFlags and not K_fpObjTVDisabled;
//Self.ObjFlags := Self.ObjFlags or K_fpObjTVDisabled;
//Self.ObjInfo := '111 222 333' + #13#10 + '111 222 333' + #13#10 + '111 222 333';

  Result := nil;
  if Self = nil then
    Exit;

  if ObjLiveMark <> N_ObjLiveMark then
    raise TK_UDBaseConsistency.Create(
      'TN_UDCMSlide.GetCurrentImage Consistency Error');

  if (K_CMEDAccess.EDAGetSlideCurImage(Self, ASkipLoad) <> K_edOK) then
    Exit;

  Result := TN_UDDIB(DirChild(K_CMSlideIndCurImg));
  if (Result <> nil) and ((Result.ObjFlags and K_fpObjSLSRFlag) <> 0) then
    Result := TN_UDDIB(Result.DirChild(0)); // Get UDDIB from Section

  // this check is done to prevent Dump String 'LoadDIBObj fin'
  if ASkipLoadDIB           or
     (Result = nil)         or
     (Result.DIBObj <> nil) or
     (Length(Result.UDData) = 0) then Exit; // Self is not Assigned or DIB is already loaded

  N_Dump2Str( 'Cur LoadDIBObj Start ID=' + ObjName );
  try
    Result.LoadDIBObj();
  except
     on E: Exception do begin
       raise TK_LoadUDDataError.Create( format( 'Slide ID=%s Cur LoadDIBObj Error >> %s', [ObjName, E.Message] ) );
     end;
  end;
  N_Dump2Str( 'Cur LoadDIBObj Fin ID=' + ObjName );
end; // function TN_UDCMSlide.GetCurrentImage

//*************************************** TN_UDCMSlide.GetCurrentImageSData ***
// Get Current Image Serialized Data
//
//     Parameters
// ABuf        - Current Image buffer (TN_BArray)
// ACurImgSize - number of Data bytes in ABuf
//
procedure TN_UDCMSlide.GetCurrentImageSData(out AMemPtr: Pointer; out AImgSize: Integer);
var
  CurImg: TN_UDDIB;
//  DSize : Integer;
begin
  AImgSize := 0;
  CurImg := GetCurrentImage( FALSE, TRUE );
  if CurImg = nil then
    Exit;
{ // This code is moved to SetCurrentImageBySData
  with CurImg.PISP^ do
    if CDIBDataFormat = uddfNotDef then
      CDIBDataFormat := K_CMEDAccess.SlidesDIBFormat;
}

  K_CMGetUDDIBSData( CurImg, AMemPtr, AImgSize );
{
  if CurImg.UDData <> nil then
    DSize := Length(CurImg.UDData)
  else
    DSize := CurImg.DIBObj.SerializedSize();
  N_SerialBuf.SetCapacity( DSize + 1000 );
  K_SaveTreeToMem( CurImg, N_SerialBuf );
  AImgSize := N_SerialBuf.OfsFree;
  AMemPtr := @N_SerialBuf.Buf1[0];
}
end; // procedure TN_UDCMSlide.GetCurrentImageSData

//************************************* TN_UDCMSlide.SetCurrentImageBySData ***
// Set Current Image by Serialized Data
//
//     Parameters
// ABuf        - Current Image buffer (TN_BArray)
// ACurImgSize - number of Data bytes in ABuf
//
function TN_UDCMSlide.SetCurrentImageBySData(AMemPtr: Pointer;
  AImgSize: Integer; AFreeBufProc: TK_FreeBuffer = nil) : Boolean;
var
  CurImg: TN_UDDIB;
begin
  CurImg := K_CMCreateUDDIBBySData( AMemPtr, AImgSize, AFreeBufProc );
{
  N_SerialBuf.LoadFromMem(AMemPtr^, AImgSize);
  if Assigned(AFreeBufProc) then
    AFreeBufProc(AMemPtr);
  // N_SerialBuf.SBGetWideString
  CurImg := TN_UDDIB(K_LoadTreeFromMem(N_SerialBuf));
}
  Result := CurImg <> nil;

  if not Result then Exit;

  with CurImg.PISP^ do
    if CDIBDataFormat = uddfNotDef then
    begin
      CDIBDataFormat := K_CMEDAccess.SlidesDIBFormat;  // Precaution for old Images
      CDIBFlagsN := [uddfnUseUDData,uddfnFreeUDData];
    end;
  PutDirChildSafe( K_CMSlideIndCurImg, CurImg );
  RebuildVnodes();
end; // procedure TN_UDCMSlide.SetCurrentImageBySData

//**************************************** TN_UDCMSlide.GetImgViewConvAttrs ***
// Get Slide View conversion Attributes
//
//     Parameters
// APImgViewConvData - Pointer to View conversion Attributes Record
// AImgVCSet  - set of View conversion Attributes to get
//
procedure TN_UDCMSlide.GetImgViewConvData(APImgViewConvData: TK_PCMSImgViewConvData;
  AImgVCSet: TK_CMSImgViewConvSet = [vcifFlipRotate, vcifBriCoGam,
                                     vcifColorize, vcifIsodensity, vcifEmboss]);
begin
  with APImgViewConvData^, GetPMapRootAttrs()^, P().CMSDB do
  begin
    // Slide Flip/Rotate Attrs
    if vcifFlipRotate in AImgVCSet then
      VCFlipRotateAttrs := MRFlipRotateAttrs;

    // Image BriCoGam Attributes
    if vcifBriCoGam in AImgVCSet then
    begin
      VCNegateFlag := K_smriNegateImg in MRImgFlags;
      VCCoFactor   := MRCoFactor; // Image Contrast Correction Factor
      VCGamFactor  := MRGamFactor; // Image Gamma Correction Factor
      VCBriFactor  := MRBriFactor; // Image Brightness Correction Factor
      VCBriMinFactor := MRBriMinFactor; // Image Brightness Convertion Minimal Value
      VCBriMaxFactor := MRBriMaxFactor; // Image Brightness Convertion Maximal Value
    end;

    if vcifEmboss in AImgVCSet then
    begin
      VCShowEmboss  := cmsfShowEmboss in SFlags; // Show Image Emboss
      VCEmbDepth    := ViewAttrs.EmbDepth; // Image Emboss Depth 1 - 20
      VCEmbDirAngle := ViewAttrs.EmbDirAngle; // Image Emboss Direction Angle in degrees
      VCEmbRFactor  := ViewAttrs.EmbRFactor; // Image Emboss Correction Factor
      VCEmbBase     := ViewAttrs.EmbBase; // Image Emboss Base Gray Intensity
    end;

    // Slide Image Colorize Attributes
    if vcifColorize in AImgVCSet then
    begin
      VCShowColorize := cmsfShowColorize in SFlags; // Show Image Pseudocolors
      VCColPalInd := ViewAttrs.ColPalInd; // Pseudocolors Palette Index
    end;

    // Slide Image Isodensity Attributes
    if vcifIsodensity in AImgVCSet then
    begin
      VCShowIsodensity  := cmsfShowIsodensity in SFlags; // Show Image Isodensity
      VCIsoBaseColInt   := ViewAttrs.IsoBaseColInt; // Image Base Color Intensity
      VCIsoRangeFactor  := ViewAttrs.IsoRangeFactor; // Image Colors Intensity Range Factor (0-100)
      VCIsoColor        := ViewAttrs.IsoColor; // Isodensity Draw Color
      VCIsoTranspFactor := ViewAttrs.IsoTranspFactor; // Isodensity Draw Transparency Factor (0-100)
    end;
  end;
end; // function TN_UDCMSlide.GetImgViewConvData

//*************************************** TN_UDCMSlide.RebuildMapImageByDIB ***
// Convert given DIBObj by given View Attributes
//
//     Parameters
// ASDIBObj - given source Device Independent Bitmap Object
// APImgViewConvData - pointer to all view conversion attributes
// APEmbDIB1 - pointer to first emboss buffer DIB
//
procedure TN_UDCMSlide.RebuildMapImageByDIB( ASDIBObj: TN_DIBObj = nil;
  APImgViewConvData: TK_PCMSImgViewConvData = nil; APEmbDIB1: TN_PDIBObj = nil );
var
  ImgViewConvData: TK_CMSImgViewConvData;
  CurUDImg : TN_UDDIB;
begin

  if APImgViewConvData = nil then
  begin
    APImgViewConvData := @ImgViewConvData;
    GetImgViewConvData(APImgViewConvData);
  end;

  if ASDIBObj = nil then begin
    CurUDImg := GetCurrentImage();
    ASDIBObj := CurUDImg.DIBObj;
    if ASDIBObj = nil then
      raise Exception.Create( 'Slide CurImg DIBObj is absent ID=' + ObjName );
  end;
  K_CMConvDIBBySlideViewConvData( GetMapImage.DIBObj, ASDIBObj,
                      APImgViewConvData, pf24bit, epfBMP,
                      APEmbDIB1, @CMSIsoMin, @CMSXLatBCGHist, @CMSXLatBCGColor );
end; // procedure TN_UDCMSlide.RebuildMapImageByDIB

//************************************************ TN_UDCMSlide.GetMapImage ***
// Get Slide Image
//
//     Parameters
// ASkipLoadFlag - if =TRUE then slide content shoud not be loaded
// Result - Returns Slide Image
//
function TN_UDCMSlide.GetMapImage(ASkipLoadFlag: Boolean = false): TN_UDDIB;
begin
//  Result := TN_UDDIB(GetMapRoot(ASkipLoadFlag));
  if ASkipLoadFlag then
    K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapRootLoad];
  Result := TN_UDDIB(GetMapRoot());
  K_UDCMSlideGetMapRootFlags := [];

  if (Result <> nil) and (TN_UDBase(Result) is TN_UDFile) then
    Result := nil // precation
  else
  begin
    Result := TN_UDDIB(Result.DirChild(K_CMSlideMRIndMapImg));
    if (Result <> nil) and not(TN_UDBase(Result) is TN_UDDIB) then
      Result := nil; // precation
  end;
end; // function TN_UDCMSlide.GetMapImage

//********************************************** TN_UDCMSlide.ClearMapImage ***
// Clear MapRoot Image
//
// Load MapRoot Component if it
//
procedure TN_UDCMSlide.ClearMapImage();
var
  MapRoot: TN_UDBase;
  MapImage : TN_UDBase;
  FlashLightUDDIBRect : TN_UDBase;
  ClearFlashLightRefFlag : Boolean;
begin
//!!! not use any K_UDCMSlideGetMapRootFlags here
  K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapImgBuild,K_gmrfSkipCurImgLoad];
  MapRoot := TN_UDBase(GetMapRoot());
  K_UDCMSlideGetMapRootFlags := [];
  if MapRoot = nil then Exit;

  PrepROIView([K_roiClearRefs]);
  MapImage := MapRoot.DirChild(K_CMSlideMRIndMapImg);
  ClearFlashLightRefFlag := (MapImage = nil) or (MapImage.RefCounter > 1);
  MapRoot.PutDirChildSafe(K_CMSlideMRIndMapImg, nil);

//  if (MapImage = nil) or                          // MapImage is absent
//   (MapImage.ObjLiveMark <> N_ObjLiveMark) then // Map Image was deleted
  if not ClearFlashLightRefFlag then // Map Image was deleted
    Exit;

  if CMSRFrame = nil then
  begin
    N_Dump1Str( '!!! FlashLight absent >> Slide is closed ID=' + ObjName );
    Exit;
  end;

  // Clear Link Flashlight to Slide MapImage and Clear Flashlight CMEFLComp
  with TN_CMREdit3Frame(CMSRFrame.Parent).EdFlashLightModeRFA do
  begin
    if CMEFLComp <> nil then
    begin
      FlashLightUDDIBRect := CMEFLComp;
      CMEFLComp := nil;
      N_Dump2Str( '!!! FlashLight action comp ID=' + ObjName );
    end
    else
    begin
      FlashLightUDDIBRect := MapRoot.DirChild(MapRoot.DirHigh());
      if FlashLightUDDIBRect.ObjName <> 'ZEllipse' then Exit;
      N_Dump1Str( '!!! FlashLight absent >> FlashLight Comp is not found ID=' + ObjName );
    end;

    with TN_UDDIBRect(FlashLightUDDIBRect.DirChild(1)).PISP^ do
      K_SetUDRefField( TN_UDBase(CDRSrcUDDIB), nil, TRUE );
  end;
end; // function TN_UDCMSlide.ClearMapImage

//****************************************** TN_UDCMSlide.SwitchMapRootSize ***
// Switch MapRoot Size
//
procedure TN_UDCMSlide.SwitchMapRootSize();
var
  MapRoot: TN_UDCompVis;
  PCompCoords : TN_PCompCoords;
  FSize : Float;
//  MapImage : TN_UDBase;
//  FlashLightUDDIBRect : TN_UDBase;
//  ClearFlashLightRefFlag : Boolean;
begin
  K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapImgBuild,K_gmrfSkipCurImgLoad];
  MapRoot := TN_UDCompVis(GetMapRoot());
  K_UDCMSlideGetMapRootFlags := [];

  PCompCoords := MapRoot.PCCS();
  with PCompCoords^, P^ do
  begin
    FSize := SRSize.X;
    SRSize.X := SRSize.Y;
    SRSize.Y := FSize;
    CMSDB.PixWidth  := Round(SRSize.X);
    CMSDB.PixHeight := Round(SRSize.Y);
  end;
{
  PrepROIView([K_roiClearRefs]);
  MapImage := MapRoot.DirChild(K_CMSlideMRIndMapImg);
  ClearFlashLightRefFlag := (MapImage = nil) or (MapImage.RefCounter > 1);
  MapRoot.PutDirChildSafe(K_CMSlideMRIndMapImg, nil);

//  if (MapImage = nil) or                          // MapImage is absent
//   (MapImage.ObjLiveMark <> N_ObjLiveMark) then // Map Image was deleted
  if not ClearFlashLightRefFlag then // Map Image was deleted
    Exit;

  if CMSRFrame = nil then
  begin
    N_Dump1Str( '!!! FlashLight absent >> Slide is closed ID=' + ObjName );
    Exit;
  end;

  // Clear Link Flashlight to Slide MapImage and Clear Flashlight CMEFLComp
  with TN_CMREdit3Frame(CMSRFrame.Parent).EdFlashLightModeRFA do
  begin
    if CMEFLComp <> nil then
    begin
      FlashLightUDDIBRect := CMEFLComp;
      CMEFLComp := nil;
      N_Dump2Str( '!!! FlashLight action comp ID=' + ObjName );
    end
    else
    begin
      FlashLightUDDIBRect := MapRoot.DirChild(MapRoot.DirHigh());
      if FlashLightUDDIBRect.ObjName <> 'ZEllipse' then Exit;
      N_Dump1Str( '!!! FlashLight absent >> FlashLight Comp is not found ID=' + ObjName );
    end;

    with TN_UDDIBRect(FlashLightUDDIBRect.DirChild(1)).PISP^ do
      K_SetUDRefField( TN_UDBase(CDRSrcUDDIB), nil, TRUE );
  end;
}
end; // function TN_UDCMSlide.SwitchMapRootSize

//********************************************* TN_UDCMSlide.GetSourceImage ***
// Get Original Image DIB Object
//
//     Parameters
// ASkipLoad - if =TRUE then slide Original image shoud not be loaded from External Storage
// ASkipLoadDIB - if =TRUE then slide Original image DIBObj shoud not be loaded from UDData
// Result - Returns Self Original Image DIB Object or nil if Original Image  is absent
//
function TN_UDCMSlide.GetSourceImage( ASkipLoad: Boolean = FALSE;
                                      ASkipLoadDIB : Boolean = FALSE ): TN_UDDIB;
begin
  Result := nil;
  if Self = nil then
    Exit;
  if ObjLiveMark <> N_ObjLiveMark then
    raise TK_UDBaseConsistency.Create(
      'TN_UDCMSlide.GetSourceImage Consistency Error');
  if (K_CMEDAccess.EDAGetSlideSrcImage(Self, ASkipLoad) <> K_edOK) then
    Exit;
  Result := TN_UDDIB(DirChild(K_CMSlideIndSrcImg));
  if (Result <> nil) and ((Result.ObjFlags and K_fpObjSLSRFlag) <> 0) then
    Result := TN_UDDIB(Result.DirChild(0)); // Get UDDIB from Section

  if ASkipLoadDIB then Exit;
  N_Dump2Str( 'Src LoadDIBObj Start ID=' + ObjName );
  try
    Result.LoadDIBObj();
  except
     on E: Exception do begin
       raise TK_LoadUDDataError.Create( format( 'Slide ID=%s Cur LoadDIBObj Error >> %s', [ObjName, E.Message] ) );
     end;
  end;
  N_Dump2Str( 'Src LoadDIBObj Fin ID=' + ObjName );
end; // function TN_UDCMSlide.GetSourceImage

//**************************************** TN_UDCMSlide.GetSourceImageSData ***
// Get Original  Image Serialized Data
//
//     Parameters
// ABuf        - Current Image buffer (TN_BArray)
// ACurImgSize - number of Data bytes in ABuf
//
procedure TN_UDCMSlide.GetSourceImageSData(out AMemPtr: Pointer; out AImgSize: Integer);
var
  OriginalImg: TN_UDDIB;
//  DSize : Integer;
begin
  AImgSize := 0;
  OriginalImg := GetSourceImage( FALSE, TRUE );
  if OriginalImg = nil then
    Exit;
{ // This code is moved to SetSourceImageBySData
  with OriginImg.PISP^ do
    if CDIBDataFormat = uddfNotDef then
      CDIBDataFormat := K_CMEDAccess.SlidesDIBFormat;
}
  K_CMGetUDDIBSData( OriginalImg, AMemPtr, AImgSize );
{
  if OriginalImg.UDData <> nil then
    DSize := Length(OriginalImg.UDData)
  else
    DSize := OriginalImg.DIBObj.SerializedSize();
  N_SerialBuf.SetCapacity( DSize + 1000 );

  K_SaveTreeToMem(OriginalImg, N_SerialBuf);
  AImgSize := N_SerialBuf.OfsFree;
  AMemPtr := @N_SerialBuf.Buf1[0]
}
end; // procedure TN_UDCMSlide.GetSourceImageSData

//************************************** TN_UDCMSlide.SetSourceImageBySData ***
// Set Original Image by Serialized Data
//
//     Parameters
// ABuf        - Current Image buffer (TN_BArray)
// ACurImgSize - number of Data bytes in ABuf
//
function TN_UDCMSlide.SetSourceImageBySData( AMemPtr: Pointer;
  AImgSize: Integer; AFreeBufProc: TK_FreeBuffer = nil ) : Boolean;
var
  SrcImg: TN_UDDIB;
begin
  SrcImg := K_CMCreateUDDIBBySData( AMemPtr, AImgSize, AFreeBufProc );
{
  N_SerialBuf.LoadFromMem(AMemPtr^, AImgSize);
  if Assigned(AFreeBufProc) then
    AFreeBufProc(AMemPtr);
  // N_SerialBuf.SBGetWideString
  SrcImg := TN_UDDIB(K_LoadTreeFromMem(N_SerialBuf));
}
  Result := SrcImg <> nil;
  if not Result then Exit;
  with SrcImg.PISP^ do
    if CDIBDataFormat = uddfNotDef then // precaution
    begin
      CDIBDataFormat := K_CMEDAccess.SlidesDIBFormat; // Precaution for old Images
      CDIBFlagsN := [uddfnUseUDData,uddfnFreeUDData];
    end;
  PutDirChildSafe(K_CMSlideIndSrcImg, SrcImg );
//  PutDirChildSafe(K_CMSlideIndCurImg, SrcImg );
  RebuildVnodes();
end; // procedure TN_UDCMSlide.SetSourceImageBySData

//*********************************** TN_UDCMSlide.SetSourceImageByDIBSData ***
// Create Original Image, based upon given AMemPtrBMP, and replace existing Thumbnail or
// (if absent) add it as Self zero Child and return it
//
function TN_UDCMSlide.SetSourceImageByDIBSData(AMemPtr: Pointer): TN_UDDIB;
var
  UDCurImg: TN_UDDIB;
  PCDIBN: TN_PCDIBN;
begin
  Result := nil;
  if AMemPtr = nil then
    Exit; // Thumbnail is not given

  Result := GetSourceImage(TRUE);
  if Result = nil then
  begin
    Result := N_CreateUDDIB(N_CMDIBURect, [], '', 'SrcImg');
    Result.DIBObj := TN_DIBObj.Create();
    PutDirChildSafe(K_CMSlideIndSrcImg, Result);
    UDCurImg := GetCurrentImage(FALSE,TRUE);
    Result.UDData := Copy(UDCurImg.UDData);
    PCDIBN := UDCurImg.PISP();
    with Result.PISP^ do
    begin
      CDIBFlagsN := PCDIBN.CDIBFlagsN;
      CDIBDataFormat := PCDIBN.CDIBDataFormat;
      CDIBJPEGQuality := PCDIBN.CDIBJPEGQuality;
    end;
  end;

  Result.DIBObj.DeSerializeSelf(AMemPtr);
  with P()^ do
    Include(CMSDB.SFlags, cmsfHasSrcImg);

end; // function TN_UDCMSlide.SetSourceImageByDIBSData

//********************************************* TN_UDCMSlide.GetMeasureRoot ***
// Get Slide Annot/Measure Root
//
//     Parameters
// Result - Returns Slide Annot/Measure Root
//
function TN_UDCMSlide.GetMeasureRoot(): TN_UDCompVis;
var
  MapRoot: TN_UDBase;
begin
  // Get MapRoot Measures Root

//  MapRoot := GetMapRoot(FALSE,TRUE,TRUE);
  K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapImgBuild,K_gmrfSkipCurImgLoad];
  MapRoot := GetMapRoot();
  K_UDCMSlideGetMapRootFlags := [];
  Result := TN_UDCompVis(MapRoot.DirChild(K_CMSlideMRIndMeasures));
  if Result = nil then
  begin // Add Measures Root
    Result := TN_UDCompVis(K_CMEDAccess.ArchMLibMRMPat.Clone);
    MapRoot.PutDirChildSafe(K_CMSlideMRIndMeasures, Result);
    Result.RebuildVnodes();
  end;
end; // function TN_UDCMSlide.GetMeasureRoot

//************************************ TN_UDCMSlide.GetPMeasureRootSkipSelf ***
// Get Ponter to Measure Root SkipSelf Field
//
//     Parameters
// Result - Returns pointer to Slide Annot/Measure Root SkipSelf Field
//
function TN_UDCMSlide.GetPMeasureRootSkipSelf(): PByte;
var
  MapRoot: TN_UDBase;
begin
  Result := nil;
  MapRoot := DirChild(K_CMSlideIndMapRoot);
  if (MapRoot <> nil) and not(TN_UDBase(MapRoot) is TN_UDFile) then
  begin
    Result := @GetMeasureRoot.PSP.CCompBase.CBSkipSelf;
  end;
end; // function TN_UDCMSlide.GetPMeasureRootSkipSelf

//****************************************** TN_UDCMSlide.AddNewMeasurement ***
// Add Slide Measurement Object
//
//     Parameters
// APatName - name of Object Pattern SubTree to Add
// Result - Returns new Measurement Object Subtree Root
//
function TN_UDCMSlide.AddNewMeasurement(const APatName: string;
  AInsBeforeAll: Boolean = false): TN_UDCompVis;
var
  MapRootMeasures: TN_UDBase;
  PatMeasureObj: TN_UDBase;
begin
  // Get Measure Pattern Objects
  PatMeasureObj := K_CMEDAccess.ArchMLibRoot.DirChildByObjName(APatName);
  Assert(PatMeasureObj <> nil,
    'Measurement Pattern Object ' + APatName + ' is absent');

  // Get Slide Measures Root
  MapRootMeasures := GetMeasureRoot();

  // Create Measure SubTree Clone and Add it to MapRootMeasures
  Result := TN_UDCompVis( K_CMSAddCloneChild(MapRootMeasures, PatMeasureObj,
                                             AInsBeforeAll) );
  // Result
end; // function TN_UDCMSlide.AddNewMeasurement

//*********************************************** TN_UDCMSlide.DistMM2Units ***
// Convert given distance in mm to distance in current units
//
//     Parameters
// AMMDistance  - distance in mm
// AUnitsIndex  - index of Units Enum to Texts Rebuild, if =-1 then
// Slide Self Units are used
// Result - Returns given distance in current units
//
function TN_UDCMSlide.DistMM2Units(AMMDistance: Double;
  AUnitsIndex: Integer = -1): Double;
begin
  Result := AMMDistance;
  with P().CMSDB do
  begin
    if AUnitsIndex = -1 then
      AUnitsIndex := Ord(DUnits);
    if AUnitsIndex = Ord(cmsduInch) then
      Result := Result / 25.4;
  end;
end; // function TN_UDCMSlide.DistMM2Units

//******************************************* TN_UDCMSlide.DistMM2UnitsText ***
// Convert given distance in mm to Text with Units
//
//     Parameters
// AMMDistance  - distance in mm
// AUnitsIndex  - index of Units Enum to Texts Rebuild, if =-1 then
// Slide Self Units are used
// Result - Returns given distance text with units
//
function TN_UDCMSlide.DistMM2UnitsText(AMMDistance: Double;
  AUnitsIndex: Integer = -1): string;
begin
  with P().CMSDB do
  begin
    if AUnitsIndex = -1 then
      AUnitsIndex := Ord(DUnits);
    // if AUnitsIndex > High(K_CMSDistUnitsFormat) then
    // AUnitsIndex := 0;
    Result := format( K_CML1Form.LLLDistUnitsFormat.Items[AUnitsIndex],
//      K_CMSDistUnitsFormat[AUnitsIndex],
      [K_CMSDistRoundFactor[Ord(DUnits)], DistMM2Units(AMMDistance,
        AUnitsIndex)]);
  end;
end; // function TN_UDCMSlide.DistMM2UnitsText

//********************************************* TN_UDCMSlide.CalcMMDistance ***
// Calculate distance between two given Measurement Points in mm
//
//     Parameters
// AFP1   - First Float Point
// AFP2   - Second Float Point
// Result - Returns distance between two given Measurement Points.
//
function TN_UDCMSlide.CalcMMDistance(const AFP1, AFP2: TFPoint): Double;
var
  FP1, FP2: TFPoint;
  K: Double;
begin
//  with P()^.CMSDB, GetMapRoot(TRUE).PSP.CCoords, CompUCoords do
  K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapRootLoad];
  with P()^.CMSDB, GetMapRoot().PSP.CCoords, CompUCoords do
  begin
    K_UDCMSlideGetMapRootFlags := [];

    // K := PixWidth / PixPermm / (Right - Left);
    K := SRSize.X / PixPermm / (Right - Left);
    FP1.X := (AFP1.X - Left) * K;
    FP2.X := (AFP2.X - Left) * K;

    // K := PixHeight / PixPermm / (Bottom - Top);
    K := SRSize.Y / PixPermm / (Bottom - Top);
    FP1.Y := (AFP1.Y - Top) * K;
    FP2.Y := (AFP2.Y - Top) * K;
  end;
  Result := N_P2PDistance(FP1, FP2);
end; // end of TN_UDCMSlide.CalcMMDistance

//******************************************* TN_UDCMSlide.CalcMMLineLength ***
// Calculate given PoyLine length in mm
//
//     Parameters
// AUDLine - given PoyLine Object
// Result  - Returns given PoyLine length.
//
function TN_UDCMSlide.CalcMMLineLength(AUDLine: TN_UDPolyline): Double;
var
  USize, KX, KY: Double;
  MMSize: Double;
  FP1, FP2: TFPoint;
  i: Integer;
begin
  Result := 0;
//  with P()^.CMSDB, GetMapRoot(TRUE).PSP.CCoords.CompUCoords,
//    AUDLine.PSP.CPolyline.CPCoords do
  K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapRootLoad];
  with P()^.CMSDB, GetMapRoot().PSP.CCoords.CompUCoords,
    AUDLine.PSP.CPolyline.CPCoords do
  begin
    K_UDCMSlideGetMapRootFlags := [];
    USize := Right - Left;
    MMSize := PixWidth / PixPermm;
    KX := MMSize / USize;

    USize := Bottom - Top;
    MMSize := PixHeight / PixPermm;
    KY := MMSize / USize;

    for i := 0 to AHigh - 1 do
    begin

      FP1 := PFPoint(P(i))^;
      FP2 := PFPoint(P(i + 1))^;
      FP1.X := (FP1.X - Left) * KX;
      FP2.X := (FP2.X - Left) * KX;

      FP1.Y := (FP1.Y - Top) * KY;
      FP2.Y := (FP2.Y - Top) * KY;
      Result := Result + N_P2PDistance(FP1, FP2);

    end;
  end;
end; // end of TN_UDCMSlide.CalcMMLineLength

//****************************************** TN_UDCMSlide.RebuildMLineTexts ***
// Rebuild given PolyLine Text Components
//
//     Parameters
// AUDMLineRoot - measure PolyLine Root Component to rebuild
// AUnitsIndex  - index of Units Enum to Texts Rebuild, if =-1 then
// Slide Self Units are used
// ARoundVector - index of Units Enum to Texts Rebuild, if =-1 then
// Slide Self Units are Used
// Result  - Returns Measure Line Length in given Units
//
// If AUnitsIndex <> -1, then PolyLine Text Components shouldn't be rebuild - only
// Measure Line Length is calculated
//
function TN_UDCMSlide.RebuildMLineTexts(AUDMLineRoot: TN_UDBase;
  AUnitsIndex: Integer = -1; APRSum: PDouble = nil): Double;
var
  j, NPoints, K: Integer;
  UDLine: TN_UDPolyline;
  PrevFPoint, CurFPoint: TFPoint;
  DL, RDL: TN_DArray;
  CFactor: Double;
  RFactor: Integer;
  FormStr: string;
  SkipTextsRebuild: Boolean;
  Sum, RVal, CSum: Double;
begin
  with P()^.CMSDB do
  begin
    SkipTextsRebuild := AUnitsIndex >= 0;
    if not SkipTextsRebuild then
      AUnitsIndex := Ord(DUnits);
    RFactor := K_CMSDistRoundFactor[AUnitsIndex];
    FormStr := K_CML1Form.LLLDistUnitsFormat.Items[AUnitsIndex];
//     K_CMSDistUnitsFormat[AUnitsIndex];
    CFactor := IntPower(10, RFactor);
  end;

  // !! Old Annot  UDLine := TN_UDPolyline(AUDMLineRoot.DirChild(0));
  UDLine := TN_UDPolyline(AUDMLineRoot.DirChild(1));
  with UDLine.PSP.CPolyline.CPCoords do
  begin
    NPoints := ALength();
    K := NPoints - 1;
    SetLength(DL, K);
    SetLength(RDL, K);

    PrevFPoint := PFPoint(P())^;
    CSum := 0;
    for j := 1 to K do
    begin
      CurFPoint := PFPoint(P(j))^;
      RVal := DistMM2Units(CalcMMDistance(PrevFPoint, CurFPoint), AUnitsIndex)
        * CFactor;
      CSum := CSum + RVal;
      DL[j - 1] := RVal;
      RDL[j - 1] := RVal;
      PrevFPoint := CurFPoint;
    end;

    if APRSum <> nil then
    begin
      Sum := APRSum^ * CFactor;
      APRSum := @Sum;
    end;

    if CSum >= 1 then
      CSum := Round(K_RoundDVectorBySum(@RDL[0], K, @DL[0], APRSum));
    Result := CSum / CFactor;

    // Result := Round( K_RoundDVectorBySum(  @RDL[0], k, @DL[0], APRSum ) ) / CFactor;

    if SkipTextsRebuild then
      Exit;

    for j := 1 to K do
    begin
      RVal := RDL[j - 1] / CFactor;
      // !! Old      with TN_POneTextBlock((TN_UDParaBox(AUDMLineRoot.DirChild(j)).PSP.CParaBox.CPBTextBlocks.P()))^ do
      with TN_POneTextBlock((TN_UDParaBox(AUDMLineRoot.DirChild(j + 1))
            .PSP.CParaBox.CPBTextBlocks.P()))^ do
        // Build Segment Lehth Text
        OTBMText := format(FormStr, [RFactor, RVal]);
    end;
  end;
  if NPoints > 2 then
    // !! Old    with TN_POneTextBlock((TN_UDParaBox(AUDMLineRoot.DirChild(NPoints)).PSP.CParaBox.CPBTextBlocks.P()))^ do
    with TN_POneTextBlock((TN_UDParaBox(AUDMLineRoot.DirChild(NPoints + 1))
          .PSP.CParaBox.CPBTextBlocks.P()))^ do
      OTBMText := '= ' + format(FormStr, [RFactor, Result]);

end; // end of TN_UDCMSlide.RebuildMLineTexts

//*************************************** TN_UDCMSlide.RebuildAllMLineTexts ***
// Rebuild Slide Measure PolyLines Text Components
//
//     Parameters
// ASkipedMLine - measure Polyline which rebuild is not needed
//
procedure TN_UDCMSlide.RebuildAllMLineTexts(ASkipedMLine: TN_UDBase = nil);
var
  i: Integer;
  UDRObj: TN_UDBase;
begin
  with GetMeasureRoot() do
    for i := 0 to DirHigh() do
    begin
      UDRObj := DirChild(i);
      if (UDRObj.ObjName[1] <> 'M') or (ASkipedMLine = UDRObj) then
        Continue; // Not Measure Line
      RebuildMLineTexts(UDRObj);
    end;
end; // end of TN_UDCMSlide.RebuildAllMLineTexts

//**************************** TN_UDCMSlide.SetMLineInterimTextsDisplayMode ***
// Set given PolyLine Interim Texts Display Mode
//
//     Parameters
// AUDMLineRoot - measure PolyLine Root Component to rebuild
// ADisplayMode  - if =TRUE then interim texts should be displayed
//
procedure TN_UDCMSlide.SetMLineInterimTextsDisplayMode( AUDMLineRoot: TN_UDBase;
  ADisplayMode: Boolean );
var
  j, K: Integer;
  SkipSelf : Byte;
begin
  K := AUDMLineRoot.DirHigh() - 1;
  SkipSelf := 255;
  if ADisplayMode then
    SkipSelf := 0;
  for j := 2 to K do
    TN_UDCompVis(AUDMLineRoot.DirChild(j)).PSP.CCompBase.CBSkipSelf := SkipSelf;
end; // end of TN_UDCMSlide.SetMLineInterimTextsDisplayMode

//**************************** TN_UDCMSlide.GetMLineInterimTextsDisplayMode ***
// Get given PolyLine Interim Texts Display Mode
//
//     Parameters
// AUDMLineRoot - measure PolyLine Root Component to rebuild
// Result - Returns
//#F
//   -1 - one segment line,
//    0 - line has more then one segment and Display Mode is FALSE,
//    1 - line has more then one segment and Display Mode is TRUE
//#/F
//
function  TN_UDCMSlide.GetMLineInterimTextsDisplayMode( AUDMLineRoot: TN_UDBase ) : Integer;
begin
  if AUDMLineRoot.DirHigh() = 2 then
    Result := -1
  else if TN_UDCompVis(AUDMLineRoot.DirChild(2)).PSP.CCompBase.CBSkipSelf = 0 then
    Result := 1
  else
    Result := 0;
end; // end of TN_UDCMSlide.GetMLineInterimTextsDisplayMode

//******************************************** TN_UDCMSlide.CalibrateByLine ***
// Calibrate Slide by given PolyLine new Length and Units
//
//     Parameters
// AUDLine - given PoyLine Object
// ALength - given PoyLine new Total Length
// AUnits  - new show distance units
//
procedure TN_UDCMSlide.CalibrateByLine(AUDLine: TN_UDPolyline; ALength: Double;
  AUnits: TN_CMSlideDUnits);
var
  CFactor: Double;

begin

  // Round given ALength
  CFactor := IntPower(10, K_CMSDistRoundFactor[Ord(AUnits)]);

  ALength := Min(10000, ALength); // precaution
  ALength := Round(ALength * CFactor) / CFactor;
  ALength := Max(1 / CFactor, ALength); // precaution


  // Length to MM Units
  // if AUnits = cmsduInch then
  // ALength := 25.4 * ALength;

  // Recalibrate Slide Lines
  CFactor := RebuildMLineTexts(AUDLine.Owner, Ord(AUnits)) / ALength;
  with P()^, CMSDB do
  begin
    DUnits := AUnits;
    PixPermm := PixPermm * CFactor;
    SFlags := SFlags + [cmsfUserCalibrated];
    SFlags := SFlags - [cmsfProbablyCalibrated];
  end;
  RebuildMLineTexts(AUDLine.Owner, -1, @ALength);

  // Rebuild All Measure Line Texts
  RebuildAllMLineTexts(AUDLine.Owner);

end; // end of TN_UDCMSlide.CalibrateByLine

//************************************************ TN_UDCMSlide.PrepOneVObj ***
// Convert given Vector Object IDB Tree to new structure
//
//     Parameters
// AUDRObj - Vector Object Root
// Result - Returns resulting covertion code:
//#F
// 1 - Vector Objeñt IDB Tree was converted
// 0 - Vector Objeñt has no IDB Tree
// -1 - Vector Objeñt IDB Tree has already new structure
//#/F
//
// conversion to new structure adds special Zero Child to Each VObject Root,
// moves VObject UserParams to this new Child and rebuild all references to
// VObject by reference to this new Child in all VObject SubTree
//
function TN_UDCMSlide.PrepOneVObj(AUDRObj: TN_UDBase): Integer;
var
  i, j: Integer;
  UDRObj: TN_UDCompBase;
  UDParRObj: TN_UDCompBase;
begin
  Result := 0;
  UDRObj := TN_UDCompBase(AUDRObj.DirChild(0));
  if UDRObj = nil then
    Exit;
  Result := -1;
  // if K_GetExecTypeName( UDRObj.R.ElemType.All ) = 'TN_RCompBase' then Exit;
  if UDRObj.ObjName = 'Attrs' then
    Exit;
  Result := 1;
  // Create new Child
  UDParRObj := TN_UDCompBase(K_CreateUDByRTypeName('TN_RCompBase', 1,
      N_UDCompBaseCI));
  UDParRObj.ObjName := 'Attrs';
  AUDRObj.InsOneChild(0, UDParRObj);

  // Move Root Attrs to NewChild
  with UDParRObj.PSP()^.CCompBase do
  begin
    CBUserParams := TN_UDCompBase(AUDRObj).PSP().CCompBase.CBUserParams;
    CBSkipSelf := 255;
  end;
  TN_UDCompBase(AUDRObj).PSP().CCompBase.CBUserParams := nil;

  for i := 1 to AUDRObj.DirHigh() do
  begin
    UDRObj := TN_UDCompBase(AUDRObj.DirChild(i));
    with UDRObj.PSP()^.CSetParams do
      for j := 0 to AHigh do
        with TN_POneSetParam(P(j))^ do
          if SPSrcUObj = AUDRObj then
            K_SetUDRefField(SPSrcUObj, UDParRObj);

  end;
end; // end of TN_UDCMSlide.PrepOneVObj

//************************************************** TN_UDCMSlide.PrepVObjs ***
// Convert Slide Vector Objects IDB Tree to new structure
//
procedure TN_UDCMSlide.PrepVObjs();
var
  i: Integer;
  UDMeasureRoot : TN_UDBase;
begin
  UDMeasureRoot := GetMeasureRoot();
  with UDMeasureRoot do
    for i := 0 to DirHigh() do
      if PrepOneVObj(DirChild(i)) = -1 then
        break;
end; // end of TN_UDCMSlide.PrepVObjs

//************************************************ TN_UDCMSlide.ExportToDIB ***
// Export Slide to DIB
//
//     Parameters
// AExportFlags - export image flags
//#F
// bit0 (0001) - export Original Image
// bit1 (0002) - skip conversion TrueColor Image to Grey if its pixels are realy Grey
// bit2 (0004) - skip Grey 16bit conversion to 8bit
//#/F
// AMaxWidth   - resulting maximal Width, if =0 the Slide Width is used
// AMaxHeight  - resulting maximal Height, if =0 the Slide Height is used
// Result - Returns DIB object
//
// Create DIBObj of Slide Image actual size and draw Self to it
// If Slide contains media file results NIL.
//
function TN_UDCMSlide.ExportToDIB( AExportFlags : TK_CMBSlideExportToDIBFlags = [];
                                   AMaxWidth : Integer = 0;
                                   AMaxHeight : Integer = 0 ): TN_DIBObj;
var
  ExpParams: TN_ExpParams;
  DIBRect1: TRect;
  MapRoot: TN_UDCompBase;
  SrcImg: TN_UDDIB;
  RGBDiff : Double;
  TmpDIB: TN_DIBObj;
  ChangingSizeIsNeeded : Boolean;
  FCSize : TPoint;
  PCMSlide : TN_PCMSlide;
  FPixPermm : Float;
  HasAnnots : Boolean;
  RDIBExPixFmt: TN_ExPixFmt;// Extended (own) Pixel Format
  FreePrevResult : Boolean;
  ReturnToGrey : Boolean;
  ImgViewConvData : TK_CMSImgViewConvData;
  PSkipAnnots : PByte;
  WSkipAnnots : Byte;
label LFinExport;

  procedure ConvertResultToGrey();
  begin
    TmpDIB := TN_DIBObj.Create();
    try
      TmpDIB.PrepEmptyDIBObj( Result.DIBSize.X, Result.DIBSize.Y, pfCustom, -1, epfGray8 );
    except
    // Out Of Memory
      FreeAndNil(TmpDIB);
      FreeAndNil(Result);
      Exit;
    end;
    Result.CalcGrayDIB( TmpDIB );
    Result.Free();
    Result := TmpDIB;
  end;

  procedure ShiftTo16Bit( ADIBObj : TN_DIBObj );
  var
    SMD: TN_SMatrDescr;
  begin
    N_PixOpObj.PO_IntOperand := 16 - ADIBObj.DIBNumBits; // Left Shift size
    if (N_PixOpObj.PO_IntOperand <= 0) or (N_PixOpObj.PO_IntOperand >= 8) then Exit;
    N_Dump2Str( format( 'Shift %d bit to 16', [ADIBObj.DIBNumBits] ) );
    ADIBObj.PrepSMatrDescr( @SMD );
    N_Conv1SMProcObj( @SMD, N_PixOpObj.PO_SHLTwoBytes ); // Shift DIB Pixels by PO_SHLTwoBytes ProcObj
  end;

  procedure InitSize( AImgWidth, AImgHeight : Integer );
  begin
    if AMaxWidth = 0 then
      AMaxWidth :=  AImgWidth;
    if AMaxHeight = 0 then
      AMaxHeight := AImgHeight;

    FCSize := Point(AImgWidth, AImgHeight);
    FPixPermm := PCMSlide.CMSDB.PixPermm;
    ChangingSizeIsNeeded := ((AMaxWidth < FCSize.X) or (AMaxHeight < FCSize.Y));
//    ChangingSizeIsNeeded := ((AMaxWidth <> 0) and (AMaxWidth < FCSize.X)) or
//                            ((AMaxHeight <> 0) and (AMaxHeight < FCSize.Y));
{}
    if not ChangingSizeIsNeeded then
    begin
      AMaxWidth := FCSize.X;
      AMaxHeight := FCSize.Y;
    end;
{}
    N_Dump2Str( format( 'ExportToDIB InitSize maxWxH=%dx%d rWxH=%dx%d',
                      [AMaxWidth,AMaxHeight,FCSize.X,FCSize.Y] ) );
  end;

begin

  Result := nil;
  PCMSlide := P();

  N_Dump2Str( format( 'ExportToDIB start F=%x maxWxH=%dx%d',
                      [Byte(AExportFlags),AMaxWidth, AMaxHeight] ) );

  if K_bsedExportOriginal in AExportFlags then
  begin  // Original
////////////////////////////////////////
// Export original
//
    // Check Memory for SrcImage
    with PCMSlide^ do
      if not K_CMSCheckMemForSlide1( nil, 0, 1, CMSDB.PixWidth, CMSDB.PixHeight ) then Exit;

    // Try to get DIB from UNDO buffer (for not saved Slides)
    if CMSUndoBuf <> nil then // Original Imag is in UNDO Buf only
      Result := CMSUndoBuf.UBGetSrcImageDIB();

    FreePrevResult := Result <> nil;
    if not FreePrevResult then
    begin
      SrcImg := GetSourceImage();
      if SrcImg = nil then
        SrcImg := GetCurrentImage();
      Result := SrcImg.DIBObj // Set for Future Convert
    end;

    InitSize( Result.DIBSize.X, Result.DIBSize.Y );

    if not ChangingSizeIsNeeded then
    begin
    // Changing Size Is Not Needed - create DIB Resulting copy
      TmpDIB := Result;
      RDIBExPixFmt := TmpDIB.DIBExPixFmt;// Extended (own) Pixel Format
      Result := TN_DIBObj.Create();
      if not (K_bsedSkipConvGrey16To8 in AExportFlags) and
        (RDIBExPixFmt = epfGray16) then
      begin
        RDIBExPixFmt := epfGray8;
      end;
      try
        Result.PrepEmptyDIBObj( TmpDIB.DIBSize.X,
                                TmpDIB.DIBSize.Y,
                                TmpDIB.DIBPixFmt, -1, RDIBExPixFmt );
      except
      // Out Of Memory
        FreeAndNil(Result);
        if FreePrevResult then
          FreeAndNil(TmpDIB);
        Exit; // Out Of Memory
      end;
      Result.CopyRectAuto( Point(0,0), TmpDIB, TmpDIB.DIBRect );
      if FreePrevResult then
        FreeAndNil(TmpDIB);

    end // if not ChangingSizeIsNeeded then
    else
    begin // if ChangingSizeIsNeeded then
    // Resample DIB to smaller
      FCSize := N_AdjustSizeByAspect( aamDecRect, Point( AMaxWidth,AMaxHeight ),
                                      FCSize.Y / FCSize.X );
      FPixPermm := FPixPermm * FCSize.X / Result.DIBSize.X;

      ReturnToGrey := Result.DIBPixFmt <> pf24bit;

      if ReturnToGrey then
      begin
      // Rebuild Grey DIB to Color because N_StretchRect needed Color Image to Resample

        TmpDIB := TN_DIBObj.Create();
        try
          TmpDIB.PrepEmptyDIBObj( Result.DIBSize.X,
                                  Result.DIBSize.Y,
                                  pf24bit );
        except
       // Out Of Memory
          FreeAndNil(TmpDIB);
          if FreePrevResult then
            FreeAndNil(Result)
          else
            Result := nil;
          Exit;
        end;

        TmpDIB.CopyRectAuto( Point(0,0), Result, Result.DIBRect );
        if FreePrevResult then
          FreeAndNil(Result);
        Result := TmpDIB;
        FreePrevResult := TRUE;
      end; // if ReturnToGrey then

      // Create Smaller Copy
      TmpDIB := TN_DIBObj.Create();
      try
        TmpDIB.PrepEmptyDIBObj( FCSize.X, FCSize.Y, pf24bit );
      except
      // Out Of Memory
        FreeAndNil(TmpDIB);
        if FreePrevResult then
          FreeAndNil(Result)
        else
          Result := nil;
        Exit;
      end;

      // Resample Image
      N_StretchRect(TmpDIB.DIBOCanv.HMDC, TmpDIB.DIBRect, Result.DIBOCanv.HMDC, Result.DIBRect );

      if FreePrevResult then
        Result.Free;

      Result := TmpDIB;

      if ReturnToGrey then
        ConvertResultToGrey();

    end; // if ChangingSizeIsNeeded then
{
    if Result = nil then
    begin
    // Get DIB from Original or Current Image
      SrcImg := GetSourceImage();
      if SrcImg = nil then
        SrcImg := GetCurrentImage();

      InitSize( SrcImg.DIBObj.DIBSize.X, SrcImg.DIBObj.DIBSize.Y );

      if ChangingSizeIsNeeded then
        Result := SrcImg.DIBObj // Set for Future Convert
      else
      begin // if not ChangingSizeIsNeeded then
      // Changing Size Is Not Needed - create DIB Resulting copy
        RDIBExPixFmt := SrcImg.DIBObj.DIBExPixFmt;// Extended (own) Pixel Format
        Result := TN_DIBObj.Create();
        if not (K_bsedSkipConvGrey16To8 in AExportFlags) and
          (RDIBExPixFmt = epfGray16) then
        begin
          RDIBExPixFmt := epfGray8;
        end;
        try
          Result.PrepEmptyDIBObj( SrcImg.DIBObj.DIBSize.X,
                                  SrcImg.DIBObj.DIBSize.Y,
                                  SrcImg.DIBObj.DIBPixFmt, -1, RDIBExPixFmt );
        except
        // Out Of Memory
          FreeAndNil(Result);
          Exit; // Out Of Memory
        end;
        Result.CopyRectAuto( Point(0,0), SrcImg.DIBObj, SrcImg.DIBObj.DIBRect );
      end // // if not ChangingSizeIsNeeded then
    end // if Result = nil then
    else
      InitSize( Result.DIBSize.X, Result.DIBSize.Y );

    if ChangingSizeIsNeeded then
    begin
    // Resample DIB to smaller
      FCSize := N_AdjustSizeByAspect( aamDecRect, Point( AMaxWidth,AMaxHeight ),
                                      FCSize.Y / FCSize.X );
      FPixPermm := FPixPermm * FCSize.X / Result.DIBSize.X;

      ReturnToGrey := Result.DIBPixFmt <> pf24bit;
      if ReturnToGrey then
      begin
      // Rebuild Grey DIB to Color
        TmpDIB := TN_DIBObj.Create();
        try
          TmpDIB.PrepEmptyDIBObj( Result.DIBSize.X,
                                  Result.DIBSize.Y,
                                  pf24bit );
        except
       // Out Of Memory
          FreeAndNil(TmpDIB);
          if FreePrevResult then
            FreeAndNil(Result)
          else
            Result := nil;
          Exit;
        end;

        TmpDIB.CopyRectAuto( Point(0,0), Result, Result.DIBRect );
        if FreePrevResult then
          FreeAndNil(Result);
        Result := TmpDIB;
        FreePrevResult := TRUE;
      end; // if ReturnToGrey then

      // Create Smaller Copy
      TmpDIB := TN_DIBObj.Create();
      try
        TmpDIB.PrepEmptyDIBObj( FCSize.X, FCSize.Y, pf24bit );
      except
      // Out Of Memory
        FreeAndNil(TmpDIB);
        if FreePrevResult then
          FreeAndNil(Result)
        else
          Result := nil;
        Exit;
      end;

      // Resample Image
      N_StretchRect(TmpDIB.DIBOCanv.HMDC, TmpDIB.DIBRect, Result.DIBOCanv.HMDC, Result.DIBRect );

      if FreePrevàResult then
        Result.Free;

      Result := TmpDIB;

      if ReturnToGrey then
        ConvertResultToGrey();

    end; // if ChangingSizeIsNeeded then
}
    // Original Image DIB created
//
// Export original
////////////////////////////////////////
  end // if K_bsedExportOriginal in AExportFlags then
  else
  begin // if not (K_bsedExportOriginal in AExportFlags) then
////////////////////////////////////////
// Export CurrentImage + Annotations
//
  // Export CurrentImage + Annotations
    if not K_CMSCheckMemForSlide1( Self, 0, 1 ) then Exit;
    MapRoot := GetMapRoot();

    if MapRoot is TN_UDFile then // precaution
      Exit;

    with PCMSlide^ do //++
      InitSize( CMSDB.PixWidth, CMSDB.PixHeight );

    // Check if Grey Image Special Processing
    if not ChangingSizeIsNeeded then
    begin
      if K_bsedSkipAnnotations in AExportFlags then
        HasAnnots := FALSE
      else
        HasAnnots := GetMeasureRoot( ).DirLength() > 0;

      if not HasAnnots and
         (K_bsedSkipConvGrey16To8 in AExportFlags) then
      begin
        N_Dump2Str( 'ExportToDIB use current'  );
        SrcImg := GetCurrentImage();
        N_Dump2Str( 'ExportToDIB after GetCurrentImage ExPixFmt=' +
                      IntToStr( Ord(SrcImg.DIBObj.DIBExPixFmt) ) );
        if (SrcImg.DIBObj.DIBExPixFmt = epfGray16) or
           (SrcImg.DIBObj.DIBExPixFmt = epfGray8) then
        begin
        // Prepare FlipRotateNegate Result DIB
          FillChar( ImgViewConvData, SizeOf(TK_CMSImgViewConvData), 0 );
          GetImgViewConvData( @ImgViewConvData, [vcifFlipRotate, vcifBriCoGam] );
          K_CMConvDIBBySlideViewConvData( Result, SrcImg.DIBObj,
                      @ImgViewConvData, pfCustom, SrcImg.DIBObj.DIBExPixFmt );
          N_Dump2Str( 'ExportToDIB after K_CMConvDIBBySlideViewConvData'  );
          goto LFinExport;
        end; // if (SrcImg.DIBObj.DIBExPixFmt = epfGray16) or (SrcImg.DIBObj.DIBExPixFmt = epfGray8)
      end; // if not HasAnnots and (K_bsedSkipConvGrey16To8 in AExportFlags)
    end; // if not ChangingSizeIsNeeded then

    ExpParams := N_DefExpParams;
    with ExpParams, EPImageFPar do
    begin
      EPImageExpMode := iemJustDraw;
      EPExecFlags := EPExecFlags + [epefHALFTONE];
      IFPPixFmt := pf24bit;
      IFPSizePix := IPoint(TN_UDCompVis(MapRoot).PCCS.SRSize);
      if ChangingSizeIsNeeded then
        IFPSizePix := N_AdjustSizeByAspect( aamDecRect, Point( AMaxWidth,AMaxHeight ),
                                            FCSize.Y / FCSize.X )
      else
        IFPSizePix := FCSize;

      FPixPermm := FPixPermm * IFPSizePix.X / FCSize.X;

      IFPSizemm := FPoint(IFPSizePix.X / FPixPermm, IFPSizePix.Y / FPixPermm);

      DIBRect1 := IRect(IFPSizePix.X, IFPSizePix.Y);
      N_Dump2Str( format( 'ExportToDIB before create RDIB WxH=%dx%d',
                          [IFPSizePix.X, IFPSizePix.Y] )  );
      Result := TN_DIBObj.Create();
      try
        Result.PrepEmptyDIBObj(IFPSizePix.X, IFPSizePix.Y, pf24bit);
      except
      // // Out Of Memory
        N_Dump2Str( 'ExportToDIB out of memory'  );
        FreeAndNil( Result );
        Exit;
      end;

      with TN_GlobCont.Create() do
      begin
        ////////////////////////////////////////
        //  Control Annotation on resulting DIB
        //
        PSkipAnnots := GetPMeasureRootSkipSelf;
        WSkipAnnots := PSkipAnnots^;
        if K_bsedSkipAnnotations in AExportFlags then
        begin
          if WSkipAnnots = 0 then
            PSkipAnnots^ := 1;
        end
        else
        begin
          if WSkipAnnots <> 0 then
            PSkipAnnots^ := 0;
        end;
        //
        //  Control Annotation on resulting DIB
        ////////////////////////////////////////

        N_Dump2Str( 'ExportToDIB before ExecuteRootComp SkipAnnots=' + N_B2S(PSkipAnnots^ <> 0)  );
        ExecuteRootComp(MapRoot, [], nil, nil, @ExpParams );
        N_Dump2Str( 'ExportToDIB after ExecuteRootComp'  );

        PSkipAnnots^ := WSkipAnnots; // Return Annotations Draw State

        N_Dump2Str( 'ExportToDIB before N_StretchRect'  );
        N_StretchRect(Result.DIBOCanv.HMDC, DIBRect1, DstOCanv.HMDC, DstPixRect);
        N_Dump2Str( 'ExportToDIB after N_StretchRect'  );

        Free;
      end;
    end; // with ExpParams.EPImageFPar do

    if not( K_bsedSkipConvColorToGrey in AExportFlags) then
    begin // Convert To Grey if needed
      // Check if Result DIB should be converted to Gray format
      RGBDiff := Result.GetMaxRGBDif(0);
      N_Dump2Str( 'ExportToDIB RGDiff=' + FloatToStr(RGBDiff)  );
      if RGBDiff <= 0 then // Convert Result DIB to Gray
        ConvertResultToGrey();
    end; // if not( K_bsedSkipConvColorToGrey in AExportFlags) then
//
// Export CurrentImage + Annotations
////////////////////////////////////////
  end; // Export CurrentImage + Annotations

LFinExport:
  with Result.DIBInfo.bmi do
  begin
    biXPelsPerMeter := Round(FPixPermm * 1000);
    biYPelsPerMeter := biXPelsPerMeter;
  end;

  N_Dump2Str( 'ExportToDIB before ShiftTo16Bit'  );
  ShiftTo16Bit( Result );
  N_Dump2Str( 'ExportToDIB fin' );

end; // end of TN_UDCMSlide.ExportToDIB

//********************************************** TN_UDCMSlide.GetCMSUndoBuf ***
// Get Slide UNDO buffer object
//
function TN_UDCMSlide.GetCMSUndoBuf: TK_CMSUndoBuf;
begin
  if CMSUndoBuf = nil then
  begin
    CMSUndoBuf := TK_CMSUndoBuf.Create;
    CMSUndoBuf.UBInitBySlide(Self);
  end
  else
  with P^ do
    if cmsfInitUndoBuf in CMSRFlags then
    begin
      CMSUndoBuf.UBInitBySlide(Self);
      Exclude( CMSRFlags, cmsfInitUndoBuf );
    end;
  Result := CMSUndoBuf;
end; // end of TN_UDCMSlide.GetCMSUndoBuf

//******************************************* TN_UDCMSlide.SetTextFontAttrs ***
// Set given Text Component Font Attributes by AutoSacale Factor
//
//     Parameters
// AUDText - given Drawing Text Component Object
// ADecreaseFont - if =TRUE Font Size will be decreased by AutoScaleFactor
// else Font Size will be increased
//
procedure TN_UDCMSlide.SetTextFontAttrs(AUDText: TN_UDParaBox;
  ADecreaseFont: Boolean = false);
var
  ScaleFactor: Double;
begin
  ScaleFactor := CMSScaleFontFactor;
  if ADecreaseFont then
    ScaleFactor := 1 / CMSScaleFontFactor;
  if CMSScaleFontFactor > 1 then
    with TN_PNFont(K_GetPVRArray(TN_POneTextBlock
          (AUDText.PSP.CParaBox.CPBTextBlocks.P()).OTBNFont).P())^ do
      NFLLWHeight := Round(NFLLWHeight * ScaleFactor);
end; // procedure TN_UDCMSlide.SetTextFontAttrs

//***************************************** TN_UDCMSlide.CMSlideAddCurState ***
// Add to given strings current state params
//
//     Parameters
// AStrings - given strings
// AIndent  - number of spaces to add before all strings
//
// Used to dump Slide info for debug purpose
//
procedure TN_UDCMSlide.CMSlideAddCurState(AStrings: TStrings; AIndent: Integer);
var
  Prefix: string;
  PCMSlide: TN_PCMSlide;
  UDDIB : TN_UDDIB;
begin
  Prefix := DupeString(' ', AIndent + 2);
  with AStrings do
  begin
    if Self = nil then
    begin
      AStrings.Add(Prefix + 'Self = nil');
      Exit;
    end
    else
    if ObjLiveMark <> N_ObjLiveMark then
    begin
      Add(Prefix + 'Slide is not alive');
      Exit;
    end;

    try
      Add(Prefix + 'ID: ' + ObjName + ', ' + ObjInfo);
      PCMSlide := P;
      Add(Prefix + 'Fields: ' + K_SPLValueToString(PCMSlide^,
          K_GetTypeCode('TN_CMSlide')));

//      if GetMapRoot(TRUE, TRUE, TRUE) <> nil then
      K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapRootLoad,
                                     K_gmrfSkipMapImgBuild,
                                     K_gmrfSkipCurImgLoad];
      if GetMapRoot() <> nil then
        Add(Prefix + 'MRFields: ' + K_SPLValueToString(GetPMapRootAttrs()^,
            K_GetTypeCode('TK_CMSMRImgAttrs')));
      K_UDCMSlideGetMapRootFlags := [];

      UDDIB := GetCurrentImage(TRUE,TRUE);
      if UDDIB <> nil then
      begin
        Add(Prefix + ' CurImg is loaded');
        if (UDDIB.PSP.CDIBN.CDIBDataFormat = uddfNotDef) then
          Add(Prefix + ' CurImg.CDIBDataFormat = uddfNotDef');
      end;

      if (cmsfHasSrcImg in PCMSlide.CMSDB.SFlags) then
      begin
        UDDIB := GetSourceImage(TRUE,TRUE);
        if UDDIB <> nil then
        begin
          Add(Prefix + ' SrcImg is loaded');
          if (UDDIB.PSP.CDIBN.CDIBDataFormat = uddfNotDef) then
            Add(Prefix + ' SrcImg.CDIBDataFormat = uddfNotDef');
        end;
      end;
    except
      on E: Exception do
      begin
        Add(Prefix + ' Except:' + E.Message);
      end;
    end;
    Add('');

  end; // with AStrings do
end; // procedure TN_UDCMSlide.CMSlideAddCurState

//******************************************** TN_UDCMSlide.AffConvVObjects ***
// Convert Vector Objects Cordinates
//
//     Parameters
// APixAffCoefs6  - AffCoefs6 coeficients for User coordinates
//                  transformation
// AAngle         - Rotate Angle
// ARFVectorScale - MapImage current vector scale factor for flashlight objects
//
procedure TN_UDCMSlide.AffConvVObjects6( APixAffCoefs6: TN_AffCoefs6; AAngle : Double;
                                        ARFVectorScale : Float  );
var
  MapRootMeasures : TN_UDBase;
  i, h, j, n, k : Integer;
  UDVObj, UDVChild : TN_UDCompVis;
  WPoint : TFPoint;

  PCompCoords : TN_PCompCoords;
  PChildCompCoords : TN_PCompCoords;
  ObjTypeChar : Char;
  PLP : PFPoint;

  procedure N_AffConv6F2FPoint ( PP : PFPoint );
  var
    X1 : Double;
  begin
    with APixAffCoefs6, PP^ do begin
      X1 := X;
      X := CXX * X + CXY * Y + SX;
      Y := CYX * X1 + CYY * Y + SY;
    end;
  end;


  function NormAngle( Ang : Float ) : Float;
  begin
    Result := Ang;
    if Result < 0 then
      Result := 360 + Result
    else if Result > 360 then
      Result := Result - 360;
  end;

begin
//  Exit; // debug

  MapRootMeasures := GetMeasureRoot( );
  h := MapRootMeasures.DirHigh;
  for i := 0 to h do
  begin
    UDVObj := TN_UDCompVis(MapRootMeasures.DirChild(i));
    ObjTypeChar := UDVObj.ObjName[1];
    PCompCoords := @UDVObj.PSP.CCoords;
    with PCompCoords^ do
    begin
      if ( (ObjTypeChar = 'E') and
           ((Length(UDVObj.ObjName) = 7) or (UDVObj.ObjName[8] <> 'L')) ) or
         ( (ObjTypeChar = 'R') and
           ((Length(UDVObj.ObjName) = 4) or (UDVObj.ObjName[5] <> 'L')) ) or
         (ObjTypeChar = 'Z') then
      begin
      // Rectangle Type Objects Ellips, Rectangle, Arrow, Flashlight
        WPoint := FPoint( BPCoords.X + SRSize.X / 2, BPCoords.Y + SRSize.Y / 2 );
        N_AffConv6F2FPoint ( @WPoint );
        SRSize.X := SRSize.X * APixAffCoefs6.CXX;
        SRSize.Y := SRSize.Y * APixAffCoefs6.CYY;
        BPCoords := FPoint( WPoint.X - SRSize.X / 2, WPoint.Y - SRSize.Y / 2 );
        if UDVObj.ObjName[1] = 'Z' then
          K_CMSFlashlightCalcSrcRect( UDVObj, ARFVectorScale, Point(0,0) );
      end else if (ObjTypeChar = 'A') and (Length(UDVObj.ObjName) = 5) then
      begin // Old Arrow
        N_AffConv6F2FPoint ( @BPCoords );
        SRSize.X := SRSize.X * APixAffCoefs6.CXX;
        SRSize.Y := SRSize.Y * APixAffCoefs6.CYY;
      end else if (ObjTypeChar = 'T') then
        N_AffConv6F2FPoint ( @BPCoords )
      else
      begin
      // Other Type Objects Line, Measured Line, Freehand, Angle, Free Angle
        n := UDVObj.DirHigh;
        for j := 0 to n do
        begin
          UDVChild := TN_UDCompVis(UDVObj.DirChild(j));
          PChildCompCoords := @UDVChild.PSP.CCoords;
          if UDVChild is TN_UDPolyLine then
          begin
          // Polyline childs
            with TN_UDPolyline(UDVChild), PISP.CPCoords  do
              for k := 0 to AHigh() do
              begin
                PLP := PFPoint(P(k));
                PLP^ := N_Add2P( PCompCoords.BPCoords, PLP^ );
                N_AffConv6F2FPoint ( PLP );
              end;
          end else if (UDVChild is TN_UDArc) or (UDVChild is TN_UDParaBox) then
          begin
          // Arc and Text Childs
            PChildCompCoords.BPCoords := N_Add2P( PCompCoords.BPCoords,
                                                  PChildCompCoords.BPCoords );
            N_AffConv6F2FPoint ( @PChildCompCoords.BPCoords );
            if UDVChild is TN_UDArc then
            begin
              with TN_UDArc(UDVChild).PSP.CArc do
              begin
                CArcBegAngle := NormAngle( CArcBegAngle + AAngle );
                CArcEndAngle := NormAngle( CArcEndAngle + AAngle );
              end;
            end;
          end;
        end;
        PCompCoords.BPCoords := FPoint(0,0);
      end;
    end;
  end;

end; // procedure TN_UDCMSlide.AffConvVObjects6

//******************************************** TN_UDCMSlide.AffConvVObjects ***
// Convert Vector Objects Cordinates
//
//     Parameters
// AVOConv        - coordinates conversion mode
// ARFVectorScale - MapImage current vector scale factor for flashlight objects
//
// Should be used after Slide Raster Affine conversion
//
procedure TN_UDCMSlide.AffConvVObjects( AFlipRotateFlags : Integer; ARFVectorScale : Float );
var
  MapRootMeasures : TN_UDBase;
  i, h, j, n, k : Integer;
  UDVObj, UDVChild : TN_UDCompVis;
  WPoint : TFPoint;

  AffCoefs1 : TN_AffCoefs6;
  AffCoefs2 : TN_AffCoefs6;
  PCompCoords : TN_PCompCoords;
  WF : single;
  ObjTypeChar : Char;

  procedure N_AffConv1F2FPoint ( PP : PFPoint ); // local
  // Convert one float point by AffCoefs1
  var
    X1 : Double;
  begin
    with AffCoefs1, PP^ do begin
      X1 := X;
      X := CXX * X + CXY * Y + SX;
      Y := CYX * X1 + CYY * Y + SY;
    end;
  end; // procedure N_AffConv1F2FPoint ( PP : PFPoint ); / // local

  procedure N_AffConv2F2FPoint ( PP : PFPoint ); // local
  // Convert one float point by AffCoefs1
  var
    X1 : Double;
  begin
    with AffCoefs2, PP^ do begin
      X1 := X;
      X := CXX * X + CXY * Y + SX;
      Y := CYX * X1 + CYY * Y + SY;
    end;
  end; // procedure N_AffConv2F2FPoint ( PP : PFPoint ); // local

  function NormAngle( Ang : Float ) : Float; // local
  begin
    Result := Ang;
    if Result < 0 then
      Result := 360 + Result
    else if Result > 360 then
      Result := Result - 360;
  end; // function NormAngle( Ang : Float ) : Float; // local

begin //**************************** main body of TN_CMREdit3Frame.AffConvVObjs
  if (Self = nil) or (AFlipRotateFlags = 0) then Exit;

// FlipRotate Flags illustrations:
//
// Positive directions are from left to right and from bottom to top
//   ((0,0) is lower left corner, as in BMP raster)
//
//  0(000)    1(001)     2(010)    3(011)  FlipRotate Flags: decimal(binary)
//
//     *        *        *****     *****
//    **        **         *         *
//     *        *          *         *
//     *        *          *         *
//     *        *         **         **
//   *****    *****        *         *
//
//
//   7(111)    6(110)    5(101)    4(100)  FlipRotate Flags: decimal(binary)
//
//        *    *              *     *
//    *   *    *   *          *     *
//   ******    ******    ******     ******
//        *    *          *   *     *   *
//        *    *              *     *

  MapRootMeasures := GetMeasureRoot( );
  h := MapRootMeasures.DirHigh;
  if h = -1 then Exit;

  case AFlipRotateFlags of

    1: // FLip Horisontally
    begin
      AffCoefs1 := N_CalcAffCoefs6( D3PReper(   0, 0,   0, 100, 100, 0 ),
                                    D3PReper( 100, 0, 100, 100,   0, 0  ) );
      AffCoefs2 := N_CalcAffCoefs6( D3PReper(  0, 0,  0, 10,  10, 0 ),
                                    D3PReper(  0, 0,  0, 10, -10, 0 ) );
    end;

    2: // FLip Vertically
    begin
      AffCoefs1 := N_CalcAffCoefs6( D3PReper(  0,   0, 0, 100, 100,   0 ),
                                    D3PReper(  0, 100, 0,   0, 100, 100 ) );
      AffCoefs2 := N_CalcAffCoefs6( D3PReper( 0, 0, 0,  10, 10, 0 ),
                                    D3PReper( 0, 0, 0, -10, 10, 0 ) );
    end;

    3: // Rotate 180
    begin
      AffCoefs1 := N_CalcAffCoefs6( D3PReper( 0, 0, 0, 100, 100, 0 ),
                                    D3PReper( 100, 100, 100, 0, 0, 100 ) );
      AffCoefs2 := N_CalcAffCoefs6( D3PReper(  0, 0, 0,  10,  10, 0 ),
                                    D3PReper(  0, 0, 0, -10, -10, 0 ) );
    end;

    4: // Flip diagonal 1
    begin
      AffCoefs1 := N_CalcAffCoefs6( D3PReper(   0,   0,  0, 100, 100, 0 ),
                                    D3PReper( 100, 100,  0, 100, 100, 0  ) );
      AffCoefs2 := N_CalcAffCoefs6( D3PReper(  0, 0,   0, 10, 10,   0 ),
                                    D3PReper(  0, 0, -10,  0,  0, -10 ) );
    end;

    5: // Rotate Left
    begin
      AffCoefs1 := N_CalcAffCoefs6( D3PReper( 0, 0, 0, 100, 100, 0 ),
                                    D3PReper( 0, 100, 100, 100, 0, 0 ) );
      AffCoefs2 := N_CalcAffCoefs6( D3PReper( 0, 0, 0, 10, 10, 0 ),
                                    D3PReper( 0, 0, 10, 0, 0, -10 ) );
    end;

    6: // Rotate Right
    begin
      AffCoefs1 := N_CalcAffCoefs6( D3PReper(   0, 0, 0, 100, 100, 0 ),
                                    D3PReper( 100, 0, 0,   0, 100, 100 ) );
      AffCoefs2 := N_CalcAffCoefs6( D3PReper( 0, 0,   0, 10, 10, 0 ),
                                    D3PReper( 0, 0, -10,  0,  0, 10 ) );
    end;

    7: // Flip diagonal 2
    begin
      AffCoefs1 := N_CalcAffCoefs6( D3PReper( 0,  0,   0, 100, 100,   0 ),
                                    D3PReper( 0,  0, 100,   0,   0, 100 ) );
      AffCoefs2 := N_CalcAffCoefs6( D3PReper(  0, 0,  0, 10, 10,  0 ),
                                    D3PReper(  0, 0, 10,  0,  0, 10 ) );
    end;
  end; // case AVOConv of

  for i := 0 to h do
  begin
    UDVObj := TN_UDCompVis(MapRootMeasures.DirChild(i));
    ObjTypeChar := UDVObj.ObjName[1];
    PCompCoords := @UDVObj.PSP.CCoords;

    with PCompCoords^ do
    begin
      if (ObjTypeChar = 'A') and
         ((Length(UDVObj.ObjName) = 5) or (UDVObj.ObjName[6] <> 'L')) then // old Arrow
      begin
        N_AffConv1F2FPoint ( @BPCoords );
      end
      else // Rect Like - Rect, Ellipse, Marnify region
      if ( (ObjTypeChar = 'E') and
           ((Length(UDVObj.ObjName) = 7) or (UDVObj.ObjName[8] <> 'L')) ) or
         ( (ObjTypeChar = 'R') and
           ((Length(UDVObj.ObjName) = 4) or (UDVObj.ObjName[5] <> 'L')) ) or
         (ObjTypeChar = 'Z') then // Rect Like - Rect, Ellipse, Arrow, Marnify region
      begin
        WPoint := FPoint( BPCoords.X + SRSize.X / 2, BPCoords.Y + SRSize.Y / 2 );
        N_AffConv1F2FPoint ( @WPoint );

        if AFlipRotateFlags >= 4 then
        begin
          // Swap User Size
          WF := SRSize.Y;
          SRSize.Y := SRSize.X;
          SRSize.X := WF;
        end;

        BPCoords := FPoint( WPoint.X - SRSize.X / 2, WPoint.Y - SRSize.Y / 2 );

        if UDVObj.ObjName[1] = 'Z' then // for magnify region only
        begin
          K_CMSFlashlightCalcSrcRect( UDVObj, ARFVectorScale, Point(0,0) );
        end;
      end else // not Rect Like - Line, Angle
      begin
        N_AffConv1F2FPoint ( @BPCoords );
        n := UDVObj.DirHigh;

        for j := 0 to n do // loop along child components
        begin
          UDVChild := TN_UDCompVis(UDVObj.DirChild(j));

          if UDVChild is TN_UDPolyLine then
          begin
            with TN_UDPolyline(UDVChild), PISP.CPCoords do
            begin
              for k := 0 to AHigh() do // along all internal points
                N_AffConv2F2FPoint( PFPoint(P(k)) );
            end;
            if (ObjTypeChar = 'R') or
               ((ObjTypeChar = 'E') and (j = 2)) then
              K_CMSVObjRectReorderLineVertexes( TN_UDPolyline(UDVChild) );
          end
          else if UDVChild is TN_UDArc then
          begin
            N_AffConv2F2FPoint ( @UDVChild.PSP.CCoords.BPCoords );

            with TN_UDArc(UDVChild).PSP.CArc do
            case AFlipRotateFlags of
              1 : begin // Flip Horisontally
                CArcBegAngle := NormAngle( -CArcBegAngle );
                CArcEndAngle := NormAngle( -CArcEndAngle );
              end;
              2 : begin // Flip vertically
                CArcBegAngle := NormAngle( 180 - CArcBegAngle );
                CArcEndAngle := NormAngle( 180 - CArcEndAngle );
              end;
              3 : begin // Rotate 180
                CArcBegAngle := NormAngle( CArcBegAngle - 180 );
                CArcEndAngle := NormAngle( CArcEndAngle - 180 );
              end;
              4 : begin // Flip diagonal 1
                CArcBegAngle := NormAngle( 270 - CArcBegAngle );
                CArcEndAngle := NormAngle( 270 - CArcEndAngle );
              end;
              5 : begin // Rotate Left
                CArcBegAngle := NormAngle( CArcBegAngle + 90 );
                CArcEndAngle := NormAngle( CArcEndAngle + 90 );
              end;
              6 : begin // Rotate Right
                CArcBegAngle := NormAngle( CArcBegAngle - 90 );
                CArcEndAngle := NormAngle( CArcEndAngle - 90 );
              end;
              7 : begin // Flip diagonal 2
                CArcBegAngle := NormAngle( 90 - CArcBegAngle );
                CArcEndAngle := NormAngle( 90 - CArcEndAngle );
              end;
            end; // case AVOConv of
          end else if UDVChild is TN_UDParaBox then // Text
            N_AffConv2F2FPoint ( @UDVChild.PSP.CCoords.BPCoords );
        end; // for j := 0 to n do begin // loop along child components
      end; // else begin // not Rect Like - Line, Angle
    end; // with PCompCoords^ do begin
  end; // for i := 0 to h do begin
end; // procedure TN_UDCMSlide.AffConvVObjects

//****************************************** TN_UDCMSlide.SetAutoCalibrated ***
// Set Slide Image to Autocalibrated State
//
procedure TN_UDCMSlide.SetAutoCalibrated();
begin
  with P().CMSDB do
  begin
    if not (cmsfProbablyCalibrated in SFlags) then Exit;
    Include( SFlags, cmsfAutoCalibrated );
    Exclude( SFlags, cmsfProbablyCalibrated );
  end;
end; // procedure TN_UDCMSlide.SetAutoCalibrated

//************************* TN_UDCMSlide.GetCurImgPixColorByMapImgCursorPos ***
// Get current image pixel color by given map image cusor position
//
//     Parameters
// AMapImgCursorPos - map image cursor position
// APMapImgPixPos   - pointer to varaible with resulting map image pixel coords
// Result - Returns given pixel color
//
function  TN_UDCMSlide.GetCurImgPixColorByMapImgCursorPos( AMapImgCursorPos : TPoint; APMapImgPixPos : PPoint ) : Integer;
var
  PixMapImageCoords: TPoint;
  PixCurImageCoords: TPoint;
begin
  Result := 0;
  with GetMapImage() do
  begin
    PixMapImageCoords := BufToDIBCoords(AMapImgCursorPos);
    PixCurImageCoords := N_FlipRotateCoords( PixMapImageCoords,
              N_BackwardFlags[GetPMapRootAttrs()^.MRFlipRotateAttrs],
              DIBObj.DIBRect );
    with GetCurrentImage().DIBObj do
    begin
      if N_PointInRect( PixCurImageCoords, DIBRect ) = 0 then
      begin
        Result := GetPixValue(PixCurImageCoords);
      end;
    end;
    if APMapImgPixPos <> nil then
      APMapImgPixPos^ := PixMapImageCoords;
  end;
end; // procedure TN_UDCMSlide.GetCurImgPixColorByMapImgCursorPos

//*********************************************** TN_UDCMSlide.GetStudyItem ***
// Get Slide StudyItem
//
//     Parameters
// Result - Returns Slide Study Item
//
function TN_UDCMSlide.GetStudyItem(): TN_UDBase;
begin
  Result := nil;
  if Self = nil then Exit;
  Result := TN_UDBase(DirChild(K_CMSlideIndStudyItem));
end; // function TN_UDCMSlide.GetStudyItem

//*************************************************** TN_UDCMSlide.GetStudy ***
// Get Slide Study
//
//     Parameters
// Result - Returns Slide Study
//
function TN_UDCMSlide.GetStudy(): TN_UDCMStudy;
begin
  Result := TN_UDCMStudy(GetStudyItem());
  if Result = nil then Exit;
  Result := TN_UDCMStudy(Result.Owner.Owner);
end; // function TN_UDCMSlide.GetStudy

//****************************************** TN_UDCMSlide.GetFileTypeCounts ***
// Get Slide File Types Counters
//
//     Parameters
// APImgCount - pointer to resulting image files counter
// APMediaCount - pointer to resulting media files counter
//
function TN_UDCMSlide.GetFileTypeCounts( APImgCount : PInteger = nil;
                                         APMediaCount : PInteger = nil;
                                         APImg3DCount : PInteger = nil ) : Integer;
begin
  Result := 1;
  with P^.CMSDB do
  if cmsfIsMediaObj in SFlags then
  begin
    if APMediaCount <> nil then
      Inc(APMediaCount^)
  end
  else
  if cmsfIsImg3DObj in SFlags then
  begin
// 2020-07-28 add Capt3DDevObjName <> '' if (APImg3DCount <> nil) and (Capt3DDevObjName = '') then
// 2020-09-25 add new condition for Dev3D objs
   if (APImg3DCount <> nil) and ((Capt3DDevObjName = '') or (MediaFExt = '')) then
    Inc(APImg3DCount^)
  end
  else
  begin
    if APImgCount <> nil then
      Inc(APImgCount^);
  end;
end; // function TN_UDCMSlide.GetFileTypeCounts

//******************************************** TN_UDCMSlide.SetInitDCMAttrs ***
// Set Slide Initial DICOM Attributes
//
//     Parameters
// APDICOMAttrs - pointer to slide DICOM attributes
//
procedure TN_UDCMSlide.SetInitDCMAttrs( APDCMAttrs: TK_PCMDCMAttrs );
begin
  if APDCMAttrs = nil then Exit;
  with P^, CMSDB, APDCMAttrs^ do
  begin
    if (cmsfIsMediaObj in SFlags) or
       (cmsfIsImg3DObj in SFlags) then Exit;

    DCMModality := CMDCMModality; // DICOM Modality
    if  not (cmsfGreyScale in SFlags)    or
       (DCMModality = '') or
       (DCMModality = K_CMSlideDefDCMModColorXC) or
       (DCMModality = K_CMSlideDefDCMModColorES) or
       (DCMModality = K_CMSlideDefDCMModColorGM) then Exit;

    DCMKVP      := CMDCMKVP;      // DICOM KVP - Peak kilo voltage output of the x-ray generator used
    DCMExpTime  := CMDCMExpTime;  // DICOM ExposureTime - Time of x-ray exposure in msec
    DCMTubeCur  := CMDCMTubeCur;  // DICOM Integer TubeCurrent - X-Ray Tube Current in mA
//      DCMTubeCurF := CMDCMTubeCurF; // DICOM Float TubeCurrent - X-Ray Tube Current in mA
//      DCMRDoseF   := CMDCMRDoseF;   // DICOM RadiationDose     - X-Ray Radiation Dose in mGy
  end;
end; // procedure TN_UDCMSlide.SetInitDCMAttrs

//*********************************************** TN_UDCMSlide.InitSelfName ***
// Init Self Name
//
procedure TN_UDCMSlide.InitSelfName();
begin
  ObjName := IntToStr(K_CMEDAccess.CurSlidesList.Count) + 'new';
end; // procedure TN_UDCMSlide.InitSelfName

//********************************************* TN_UDCMSlide.ECacheInitName ***
// Init Slide ECache main file name
//
procedure TN_UDCMSlide.ECacheInitName();
var
  ECFPath: string;
begin
//  ECFPath := K_ExpandFileName('(#CMECacheFiles#)');
  ECFPath := K_CMGetECacheFilesPath();
  if not DirectoryExists(ECFPath) then
    K_ForceDirPath(ECFPath);
  CMSlideECFName := format('%sF%s_%d_%d_%s_A.ecd', [ECFPath, GetIDForFileName(),
                           K_CMEDAccess.CurProvID, K_CMEDAccess.CurPatID,
                           K_DateTimeToStr( K_CMEDAccess.EDAGetSyncTimestamp(), 'yymmddhhnnsszzz' )]);
end; // procedure TN_UDCMSlide.ECacheInitName

//************************************************* TN_UDCMSlide.ECacheSave ***
// Save Slide to ECache
//
//     Parameters
// ADumpRTID - CMS application runtime ID for dump
// ASaveMode - Save Mode defines what data will be save to ECache:
//#F
//  0 - saved data is define by Slide state
//  1 - saved data is define by Slide state, but Slide Attributes will be saved
//      unconditionally
//  2 - saved data is define by Slide state except Original Image,
//      Current Image will be saved unconditionally
// -1 - saved data is define by Slide state except Original Image,
//      but Slide attributes will be saved unconditionally and
//      and Original Image will be saved if has not been saved earlier
//#/F
//
procedure TN_UDCMSlide.ECacheSave( ADumpRTID : Integer; ASaveMode : Integer = 0 );
var
  ECFName: string;
  ECFlags: Integer;
  UDThumb: TN_UDBase;
  UDMapRoot: TN_UDBase;
  PData: Pointer;
  DSize: Integer;
  // ECFNameInd : Integer;
  ECFNameR, ECFNameS: string;
  SrcDIBObj: TN_DIBObj;
  SrcUDDIBObj: TN_UDDIB;
  CurUDDIBObj: TN_UDDIB;

  PCMSlide: TN_PCMSlide;
  PCDIBN : TN_PCDIBN;
  InitUDData : TN_BArray;
  PSelfCMSlide: TN_PCMSlide;
label LExit;
begin


  // if cmsfIsMediaObj in AUDSlide.P.CMSDB.SFlags  then Exit;
  PSelfCMSlide := P();
  if (cmsfSkipChangesSave in PSelfCMSlide.CMSRFlags) then
    goto LExit;

  if (ObjName[Length(ObjName)] = 'w') and
      not (cmsfIsNew in PSelfCMSlide.CMSRFlags) then
    raise Exception.Create( format( 'DB>> ECache new SLide save error ID=%s Flags=%d',
                                    [ObjName, Word(PSelfCMSlide.CMSRFlags)] ) );

  if CMSlideECFName = '' then // Build Slide ECache Name
    ECacheInitName();

  ECFName := CMSlideECFName;

  ECFlags := Byte(CMSlideECSFlags);
  N_Dump2Str(format( 'DB>> Save Slide to ECache ECSFlags=%d ActRTID=%d', [ECFlags, ADumpRTID]));

  if cmssfIsNew in CMSlideECSFlags then
    CMSlideECSFlags := CMSlideECSFlags +
      [cmssfAttribsChanged, cmssfMapRootChanged, cmssfCurImgChanged];

  if (cmssfAttribsChanged in CMSlideECSFlags) or
     (cmssfCurImgChanged  in CMSlideECSFlags) or
     (cmssfMapRootChanged in CMSlideECSFlags) or
     (ASaveMode <> 0) then
  begin
    // Save Main Slide ECache File
    N_Dump2Str(format( 'DB>> Save Slide Attrs File="%s"', [ECFName]));

    // Set Slide Attributes to ECache Object
    CMSUndoBuf.UBSetSlideChangeDataFlags();
    K_CMEDAccess.SlideECRoot.ObjName := ObjName;
    PCMSlide := K_CMEDAccess.SlideECRoot.P;
    PCMSlide^ := PSelfCMSlide^;
    PCMSlide^.CMSRFlags := PCMSlide^.CMSRFlags - [cmsfIsLocked, cmsfSkipUnlock,
      cmsfIsUsed, cmsfHideDrawings, cmsfIsOpened, cmsfIsPrinting];
    // Link Slide Thumbnail Object to ECache Object
    UDThumb := GetThumbnail();
    K_CMEDAccess.SlideECRoot.PutDirChildSafe(K_CMSlideIndThumbnail, UDThumb);
    UDThumb.Owner := K_CMEDAccess.SlideECRoot;

    // Link Slide MapRoot Object to ECache Object
    UDMapRoot := DirChild(K_CMSlideIndMapRoot);
    if UDMapRoot <> nil then
    begin
      PrepROIView([K_roiClearRefs]); // Clear Slide ROI
      K_CMEDAccess.SlideECRoot.PutDirChildSafe(K_CMSlideIndMapRoot, UDMapRoot);
      UDMapRoot.Owner := K_CMEDAccess.SlideECRoot;
    end;

//N_T1.Start;

    // Save Main Slide SubTree To File
{} // Text Slide Format
    K_SaveTreeToText( K_CMEDAccess.SlideECRoot, K_SerialTextBuf );
    K_CMEDAccess.StrTextBuf := K_SerialTextBuf.TextStrings.Text;
    DSize := Length(K_CMEDAccess.StrTextBuf);
//    if SizeOf(Char) = 2 then
//      DSize := DSize shl 1;
    PData := @K_CMEDAccess.StrTextBuf[1];
{
    with  K_GetFormTextEdit( nil ) do
      EditStrings( K_SerialTextBuf.TextStrings, 'All Form Texts',
                                      TRUE, TRUE );
}

    if CMSlideECFStream = nil then
    // Open CMSlideECFStream not DesignMode
//      CMSlideECFStream := TFileStream.Create(CMSlideECFName, fmOpenWrite);
      CMSlideECFStream := TFileStream.Create( CMSlideECFName, fmCreate );
    K_DFStreamWriteAll( CMSlideECFStream, K_DFCreateProtected, PData,
                                                      DSize * SizeOf(Char) );

//    FlushFileBuffers( CMSlideECFStream.Handle );
    if not FlushFileBuffers(CMSlideECFStream.Handle) then
     N_Dump1Str( format( '!!! File %s >> FlushFileBuffers Error >> %s', [CMSlideECFName,SysErrorMessage(GetLastError())] ) );
    N_Dump2Str( 'DB>> Slide Attrs File done' );

    //    FreeAndNil( CMSlideECFStream ); // skip Stream close to prevent process "active" Slides by ECache Restore Routines

//N_T1.SS( 'ECache ' );

    // Clear Slide Thumbnail Object Link to ECache Object
    UDThumb.Owner := Self;
    K_CMEDAccess.SlideECRoot.PutDirChild(K_CMSlideIndThumbnail, nil);

    // Clear Slide MapRoot Object Link to ECache Object
    if UDMapRoot <> nil then
    begin
      UDMapRoot.Owner := Self;
      K_CMEDAccess.SlideECRoot.PutDirChild(K_CMSlideIndMapRoot, nil);
      // Restore Slide ROI
      PrepROIView([K_roiRestoreIfImage]);
    end;
    PCMSlide^.CMSHist := nil; // Clear History Events RArray after Use

  end; // end of Save Main Slide ECache File

  with PSelfCMSlide.CMSDB do
  if (cmsfIsImg3DObj in SFlags) and
     (MediaFExt <> '')          and
     (Capt3DDevObjName = '') then
// 2020-07-28 add Capt3DDevObjName <> '' (PSelfCMSlide.CMSDB.MediaFExt <> '')          and
//                                       (PSelfCMSlide.CMSDB.Capt3DDevObjName = '') then
// 2020-09-25 add new condition for Dev3D objs
  begin // Do only for Self stored 3D objects only (not for Device 3D)
    if not K_ForceDirPath( MediaFExt ) then
      raise Exception.Create( format('DB>> ECache 3D Slide force TMP path error >> "%s"',
                                     [MediaFExt]) );
  end;

  if (cmsfIsMediaObj in PSelfCMSlide.CMSDB.SFlags) or
     (cmsfIsImg3DObj in PSelfCMSlide.CMSDB.SFlags) or
     (ASaveMode  = 1) then
    goto LExit;

  ECFNameR := ECFName;
  ECFNameR[Length(ECFNameR) - 4] := 'R';
  ECFNameS := ECFName;
  ECFNameS[Length(ECFNameS) - 4] := 'S';

  CurUDDIBObj := nil;
  if (ASaveMode = 2)                         or
     (cmssfCurImgChanged in CMSlideECSFlags) or
     (not FileExists(ECFNameR) and (K_CMEDAccess.EDAGetSlideCurImage0(Self) = K_edOK)) then
  begin
    // Load CurImage if absent for saving in ECache
    // 07.01.2010       (EDAGetSlideCurImage( AUDSlide, TRUE ) <> K_edAbsentData) ) then begin
    // CurImg was changed or it is not saved to ECach and is Loaded for (full Cache creation)

    N_Dump2Str( 'DB>> Start Save Slide Image' );

    if ASaveMode  = 0 then
    begin
      // Check if SrcImg Saving is needed
      if CMSUndoBuf.UBGetSrcImgCreationIsNeeded() then
      begin
        if not FileExists(ECFNameS) and FileExists(ECFNameR) then
        begin
          // Copy Cur Img To Origial Img for New Slide (before any changes)
          K_CopyFile(ECFNameR, ECFNameS);
          N_Dump2Str(format(
              'DB>> Copy Slide Cur Image file to Original ECache="%s" ActRTID=%d',
              [ECFNameS, ADumpRTID]));
        end;
      end;
    end; // if ASaveMode  = 0 then

    // Save Cur Image
    CurUDDIBObj := GetCurrentImage( FALSE, TRUE ); // needed to skip DIBObj Creation if UDData Exists

    GetCurrentImageSData(PData, DSize);

    K_DFWriteAll(ECFNameR, K_DFCreateProtected, PData, DSize);

    N_Dump2Str(format('DB>> Save Slide Cur Img to ECache="%s" ActRTID=%d',
        [ECFNameR, ADumpRTID]));

    if ASaveMode = 2 then goto LExit;

  end; // fin Save Slide Image

  if not FileExists(ECFNameS) then
  begin
    PData := nil;
    if CMSUndoBuf <> nil then
    begin
      SrcDIBObj := CMSUndoBuf.UBGetSrcImageDIB( @InitUDData );
      if SrcDIBObj <> nil then
      begin
        // Get Original Image from Undo Buffer
        N_Dump2Str('DB>> Get Slide Original Img Data 0' );
        SrcUDDIBObj := N_CreateUDDIB(N_CMDIBURect, [], '', 'SrcImg');
        SrcUDDIBObj.DIBObj := SrcDIBObj;
        SrcUDDIBObj.UDData := InitUDData;
        PCDIBN := CurUDDIBObj.PISP;
        with SrcUDDIBObj.PISP^ do
        begin
          if Length(InitUDData) > 0 then
            CDIBFlagsN := [uddfnUseUDData] // Original UDDIB should have Initial UDData - skip UDData Clear
          else
            CDIBFlagsN := [uddfnUseUDData, uddfnFreeUDData];
          CDIBDataFormat := PCDIBN^.CDIBDataFormat;
          CDIBJPEGQuality := PCDIBN^.CDIBJPEGQuality;
        end;
        K_CMGetUDDIBSData( SrcUDDIBObj, PData, DSize );
        SrcUDDIBObj.Free;
      end;
    end; // if SrcDIBObj <> nil then

    if (PData = nil) and
       (K_CMEDAccess.EDAGetSlideSrcImage(Self,TRUE) <> K_edAbsentData) then
    begin
      // Get Original Image from Src UDDIB if it is Loaded
      N_Dump2Str('DB>> Get Slide Original Data 1' );
      GetSourceImageSData(PData, DSize);
    end;

    if PData <> nil then
    begin
      K_DFWriteAll(ECFNameS, K_DFCreateProtected, PData, DSize);
      N_Dump2Str(format(
          'DB>> Save Slide Original Img to ECache="%s" ActRTID=%d',
          [ECFNameS, ADumpRTID]));
    end;
  end; // if not FileExists(ECFNameS) then

LExit :
  CMSlideECSFlags := [];

end; // TN_UDCMSlide.ECacheSave

//************************************************ TN_UDCMSlide.ECacheClear ***
// Clear Slide ECache
//
procedure TN_UDCMSlide.ECacheClear( ADumpRTID : Integer );
var
  ECFPat: string;
  ECPath: string;

begin
  if CMSlideECFName = '' then
    Exit;
  ECPath := ExtractFilePath(CMSlideECFName);
  ECFPat := ChangeFileExt(ExtractFileName(CMSlideECFName), '');
  ECFPat := Copy(ECFPat, 1, Length(ECFPat) - 1) + '*.*';

  N_Dump2Str(format('DB>> Clear Slide ECache="%s" ActRTID=%d',
                    [ECPath + ECFPat, ADumpRTID]));
  // clear CMSlideECFName content to prevent ECache use while it is deleting
  if CMSlideECFStream = nil then
    CMSlideECFStream := TFileStream.Create(CMSlideECFName, fmOpenWrite);
  CMSlideECFStream.Size := 0;
  FreeAndNil(CMSlideECFStream);
  with P^ do
    if cmsfIsMediaObj in CMSDB.SFlags then
    begin  // Video
      if CMSDB.MediaFExt[1] <> '.' then
      begin
        K_DeleteFile(CMSDB.MediaFExt); // Del Video File
      end;
      K_DeleteFile(CMSlideECFName); // Del ECache Main File
    end
    else
    if cmsfIsImg3DObj in CMSDB.SFlags then
    begin  // 3D Image
// 2020-07-28 add Capt3DDevObjName <> '' if CMSDB.Capt3DDevObjName = '' then // Delete Folder with 3D Tmp Files - not actual for Device 3D objects
// 2020-09-25 add new condition for Dev3D objs
        if CMSDB.Capt3DDevObjName = '' then
          K_CMImg3DTmpFilesClear ( CMSDB.MediaFExt );
{
      if (CMSDB.MediaFExt <> '') and
         DirectoryExists( CMSDB.MediaFExt ) then
      begin // Delete Temporary 3D folder
        K_CMEDAccess.TmpStrings.Clear();
        K_DeleteFolderFilesEx( CMSDB.MediaFExt, K_CMEDAccess.TmpStrings );
        if K_CMEDAccess.TmpStrings.Count > 0 then
        begin
          N_Dump1Str( 'DB>> Clear 3D Slide TmpFiles couldn''t delete:'#13#10 +
                      K_CMEDAccess.TmpStrings.Text );
          raise Exception.Create( 'Clear 3D Slide TmpFiles');
        end;
        RemoveDir( CMSDB.MediaFExt );
        // Remove All Parent Directories if needed
        if TK_CMEDDBAccess(K_CMEDAccess).SlidesImg3DRootFolder <> '' then
          K_CMEDAccess.EDARemovePathFolders0( ExcludeTrailingPathDelimiter(CMSDB.MediaFExt),
                    TK_CMEDDBAccess(K_CMEDAccess).SlidesImg3DRootFolder );
      end; // if Temporary 3D folder Exists
}
      K_DeleteFile(CMSlideECFName); // Del ECache Main File
    end
    else  // 2D Image
      K_DeleteFolderFiles(ECPath, ECFPat, []); // Del ECache Main + Image Files
  CMSlideECFName := '';
end; // procedure TN_UDCMSlide.ECacheClear

//*********************************************** TN_UDCMSlide.ECacheToFile ***
// Copy/move Current file from ECache to File Storage
//
//     Parameters
// AFName - path file in storage folder
// AFNamePar - image file name parameter
// Result - Returns file size or value <= 0
//#F
//  0 - ecache is absent
// -1 - file is absent
// -2 - file copy|move fails
//#/F
//
function TN_UDCMSlide.ECacheToFile( const AFName : string; AFNamePar : char ) : Integer;
var
  ECFName : string;
  RC : TK_CMEDResult;
  F: File;
begin
// Result:=-2;Exit; // Debug

  Result := 0;
  if CMSlideECFName = '' then Exit;

  ECFName := CMSlideECFName;
  ECFName[Length(ECFName) - 4] := AFNamePar;

  Result := -1;
  if not FileExists( ECFName ) then Exit;

  Result := -2;
  try
    AssignFile( F, ECFName );
    Reset( F, 1 );
    Result := FileSize( F );
    Close( F );
  except
    N_Dump1Str( format( '!!! Slide.ECacheToFile >> Get File %s Size Error', [ECFName] ) );
    Exit;
  end;

  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    RC := K_edFails;
    if SameText( ExtractFileDrive(ECFName), ExtractFileDrive(AFName) ) then
    begin
    // move
      RC := EDARenameFileOnServer( ECFName, AFName, SlidesImgRootFDA );
      if RC <> K_edOK then
        N_Dump1Str( format( '!!! Slide.ECacheToFile >> Rename Error: %s >> %s', [ECFName,AFName] ) );
    end;

    if RC <> K_edOK then
    begin
    // Copy
      RC := EDACopyFileOnServer( ECFName, AFName, SlidesImgRootFDA );
      if RC <> K_edOK then
        N_Dump1Str( format( '!!! Slide.ECacheToImageFile >> Copy Error: %s >> %s', [ECFName,AFName] ) );
    end;
  end;
  if RC <> K_edOK then
    Result := -2;
end; // function TN_UDCMSlide.ECacheToFile

//*************************************** TN_UDCMSlide.ECacheToCurImageFile ***
// Copy/move Current Image file from ECache to File Storage
//
//     Parameters
// APath - path file storage folder
// Result - Returns file size or value <= 0
//#F
//  0  - ecache is absent
// -1 - file is absent
// -2 - file copy|move fails
//#/F
//
function TN_UDCMSlide.ECacheToCurImageFile( const APath : string; var AFileName : string ) : Integer;
begin
  if AFileName = '' then
    AFileName := GetCurImgFileName( APath );
  Result := ECacheToFile( AFileName, 'R' );
end; // function TN_UDCMSlide.ECacheToCurImageFile

//*************************************** TN_UDCMSlide.ECacheToSrcImageFile ***
// Copy/move Source Image file from ECache to File Storage
//
//     Parameters
// APath - path file storage folder
// Result - Returns file size or value <= 0
//#F
//  0  - ecache is absent
// -1 - file is absent
// -2 - file copy|move fails
//#/F
//
function TN_UDCMSlide.ECacheToSrcImageFile( const APath : string; var AFileName : string ) : Integer;
begin
  if AFileName = '' then
    AFileName := GetSrcImgFileName( APath );
  Result := ECacheToFile( AFileName, 'S' );
end; // function TN_UDCMSlide.ECacheToSrcImageFile

//*************************************** TN_UDCMSlide.ECacheToDCMAttrsFile ***
// Copy/move DCM attrs file from ECache to File Storage
//
//     Parameters
// APath - path file storage folder
// Result - Returns file size or value <= 0
//#F
//  0  - ecache is absent
// -1 - file is absent
// -2 - file copy|move fails
//#/F
//
function TN_UDCMSlide.ECacheToDCMAttrsFile( const APath : string; var AFileName : string ) : Integer;
begin
  if AFileName = '' then
    AFileName := GetDCMFileName( APath );
  Result := ECacheToFile( AFileName, 'D' );
end; // function TN_UDCMSlide.ECacheToDCMAttrsFile

//******************************************** TN_UDCMSlide.SaveAttrsToFile ***
// Save Slide Atributes to file
//
//     Parameters
// AFName - Attributes File Name
// ASaveToArchiveFlag - if TRUE then Slide Thumbnail should be saved to file
//
// Slide Thumbnail should be get from DB before call to this object
//
procedure TN_UDCMSlide.SaveAttrsToFile( const AFName : string; ASaveToArchiveFlag : Boolean );
var
  PData: Pointer;
  DSize: Integer;
  UDThumb,  UDCurImg, UDSrcImg : TN_UDBase;
begin

  // Clear Slide ROI for MapRoot saving
  PrepROIView([K_roiClearRefs]);

  // Clear Reference to Thumbnail
  if ASaveToArchiveFlag then
    UDThumb := nil
  else
    UDThumb := DirChild(K_CMSlideIndThumbnail);

  if UDThumb <> nil then
  begin
    Inc(UDThumb.RefCounter);
    PutDirChild(K_CMSlideIndThumbnail, nil);
  end;

  // Clear Reference to Current Image
  UDCurImg := DirChild(K_CMSlideIndCurImg);
  if UDCurImg <> nil then
  begin
    Inc(UDCurImg.RefCounter);
    PutDirChild(K_CMSlideIndCurImg, nil);
  end;

  // Clear Reference to Original Image
  UDSrcImg := DirChild(K_CMSlideIndSrcImg);
  if UDSrcImg <> nil then
  begin
    Inc(UDSrcImg.RefCounter);
    PutDirChild(K_CMSlideIndSrcImg, nil);
  end;

  // Save Slide Attrs, MapRoot and Thumbnail to File
  K_SaveTreeToText( Self, K_SerialTextBuf );
  K_CMEDAccess.StrTextBuf := K_SerialTextBuf.TextStrings.Text;
//K_GetFormTextEdit.EditText(K_CMEDAccess.StrTextBuf);

  DSize := Length(K_CMEDAccess.StrTextBuf);
  if SizeOf(Char) = 2 then
    DSize := DSize shl 1;
  PData := @K_CMEDAccess.StrTextBuf[1];

  K_DFWriteAll( AFName, K_DFCreateProtected, PData, DSize );
  N_Dump2Str( format( 'DB>> SaveAttrsToFile DSize=%d %s', [DSize, AFName] ) );

  // Restore Slide ROI after MapRoot saving
  PrepROIView([K_roiRestoreIfImage]);

  // Restore Reference to Thumbnail after saving
  if UDThumb <> nil then
  begin
    Dec(UDThumb.RefCounter);
    PutDirChild(K_CMSlideIndThumbnail, UDThumb);
  end;

  // Restore Reference to Current Image after saving
  if UDCurImg <> nil then
  begin
    Dec(UDCurImg.RefCounter);
    PutDirChild(K_CMSlideIndCurImg, UDCurImg);
  end;

  // Restore Reference to Original Image after saving
  if UDSrcImg <> nil then
  begin
    Dec(UDSrcImg.RefCounter);
    PutDirChild(K_CMSlideIndSrcImg, UDSrcImg);
  end;

end; // TN_UDCMSlide.SaveAttrsToFile


// ********** TN_UDCMStudy class methods  **************

//***************************************************** TN_UDCMStudy.Create ***
//
constructor TN_UDCMStudy.Create;
begin
  inherited Create;
  ClassFlags := (ClassFlags and $FFFFFF00) or N_UDCMStudyCI;
  ImgInd := 86;
end; // end_of constructor TN_UDCMStudy.Create

//************************************************* TN_UDCMStudy.GetMapRoot ***
// Get Study MapRoot
//
//     Parameters
// Result - Returns Study MapRoot
//
function TN_UDCMStudy.GetMapRoot( ): TN_UDCompVis;
begin
  Result := inherited GetMapRoot();

  if Self = nil then  Exit;

  if K_CMEDAccess.EDAStudyGetMapRoot(Self) <> K_edOK then
  begin
    PutDirChild(K_CMSlideIndMapRoot, nil);
    Exit;
  end;
  Result := TN_UDCompVis(DirChild(K_CMSlideIndMapRoot));
  if CMSStudyItemsCount = 0 then
    CMSStudyItemsCount := Result.DirLength();
end; // function TN_UDCMStudy.GetMapRoot

//********************************************** TN_UDCMStudy.InitByMapRoot ***
// Init Self Runtime Fields by MapRoot
//
//     Parameters
// Result - Returns Study MapRoot
//
procedure TN_UDCMStudy.InitByMapRoot;
var
  MapRoot : TN_UDCompVis;
begin
  MapRoot := GetMapRoot();

  with P()^, CMSDB do
  begin
    PixPermm := Round( 72*100/2.54 ) / 1000;
    with MapRoot.PCCS()^ do
    begin
      PixWidth := Round(SRSize.X);
      PixHeight := Round(SRSize.Y);
    end;
    BytesSize := PixHeight * PixWidth * 3;
  end;
  if CMSStudyItemsCount = 0 then
    CMSStudyItemsCount := MapRoot.DirLength();
end; // function TN_UDCMStudy.InitByMapRoot

//*********************************************** TN_UDCMStudy.InitBySample ***
// Init Self Runtime Fields by MapRoot
//
//     Parameters
// Result - Returns Study MapRoot
//
procedure TN_UDCMStudy.InitBySample;
var
  StudySample : TN_UDBase;
  MapRoot : TN_UDBase;
begin
  if DirChild(K_CMSlideIndMapRoot) <> nil then Exit;
  // Get Study Sample from Lib
  StudySample := K_CMEDAccess.ArchStudySamplesLibRoot.DirChildByObjName( IntToStr(CMSStudySampleID) );
  Assert( StudySample <> nil, format( 'Study SampleID=%d is absent', [CMSStudySampleID] ) );
  PutDirChildSafe( K_CMStudyIndSrcSample, StudySample ); // Reference to Source Sample

  // Copy Sample MapRoot
  K_SaveTreeToMem( StudySample.DirChild(K_CMSlideIndMapRoot), N_SerialBuf, false, [K_lsfJoinAllSLSR] );
  MapRoot := K_LoadTreeFromMem(N_SerialBuf, [K_lsfJoinAllSLSR]);
  PutDirChildSafe( K_CMSlideIndMapRoot, MapRoot );

  InitByMapRoot();
end; // function TN_UDCMStudy.InitBySample

//********************************************** TN_UDCMStudy.CreateMapRoot ***
// Create Study MapRoot
//
//     Parameters
// Result - Returns Study MapRoot
//
function TN_UDCMStudy.CreateMapRoot: TN_UDCompVis;
begin
   Result := nil;

end; // function TN_UDCMStudy.CreateMapRoot

//******************************************** TN_UDCMStudy.CreateThumbnail ***
// Create Self Thumbnail, and replace existing Thumbnail or
// (if absent) add it as Self zero Child and return it
//
function TN_UDCMStudy.CreateThumbnail(): TN_UDDIB;
var
  ThumbDIBObj: TN_DIBObj;
  MapRoot : TN_UDCompVis;
begin
  MapRoot := GetMapRoot();
  ThumbDIBObj := K_CMBStudyCreateThumbnailDIBByMapRoot( MapRoot );
  Result := SetThumbnailByDIB( ThumbDIBObj );
  // Include( P().CMSRFlags, cmsfThumbChanged );
end; // procedure TN_UDCMStudy.CreateThumbnail

//********************************************* TN_UDCMStudy.SetChangeState ***
// Set Study changed state
//
procedure TN_UDCMStudy.SetChangeState();
begin
  with P^ do
  begin
    CMSRFlags := CMSRFlags + [cmsfAttribsChanged, cmsfMapRootChanged];
    CMSDTMapRootMod := K_CMEDAccess.EDAGetSyncTimestamp();
    CMSProvIDModified := K_CMEDAccess.CurProvID; // Provider ID Modified
    CMSLocIDModified  := K_CMEDAccess.CurLocID; // Location ID Modified
    CMSCompIDModified := K_CMSServerClientInfo.CMSClientVirtualName;
  end;
end; // procedure TN_UDCMStudy.SetChangeState

//******************************************* TN_UDCMStudy.GetStudyFileName ***
// Get Study File Name
//
//     Parameters
// Result - Returns Study File Name
//
function TN_UDCMStudy.GetFileName(const APath: string): string;
begin
  Result := APath + K_CMStudyGetFileName( ObjName );
end; // function TN_UDCMStudy.GetCurImgFileName

//************************************************ TN_UDCMStudy.ExportToDIB ***
// Export Study to DIB
//
//     Parameters
// AExportFlags - export image flags
//#F
// bit0 (0001) - export Original Image (not used)
// bit1 (0002) - skip TrueColor Image conversion to Grey if its pixels are realy Grey
//#/F
// AMaxWidth   - resulting maximal Width, if =0 the Slide Width is used
// AMaxHeight  - resulting maximal Height, if =0 the Slide Height is used
// Result - Returns DIB object
//
// Create DIBObj of Study actual size and draw Self to it
//
function TN_UDCMStudy.ExportToDIB( AExportFlags : TK_CMBSlideExportToDIBFlags = [];
                                   AMaxWidth : Integer = 0;
                                   AMaxHeight : Integer = 0 ): TN_DIBObj;
var
  ExpParams: TN_ExpParams;
  DIBRect: TRect;
  MapRoot: TN_UDCompBase;
  RGBDiff : Double;
  TmpDIB: TN_DIBObj;
  FCSize : TPoint;
  FPixPermm : Float;
  ChangingSizeIsNeeded : Boolean;

begin

  MapRoot := GetMapRoot();

  ExpParams := N_DefExpParams;

  with ExpParams, EPImageFPar do
  begin
    EPImageExpMode := iemJustDraw;
    EPExecFlags := EPExecFlags + [epefHALFTONE];

    IFPPixFmt := pf24bit;
    with P()^.CMSDB do
    begin
{}
      FCSize := IPoint(TN_UDCompVis(MapRoot).PCCS.SRSize);
      FPixPermm := PixPermm;
      if AMaxWidth = 0 then AMaxWidth := FCSize.X;
      if AMaxHeight = 0 then AMaxHeight := FCSize.Y;
      ChangingSizeIsNeeded := ((AMaxWidth < FCSize.X) or (AMaxHeight < FCSize.Y));
      if not ChangingSizeIsNeeded then
        IFPSizePix := FCSize
      else
        IFPSizePix := N_AdjustSizeByAspect( aamDecRect, Point( AMaxWidth,AMaxHeight ),
                                            FCSize.Y / FCSize.X );

      FPixPermm := FPixPermm * IFPSizePix.X / FCSize.X;

      IFPSizemm := FPoint(IFPSizePix.X / FPixPermm, IFPSizePix.Y / FPixPermm);

      DIBRect := IRect(IFPSizePix.X, IFPSizePix.Y);
{}
{
      IFPSizePix := IPoint(TN_UDCompVis(MapRoot).PCCS.SRSize);
      IFPSizemm := FPoint(IFPSizePix.X / PixPermm, IFPSizePix.Y / PixPermm);
      DIBRect := IRect(IFPSizePix.X, IFPSizePix.Y);
{}
      Result := TN_DIBObj.Create(IFPSizePix.X, IFPSizePix.Y, pf24bit);
      with Result.DIBInfo.bmi do
      begin
        biXPelsPerMeter := Round(PixPermm * 1000);
        biYPelsPerMeter := biXPelsPerMeter;
      end;
    end;
    with TN_GlobCont.Create() do
    begin
      ExecuteRootComp(MapRoot, [], nil, nil, @ExpParams, K_CMSStudyExportBGColor );
      N_StretchRect(Result.DIBOCanv.HMDC, DIBRect, DstOCanv.HMDC, DstPixRect);
      Free;
    end;
  end; // with ExpParams.EPImageFPar do

  if not( K_bsedSkipConvColorToGrey in AExportFlags) then
  begin // Convert To Grey if needed
    // Check if Result DIB should be converted to Gray format
    RGBDiff := Result.GetMaxRGBDif(0);
    if RGBDiff <= 0 then // Convert Result DIB to Gray
    begin
      TmpDIB := TN_DIBObj.Create(Result, 0, pfCustom, -1, epfGray8);
      Result.CalcGrayDIB( TmpDIB );
      Result.Free();
      Result := TmpDIB;
    end
  end;

end; // end of TN_UDCMStudy.ExportToDIB

//****************************************** TN_UDCMStudy.GetSlidesPixRects ***
// Get Study Items Slides and Pix Rects
//
//     Parameters
// ASlides - Study Items Slides Array
// APixRects - Study Items Pix Rects Array
//
// Should be used just after ExportToDIB
//
procedure TN_UDCMStudy.GetSlidesPixRects( var ASlides : TN_UDCMSArray; var APixRects : TN_IRArray );
var
  Slide : TN_UDCMSlide;
  MapRoot, Item : TN_UDBase;
  i, h, Count : Integer;
begin
  if Self = nil then
  begin
    ASlides := nil;
    Exit; // precaution
  end;

  MapRoot := GetMapRoot( );
  h := MapRoot.DirHigh;
  SetLength( APixRects, h + 1 );
  SetLength( ASlides, h + 1 );
  Count := 0;
  for i := 0 to h do
  begin
    Item := MapRoot.DirChild(i);
    Slide := K_CMStudyGetOneSlideByItem( Item );
    if Slide = nil then Continue;
    ASlides[i] := Slide;
    APixRects[i] := TN_UDCompVis(Item).CompOuterPixRect;
    Inc(Count);
  end;
  SetLength( APixRects, Count );
  SetLength( ASlides, Count );

end; // procedure TN_UDCMStudy.GetSlidesPixRects

//**************************************** TN_UDCMStudy.GetCurSlidesToArray ***
// Get Study Slides to Given Array
//
//     Parameters
// ASlides - Slides array to add
// AStartInd - Slides array start ind to add
// Result - Returns resulting Array Slides number
//
function  TN_UDCMStudy.GetCurSlidesToArray( var ASlides : TN_UDCMSArray; AStartInd : Integer = 0 ): Integer;
var
  i : Integer;
  MapRoot : TN_UDBase;
  Slide : TN_UDCMSlide;
  Capacity : Integer;
begin
  MapRoot := GetMapRoot();
  Result := AStartInd;
  Capacity := Length(ASlides);
  for i := 0 to MapRoot.DirHigh do
  begin
    Slide := K_CMStudyGetOneSlideByItem( MapRoot.DirChild(i) );
    if Slide = nil then Continue;
    if K_NewCapacity( Result + 1,  Capacity ) then
      SetLength(ASlides, Capacity);
    ASlides[Result] := Slide;
    Inc(Result);
  end;
end; // function  TN_UDCMStudy.GetCurSlidesToArray

//*********************************** TN_UDCMStudy.GetSelectedSlidesToArray ***
// Get Selected Study Slides to Given Array
//
//     Parameters
// ASlides - Slides array to add
// AStartInd - Slides array strat ind to add
// Result - Returns resulting Array Slides number
//
function  TN_UDCMStudy.GetSelectedSlidesToArray( var ASlides : TN_UDCMSArray; AStartInd : Integer = 0 ): Integer;
var
  i, MaxInd, NewMaxInd : Integer;
begin
  Result := AStartInd;
  MaxInd := Length(ASlides);
  N_Dump2Str( format( 'Study >> GetSelected ID=%s SelCount=%d', [Self.ObjName,CMSSelectedCount]));
  for i := 0 to CMSSelectedCount - 1 do
  begin
    if Result >= MaxInd then
    begin
    // Increase Array
      NewMaxInd := MaxInd + (MaxInd shr 2);
      if NewMaxInd = MaxInd then NewMaxInd := MaxInd + 3;
      MaxInd := NewMaxInd;
      SetLength(ASlides, MaxInd);
    end;
{
    N_Dump2Str( format( 'Study >> GetSelected Ind=%d, Item=%s', [Result,CMSSelectedItems[i].GetUName()]));
    N_Dump2Str( 'Study >> GetSelected 1 ' + CMSSelectedItems[i].DirChild(0).GetUName() );
    N_Dump2Str( 'Study >> GetSelected 2 ' + CMSSelectedItems[i].DirChild(0).DirChild(0).GetUName() );
    N_Dump2Str( 'Study >> GetSelected 3 ' + CMSSelectedItems[i].DirChild(0).DirChild(0).DirChild(0).GetUName() );
}
    ASlides[Result] := K_CMStudyGetOneSlideByItem( CMSSelectedItems[i] );
    if ASlides[Result] <> nil then
      Inc(Result);
  end;
end; // function  TN_UDCMStudy.GetSelectedSlidesToArray

//**************************************** TN_UDCMStudy.GetAllSlidesToArray ***
// Get Study Slides to Given Array
//
//     Parameters
// ASlides - Slides array to add
// AStartInd - Slides array start ind to add
// Result - Returns resulting Array Slides number
//
procedure TN_UDCMStudy.GetAllSlidesToArray( out ASlides : TN_UDCMSArray );
var
  i, Ind : Integer;
  MapRoot : TN_UDBase;

begin
  MapRoot := GetMapRoot();
  Ind := 0;
  ASlides := nil;
  for i := 0 to MapRoot.DirHigh do
    K_CMStudyGetAllSlidesByItem( MapRoot.DirChild(i), ASlides, Ind );

  SetLength( ASlides, Ind );

end; // function  TN_UDCMStudy.GetAllSlidesToArray

//********************************************* TN_UDCMStudy.IfItemSelected ***
// Check if Slide given by Study Item is selected
//
//     Parameters
// AItem - Slide Study Item
// Result - Returns 1 if given Item is selected, else 0
//
// Used by Low Level Screen Cursor maintenance Code
//
function  TN_UDCMStudy.IfItemSelected( AItem : TN_UDBase ) : Integer;
var
  Ind : Integer;
begin
  Result := 0;
  if Length(CMSSelectedItems) = 0 then Exit;
  Ind := K_IndexOfIntegerInRArray( Integer(AItem),
              PInteger(@CMSSelectedItems[0]), CMSSelectedCount );
  if Ind < 0 then Exit;
  Result := 1;
end; // procedure TN_UDCMStudy.IfItemSelected

//*********************************************** TN_UDCMStudy.GetItemIndex ***
// Get given Study Item Index
//
//     Parameters
// ASlide - Slide Study Item to select
// Result - Returns index of given Study Item
//
function  TN_UDCMStudy.GetItemIndex( AItem: TN_UDBase ) : Integer;
begin
  Result := GetMapRoot.IndexOfDEField(AItem);
end; // function  TN_UDCMStudy.GetItemIndex

//****************************************** TN_UDCMStudy.SelectItemByIndex ***
// Add Slide given by Study Item to Selected
//
//     Parameters
// ASlide - Slide Study Item to select
// Result - Returns 1 if New Selected Item is Added,
//                  0 - if Item is already selected,
//                 -1 if Index is out of range
//
// Used by Low Level Screen Cursor maintenance Code
//
function  TN_UDCMStudy.SelectItemByIndex( AItemInd: Integer ) : Integer;
var
  Item : TN_UDBase;
begin
  Result := -1;
  Item := GetMapRoot.DirChild(AItemInd);
  if Item = nil then Exit;
  Result := SelectItem( Item );
end; // procedure TN_UDCMStudy.SelectItemByIndex


//************************************************* TN_UDCMStudy.SelectItem ***
// Add Slide given by Study Item to Selected
//
//     Parameters
// ASlide - Slide Study Item to select
// Result - Returns 1 if New Selected Item is Added, else 0
//
// Used by Low Level Screen Cursor maintenance Code
//
function  TN_UDCMStudy.SelectItem( AItem: TN_UDBase ) : Integer;
var
  PUP: TN_POneUserParam;
  PMarkFlag : PByte;
  Ind : Integer;
begin
  Result := 0;
  if Length(CMSSelectedItems) = 0 then
  begin
    SetLength( CMSSelectedItems, GetMapRoot().DirLength );
    CMSSelectedCount := 0;
  end;
  Ind := K_IndexOfIntegerInRArray( Integer(AItem),
              PInteger(@CMSSelectedItems[0]), CMSSelectedCount );
  if Ind >= 0 then Exit; // Already Selected

  N_Dump2Str('Study >> Select Item=' + AItem.ObjName);
  // Add to selected
  CMSSelectedItems[CMSSelectedCount] := TN_UDCompVis(AItem);
  Inc(CMSSelectedCount);

  // Set Mark Show State
  PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'MarkItemShow');
  PMarkFlag := PByte(PUP.UPValue.P);
  if PMarkFlag^ = 1 then Exit;

  PMarkFlag^ := 1;
  Result := 1;
end; // procedure TN_UDCMStudy.SelectItem

//*********************************************** TN_UDCMStudy.UnSelectItem ***
// Remove Slide given by Study Item from Selected in Study
//
//     Parameters
// ASlide - Slide Study Item to unselect
// Result - Returns 1 if Selected Item is unselected, else 0
//
// Used by Low Level Screen Cursor maintenance Code
//
function  TN_UDCMStudy.UnSelectItem( AItem : TN_UDBase ) : Integer;
var
  PUP: TN_POneUserParam;
  Ind : Integer;
  PMarkFlag : PByte;
begin
  N_Dump2Str('Study >> Unselect Item=' + AItem.ObjName);
  Result := 0;
  if Self = nil then Self := TN_UDCMStudy(AItem.Owner.Owner);
  if Self = nil then Exit;
  if (Length(CMSSelectedItems) = 0) or (CMSSelectedCount = 0) then Exit;
{
  N_SL.Clear;
  for Ind := 0 to CMSSelectedCount - 1 do
    N_SL.Add( CMSSelectedItems[Ind].ObjName );
  N_Dump2Str( 'Study >> Unselect 0 Selected=' + N_SL.CommaText );
}
  Ind := K_IndexOfIntegerInRArray( Integer(AItem),
              PInteger(@CMSSelectedItems[0]), CMSSelectedCount ) + 1;

//  N_Dump2Str( 'Study >> Unselect Ind=' + IntToStr(Ind));

  if Ind = 0 then Exit;

  Result := 1;
  if Ind  < CMSSelectedCount then // Move Other Selected
    Move( CMSSelectedItems[Ind], CMSSelectedItems[Ind - 1], (CMSSelectedCount - Ind) * SizeOf(TN_UDBase) );

  Dec(CMSSelectedCount);

{
  N_Dump2Str('Study >> Unselect SelCount=' + IntToStr(CMSSelectedCount));
  N_SL.Clear;
  for Ind := 0 to CMSSelectedCount - 1 do
    N_SL.Add( CMSSelectedItems[Ind].ObjName );
  N_Dump2Str( 'Study >> Unselect 1 Selected=' + N_SL.CommaText );
}

  // Clear Mark Show State
  PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'MarkItemShow');
  PMarkFlag := PByte(PUP.UPValue.P);
  PMarkFlag^ := 0;
//  if PMarkFlag^ = 0 then Exit;
//  PMarkFlag^ := 0;

end; // procedure TN_UDCMStudy.UnSelectItem

//************************************************ TN_UDCMStudy.ToggleSlide ***
// Toggle Slide given by Study Item Selected State
//
//     Parameters
// ASlide - Slide Study Item to toggle
// Result - Returns 1 if Selected Item is Selected, else 0
//
// Used by Low Level Screen Cursor maintenance Code
//
procedure  TN_UDCMStudy.ToggleSlide( AItem: TN_UDBase );
var
  PUP: TN_POneUserParam;
  PMarkFlag : PByte;
begin
  // Set Mark Show State
  PUP := N_GetUserParPtr(TN_UDCompBase(AItem).R, 'MarkItemShow');
  PMarkFlag := PByte(PUP.UPValue.P);
  if PMarkFlag^ = 1 then
    UnSelectItem(AItem)
  else
    SelectItem(AItem);
end; // procedure TN_UDCMStudy.ToggleSlide

//************************************************** TN_UDCMStudy.SelectAll ***
// Add All Study Slides to Selected
//
//     Parameters
// Result - Returns number of selected Items
//
// Used for all Study Slides programaticaly selection
//
function TN_UDCMStudy.SelectAll( ) : Integer;
var
  PUP: TN_POneUserParam;
  i : Integer;
  MapRoot : TN_UDBase;
  Item : TN_UDBase;
begin
  N_Dump2Str('Study >> Select All');
  MapRoot := GetMapRoot();
  Result := MapRoot.DirLength;
  if Length(CMSSelectedItems) = 0 then
  begin
    SetLength( CMSSelectedItems, Result );
  end;

  Result := 0;
  for i := 0 to High(CMSSelectedItems) do
  begin
    Item := MapRoot.DirChild(i);
    if K_CMStudyGetOneSlideByItem( Item ) = nil then Continue;
    CMSSelectedItems[Result] := TN_UDCompVis(Item);
    PUP := N_GetUserParPtr(TN_UDCompVis(Item).R, 'MarkItemShow');
    PByte(PUP.UPValue.P)^ := 1;
    Inc(Result);
  end;
  CMSSelectedCount := Result;

end; // procedure TN_UDCMStudy.SelectAll

//************************************************ TN_UDCMStudy.UnSelectAll ***
// Remove All Study Slides from Selected
//
//     Parameters
// Result - Returns number of unselected Items
//
// Used for all Study Slides programaticaly unselection
//
function TN_UDCMStudy.UnSelectAll( ) : Integer;
var
  PUP: TN_POneUserParam;
  i : Integer;
  PMarkFlag : PByte;
begin
  N_Dump2Str('Study >> Unselect All');
  Result := 0;
  if (Length(CMSSelectedItems) = 0) or (CMSSelectedCount = 0) then Exit;

  for i := 0 to CMSSelectedCount - 1 do
  begin
    PUP := N_GetUserParPtr(CMSSelectedItems[i].R, 'MarkItemShow');
    PMarkFlag := PByte(PUP.UPValue.P);
    if PMarkFlag^ <> 0 then Inc(Result);
    PMarkFlag^ := 0;
  end; // for i := 0 to CMSSelectedCount - 1 do

  CMSSelectedCount := 0;

end; // procedure TN_UDCMStudy.UnSelectAll

//******************************************** TN_UDCMStudy.InvertSelection ***
// Invert Study Slides Selection
//
// Used for all Study Slides programaticaly selection invertion
//
function TN_UDCMStudy.InvertSelection( ) : Integer;
var
  PUP: TN_POneUserParam;
  i : Integer;
  PMarkFlag : PByte;
  MapRoot : TN_UDBase;
  Item : TN_UDBase;
  CCount : Integer;
begin

  MapRoot := GetMapRoot();
  CCount := MapRoot.DirLength;
  if Length(CMSSelectedItems) = 0 then
  begin
    SetLength( CMSSelectedItems, CCount );
  end;

  Result := 0;
  for i := 0 to CCount - 1 do
  begin
    Item := MapRoot.DirChild(i);
    if K_CMStudyGetOneSlideByItem( Item ) = nil then Continue;
    PUP := N_GetUserParPtr(TN_UDCompVis(Item).R, 'MarkItemShow');
    PMarkFlag := PByte(PUP.UPValue.P);
    if PMarkFlag^ = 0 then
    begin
      CMSSelectedItems[Result] := TN_UDCompVis(Item);
      PMarkFlag^ := 1;
      Inc(Result);
    end
    else
      PMarkFlag^ := 0;
  end;
  CMSSelectedCount := Result;

end; // procedure TN_UDCMStudy.InvertSelection

//****************************************** TN_UDCMStudy.GetFileTypeCounts ***
// Get Slide File Types Counters
//
//     Parameters
// APImgCount - pointer to resulting image files counter
// APMediaCount - pointer to resulting media files counter
//
function TN_UDCMStudy.GetFileTypeCounts( APImgCount : PInteger = nil;
                                         APMediaCount : PInteger = nil;
                                         APImg3DCount : PInteger = nil ) : Integer;
var
  i : Integer;
  MapRoot : TN_UDBase;
  Slide : TN_UDCMSlide;
begin
  MapRoot := GetMapRoot();
  Result := 0;
  for i := 0 to MapRoot.DirHigh do
  begin
    Slide := K_CMStudyGetOneSlideByItem( MapRoot.DirChild(i) );
    if Slide = nil then Continue;
    Inc(Result);
    with Slide.P^.CMSDB do
    if cmsfIsMediaObj in SFlags then
    begin
      if APMediaCount <> nil then
        Inc(APMediaCount^)
    end
    else
    if cmsfIsImg3DObj in SFlags then
    begin
// 2020-07-28 add Capt3DDevObjName <> ''      if (APImg3DCount <> nil) and (Capt3DDevObjName = '') then
//      if APImg3DCount <> nil then
// 2020-09-25 add new condition for Dev3D objs
      if (APImg3DCount <> nil) and ((Capt3DDevObjName = '') or (MediaFExt = '')) then
        Inc(APImg3DCount^);
    end
    else
    begin
      if APImgCount <> nil then
        Inc(APImgCount^);
    end;
  end;
end; // function TN_UDCMStudy.GetFileTypeCounts

//************************************* TN_UDCMStudy.RebuildItemsSearchList ***
// Rebuild Study Items Search List
//
//      Parameters
// ASearchGroup  - TN_SGComp object to include search items
// AIncUsedItems - if TRUE then only used items will be used
//
procedure TN_UDCMStudy.RebuildItemsSearchList( ASearchGroup : TN_SGComp; AIncUsedItems : Boolean );
var
  MapRoot, Item : TN_UDBase;
  i, j, h : Integer;
begin

  ASearchGroup.OneSR.SRType := srtPanel;
  MapRoot := GetMapRoot( );
  h := MapRoot.DirHigh;
  with ASearchGroup do
  begin
    SetLength( SComps, h + 1 );
    j := 0;
    for i := 0 to h do
      with SComps[j] do
      begin
        Item := MapRoot.DirChild(i);
        if AIncUsedItems and
           (K_CMStudyGetOneSlideByItem( Item ) = nil) then Continue;
        SComp  := TN_UDCompVis(Item);
        SFlags := 0;
        Inc( j );
      end;
    SetLength( SComps, j );
  end;
end; // procedure TN_UDCMStudy.RebuildItemsSearchList

//************************************ TN_UDCMStudy.GetItemThumbnailByIndex ***
// Get study item slide thumbnail or stub image by item index
//
//     Parameters
// AItemInd - study item index
// Result - Returns TN_UDDIB object
//
// Used by some photometric needs
//
function TN_UDCMStudy.GetItemThumbnailByIndex( AItemInd: Integer ): TN_UDDIB;
var
  Item : TN_UDBase;
  ImgSlide : TN_UDCMSlide;
begin
  Result := nil;
  Item := GetMapRoot.DirChild(AItemInd);
  if Item = nil then Exit;
  ImgSlide := K_CMStudyGetOneSlideByItem( Item );
  if ImgSlide <> nil then
    Result := ImgSlide.GetThumbnail()
  else
  begin
    Result := TN_UDDIB(Item.DirChild(1).DirChild(0).DirChild(0));
    Result.LoadDIBObj();
  end;  
end; // function TN_UDCMStudy.GetItemThumbnailByIndex

//************************************************* TN_UDCMStudy.ECacheSave ***
// Save Study to ECache
//
procedure TN_UDCMStudy.ECacheSave( ADumpRTID : Integer; ASaveMode : Integer = 0 );
begin
  CMSlideECSFlags := [];
end; // procedure TN_UDCMStudy.ECacheSave

// ********** end of TN_UDCMStudy class methods  **************

{ *** TK_CMSUndoBuf *** }
const
  K_CMSUBHistCodeSRInd  = 0;
  K_CMSUBMapRootIDSRInd = 1;
  K_CMSUBMapRootSRInd   = 2;
  K_CMSUBAttribsIDSRInd = 3;
  K_CMSUBAttribsSRInd   = 4;
  K_CMSUBImgIDSRInd     = 5;
  K_CMSUBImgSRInd       = 6;
  K_CMSUBImgUDDataSRInd = 7;

//********************************************************** TK_CMSUndoBuf.Create ***
// Slide Undo buffer class constructor
//
constructor TK_CMSUndoBuf.Create();
begin
  inherited Create('(#TmpFiles#)UNDO.dat', 8)
end; // end of TK_CMSUndoBuf.Create

//********************************************************** TK_CMSUndoBuf.CreateByUNDOBuf ***
// Slide Undo buffer class constructor
//
//     Parameters
// AUNDOBuf - source UNDO buffer
//
constructor TK_CMSUndoBuf.CreateByUNDOBuf(AUNDOBuf: TK_CMSUndoBuf);
begin
  inherited CreateByUNDOBuf(AUNDOBuf);
  FSavedCurInd := -1;
  FSavedAttribsID := -1;
  FSavedMapRootID := -1;
  FSavedCurImgID := -1;
  FAttribsID := AUNDOBuf.FAttribsID;
  FMapRootID := AUNDOBuf.FMapRootID;
  FCurImgID := AUNDOBuf.FCurImgID;
  FSkipSetRestoreSrcImgFlag := AUNDOBuf.FSkipSetRestoreSrcImgFlag;

end; // end of TK_CMSUndoBuf.Create

//********************************************************** TK_CMSUndoBuf.Destroy ***
// Slide Undo buffer classs denstructor
//
destructor TK_CMSUndoBuf.Destroy;
begin
  inherited;
end; // end of TK_CMSUndoBuf.Destroy

//********************************************************** TK_CMSUndoBuf.UBInitBySlide ***
// Init Undo buffer for new Slide editing
//
//     Parameters
// ASlide - Slide for buffering image changes
//
procedure TK_CMSUndoBuf.UBInitBySlide(ASlide: TN_UDCMSlide);
var
  ASaveStateFlags : TK_CMSlideSaveStateFlags;
begin
  UDCMSlide := ASlide;
  UBInit();

  FMapRootID := -1;
  FAttribsID := -1;
  FCurImgID := -1;

  ASaveStateFlags := [cmssfAttribsChanged, cmssfMapRootChanged,cmssfCurImgChanged];
  if UDCMSlide.CMSlideEdState = K_edsSkipOpen then
    ASaveStateFlags := [cmssfAttribsChanged];

//  UBPushSlideState( 'Initial state', ASaveStateFlags, -1);
  UBPushSlideState( K_CML1Form.LLLUndoRedo1.Caption, ASaveStateFlags, -1);

  UDCMSlide.CMSlideECSFlags := [];

  FSavedAttribsID := FAttribsID;
  FSavedMapRootID := FMapRootID;
  FSavedCurImgID := FCurImgID;

  FSavedCurInd := UBCurInd;
end; // end of TK_CMSUndoBuf.UBInitBySlide

//********************************************************** TK_CMSUndoBuf.UBGetSlideHistActionCode ***
// Get Slide History Action Code
//
//     Parameters
// Result - Returns History Action Code
//
function TK_CMSUndoBuf.UBGetSlideHistActionCode(AInd: Integer): Integer;
var
  CurBufInd: Integer;
begin
  CurBufInd := -1;
  if UBCurInd <> AInd then
  begin
    // Set New Current Index
    CurBufInd := UBCurInd;
    UBCurInd := AInd;
  end;
  UBGetSubRecordData(K_CMSUBHistCodeSRInd, K_CMSUNDOBuffer, Result);
  Result := PInteger(@K_CMSUNDOBuffer[0])^;
  if CurBufInd <> -1 then // Restore Current Index
    UBCurInd := CurBufInd;
end; // end of TK_CMSUndoBuf.UUBGetSlideHistActionCode

//********************************************************** TK_CMSUndoBuf.UBGetSlideHistActionCode ***
// Get Slide Current Image UDData
//
//     Parameters
// ACurUDImg - given TN_UDDIB for initial UDData restoring
//
procedure TK_CMSUndoBuf.UBGetSlideCurImgUDData( ACurUDImg : TN_UDDIB );
var
  BufSize: Integer;
begin
  ACurUDImg.UDData := nil;
  UBGetSubRecordData(K_CMSUBImgUDDataSRInd, ACurUDImg.UDData, BufSize);
  if BufSize <= 1 then
    BufSize := 0;
  SetLength( ACurUDImg.UDData, BufSize );
  if BufSize > 0 then // Clear FreeUDData Flag
    Exclude( ACurUDImg.PISP()^.CDIBFlagsN, uddfnFreeUDData ); // may be it is precaution because UDData should be saved only if uddfnFreeUDData is not set
end; // end of TK_CMSUndoBuf.UUBGetSlideHistActionCode

//************************************************* TK_UNDOBuf.UBGetDataByInd ***
// Get Slide MapRoot and Current Image (if needed)  by given UNDO buffer record index
//
//     Parameters
// AInd - UNDO buffer record index
// Result - Returns change Slide current state flags set
//
function TK_CMSUndoBuf.UBGetSlideState(AInd: Integer): TK_CMSlideSaveStateFlags;
var
  BufSize: Integer;
  WSavedInd: Integer;
  USA: TN_CMSUndoSlideAttrs;
  PrevImgGreyState: Boolean;
  PrevPixBits: Integer;
  CurUDImg : TN_UDDIB;
begin
  if UBCurInd <> AInd then
    N_Dump2Str(format('Get Undo State %s I=%d', [UBCaptions[AInd], AInd]));

  UBCurInd := AInd;

  Result := [];
  UBGetSubRecordData(K_CMSUBMapRootIDSRInd, K_CMSUNDOBuffer, BufSize);
  WSavedInd := PInteger(@K_CMSUNDOBuffer[0])^;
  if FMapRootID <> WSavedInd then
  begin
    Include(Result, cmssfMapRootChanged);
    FMapRootID := WSavedInd;
    UBGetSubRecordData(K_CMSUBMapRootSRInd, K_CMSUNDOBuffer, BufSize);
    // CMSlide.SetMapRoot( N_LoadUObjFromMem( @K_CMSUNDOBuffer[0], BufSize ) );
    // !!    CMSlide.PrepROIView( [K_roiClearRefs] ); // for destroying MapImage
    UDCMSlide.PutDirChildSafe(K_CMSlideIndMapRoot,
      N_LoadUObjFromMem(@K_CMSUNDOBuffer[0], BufSize));
    { // Only Map Root Childs Get
      N_SerialBuf.LoadFromMem( K_CMSUNDOBuffer[0], BufSize );
      MapRoot := CMSlide.GetMapRoot();
      K_LoadTreeFromMem0( MapRoot, N_SerialBuf, TRUE );
    }
    N_Dump2Str('Get Undo MapRoot');
  end;

  with USA, UDCMSlide.P()^, CMSDB do
  begin
    PrevImgGreyState := (cmsfGreyScale in SFlags);
    // store Image GreyState and PixBits
    PrevPixBits := CMSDB.PixBits;
    UBGetSubRecordData(K_CMSUBAttribsIDSRInd, K_CMSUNDOBuffer, BufSize);
    WSavedInd := PInteger(@K_CMSUNDOBuffer[0])^;
    if FAttribsID <> WSavedInd then
    begin
      Include(Result, cmssfAttribsChanged);
      FAttribsID := WSavedInd;
      UBGetSubRecordData(K_CMSUBAttribsSRInd, K_CMSUNDOBuffer, BufSize);
      if K_CMSUndoSlideAttrsType.DTCode = 0 then
        K_CMSUndoSlideAttrsType := K_GetExecTypeCodeSafe
          ('TN_CMSUndoSlideAttrs');
      // FillChar(USA, SizeOf(TN_CMSUndoSlideAttrs), 0 );
      K_SPLValueFromMem(USA, K_CMSUndoSlideAttrsType, @K_CMSUNDOBuffer[0],
        BufSize);
      CMSDTImgMod := USADTImgMod;
      CMSDTMapRootMod := USADTMapRootMod;
      CMSDTPropMod := USADTPropMod;
      CMSDTTaken := USADTTaken;
      CMSTeethFlags := USATeethFlags;
      CMSMediaType := USAMediaType;
      CMSDiagn := USADiagn;
      CMSDB.PixPermm := USAPixpermm;
      CMSDB.PixBits := USAPixBits;
      CMSDB.PixWidth := USAPixWidth;
      CMSDB.PixHeight := USAPixHeight;
      CMSDB.DUnits := USADUnits;
      CMSDB.SFlags := CMSDB.SFlags - [cmsfGreyScale] + USASFlags;
      CMSProvIDModified := USAProvIDModified;
      CMSLocIDModified := USALocIDModified;
      CMSCompIDModified := USACompModified;
      CMSDB.IniDTTaken  := USAIniDTTaken;
      N_Dump2Str('Get Undo Fields');
    end;
  end;

  UBGetSubRecordData(K_CMSUBImgIDSRInd, K_CMSUNDOBuffer, BufSize);
  WSavedInd := PInteger(@K_CMSUNDOBuffer[0])^;
  if FCurImgID <> WSavedInd then
  begin
    Include(Result, cmssfCurImgChanged);
    FCurImgID := WSavedInd;
    UBGetSubRecordData(K_CMSUBImgSRInd, K_CMSUNDOBuffer, BufSize);
    // CMSlide.SetCurrentImageByBMP( @K_CMSUNDOBuffer[0] );
    CurUDImg := UDCMSlide.GetCurrentImage;
    with CurUDImg.DIBObj do
      DeSerializeSelf(@K_CMSUNDOBuffer[0]);
    if Length(K_CMSUNDOBuffer) > K_CMBufMaxCapacity then
      K_CMSUNDOBuffer := nil;
    // Get Initial UDData
    UBGetSlideCurImgUDData(CurUDImg);

    UDCMSlide.ClearMapImage();
    N_Dump2Str('Get Undo CurImg');
    UBRebuildCurImageGreyState(PrevImgGreyState, PrevPixBits);
  end;
end; // end of TK_CMSUndoBuf.UBGetSlideState

//********************************************************** TK_CMSUndoBuf.UBPopSlideState ***
// Get Slide MapRoot and Current Image (if needed) previous state from Undo buffer
//
//     Parameters
// Result - Returns change Slide current state flags set
//
function TK_CMSUndoBuf.UBPopSlideState(): TK_CMSlideSaveStateFlags;
begin
  if not UBDecCurInd() then
    Exit;
  Result := UBGetSlideState(UBCurInd);
  // Add Slide History
  with K_CMEDAccess do
    EDAAddHistActionToSlideBuffer( UDCMSlide,
      EDAChangeHistActionType(UBGetSlideHistActionCode(UBCurInd + 1),
                              K_shATUndoChange) );
end; // end of TK_CMSUndoBuf.UBPopSlideState

//********************************************************** TK_CMSUndoBuf.UBPrevPopedSlideState ***
// Get Slide MapRoot and Current Image (if needed) previous state from Undo buffer
//
//     Parameters
// Result - Returns change Slide current state flags set
//
function TK_CMSUndoBuf.UBPrevPopedSlideState(): TK_CMSlideSaveStateFlags;
begin
  if not UBIncCurInd() then
    Exit;
  Result := UBGetSlideState(UBCurInd);
  // Add Slide History
  with K_CMEDAccess do
    EDAAddHistActionToSlideBuffer( UDCMSlide,
      EDAChangeHistActionType(UBGetSlideHistActionCode(UBCurInd),
                              K_shATRedoChange) );
end; // end of TK_CMSUndoBuf.UBPrevPopedSlideState

//********************************************************** TK_CMSUndoBuf.UBPushSlideState ***
// Push Slide Attributes, MapRoot and Current Image (if needed) to Undo buffer
//
//     Parameters
// AEditCapt      - editing operation caption
// ASaveStateFlags - Save Slide State Flags
//
procedure TK_CMSUndoBuf.UBPushSlideState(AEditCapt: string;
  ASaveStateFlags: TK_CMSlideSaveStateFlags; AHistActionCode: Integer);
var
  PBuf: Pointer;
  BufSize: Integer;
  USA: TN_CMSUndoSlideAttrs;
//  i, j: Integer;
  // ISFlags : Integer;
  CurUDImg : TN_UDDIB;
  PCMSMRImgAttrs : TK_PCMSMRImgAttrs;
begin

  // *** Change Restore Original Image Enable Flag if needed
  with UDCMSlide do
  begin
    if not(cmsfIsMediaObj in P.CMSDB.SFlags) and
       not(cmsfIsImg3DObj in P.CMSDB.SFlags) then
    begin
      // Simple Image (not MediaFile)
      PCMSMRImgAttrs := GetPMapRootAttrs();
      with PCMSMRImgAttrs^ do
        if (cmssfCurImgChanged in ASaveStateFlags) and // Image was changed
           not FSkipSetRestoreSrcImgFlag           and // not after restoring Original Image
           not (K_smriRestoreSrcImg in MRImgFlags) and // Restoring Original Image was not enabled
          (UBCurInd >= 0) then                         // It is not saving Initial UNDO state
        begin
        // Set RestoreSrcImg Enable Flag
          Include(MRImgFlags, K_smriRestoreSrcImg);
          ASaveStateFlags := ASaveStateFlags + [cmssfMapRootChanged];
        end
        else
        if FSkipSetRestoreSrcImgFlag and // Call after restoring Original Image
           (K_smriRestoreSrcImg in MRImgFlags) then
        begin // Restoring Original Image was enabled
          // Clear RestoreSrcImg Enable Flag
          Exclude(MRImgFlags, K_smriRestoreSrcImg);
          ASaveStateFlags := ASaveStateFlags + [cmssfMapRootChanged];
        end;
    end
    else
      ASaveStateFlags := ASaveStateFlags - [cmssfCurImgChanged,cmssfMapRootChanged]; // Skip CurImgChange MapRootChanged
//      Exclude(ASaveStateFlags, cmssfCurImgChanged); // Skip CurImgChange
    CMSlideECSFlags := ASaveStateFlags;
  end;

  FSkipSetRestoreSrcImgFlag := false;

  // *** Change Restore Original Image Enable Flag if needed
  // Remove '&' from caption
  AEditCapt := K_CMClearActCaption( AEditCapt );
{
  j := 1;
  for i := 1 to Length(AEditCapt) do
    if AEditCapt[i] <> '&' then
    begin
      AEditCapt[j] := AEditCapt[i];
      Inc(j);
    end;
  if j <= Length(AEditCapt) then
    SetLength(AEditCapt, j - 1);
}

  UBPushRecord(AEditCapt);
  if AHistActionCode <> -1 then
  begin
    UBPushSubRecordData(K_CMSUBHistCodeSRInd, @AHistActionCode,
      SizeOf(Integer));
    with K_CMEDAccess do
      EDAAddHistActionToSlideBuffer(UDCMSlide, AHistActionCode);
  end;

  if cmssfMapRootChanged in ASaveStateFlags then
  begin
    // Save MapRoot
    Inc(FMapRootID);
    UBPushSubRecordData(K_CMSUBMapRootIDSRInd, @FMapRootID, SizeOf(Integer));
    UDCMSlide.PrepROIView([K_roiClearRefs]);
    BufSize := N_SaveUObjToMem(UDCMSlide.GetMapRoot(), PBuf);
    UDCMSlide.PrepROIView([K_roiRestoreIfImage]);
    UBPushSubRecordData(K_CMSUBMapRootSRInd, PBuf, BufSize);
    { // Only MapRoot Childs Save Code
      K_SaveTreeToMem( CMSlide.GetMapRoot(), N_SerialBuf, TRUE );
      UBPushSubRecordData( K_CMSUBMapRootSRInd, @N_SerialBuf.Buf1[0], N_SerialBuf.OfsFree );
    }
  end;

  if cmssfAttribsChanged in ASaveStateFlags then
  begin
    // Save Attributes
    Inc(FAttribsID);
    UBPushSubRecordData(K_CMSUBAttribsIDSRInd, @FAttribsID, SizeOf(Integer));

    with USA, UDCMSlide.P()^ do
    begin
      USADTImgMod := CMSDTImgMod;
      USADTMapRootMod := CMSDTMapRootMod;
      USADTPropMod := CMSDTPropMod;
      USADTTaken := CMSDTTaken;
      USATeethFlags := CMSTeethFlags;
      USAMediaType := CMSMediaType;
      USADiagn := CMSDiagn;
      USAPixpermm := CMSDB.PixPermm;
      USAPixBits := CMSDB.PixBits;
      USAPixWidth := CMSDB.PixWidth;
      USAPixHeight := CMSDB.PixHeight;
      USADUnits := CMSDB.DUnits;
      USASFlags := CMSDB.SFlags * [cmsfGreyScale];
      USAProvIDModified := CMSProvIDModified;
      USALocIDModified := CMSLocIDModified;
      USACompModified := CMSCompIDModified;
      USAIniDTTaken := CMSDB.IniDTTaken;
    end;
    if K_CMSUndoSlideAttrsType.DTCode = 0 then
      K_CMSUndoSlideAttrsType := K_GetExecTypeCodeSafe('TN_CMSUndoSlideAttrs');
    K_SPLValueToMem(USA, K_CMSUndoSlideAttrsType, PBuf, BufSize);
    UBPushSubRecordData(K_CMSUBAttribsSRInd, PBuf, BufSize);
  end;

  if cmssfCurImgChanged in ASaveStateFlags then
  begin
    // Save Current Image
    Inc(FCurImgID);
    FCurImgID := Max( FCurImgID, FCurInd ); // It is actual if new image state is written after Restore Original Image
    UBPushSubRecordData(K_CMSUBImgIDSRInd, @FCurImgID, SizeOf(Integer));

    CurUDImg := UDCMSlide.GetCurrentImage;

    // CMSlide.GetCurrentImageBMP( K_CMSUNDOBuffer, BufSize );
    with CurUDImg.DIBObj do
    begin
      BufSize := SerializedSize;
      if Length(K_CMSUNDOBuffer) < BufSize then
      begin
        K_CMSUNDOBuffer := nil; // Free K_CMSUNDOBuffer before realloc
        SetLength(K_CMSUNDOBuffer, BufSize);
      end;
      SerializeSelf(@K_CMSUNDOBuffer[0], BufSize);
    end;
    UBPushSubRecordData(K_CMSUBImgSRInd, @K_CMSUNDOBuffer[0], BufSize);

    // Save or Clear CurImage UDData
    BufSize := 1; // UDData Size 1 means Clear previous UDData
    PBuf := @K_CMSUNDOBuffer[0];
    with CurUDImg.PISP()^ do
    begin
      if (Length(CurUDImg.UDData) > 0) and
         not (uddfnFreeUDData in CDIBFlagsN) then
      begin
        BufSize := Length(CurUDImg.UDData);
        PBuf := @CurUDImg.UDData[0];
      end;
      UBPushSubRecordData( K_CMSUBImgUDDataSRInd, PBuf, BufSize );
    end;

    if Length(K_CMSUNDOBuffer) > K_CMBufMaxCapacity then
      K_CMSUNDOBuffer := nil;
  end;

end; // end of TK_CMSUndoBuf.UBPushSlideState

//********************************************************** TK_CMSUndoBuf.UBGetSrcImgCreationIsNeeded ***
// Slide Original Image Creation is needed
//
function TK_CMSUndoBuf.UBGetSrcImgCreationIsNeeded(ASavedCurImgID: Integer = -1)
  : Boolean;
begin
  Result := false;
  if Self = nil then
    Exit;
  if ASavedCurImgID = -1 then
    ASavedCurImgID := FSavedCurImgID;
  with UDCMSlide, P().CMSDB do
    if (cmsfHasSrcImg in SFlags)      or
       not (cmsfSaveSrcImg in SFlags) or
      (ASavedCurImgID = FCurImgID) then
      Exit;
  Result := TRUE;
end; // end of TK_CMSUndoBuf.UBGetSrcImgCreationIsNeeded

//********************************************************** TK_CMSUndoBuf.UBMarkSlideBufState ***
// Marked Current Buffer UNDO state
//
procedure TK_CMSUndoBuf.UBMarkSlideBufState();
begin
  FMarkedAttribsID := FAttribsID;
  FMarkedMapRootID := FMapRootID;
  FMarkedCurImgID := FCurImgID;
  FMarkedCurInd := UBCurInd;
end; // end of TK_CMSUndoBuf.UBMarkSlideBufState

//********************************************************** TK_CMSUndoBuf.UBMarkSlideBufState ***
// Get Slide Save State Flags while slide changed from Marked to Current Buffer state
//
//     Parameters
// Result - Returns Save State Flags
//
function TK_CMSUndoBuf.UBMarkSaveStateFlags(): TK_CMSlideSaveStateFlags;
begin
  Result := [];
  if FMapRootID <> FMarkedMapRootID then
    Include(Result, cmssfMapRootChanged);

  if FAttribsID <> FMarkedAttribsID then
    Include(Result, cmssfAttribsChanged);

  if FCurImgID <> FMarkedCurImgID then
    Include(Result, cmssfCurImgChanged);

end; // end of TK_CMSUndoBuf.UBMarkSlideBufState

//************************************** TK_CMSUndoBuf.UBSlidePrepForSaving ***
// Prepare Slide for saving to DB
//
procedure TK_CMSUndoBuf.UBSlidePrepForSaving;
var
  BufSize, WCInd: Integer;
begin
  if Self = nil then
    Exit;
  // Save Prev saving context
  FPrevCurInd := FSavedCurInd;
  FPrevAttribsID := FSavedAttribsID;
  FPrevMapRootID := FSavedMapRootID;
  FPrevCurImgID := FSavedCurImgID;

  FSavedCurInd := UBCurInd; // UNDO Record Index when slide was saved to DB
  FSavedAttribsID := FAttribsID;
  FSavedMapRootID := FMapRootID;
  WCInd := FSavedCurImgID; // Store PrevState
  FSavedCurImgID := FCurImgID;
  if not UBGetSrcImgCreationIsNeeded(WCInd) then
    Exit;

  with UDCMSlide, P().CMSDB do
  begin
    // Create Slide Original Image Object
    WCInd := UBCurInd;
    UBCurInd := 0;
    UBGetSubRecordData( K_CMSUBImgSRInd, K_CMSUNDOBuffer, BufSize );
    // SetSourceImageByBMP( @K_CMSUNDOBuffer[0] );
    SetSourceImageByDIBSData( @K_CMSUNDOBuffer[0] );
    // Get Initial UDData
    UBGetSlideCurImgUDData( GetSourceImage() );
    UBCurInd := WCInd;
  end;
end; // end of TK_CMSUndoBuf.UBSlidePrepForSaving

//******************************* TK_CMSUndoBuf.UBSlideRestoreSavingContext ***
// Restore Slide saving to DB Context if saving fails
//
procedure TK_CMSUndoBuf.UBSlideRestoreSavingContext;
begin
  if Self = nil then
    Exit;
  // Save Prev saving context
  FSavedCurInd := FPrevCurInd;
  FSavedAttribsID := FPrevAttribsID;
  FSavedMapRootID := FPrevMapRootID;
  FSavedCurImgID := FPrevCurImgID;
end; // end of TK_CMSUndoBuf.UBSlideRestoreSavingContext

//********************************* TK_CMSUndoBuf.UBSetSlideChangeDataFlags ***
// Change Slide saving Flags According to UNDO buffer
//
procedure TK_CMSUndoBuf.UBSetSlideChangeDataFlags();
begin
  if Self = nil then // precation
    Exit;

  with UDCMSlide, P()^ do
  begin
    // Only Set (not clear) cmsfAttribsChanged because it may be set early not using UndoBuffer (in study)
    if FSavedAttribsID <> FAttribsID then
    begin
      CMSRFlags := CMSRFlags + [cmsfAttribsChanged];
      // else
      // CMSRFlags := CMSRFlags - [cmsfAttribsChanged];
    end;

    // 2018-12-24 Only Set (not clear) cmsfMapRootChanged because it may be set early not using UndoBuffer (in study)
    if FSavedMapRootID <> FMapRootID then
      CMSRFlags := CMSRFlags + [cmsfMapRootChanged];
//    else
//      CMSRFlags := CMSRFlags - [cmsfMapRootChanged];

    if FSavedCurImgID <> FCurImgID then
      CMSRFlags := CMSRFlags + [cmsfCurImgChanged]
//    else
//      CMSRFlags := CMSRFlags - [cmsfCurImgChanged];
  end;
end; // end of TK_CMSUndoBuf.UBSetSlideChangeDataFlags

//******************************** TK_CMSUndoBuf.UBRebuildCurImageGreyState ***
// Restore Original Image and push new Current Image to Undo buffer
//
//     Parameters
// APrevGreyState - image previous Grey state
// Result - Returns TRUE if image Grey state is changed
//
function TK_CMSUndoBuf.UBRebuildCurImageGreyState(APrevGreyState: Boolean;
  APrevPixBits: Integer): Boolean;
begin
  with UDCMSlide, P().CMSDB do
  begin
    SetAttrsByCurImgParams(TRUE);
    Result := ((cmsfGreyScale in SFlags) <> APrevGreyState) or
      (APrevPixBits <> PixBits);
    if Result and APrevGreyState then
      // Clear Colorize/Isodensity flags for new Image
      SFlags := SFlags - [cmsfShowColorize, cmsfShowIsodensity, cmsfShowEmboss];
  end;
end; // end of TK_CMSUndoBuf.UBRebuildCurImageGreyState

//****************************************** TK_CMSUndoBuf.UBGetSrcImageDIB ***
// Get Original Image DIB obj from Undo buffer
//
//     Parameters
// APUData - Pointer to BArray for storing Original TN_UDDIB.UDData
// Result - Returns new DIBObj build from UNDO Buffer or nil if original image is stored in slide
//
function TK_CMSUndoBuf.UBGetSrcImageDIB( APUData : TN_PBArray = nil ): TN_DIBObj;
var
  BufSize: Integer;
  WCInd: Integer;
begin
  Result := nil;
  with UDCMSlide, P().CMSDB do
  begin
    if cmsfHasSrcImg in SFlags then
      Exit;
    // Source Image is in Undo Buffer
    WCInd := UBCurInd;
    UBCurInd := 0;
    UBGetSubRecordData(K_CMSUBImgSRInd, K_CMSUNDOBuffer, BufSize);
    Result := TN_DIBObj.Create(1, 1, pf24bit);
    Result.DeSerializeSelf(@K_CMSUNDOBuffer[0]);

    if APUData <> nil then
    begin
     // Get Initial UDData
      APUData^ := nil;
      UBGetSubRecordData(K_CMSUBImgUDDataSRInd, APUData^, BufSize);
      if BufSize <= 1 then
        BufSize := 0;
      SetLength( APUData^, BufSize );
    end;

    UBCurInd := WCInd;
  end;
end; // end of TK_CMSUndoBuf.UBGetSrcImageDIB

//***************************************** TK_CMSUndoBuf.UBRestoreSrcState ***
// Prepare to restore Original Image and push new Current Image to Undo buffer
//
//     Parameters
// ARestoreCapt - restore Source Image Caption
// Result - Returns TRUE if MapImage rebuild is not needed
//
function TK_CMSUndoBuf.UBPrepRestSrcImageState( ARestoreCapt: string;
             out ASaveUndoFlags: TK_CMSlideSaveStateFlags ): Boolean;
var
  BufSize: Integer;
  WCInd: Integer;
  PSrcCDIBN : TN_PCDIBN;
  SrcUDDIB : TN_UDDIB;
  CurUDDIB : TN_UDDIB;
  PCMSMRImgAttrs : TK_PCMSMRImgAttrs;
begin
  CurUDDIB := UDCMSlide.GetCurrentImage();
  PCMSMRImgAttrs := UDCMSlide.GetPMapRootAttrs();
  with UDCMSlide, P()^.CMSDB, CurUDDIB, PISP^, PCMSMRImgAttrs^ do
  begin
    Result := FALSE;
    if cmsfHasSrcImg in SFlags then
    begin
      // Source Image Exists
      ASaveUndoFlags := [cmssfCurImgChanged];
      // Copy Current Image From Source
      SrcUDDIB := GetSourceImage();
      if SrcUDDIB = nil then
      begin
        Result := TRUE;
        Exit; // Original Imag is absent
      end;

      PSrcCDIBN := SrcUDDIB.PISP;
      DIBObj.Free;
      DIBObj := TN_DIBObj.Create(SrcUDDIB.DIBObj);
      CDIBFlagsN      := PSrcCDIBN^.CDIBFlagsN;
      CDIBJPEGQuality := PSrcCDIBN^.CDIBJPEGQuality;
      CDIBDataFormat  := PSrcCDIBN^.CDIBDataFormat;
      UDData          := Copy( SrcUDDIB.UDData );
    end
    else if cmsfSaveSrcImg in SFlags then
    begin
      // Source Image is in Undo Buffer
      ASaveUndoFlags := [];
      WCInd := UBCurInd;
      UBCurInd := 0;
      UBGetSubRecordData(K_CMSUBImgSRInd, K_CMSUNDOBuffer, BufSize);
      // !!      with CMSlide.GetCurrentImage.DIBObj do
      // !!        DeSerializeSelf( @K_CMSUNDOBuffer[0] );
      DIBObj.DeSerializeSelf(@K_CMSUNDOBuffer[0]);
      // Get Initial UDData
      FCurImgID := 0;
      UBGetSlideCurImgUDData( CurUDDIB );
      UBCurInd := WCInd;
    end
    else
      // Exit;
      Result := (MRCoFactor <> 0)     or
                (MRBriFactor <> 0)    or
                (MRGamFactor <> 0)    or
                (MRBriMinFactor <> 0) or
                ((MRBriMaxFactor > 0) and (MRBriMaxFactor < 100)) or
                (K_smriNegateImg in MRImgFlags);

    MRCoFactor := 0;
    MRBriFactor := 0;
    MRGamFactor := 0;
    MRBriMinFactor := 0;
    MRBriMaxFactor := 0;
    MRImgFlags := MRImgFlags - [K_smriNegateImg];

    GetMapRoot().PCCS().SRSize := FPoint(DIBObj.DIBSize); // !!## 09-07-2009

    ASaveUndoFlags := ASaveUndoFlags + [cmssfMapRootChanged,cmssfAttribsChanged];
    { cmssfAttribsChanged have to be added in all cases - because of ModifyDates
      if UBRebuildCurImageGreyState( cmsfGreyScale in SFlags, PixBits ) then
      ASaveUndoFlags := ASaveUndoFlags + [cmssfAttribsChanged];
    }
  end;

  FSkipSetRestoreSrcImgFlag := TRUE;

end; // end of TK_CMSUndoBuf.UBPrepRestSrcImageState

//***************************************** TK_CMSUndoBuf.UBRestoreSrcState ***
// Restore Original Image and push new Current Image to Undo buffer
//
//     Parameters
// ARestoreCapt - restore Source Image Caption
//
procedure TK_CMSUndoBuf.UBRestoreSrcState(ARestoreCapt: string);
var
  SaveUndoFlags: TK_CMSlideSaveStateFlags;
  OnlyBriCoGamRestore: Boolean;
  FName : string;
begin

  OnlyBriCoGamRestore := UBPrepRestSrcImageState(ARestoreCapt, SaveUndoFlags);

  with UDCMSlide, P^ do
    if OnlyBriCoGamRestore             and
       (cmsfHasSrcImg in CMSDB.SFlags) and
       (K_CMEDAccess is TK_CMEDDBAccess) then
    begin
      FName := GetCurImgFileName( GetFilesPathSegm() );
      K_CMShowMessageDlg(  format(  //sysout
            'The media object file "%s"'#13#10 +
            'is missing or corrupted in the folder "%s"'#13#10 +
            'Please check your folder name and try again.',
                   [FName, TK_CMEDDBAccess(K_CMEDAccess).SlidesImgRootFolder] ), mtError );
      Exit;
    end;

  if not OnlyBriCoGamRestore then // !!## 09-07-2009
    UDCMSlide.SetAttrsByCurImgParams(TRUE); // !!## 09-07-2009

  UBPushSlideState(ARestoreCapt, SaveUndoFlags,
    K_CMEDAccess.EDABuildHistActionCode(K_shATChange, Ord(K_shCAImage),
      Ord(K_shImgActRestoreSrc)));

  if not(cmssfCurImgChanged in SaveUndoFlags) then
  begin // Set Reference to Init UNDO Record
    // Set Reference to Init UNDO Record ImageID
    UBChangeSubRecordReference(K_CMSUBImgIDSRInd, 0);
    // Set Reference to Init UNDO Record Image
    UBChangeSubRecordReference(K_CMSUBImgSRInd, 0);
    // Set Reference to Init UNDO Record Image UDData
    UBChangeSubRecordReference(K_CMSUBImgUDDataSRInd, 0);
  end;

  if OnlyBriCoGamRestore then
    Exit;

  // !!## 09-07-2009  CMSlide.SetAttrsByCurImgParams( TRUE );
  UDCMSlide.ClearMapImage();
  UDCMSlide.GetMapRoot();

end; // end of TK_CMSUndoBuf.UBRestoreSrcState

//***************************************** TK_CMSUndoBuf.UBRestoreSrcState ***
// Return Original Image and push new Current Image to Undo buffer
//
//     Parameters
// ARestoreCapt - restore Source Image Caption
//
procedure TK_CMSUndoBuf.UBRestoreSrcImage(ARestoreCapt: string);
var
  SaveUndoFlags: TK_CMSlideSaveStateFlags;
  OnlyBriCoGamRestore: Boolean;
  PCMSMRImgAttrs : TK_PCMSMRImgAttrs;
  FName : string;
  PCMSlide : TN_PCMSlide;
begin
  PCMSMRImgAttrs := UDCMSlide.GetPMapRootAttrs();
  PCMSlide := UDCMSlide.P();
  with UDCMSlide, PCMSMRImgAttrs^, PCMSlide^ do
  begin
    OnlyBriCoGamRestore := UBPrepRestSrcImageState(ARestoreCapt, SaveUndoFlags);
    if OnlyBriCoGamRestore             and
       (cmsfHasSrcImg in CMSDB.SFlags) and
       (K_CMEDAccess is TK_CMEDDBAccess) then
    begin
      FName := GetCurImgFileName( GetFilesPathSegm() );
      K_CMShowMessageDlg(  format(  //sysout
            'The media object file "%s"'#13#10 +
            'is missing or corrupted in the folder "%s"'#13#10 +
            'Please check your folder name and try again.',
                   [FName, TK_CMEDDBAccess(K_CMEDAccess).SlidesImgRootFolder] ), mtError );
      Exit;
    end;

    GetMeasureRoot().ClearChilds(); // Clear Annotations
    { !!## 09-07-2009
      UBPushSlideState( ARestoreCapt, SaveUndoFlags );

      if MRFlipRotateAttrs <> 0 then
      OnlyBriCoGamRestore := FALSE;
      MRFlipRotateAttrs := 0;
    }
    // !!## 09-07-2009 new code

    if MRFlipRotateAttrs <> 0 then
      OnlyBriCoGamRestore := false;
    MRFlipRotateAttrs := 0;


    if not OnlyBriCoGamRestore then
    begin
      UDCMSlide.SetAttrsByCurImgParams(TRUE);

      // Restore Image Calibration State
      with UDCMSlide.GetCurrentImage() do
        CMSDB.PixPermm := DIBObj.DIBInfo.bmi.biXPelsPerMeter / 1000;

      CMSDB.SFlags := CMSDB.SFlags - [cmsfUserCalibrated];
    end;

//!! New Code to Restore Original Resolution And Size
//    CMSDB.PixPermm := 0;
//    UDCMSlide.SetAttrsByCurImgParams(TRUE);

    CMSDTMapRootMod := CMSDTCreated;
    CMSDTImgMod := CMSDTCreated;
    CMSProvIDModified := K_CMEDAccess.CurProvID; // Provider ID Modified
    CMSLocIDModified  := K_CMEDAccess.CurLocID; // Location ID Modified
    CMSCompIDModified := K_CMSServerClientInfo.CMSClientVirtualName;
    UBPushSlideState(ARestoreCapt, SaveUndoFlags,
      K_CMEDAccess.EDABuildHistActionCode(K_shATChange, Ord(K_shCAImage),
        Ord(K_shImgActRestoreSrc)));

  end;

  if not(cmssfCurImgChanged in SaveUndoFlags) then
  begin // Set Reference to Init UNDO Record
    // Set Reference to Init UNDO Record ImageID
    UBChangeSubRecordReference(K_CMSUBImgIDSRInd, 0);
    // Set Reference to Init UNDO Record Image
    UBChangeSubRecordReference(K_CMSUBImgSRInd, 0);
    // Set Reference to Init UNDO Record Image UDData
    UBChangeSubRecordReference(K_CMSUBImgUDDataSRInd, 0);
  end;

  if OnlyBriCoGamRestore then
    Exit;

  // !!## 09-07-2009  CMSlide.SetAttrsByCurImgParams( TRUE );
  UDCMSlide.ClearMapImage();
  UDCMSlide.GetMapRoot();
end; // end of TK_CMSUndoBuf.UBRestoreSrcImage

//******************************** TK_CMSUndoBuf.UBRestoreSrcStateIsEnabled ***
// Check if original image restoring is enabled
//
//     Parameters
// Result - Returns TRUE if Restore Original Image is Enabled
//
function TK_CMSUndoBuf.UBRestoreSrcStateIsEnabled(): Boolean;
var
  PCMSMRImgAttrs : TK_PCMSMRImgAttrs;
begin
  PCMSMRImgAttrs := UDCMSlide.GetPMapRootAttrs();
  with UDCMSlide, PCMSMRImgAttrs^ do
//    Result := (cmsfIsLocked in P()^.CMSRFlags) and
    Result := not (cmsfSkipSlideEdit in P()^.CMSRFlags) and
      ((K_smriRestoreSrcImg in MRImgFlags) or
        (MRCoFactor <> 0)        or
        (MRBriFactor <> 0)       or
        (MRGamFactor <> 0)       or
        (MRBriMinFactor <> 0)    or
        ((MRBriMaxFactor > 0) and
         (MRBriMaxFactor < 100)) or
        (MRFlipRotateAttrs <> 0) or
        (K_smriNegateImg in MRImgFlags));

end; // end of TK_CMSUndoBuf.UBRestoreSrcStateIsEnabled

//******************************** TK_CMSUndoBuf.UBRestoreSrcImageIsEnabled ***
// Check if original image returning is enabled
//
//     Parameters
// Result - Returns TRUE if Return Original Image is Enabled
//
function TK_CMSUndoBuf.UBRestoreSrcImageIsEnabled(): Boolean;
var
  PCMSMRImgAttrs : TK_PCMSMRImgAttrs;
  PCMSlide : TN_PCMSlide;
  SkipOrigInEnterpriseFlag : Boolean;
begin
  PCMSMRImgAttrs := UDCMSlide.GetPMapRootAttrs();
  PCMSlide := UDCMSlide.P();
  with UDCMSlide, PCMSlide^, PCMSMRImgAttrs^ do begin

//    Result := (cmsfIsLocked in P()^.CMSRFlags) and
    // SkipOrigInEnterpriseFlag is TRUE when original image is absent in current location
    SkipOrigInEnterpriseFlag := K_CMEnterpriseModeFlag          and
                                (cmsfHasSrcImg in CMSDB.SFlags) and
                                not (K_slfSrcImgFileExists in CMSlideLocFlags);

    Result := not (cmsfSkipSlideEdit in CMSRFlags) and
             ((not SkipOrigInEnterpriseFlag and (K_smriRestoreSrcImg in MRImgFlags)) or
              (GetMeasureRoot().DirLength() > 0) or // Some Annotions exist
              (MRCoFactor  <> 0)                 or // Contrast was changed
              (MRBriFactor <> 0)                 or // Brightness was changed
              (MRGamFactor <> 0)                 or // Gamma was changed
              (MRBriMinFactor <> 0)              or // Brightness window minimal bound
              ((MRBriMaxFactor > 0) and
               (MRBriMaxFactor < 100))           or // Brightness window maximal bound
              (K_smriNegateImg in MRImgFlags)    or // Negate
              (MRFlipRotateAttrs <> 0));            // was Flipped or/and Rotated
  end;
end; // end of TK_CMSUndoBuf.UBRestoreSrcImageIsEnabled

{ *** end of TK_CMSUndoBuf *** }

//******************************************************* K_CMDBGetImgFPath ***
// Get Img Files curent base path
//
//     Parameters
// AFPath  - Img Files current base path
// Result - Returns operation resulting code
//
// !!!!!!!!!!!!!! not used now
function K_CMDBGetImgFPath(out AFPath: string): TK_CMEDResult;
begin
  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    Result := EDACheckDBConnection(LANDBConnection);
    if Result <> K_edOK then
      Exit;

    N_Dump2Str('DB>>  Get ImgFiles path');
    AFPath := '';
    try
      with CurDSet1 do
      begin
        Connection := LANDBConnection;
        SQL.Text := 'select ' + K_CMENDBGTFImgFPath +
          ' from ' + K_CMENDBGlobAttrsTable;
        Filtered := false;
        Open;
        AFPath := EDAGetStringFieldValue(FieldList.Fields[0]);
        Close;
      end;
    except
      on E: Exception do
      begin
        Result := K_edExDataError;
        ExtDataErrorString := 'K_CMDBGetImgFPath ' + E.Message;
        EDAShowErrMessage(TRUE);
        Exit;
      end;
    end;
  end;
end; // end of K_CMDBGetImgFPath

//************************************************** K_CMSFormatTrialPeriod ***
// Format Trial Period Remaining Minutes to Text
//
//     Parameters
// AMinutes  - Trial Period remaining Minutes
// Result - Returns resulting trial period text
//
function K_CMSFormatTrialPeriod(AMinutes: Integer): string;
begin
//  Result := format('%d hours %d minutes', [AMinutes div 60, AMinutes mod 60]);
  Result := format(K_CML1Form.LLLRegister21.Caption, [AMinutes div 60, AMinutes mod 60]);
end; // end of K_CMSFormatTrialPeriod

//********************************************* K_CMSSlidesBWReorder2 ***
// Reorder array of two Slides by BW rukes
//
//     Parameters
// AImgSlides  - array of Slides to reorder by BW rukes
// Result - Returns number of BW marked slides
//
function K_CMSSlidesBWReorder2( AImgSlides: TN_UDCMSArray ): Integer;
var
  USlide: TN_UDCMSlide;
  PCMSLides0, PCMSLides1 : TN_PCMSlide;

  procedure SetSlidePointers();
  begin
    PCMSLides0 := nil;
    if AImgSlides[0] <> nil then
      PCMSLides0 := AImgSlides[0].P();
    PCMSLides1 := nil;
    if AImgSlides[1] <> nil then
      PCMSLides1 := AImgSlides[1].P();
  end;

begin
  Result := 0;
  SetSlidePointers();
  if ((PCMSLides0 <> nil) and ((PCMSLides0.CMSTeethFlags and K_CMTeethBWMask) <> 0)) or
     ((PCMSLides1 <> nil) and ((PCMSLides1.CMSTeethFlags and K_CMTeethBWMask) <> 0)) then
  begin
  // Apply BW Rule to given slides
    if ((PCMSLides0 <> nil) and ((PCMSLides0.CMSTeethFlags and K_CMTeethBWMaskL) <> 0)) or
       ((PCMSLides1 <> nil) and ((PCMSLides1.CMSTeethFlags and K_CMTeethBWMaskR) <> 0)) then
    begin
    // change slides order
      USlide := AImgSlides[0];
      AImgSlides[0] := AImgSlides[1];
      AImgSlides[1] := USlide;
      SetSlidePointers();
    end;
    Result := 1;
    if (PCMSLides0 <> nil) and (PCMSLides1 <> nil) and
       ((((PCMSLides0.CMSTeethFlags and K_CMTeethBWMaskL) <> 0) and
         ((PCMSLides1.CMSTeethFlags and K_CMTeethBWMaskL) <> 0) and
         (PCMSLides0.CMSDTTaken > PCMSLides1.CMSDTTaken)) or
        (((PCMSLides0.CMSTeethFlags and K_CMTeethBWMaskR) <> 0) and
         ((PCMSLides1.CMSTeethFlags and K_CMTeethBWMaskR) <> 0)) and
         (PCMSLides0.CMSDTTaken < PCMSLides1.CMSDTTaken)) then
    begin
     // change slides order by DateTaken for slides with same BW flags
      USlide := AImgSlides[0];
      AImgSlides[0] := AImgSlides[1];
      AImgSlides[1] := USlide;
    end;
  end;
end; // end of K_CMSSlidesBWReorder2

//*************************************************** K_CMSSlidesBWReorder4 ***
// Reorder array of three or four Slides by BW rules
//
//     Parameters
// AImgSlides  - array of Slides to reorder by BW rukes
// Result - Returns number of BW marked slides
//
function K_CMSSlidesBWReorder4( var AImgSlides: TN_UDCMSArray ): Integer;
var
  PCMSLidesArr4 : array [0..3] of TN_PCMSlide;
  CMSLidesArrL  : array [0..3] of TN_UDCMSlide;
  CMSLidesArrR  : array [0..3] of TN_UDCMSlide;
  CMSLidesArrN  : array [0..3] of TN_UDCMSlide;
  SlidesBWCountL : Integer;
  SlidesBWCountR : Integer;
  SlidesBWCountN : Integer;
  i, j : Integer;

label  NotBWSlide;

  procedure SortSlides( PS0: TN_PUDCMSlide; SC: Integer );
  var
    PS1: TN_PUDCMSlide;
    PS2: TN_PUDCMSlide;
    i, MCount : Integer;
    USlide: TN_UDCMSlide;

  begin
    repeat
      PS2 := PS0;
      Inc(PS2);
      PS1 := PS0;
      MCount := 0;
      for i := 0 to SC - 2 do
      begin
        if PCMSLidesArr4[PS1.Marker].CMSDTTaken < PCMSLidesArr4[PS2.Marker].CMSDTTaken then
        begin
          USlide := PS1^;
          PS1^ := PS2^;
          PS2^ := USlide;
          Inc(MCount);
        end;
        PS1 := PS2;
        Inc(PS2);
      end;
    until MCount = 0;
  end;

begin
  // Check if BW Rule is needed
  SlidesBWCountR := 0;
  SlidesBWCountL := 0;
  SlidesBWCountN := 0;
  for i := 0 to High(AImgSlides) do
  begin
    if AImgSlides[i] = nil then goto NotBWSlide;

    //******* Place Slide[i]
    PCMSLidesArr4[i] := AImgSlides[i].P();
    AImgSlides[i].Marker := i;
    if (PCMSLidesArr4[i].CMSTeethFlags and K_CMTeethBWMaskL) <> 0 then
    begin
    // Place to Right
      CMSLidesArrR[SlidesBWCountR] := AImgSlides[i];
      Inc(SlidesBWCountR);
    end
    else
    if (PCMSLidesArr4[i].CMSTeethFlags and K_CMTeethBWMaskR) <> 0 then
    begin
    // Place to Left
      CMSLidesArrL[SlidesBWCountL] := AImgSlides[i];
      Inc(SlidesBWCountL);
    end
    else
    begin
    // Place to Not BW
NotBWSlide:
      CMSLidesArrN[SlidesBWCountN] := AImgSlides[i];
      Inc(SlidesBWCountN);
    end;
  end;

  if SlidesBWCountN < 4 then
  begin
  // Reorder by BW rules is needed
    // Clear Slides before Reorder
    SetLength( AImgSlides, 4 );
    FillChar( AImgSlides[0], 4 * SizeOf(TObject), 0 );

    //****** Place Left
    if SlidesBWCountL > 0 then
    begin
    // Order Left by date
      if SlidesBWCountL >= 2 then
        SortSlides( @CMSLidesArrL[0], SlidesBWCountL );

      AImgSlides[0] := CMSLidesArrL[0];
      if SlidesBWCountL > 1 then
      begin
        AImgSlides[2] := CMSLidesArrL[1];
        if SlidesBWCountL > 2 then
        begin
          AImgSlides[3] := CMSLidesArrL[2];
          if SlidesBWCountL > 3 then
            AImgSlides[1] := CMSLidesArrL[3];
        end;
      end;
    end;

    //****** Place Right
    if SlidesBWCountR > 0 then
    begin
      // Order Right by date
      if SlidesBWCountR >= 2 then
        SortSlides( @CMSLidesArrR[0], SlidesBWCountR );

      AImgSlides[1] := CMSLidesArrR[0];
      if SlidesBWCountR > 1 then
      begin
        AImgSlides[3] := CMSLidesArrR[1];
        if SlidesBWCountR > 2 then
        begin
          AImgSlides[2] := CMSLidesArrR[2];
          if SlidesBWCountR > 3 then
            AImgSlides[0] := CMSLidesArrR[3];
        end;
      end;
    end;


    //****** Place Other to the free places
    j := 0;
    for i := 0 to SlidesBWCountN - 1 do
    begin
      while AImgSlides[j] <> nil do Inc(j);
      AImgSlides[j] := CMSLidesArrN[i];
      Inc(j)
    end;
    if AImgSlides[3] = nil then
      SetLength( AImgSlides, 3 ); // Return prev length

    // Clear  Slides.Marker
    for i := 0 to High(AImgSlides) do
      if AImgSlides[i] <> nil then
        AImgSlides[i].Marker := 0;

  end; // if SlidesBWCountN < 4 then

  Result := SlidesBWCountR + SlidesBWCountL;

end; // end of K_CMSSlidesBWReorder4

//****************************************** TN_CMResForm.aMediaOpenExecute ***
// Open Slides for editing
//
//     Parameters
// APSlide - pointer to Slides array start element
// ASlidesCount - number of Slides
// Result - Returns Studies counter
//
// On Output Slides first elements in source array are Studies last are Slides
//
function  K_CMSeparateSlidesAndStudies( APSlide: TN_PUDCMSlide; ASlidesCount: Integer  ): Integer;
var
  SepArray  : TN_UDCMSArray;
  i, k : Integer;
  Slide: TN_UDCMSlide;
  WPSlide: TN_PUDCMSlide;
begin
  SetLength( SepArray, ASlidesCount * 2 );
  Result := 0;
  k := ASlidesCount;
  WPSlide := APSlide;
  for i := 1 to ASlidesCount do
  begin
    Slide := WPSlide^;
    Inc(WPSlide);
    if TN_UDCMBSlide(Slide) is TN_UDCMStudy then
    begin
      SepArray[Result] := Slide;
      Inc(Result);
    end
    else
    begin
      SepArray[k] := Slide;
      Inc(k);
    end;
  end;
  if (Result = 0) or (Result = ASlidesCount) then Exit;

  // Move Studies to Src Array Head
  k := Result * SizeOf(TN_UDCMSlide);
  Move( SepArray[0], APSlide^, k );

  // Move Slides to Src Array Tail
  WPSlide := TN_PUDCMSlide(TN_BytesPtr(APSlide) + k);
//  Move( SepArray[Result], WPSlide^, (ASlidesCount - Result) * SizeOf(TN_UDCMSlide) );
  Move( SepArray[ASlidesCount], WPSlide^, ASlidesCount*SizeOf(TN_UDCMSlide) - k );

end; // function  K_CMSeparateSlidesAndStudies

//****************************************** TN_CMResForm.aMediaOpenExecute ***
// Open Slides for editing
//
//     Parameters
// APSlide - pointer to slides array start element to lock
// ASlidesCount - number of slides to lock
// ASkipEditMode - if TRUE then open not in Edit Mode
//
procedure K_CMSMediaOpen(APSlide: TN_PUDCMSlide; ASlidesCount: Integer; ASkipEditMode : Boolean = FALSE );
var
  // NumToOpen : Integer;
  NumMarked, NumImages, i, j: Integer;
  NewEdFrLayout: TN_EdFrLayout;
  NewEdFrCount: Integer;
  ImgSlides: TN_UDCMSArray;
  MediaSlide: TN_UDCMSlide;
  WStr: string;
  PCMSlide : TN_PCMSlide;
  NumReadOnly : Integer;
  NumSkipChanges : Integer;
  NumMarkAsDel : Integer;
  NumOutOfMemory : Integer;
  DumpSlidesOrderFlag : Boolean;
  LockResultMode : TK_CMEDLockResultMode;
  OutOfMemoryFlag : Boolean;
  Img3DSlide: TN_UDCMSlide;

begin
  with N_CM_MainForm do
  begin
    Inc(CMMSkipDisableActionsCount);
    CMMFShowString(''); // clear

    // *** Select Marked Slides and Media
    SetLength(ImgSlides, ASlidesCount);
    Move(APSlide^, ImgSlides[0], SizeOf(TN_UDCMSlide) * ASlidesCount);


    LockResultMode := K_cmlrmEditImgLock;
    if ASkipEditMode then
      LockResultMode := K_cmlrmOpenLock;
    K_CMSlidesLockForOpen(@ImgSlides[0], ASlidesCount, LockResultMode);

    // !! This Code can be removed because Save Code is added to EdFrame.EdFreeObjects
    // NumToOpen := 0;
    NumMarked := 0;
    MediaSlide := nil;
    Img3DSlide := nil;
    with K_CMEDAccess do
    begin
      // *** separate Image Slides and Media
      TmpStrings.Clear();
      for i := 0 to LockResCount - 1 do
      begin
        ImgSlides[NumMarked] := LockResSlides[i];
        with ImgSlides[NumMarked], P^ do
          if cmsfIsImg3DObj in CMSDB.SFlags then
          begin
            if Img3DSlide <> nil then
              // Unlock Next Media Objects
              K_CMEDAccess.EDAUnlockSlides(@ImgSlides[NumMarked], 1, K_cmlrmEditImgLock)
            else
              Img3DSlide := ImgSlides[NumMarked];
          end // if cmsfIsMediaObj in CMSDB.SFlags then
          else
          if cmsfIsMediaObj in CMSDB.SFlags then
          begin
            if MediaSlide <> nil then
              // Unlock Next Media Objects
              K_CMEDAccess.EDAUnlockSlides(@ImgSlides[NumMarked], 1, K_cmlrmEditImgLock)
            else
              MediaSlide := ImgSlides[NumMarked];
          end
          else
          begin // if not (cmsfIsMediaObj in CMSDB.SFlags) or
                //    not (cmsfIsImg3DObj in CMSDB.SFlags) then
            TmpStrings.Add(ObjName);
            Inc(NumMarked);
            // !! This Code can be removed because Save Code is added to EdFrame.EdFreeObjects
            // if not (cmsfIsOpened in CMSRFlags) then
            // Inc(NumToOpen); // Calculate number of slide to start editing
          end; // if not (cmsfIsMediaObj in CMSDB.SFlags) then
      end; // for i := 0 to LockResCount - 1 do
      LockResCount := 0;
    end; // with K_CMEDAccess do

    // ImgSlides[NumMarked] := MediaSlide;
    if MediaSlide <> nil then
    begin
      K_CMOpenMediaFile(MediaSlide);
      // Unlock Media  Object after open
      K_CMEDAccess.EDAUnlockSlides(@MediaSlide, 1, K_cmlrmEditImgLock);
    end // if MediaSlide <> nil then
    else
    if Img3DSlide <> nil then
    begin
      CMMImg3DOpen( Img3DSlide );
      // Unlock Media  Object 3DViewer
      K_CMEDAccess.EDAUnlockSlides(@Img3DSlide, 1, K_cmlrmEditImgLock);
    end; // if Img3DSlide <> nil then

    SetLength(ImgSlides, NumMarked);
    if NumMarked = 0 then
    begin
      if (MediaSlide = nil) and (Img3DSlide = nil) then
        CMMFShowStringByTimer( K_CML1Form.LLLNothingToDo.Caption ); //'Nothing to do!');
      Dec(CMMSkipDisableActionsCount);
      Exit;
    end;

    if K_CMStudySingleOpenGUIModeFlag then
    begin // Study is opened in SingleStudyMode
      if TN_UDCMBSlide(ImgSlides[0]) is TN_UDCMStudy then
      begin
        // Save Study Info in Open Context
        if NumMarked = 1 then
        begin
          CMMStudyLastOpened := TN_UDCMStudy(ImgSlides[0]);
          N_Dump2Str( 'Open >> Save in Open Context Study ID=' + ImgSlides[0].ObjName );
          if CMMStudyPrevLayout = eflNotDef then
            CMMStudyPrevLayout := CMMFEdFrLayout;
        end
      end
      else
      begin
        // Clear Study Info in Open Context
        if ImgSlides[0].GetStudyItem() = nil then
        begin
          CMMStudyPrevLayout := eflNotDef;
          CMMStudyLastOpened := nil;
          N_Dump2Str( 'Open >> Clear Prev Study in Open Context by New Slides' );
        end;
      end;

    end; // if K_CMStudySingleOpenGUIModeFlag then

    CMMFShowHideWaitState( TRUE );
    K_CMSResampleSlides( @ImgSlides[0], NumMarked, CMMFShowString );

    N_Dump2Str(format('K_CMSMediaOpen image slides to open >> %s', [K_CMEDAccess.TmpStrings.CommaText]));
    K_CMEDAccess.TmpStrings.Clear();
    DumpSlidesOrderFlag := FALSE;


    if NumMarked = 1 then
    begin
      NewEdFrLayout := eflOne;
    end
    else if NumMarked = 2 then
    begin
      if N_EdFrLayoutCounts[Ord(CMMFEdFrLayout)] = 2 then
        NewEdFrLayout := CMMFEdFrLayout
      else
        NewEdFrLayout := eflTwoHSp;
      if (CMMFEdFrLayout <> eflTwoHSp) and
         (K_CMSSlidesBWReorder2( ImgSlides ) <> 0) then
      begin
        NewEdFrLayout := eflTwoVSp;
        DumpSlidesOrderFlag := TRUE;
      end;
    end
    else if NumMarked <= 4 then
    begin
      NewEdFrLayout := eflFourHSp;
      DumpSlidesOrderFlag := K_CMSSlidesBWReorder4( ImgSlides ) > 0;
      NumMarked := Length(ImgSlides);
    end
    else
    begin
      NewEdFrLayout := eflNine;
    end;

    if DumpSlidesOrderFlag then
    begin
      K_CMEDAccess.EDADumpSlidesToTmpStrings( @ImgSlides[0], Length(ImgSlides) );
{
      for i := 0 to High(ImgSlides) do  // New SLides Open and Reopen Loop
        if ImgSlides[i] <> nil then
          with ImgSlides[i], P^ do
            K_CMEDAccess.TmpStrings.Add( format( '%s L%d R%d ',
                   [ObjName,
                   (CMSTeethFlags shr 60) and 3,
                   (CMSTeethFlags shr 28) and 3,
                   K_DateTimeToStr( CMSDTTaken, 'dd"-"mm"-"yyyy' )] ) )
        else
          K_CMEDAccess.TmpStrings.Add( '*' );
}
      N_Dump2Str(format('K_CMSMediaOpen BW slides order >> %s', [K_CMEDAccess.TmpStrings.CommaText]));
    end;
    NewEdFrCount := N_EdFrLayoutCounts[Ord(NewEdFrLayout)];

    NumImages := Min(NumMarked, NewEdFrCount);
    N_Dump2Str(format('K_CMSMediaOpen open count %d of %d', [NumImages, NumMarked]));


//    if NewEdFrCount <> CMMFNumEdFrames then // change Frames Layout Reorder Frames by opened Slides
    CMMFSetEdFramesLayout0( NewEdFrLayout, @ImgSlides[0], NumImages ); // Reorder Slides and Frames to minimize Slides reopen
    // CMMFSetEdFramesLayout( NewEdFrLayout );

    // For skip Unlock while changing opened slides reorder
    // For Skiping Free Memory for new opened Slides
    SetLength( K_CMSlidesToSkipMemFree, NumImages);
    K_CMEDAccess.TmpStrings.Clear();
    j := 0;
    for i := 0 to NumImages - 1 do // Set Skip Unlock Flag to prevent Unlock during Reopen
      if ImgSlides[i] <> nil then
        with ImgSlides[i], P^ do
        begin
          K_CMEDAccess.TmpStrings.Add(ObjName);
          Include(CMSRFlags, cmsfSkipUnlock);
          K_CMSlidesToSkipMemFree[j] := ImgSlides[i];
          Inc(j);
        end;
    SetLength( K_CMSlidesToSkipMemFree, j);

    K_CMSlidesToMemFree := nil; // Clear Slides to Free Memory for new opened Slides

//!!!    K_CMSCheckMemConstraints(nil); // Free Memory before start loading new

    N_Dump2Str('K_CMSMediaOpen after layout slides >> ' + K_CMEDAccess.TmpStrings.CommaText);

    K_CMEDAccess.TmpStrings.Clear();
    NumOutOfMemory := 0;
    N_CM_MainForm.CMMFShowString( format( K_CML1Form.LLLSlidesOpen8.Caption,
//          ' %d images are loaded. Please wait ...',
        [0] ) );
    for i := 0 to NumImages - 1 do  // New SLides Open and Reopen Loop
    begin
      if i > 0 then
      N_CM_MainForm.CMMFShowString( format( K_CML1Form.LLLSlidesOpen8.Caption,
//          ' %d images are loaded. Please wait ...',
          [i] ) );
      with CMMFEdFrames[i] do
      begin
        if EdSlide = nil then
          WStr := '*'
        else
          WStr := EdSlide.ObjName;
        RFrame.SkipOnResize := false;
        RFrame.SkipOnPaint := false;
        if ImgSlides[i] <> EdSlide then
        begin  // Try to Open New Image in current Frame
          if EdSlide <> nil then EdFreeObjects(); // Clear Closing Slide Resources for proper Memory Check
          PCMSlide := ImgSlides[i].P;
          OutOfMemoryFlag := FALSE;
          if ImgSlides[i] <> nil then
          begin
            if not K_CMSCheckMemForSlide1( ImgSlides[i] ) then
            begin
            // Image was not Loaded by memory lack - unlock it
              Exclude(PCMSlide.CMSRFlags, cmsfSkipUnlock);
              K_CMEDAccess.EDAUnlockSlides(@ImgSlides[i], 1, K_cmlrmEditImgLock);
              ImgSlides[i] := nil;
              WStr := 'OutOfMemory ' + WStr;
              OutOfMemoryFlag := TRUE;
              Inc(NumOutOfMemory);
            end;
          end;

          if not OutOfMemoryFlag and not SetNewSlide(ImgSlides[i]) then
          begin
            if ImgSlides[i] <> nil then
            begin
            // Image was not Loaded by file error - unlock it
              Exclude(PCMSlide.CMSRFlags, cmsfSkipUnlock);
              K_CMEDAccess.EDAUnlockSlides(@ImgSlides[i], 1, K_cmlrmEditImgLock);
              ImgSlides[i] := nil;
              WStr := 'Load Err ' + WStr
            end; // if ImgSlides[i] <> nil then
          end; // if not OutOfMemoryFlag and not SetNewSlide(ImgSlides[i]) then

        end  // if ImgSlides[i] <> EdSlide then
        else // Image was already opened in current Frame - Refresh Frame
        begin
          RFrame.OnResizeFrame(nil); //
        end;
        K_CMEDAccess.TmpStrings.Add(WStr + ' ' + Name);
      end; // with CMMFEdFrames[i] do

    end; // for i := 0 to NumImages - 1 do  // New SLides Open and Reopen Loop
    CMMFShowHideWaitState( FALSE );
    
    N_Dump2Str('K_CMSMediaOpen load report >> ' + K_CMEDAccess.TmpStrings.CommaText);
    CMMFShowString('');

    K_CMSlidesToSkipMemFree := nil; // Clear SLides to Skip Free Memory for new opened Slides
    K_CMSlidesToMemFree     := nil; // Clear Slides to Free Memory for new opened Slides

    NumReadOnly := 0;
    NumSkipChanges := 0;
    NumMarkAsDel := 0;
    for i := 0 to NumImages - 1 do
    begin
      if ImgSlides[i] = nil then Continue;
      PCMSlide := ImgSlides[i].P;
      Exclude(PCMSlide.CMSRFlags, cmsfSkipUnlock);
      Include(PCMSlide.CMSRFlags, cmsfIsOpened); // !! is needed if already opened Slides are opened in other Frames
      if (TN_UDCMBSlide(ImgSlides[i]) is TN_UDCMSlide) and
         (cmsfIsUsed in PCMSlide.CMSRFlags) then   // Count ReadOnly Slides
        with ImgSlides[i] do
        begin
          CMSUndoBuf.UBMinInd := CMSUndoBuf.UBCurInd;
          Inc(NumReadOnly);
          if cmsdbfMarkedAsDel in CMSDBStateFlags then
            Inc(NumMarkAsDel)
          else if CMSlideEdState = K_edsSkipChanges then
            Inc(NumSkipChanges);
        end;
    end;

    if NumOutOfMemory > 0 then
    begin
      WStr := format( K_CML1Form.LLLMemory7.Caption,
//   'There is not enough memory to open more than %d object(s) of this size.'
          [NumImages - NumOutOfMemory] );
      K_CMShowMessageDlg( WStr, mtWarning );
    end;
  /////////////////////////////////////////
  // Prepare Messages for not opened Slides
    WStr := '';
    if K_CMMarkAsDelShowFlag then
    begin
      if NumImages > 0 then
        WStr := K_CML1Form.LLLSlidesOpen2.Caption
//          ' Media object(s) opened in this mode couldn''t be changed.'
    end
    else
    if NumReadOnly > 0 then
    begin
      if NumMarkAsDel <> 0 then
      begin
        WStr := format( K_CML1Form.LLLSlidesOpen3.Caption,
//            ' %d Media object(s) are marked as deleted. They couldn''t be changed.'#13#10 +
//            '   Please restore their state first if you wish to change them.',
            [NumMarkAsDel] );
        K_CMShowMessageDlg(WStr, mtInformation);
      end;
      NumReadOnly := NumReadOnly - NumMarkAsDel;
      if NumSkipChanges = 0 then
        WStr := format( K_CML1Form.LLLSlidesOpen4.Caption,
//            ' %d Media object(s) are opened by other user(s).'#13#10 +
//            ' Any changes made to them will not be saved.',
            [NumReadOnly] )
      else
      begin
        if NumReadOnly > NumSkipChanges then
          WStr := format( K_CML1Form.LLLSlidesOpen5.Caption,
//              ' %d Media object(s) are opened by other user(s).'#13#10 +
//              ' %d Media object(s) are from another location(s).'#13#10 +
//              ' Any changes made to them will not be saved.'#13#10 +
//              ' Please duplicate the object(s) from another'#13#10 +
//              ' location(s) first if you wish to save the changes.',
              [NumReadOnly - NumSkipChanges,NumSkipChanges] )
        else
          WStr := format( K_CML1Form.LLLSlidesOpen6.Caption,
//              ' %d Media object(s) are from another location(s).'#13#10 +
//              ' Any changes made to them will not be saved.'#13#10 +
//              ' Please duplicate the object(s) first'#13#10 +
//              ' if you wish to save the changes.',
              [NumReadOnly] );
      end;
    end;
    if WStr <> '' then
//      K_CMShowMessageDlg(WStr, mtInformation);
      K_CMShowSoftMessageDlg( WStr, mtInformation, 10 );

    for i := NumImages to NewEdFrCount - 1 do
      CMMFEdFrames[i].EdFreeObjects();

    if NumMarked > NumImages then
    begin
      CMMFShowStringByTimer( format( K_CML1Form.LLLSlidesOpen7.Caption,
//        'There are too many objects to display in the "Studio" area. %d objects will not be displayed.',
          [NumMarked - NumImages] ) );

      for i := NumImages to NumMarked - 1 do
        if cmsfIsLocked in ImgSlides[i].P^.CMSRFlags then
          K_CMEDAccess.EDAUnlockSlides(@ImgSlides[i], 1, K_cmlrmEditImgLock);
      // Unlock Extra Marked Objects (> 9)
    end;
    Dec(CMMSkipDisableActionsCount);
    CMMFDisableActions(nil);
  end; // with N_CM_MainForm, CMMFThumbsDGrid do

end; // procedure K_CMSMediaOpen

//************************************************** K_CMGetProviderDetails ***
// Get Given Provider Details
//
//     Parameters
// AProvID - Provider ID, if =-1 then Current Provider info will be used
// APattern - Provider Details Pattern
// Result - Returns string with Provider Details
//
function K_CMGetProviderDetails(AProvID: Integer;
  APattern: string = ''): string;
var
  ProviderML: TStrings;
begin
  with K_CMEDAccess do
  begin
    ProviderML := EDAGetProviderMacroInfo(AProvID);
    if (ProviderML = nil) or (ExtResultCode = K_edAbsentData) then
      Result := 'Dr. ID=' + IntToStr(AProvID)
    else
    begin
      if APattern = '' then
        APattern := K_CMENPTCommonProviderDetails;
      Result := K_StringMListReplace(APattern, ProviderML, K_ummRemoveMacro);
    end;
  end;
end; // K_CMGetProviderDetails

//***************************************************** K_CMGetProviderName ***
// Get Given Provider Name
//
//     Parameters
// AProvID - Provider ID, if =-1 then Current Provider info will be used
// Result - Returns string with Provider Details
//
function K_CMGetProviderName( AProvID: Integer ): string;
var
  ProvSID : string;
  SAProvDBData : TK_CMSAProviderDBData;
begin
  Result := K_CMGetProviderDetails( AProvID );
  if K_StrStartsWith( 'Dr. ID=', Result ) then
  begin
    ProvSID := IntToStr(AProvID);
    if K_edOK = K_CMEDAccess.EDASAGetOneProviderInfo( ProvSID, @SAProvDBData, [K_cmsagiSkipLock] ) then
      Result := format( '%s %s', [SAProvDBData.AUFirstname,SAProvDBData.AUSurname] )
    else
    TK_CMEDDBAccess(K_CMEDAccess).EDAGetOneProviderHistAttrs( ProvSID, @Result );
  end;
end; // K_CMGetProviderName

//************************************************** K_CMGetLocationDetails ***
// Get Given Location Details
//
//     Parameters
// ALocID - Location ID, if =-1 then Current Location info will be used
// APattern - Provider Details Pattern
// Result - Returns string with Provider Details
//
function K_CMGetLocationDetails( ALocID: Integer; APattern: string = '' ): string;
var
  LocationML: TStrings;
begin
  with K_CMEDAccess do
  begin
    LocationML := EDAGetLocationMacroInfo(ALocID);
    if (LocationML = nil) or (ExtResultCode = K_edAbsentData) then
      Result := 'LocID=' + IntToStr(ALocID)
    else
    begin
      if APattern = '' then
        APattern := K_CMENPTCommonLocationDetails;
      Result := K_StringMListReplace(APattern, LocationML, K_ummRemoveMacro);
    end;
  end;
end; // K_CMGetLocationDetails

//*************************************************** K_CMGetPatientDetails ***
// Get Given Patient Details
//
//     Parameters
// APatID - Patient ID, if =-1 then Current Patient info will be used
// APattern - Provider Details Pattern
// Result - Returns string with Provider Details
//
function K_CMGetPatientDetails(APatID: Integer; APattern: string = ''): string;
var
  PatientML: TStrings;
begin
  with K_CMEDAccess do
  begin
    PatientML := EDAGetPatientMacroInfo(APatID);
    if (PatientML = nil) or (ExtResultCode = K_edAbsentData) then
    begin
      if APatID = -1 then APatID := CurPatID;
      Result := 'Px. ID=' + IntToStr(APatID)
    end
    else
    begin
      if APattern = '' then
        APattern := K_CMENPTCommonPatientDetails;
      Result := K_StringMListReplace(APattern, PatientML, K_ummRemoveMacro);
    end;
  end;
end; // K_CMGetPatientDetails

//****************************************************** K_CMGetPatientName ***
// Get Given Patient Name as <Lastname> <Firstname>
//
//     Parameters
// APatID - Patient ID, if =-1 then Current Patient info will be used
// APCardNum - pointer to resulting string for Patient Card Number
// Result - Returns string with Patient Details
//
function K_CMGetPatientName( APatID: Integer; APCardNum : PString = nil ): string;
var
  PatSID : string;
  SAPatientDBData : TK_CMSAPatientDBData;
  PatientHistDBData : TK_CMPatientHistDBData;
begin
  if APCardNum = nil then
  Result := K_CMGetPatientDetails( APatID );
  if K_StrStartsWith( 'Px. ID=', Result ) or (APCardNum <> nil)  then
  begin
    PatSID := IntToStr(APatID);
    if K_edOK = K_CMEDAccess.EDASAGetOnePatientInfo( PatSID,
                                     @SAPatientDBData, [K_cmsagiSkipLock] ) then
    begin
      Result := format( '%s %s', [SAPatientDBData.APFirstname,SAPatientDBData.APSurname] );
      if APCardNum <> nil then APCardNum^ := SAPatientDBData.APCardNum;
    end
    else
    if K_edOK = TK_CMEDDBAccess(K_CMEDAccess).EDAGetOnePatientHistAttrs( PatSID, @PatientHistDBData ) then
    begin
      Result := PatientHistDBData.HPName;
      if APCardNum <> nil then APCardNum^ := PatientHistDBData.HPCardNum;
    end;
  end;
end; // K_CMGetPatientName

//***************************************************** K_CMGetPatientName1 ***
// Get Given Patient Name as <Firstname> <Lastname>
//
//     Parameters
// APatID - Patient ID, if =-1 then Current Patient info will be used
// Result - Returns string with Provider Details
//
function K_CMGetPatientName1( APatID: Integer; APCardNum : PString = nil ): string;
var
  WStr : string;
  Ind, L, LL : Integer;
begin
  Result := K_CMGetPatientName( APatID, APCardNum );
  // Switch Firstname <-> Lastname
  L := Length(Result);
  if L <= 1 then Exit; // precaution

  // Search Whitespace delimiter
  Ind := 1;
  while (Ind <= L) and (Result[Ind] <> ' ') do Inc(Ind);
  if Ind > L then Exit; // Whitespace is nnot found

  // Switch Firstname <-> Lastname
  SetLength( WStr, L );
  LL := L - Ind;
  if LL > 0 then
    Move( Result[Ind + 1], WStr[1], LL * SizeOf(Char) );
  WStr[LL + 1] := ' '; // set new delimiter
  if Ind > 1  then
    Move( Result[1], WStr[LL + 2], (Ind -1) * SizeOf(Char) );
  Result := WStr;
end; // K_CMGetPatientName1

//************************************************** K_CMD4WApplyBufContext ***
// Set Saved D4W Context
//
procedure K_CMD4WApplyBufContext();
var
  PSlideFilterAttrs: TK_PCMSlideFilterAttrs;
//  CheckECache : Boolean;
  WStr : string;
begin
  if K_CMSAppStartContext.CMASMode = K_cmamCOMHPUI then
  begin
  //////////////////////////////////////
  //        Switch to HR Preview
  //
    N_Dump2Str('K_CMD4WApplyBufContext >> Switch to HP UI' );
    K_CMSwithToHPUI();
    Exit;
  end;

  //////////////////////////////////////
  //  Apply Buffered Context in VE Mode
  //
  if (K_CMD4WCNewPatientID <> -1) or K_CMD4WUseFilteringInfoFlag then
  begin
    if K_CMD4WUseFilteringInfoFlag then
      PSlideFilterAttrs := @K_CMD4WSlideFilterAttrs
    else
      PSlideFilterAttrs := nil;

    // Do Stored D4W Client Request
    N_Dump2Str('DB >> Saved D4W Context Set State PatID=' + IntToStr(K_CMD4WCNewPatientID)
        + ' ProvID=' + IntToStr(K_CMD4WCNewProviderID) + ' LocID=' + IntToStr
        (K_CMD4WCNewLocationID));

    WStr := K_CMD4WApplyNewContextInfo();
    if WStr <> '' then
      N_Dump2Str('DB >> ApplyInfo:' + WStr );
    K_CMSCLLContextFromEDAPPL( K_CMD4WCNewLocationID, K_CMD4WCNewProviderID, K_CMD4WCNewPatientID );
    K_CMSetCurSessionContext1( K_CMD4WCNewPatientID, K_CMD4WCNewProviderID,
                               K_CMD4WCNewLocationID, PSlideFilterAttrs  );
  end; // if (K_CMD4WCNewPatientID <> -1) or K_CMD4WUseFilteringInfoFlag then

  if K_CMD4WUICommandsList <> nil then
  begin
    N_Dump1Str('Before ExecUICommandsList.Count=' + IntTostr(K_CMD4WUICommandsList.Count) );
    K_ExecUICommandsList();
    N_Dump1Str('After ExecUICommandsList' );
  end;
  { // 05.01.2010
    if K_CMD4WCNewWindowState <> -1 then begin
    N_Dump2Str( 'D4WCNew >> SetWindowState to '+IntToStr(K_CMD4WCNewWindowState) );
    with N_CM_MainForm do
      CMMSetWindowState( Handle, K_CMD4WCNewWindowState );
    K_CMD4WCNewWindowState := -1;
    end;
    { }
end; // procedure K_CMD4WApplyBufContext

//************************************************* K_CMSlideHistoryShowDlg ***
// Slide Show History Dialog (used if DBVesion < 13 only)
//
procedure K_CMSlideHistoryShowDlg(ASlide: TN_UDCMSlide);
var
  i: Integer;
  VideoFExt, WStr: string;
  SL: TStringList;
  VideoFlag: Boolean;
  PCMSlideEdHist: TN_PCMSlideHist;
  SlideHist: TN_CMSlideHist;
  HistActType: TK_CMSlideHistActType;
  Hist1, Hist2, Hist3, Hist4: Byte;

  function GetHistText( const ATexts : array of string; AInd : Integer ) : string;
  begin
    if Length(ATexts) > AInd then
      Result := ATexts[AInd]
    else
      Result := 'undefined';
  end;

  procedure AddNewLine();
  begin
    with K_CMEDAccess, PCMSlideEdHist^ do
    begin
      HistActType := EDAGetHistActionInfo(SHistActCode, Hist1, Hist2, Hist3,
        Hist4);
      if HistActType = K_shATNotChange then
      begin
        // Events not changing Slide
//      WStr := K_CMSHistNCActTexts[Hist1]
        WStr := GetHistText( K_CMSHistNCActTexts, Hist1 );
        if Hist1 = Byte(Ord(K_shNCAExportFile)) then
        begin
          WStr := WStr + ' format ';
          if not VideoFlag then
//          WStr := WStr + K_CMSHistExpFormatTexts[Hist2]
            WStr := WStr + GetHistText( K_CMSHistExpFormatTexts, Hist2 )
          else
            WStr := WStr + VideoFExt;
        end;
      end
      else
      begin
        if Hist1 = Byte( Ord(K_shCACreate) ) then Exit; // Skip Slide Create Event;
//        WStr := K_CMSHistCActTexts[Hist1];
        WStr := GetHistText( K_CMSHistCActTexts, Hist1 );
        if Hist1 = Byte(Ord(K_shCAImage)) then
        begin
          WStr := WStr + ' ' + K_CMSHistImgActTexts[Hist2]
//            WStr := WStr + GetHistText( K_CMSHistImgActTexts, Hist2 )
        end
        else if Hist1 = Byte(Ord(K_shCAVOObject)) then
        begin
//          WStr := WStr + ' ' + K_CMSHistVObjTypeTexts[Hist3] + ' ' +
//            K_CMSHistVObjActTexts[Hist2];
//          if Hist2 = Ord(K_shVOActCalibrate) then
//            WStr := GetHistText( K_CMSHistVObjActTexts, Hist2 )
//          else
          WStr := WStr + ' ' + GetHistText( K_CMSHistVObjTypeTexts, Hist3 ) + ' ' +
              GetHistText( K_CMSHistVObjActTexts, Hist2 );
        end;
        if HistActType = K_shATUndoChange then
          WStr := 'Undo ' + WStr;
      end;
      SL.Add( K_DateTimeToStr(SHistActTS, 'dd.mm.yyyy "at" hh:nn AM/PM') +
          Chr($09) + format(' %-20s', [K_CMGetProviderDetails(SHistProvID)]) +
          Chr($09) + format(' %-20s', [K_CMGetLocationDetails(SHistLocID)]) +
          Chr($09) + WStr );
    end;
  end;

begin
  with K_CMEDAccess, ASlide, P()^ do
  begin
    VideoFlag := cmsfIsMediaObj in CMSDB.SFlags;
    VideoFExt := UpperCase(Copy(CMSDB.MediaFExt, 2, 5));
    SL := TStringList.Create;
    WStr := 'Image';
    if VideoFlag then
      WStr := 'Video';
    SL.Add(format('Patient: %-20s %s Object History',
        [K_CMGetPatientDetails(CMSPatId), WStr]));
    SL.Add('');
    SL.Add('   Date/Time        ' + Chr($09) +
           '       Provider     '  + Chr($09) +
           '       Location     '  + Chr($09) + '      Action ');
    SL.Add( K_DateTimeToStr(CMSDTCreated, 'dd.mm.yyyy "at" hh:nn AM/PM') +
            Chr($09) + format(' %-20s', [K_CMGetProviderDetails(CMSProvIDCreated)]) +
            Chr($09) + format(' %-20s', [K_CMGetLocationDetails(CMSLocIDHost)]) +
            Chr($09) + 'Created (' + CMSSourceDescr + ')');

    if K_CMEDAccess is TK_CMEDDBAccess then
    begin
      // Add DB History
      with TK_CMEDDBAccess(K_CMEDAccess), CurDSet1 do
      begin
        Connection := LANDBConnection;
        SQL.Text := 'select ' +
          K_CMENDBSlidesHTFSlideID + ',' + K_CMENDBSlidesHTFProvID + ',' +
          K_CMENDBSlidesHTFActID   + ',' + K_CMENDBSlidesHTFActTS +
//!!! db=10 ',' + K_CMENDBSlidesHTFLocID   +
          ' from ' + K_CMENDBSlidesHistTable +
          ' where ' + K_CMENDBSlidesHTFSlideID + '=' + ObjName +
          ' order by ' + K_CMENDBSlidesHTFActTS + ' asc';
        Filtered := false;
        Open;
        First;
        PCMSlideEdHist := @SlideHist;
        while not Eof do
        begin
          SlideHist.SHistProvID := FieldList.Fields[1].AsInteger;
          SlideHist.SHistActCode := FieldList.Fields[2].AsInteger;
          SlideHist.SHistActTS := TDateTimeField(FieldList.Fields[3]).Value;
//!!! db=10  SlideHist.SHistLocID := FieldList.Fields[4].AsInteger;
          AddNewLine();
          Next;
        end;
        Close();
      end;
    end;

    // Add SLide History
    for i := 0 to CMSHist.AHigh do
    begin
      PCMSlideEdHist := CMSHist.P(i);
      AddNewLine();
    end;

    SL.Add('');
    with K_GetFormTextEdit(nil, 'CMSHist', [rspfMFRect,rspfCenter], [rspfMFRect,rspfCenter] ) do
    begin
      BtCancel.Visible := false;
      EditStrings(SL, 'Object history', TRUE, TRUE);
    end;
    SL.Free;
  end;
end; // K_CMSlideHistoryShowDlg

//******************************************************** K_CMGetVObjPAttr ***
// Get VObject Attribute Pointer
//     Parameters
// AVObj - annotation root component object
// AAttrName - annotation attribute name
// Result - Returns Pointer to VObject Attribute
//
function K_CMGetVObjPAttr(AVObj: TN_UDBase;
  AAttrName: string): TN_POneUserParam;
var
  UDAttrs: TN_UDBase;
begin
  UDAttrs := AVObj.DirChild(0);
  if UDAttrs = nil then
    UDAttrs := AVObj;
  Result := N_GetUserParPtr(TN_UDCompBase(UDAttrs).R, AAttrName);
end; // procedure K_CMGetVObjPAttr

//************************************************** K_CMChangeVObjSelColor ***
// Change VObject Selection Color by Main Color
//     Parameters
// AVObj - annotation root component object
// AMainColor - annotation main color
//
// Change annotation selection color if main color value is "close" to selection
// color
//
procedure K_CMChangeVObjSelectedColor(AVObj: TN_UDBase; AMainColor: Integer);
var
  PUPSelColor: TN_POneUserParam;
  PC: PColor;
  RDif: Double;
begin
  PUPSelColor := K_CMGetVObjPAttr(AVObj, 'SignFillColor');
  if PUPSelColor = nil then
    Exit;
  PC := PColor(PUPSelColor.UPValue.P);
  RDif := K_GetColorsRGBDif(AMainColor, $FF);
  if (RDif > 0.3) or (RDif > K_GetColorsRGBDif(AMainColor, $FF00)) then
    // if RDif > K_GetColorsRGBDif( AMainColor, $FF00 ) then
    PC^ := $FF // red
  else
    PC^ := $FF00; // green
end; // procedure K_CMChangeVObjSelectedColor

//************************************************** K_CMChangeCaptButDelay ***
// Change VideoCam Pedal Delay
//
// Result - Returns TRUE if Pedal Delay was chahged
//
function K_CMChangeCaptButDelay(): Boolean;
begin
  Result := K_CMGetCaptButDelayDlg(K_CMCaptButDelay);
end; // K_CMChangeCaptButDelay

//********************************************** K_CMSlidesCopyMoveByPatOld ***
// Copy/move all slides from one patient to another (old version)
//
//     Parameters
// ASrcPatID - given source patient ID
// ASrcPatID - given destination patient ID
// ACopyFlag - copy/move slides mode (=0 means move mode, <> 0 copy mode
// Result    - number of copied Slides, or
//#F
//   -1 - CMS works with Source or Destination Patient on this computer
//   -2 - Source Patient Slides are used by some CMS Users
//   -3 - Copy files error
//#/F
//
function K_CMSlidesCopyMoveByPatOld(ASrcPatID, ADstPatID, ACopyFlag: Integer) : Integer;
var
  WCurSlidesList: TList;
  WSSPatID: Integer;
  i, Ind, j: Integer;
  LInds: TN_IArray;
  SrcFPath, SrcFPat, DstFPath, DstFPat: string;
  CopyResult: TK_CMEDResult;
  SrcFName, DstFName, SplitFNPat: string;
  PSlideFields: TN_PCMSlide;
  DstSlides: TN_UDCMSArray;
  SrcSlides: TN_UDCMSArray;
  SQLStr: string;
  SrcUDSlide, DstUDSlide: TN_UDCMSlide;
  SavedCurSessionHistID : Integer;
  SavedCurSessionHistStartTS : TDateTime;
  SavedCurPatID : Integer;
  AddSourceDescr : string;

  procedure FreeSlides();
  var
    i: Integer;
  begin
    with TK_CMEDDBAccess(K_CMEDAccess) do
    begin
      // Unlock Slides
//      if LockResCount <> 0 then
//        EDAUnlockSlides(@LockResSlides[0], LockResCount, K_cmlrmDeleteLock);
      EDAUnlockAllLockedSlides(K_cmlrmDeleteLock);
      // Free Src Slides Objects
      for i := 0 to CurSlidesList.Count - 1 do
        TObject(CurSlidesList[i]).Free;

      // Free Dst Slides Objects
      for i := 0 to High(DstSlides) do
        DstSlides[i].Free;

      // Restore Cur Slides Context
      CurSlidesSelectAttrs.SSPatID := WSSPatID;
      CurSlidesList.Assign(WCurSlidesList);
      WCurSlidesList.Free;
      LockResCount := 0; // Clear LockResCount to prevent AMSC Error

      if SavedCurPatID = -1 then Exit;

      EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                     Ord(K_shNCAFinishSession) ) );
      CurPatID := SavedCurPatID;
      CurSessionHistID := SavedCurSessionHistID;
      CurSessionHistStartTS := SavedCurSessionHistStartTS;
    end;
  end; // procedure FreeSlides();

begin
  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    // Check if Patients are used on this Computer
    SrcSlides := nil; // for skip warning
    N_Dump2Str(format(
        'D4W>> Old CopyMove Slides start from Patient ID=%d to ID=%d mode=%d',
        [ASrcPatID, ADstPatID, ACopyFlag]));
    SavedCurSessionHistID := -1;
    SavedCurPatID := -1;
    WSSPatID := CurSlidesSelectAttrs.SSPatID;
    Result := -1;
    if (ASrcPatID = WSSPatID) then
      N_Dump2Str(
        'D4W>> Old CopyMove Src Patient is opened on current computer')
    else if (ADstPatID = WSSPatID) then
      N_Dump2Str(
        'D4W>> Old CopyMove Dst Patient is opened on current computer')
    else
      Result := 0;
    if Result <> 0 then
      Exit;

    // Save Cur Slides Context
    WCurSlidesList := TList.Create;
    WCurSlidesList.Assign(CurSlidesList);
    CurSlidesList.Clear;
    CurSlidesSelectAttrs.SSPatID := ASrcPatID;
    EDAGetCurSlidesSet();

    if CurSlidesList.Count = 0 then
    begin
      // nothing to do
      FreeSlides();
      N_Dump2Str( 'D4W>> Old CopyMove nothing to do' );
      Exit;
    end;

  //////////////////////////////////
  // Save History Session Context
  //
    SavedCurSessionHistID := CurSessionHistID;
    SavedCurPatID := CurPatID;
    SavedCurSessionHistStartTS := CurSessionHistStartTS;
    CurPatID := ADstPatID;
    EDAAddSessionHistRecord();
    EDASaveSlidesHistory( '', EDABuildHistActionCode( K_shATNotChange,
                                             Ord(K_shNCAStartSession) ) );

    EDALockSlides( TN_PUDCMSlide(@CurSlidesList.List[0]), CurSlidesList.Count,
                   K_cmlrmDeleteLock );

    /////////////////////////////////////////
    // remove already deleted slides from locked slides array
    //
    if (LockResDelCount > 0) then
    begin
      SetLength(LInds, LockResCount);
      Ind := 0;
      for i := 0 to LockResCount - 1 do
      begin
        if K_IndexOfIntegerInRArray(Integer(LockResSlides[i]),
          PInteger(@LockResDelSlides[0]), LockResDelCount) <> -1 then
          Continue;
        LInds[Ind] := i;
        Inc(Ind);
      end;

      for i := 0 to Ind - 1 do
        LockResSlides[i] := LockResSlides[LInds[i]];
      LockResCount := Ind;
    end; // if (LockResDelCount > 0) then

    /////////////////////////////////////////
    // remove Slides replicated to another locations from locked slides array
    // in Enterprise Mode
    //
    if K_CMEnterpriseModeFlag then
    begin
      // remove already deleted slides from locked slides array
      EDABuildSelectSQLBySlidesList( @LockResSlides[0], LockResCount, @SQLStr, nil );
      with CurDSet3 do
      begin // Use CurDSet3 because CurSlidesDSet is used inside K_CMGetMediaFileName
        // Select records for Slides of Current Patient from All SLides Table
        Connection := LANDBConnection;
        SQL.Text := 'select '  + K_CMENDBLFILocSlideID +
             ' from '  + K_CMENDBLocFilesInfoTable +
             ' where ' + SQLStr;
        Filtered := false;
        Open;
        for i := 0 to LockResCount - 1 do
        begin
          Filtered := FALSE;
          Filter := K_CMENDBLFILocSlideID +'='+ LockResSlides[i].ObjName;
          Filtered := TRUE;
          if RecordCount = 1 then Continue; //
          Close;
          N_Dump2Str('D4W>> Old CopyMove Src Patient Slides are replicated to other locations');
          Result := -2;
          FreeSlides();
          Exit;
        end; // for i := 0 to LockResCount - 1 do
        Close;
      end; // with CurDSet3 do

    end; // if K_CMEnterpriseModeFlag then

    Ind := CurSlidesList.Count - LockResDelCount;
    if Ind > LockResCount then
    begin
      // Some Src Patient Slides are in use
      N_Dump2Str(format(
          'D4W>> Old CopyMove Src Patient Slides (%d of %d) are in use',
          [Ind - LockResCount, Ind]));
      Result := -2;
      FreeSlides();
      Exit;
    end; // if CurSlidesList.Count - LockResDelCount > LockResCount then

    Result := LockResCount;
    if LockResCount = 0 then
    begin
      // nothing to do
      FreeSlides();
      Exit;
    end;

    ////////////////////////////////////////////////
    // Create Dst Slides Objects
    //
    SrcSlides := Copy(LockResSlides, 0, LockResCount);
    SetLength(DstSlides, LockResCount);
    if ACopyFlag <> 0 then
      AddSourceDescr := format( ' (copied Px. ID=%d)', [ASrcPatID] );
    for i := 0 to LockResCount - 1 do
    begin
      if ACopyFlag = 0 then
      begin
        // Move Slides
        DstSlides[i] := TN_UDCMSlide(SrcSlides[i].Clone());
        DstSlides[i].P.CMSPatId := ADstPatID;
      end
      else
      begin
        // Copy Slides
        K_SaveTreeToMem(SrcSlides[i], N_SerialBuf);
        DstSlides[i] := TN_UDCMSlide(K_LoadTreeFromMem(N_SerialBuf));
        with DstSlides[i] do
        begin
          PSlideFields := P();
//          GetMapRoot(false, TRUE, TRUE);
          K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapImgBuild,K_gmrfSkipCurImgLoad];
          GetMapRoot();
          K_UDCMSlideGetMapRootFlags := [];

          PSlideFields.CMSPatId := ADstPatID; // Set Patient ID after Update because of Slide Update in GetMapRoot()
          PSlideFields.CMSRFlags := PSlideFields.CMSRFlags + [cmsfIsNew,
            cmsfMapRootChanged, cmsfAttribsChanged, cmsfThumbChanged,
            cmsfSkipNewFile];
          PSlideFields.CMSSourceDescr := PSlideFields.CMSSourceDescr + AddSourceDescr;
        end;
      end;
    end; // for i := 0 to LockResCount - 1 do


    if ACopyFlag <> 0 then
    begin
      // Save Copied Slide Objects
      EDASaveSlidesArray(@DstSlides[0], LockResCount);
      EDALockSlides(@DstSlides[0], LockResCount, K_cmlrmDeleteLock);
      N_Dump2Str('D4W>> Old CopyMove Slides copy is done');
    end;

    ///////////////////////////////////////////////
    // Copy Slides Files
    //
    Ind := 0;
    for i := 0 to LockResCount - 1 do
    begin
      Ind := i;
      SrcUDSlide := SrcSlides[i];
      DstUDSlide := DstSlides[i];
      PSlideFields := SrcUDSlide.P();
      SrcFPath := SrcUDSlide.GetFilesPathSegm();
      DstFPath := DstUDSlide.GetFilesPathSegm();
      CopyResult := K_edOK;

      if cmsfIsMediaObj in PSlideFields.CMSDB.SFlags then
      begin
        // Copy Video Files
        SrcFPat := SrcUDSlide.GetMediaFileNamePref('');
        DstFPat := DstUDSlide.GetMediaFileNamePref('');
        if SlidesClientMediaRootFolder <> '' then
        begin
        // Client Side Copy
          K_CopyFile(SlidesClientMediaRootFolder + SrcFPath + SrcFPat +
              PSlideFields.CMSDB.MediaFExt,
            SlidesClientMediaRootFolder + DstFPath + DstFPat +
              PSlideFields.CMSDB.MediaFExt);
        end; // if SlidesClientMediaRootFolder <> '' then

        if SlidesMediaRootFolder <> '' then
        begin
        // Server Side Copy
          SrcFPat := SlidesMediaRootFolder + SrcFPath + SrcFPat;
          DstFPat := SlidesMediaRootFolder + DstFPath + DstFPat;
          SplitFNPat := '_0.mfp';
          if EDAPathOrFileExists(SrcFPat + SplitFNPat, SlidesMediaRootFDA,
            false) = K_edOK then
          begin
            // Splitted Video File parts Copy
            j := 0;
            repeat
              SrcFName := SrcFPat + SplitFNPat;
              DstFName := DstFPat + SplitFNPat;
              CopyResult := EDACopyFileOnServer(SrcFName, DstFName,
                SlidesMediaRootFDA);
              Inc(j);
              SplitFNPat := format('_%d.mfp', [j]);
            until (CopyResult = K_edFails) or
              (EDAPathOrFileExists(SrcFName + SplitFNPat, SlidesMediaRootFDA,
                false) <> K_edOK);
          end
          else
          begin
            // Whole Video File parts Copy
            SrcFName := SrcFPat + PSlideFields.CMSDB.MediaFExt;
            DstFName := DstFPat + PSlideFields.CMSDB.MediaFExt;
            CopyResult := EDACopyFileOnServer(SrcFName, DstFName,
              SlidesMediaRootFDA);
          end;
        end;
      end   // if cmsfIsMediaObj in PSlideFields.CMSDB.SFlags then
      else
      begin // if not (cmsfIsMediaObj in PSlideFields.CMSDB.SFlags) then
        // Copy Image Files
        SrcFPath := SlidesImgRootFolder + SrcFPath;
        DstFPath := SlidesImgRootFolder + DstFPath;
        if TN_UDCMBSlide(SrcUDSlide) is TN_UDCMStudy then
        begin
          SrcFName := TN_UDCMStudy(SrcUDSlide).GetFileName(SrcFPath);
          DstFName := TN_UDCMStudy(DstUDSlide).GetFileName(DstFPath);
        end
        else
        begin
          SrcFName := SrcUDSlide.GetCurImgFileName(SrcFPath);
          DstFName := DstUDSlide.GetCurImgFileName(DstFPath);
        end;
        CopyResult := EDACopyFileOnServer(SrcFName, DstFName, SlidesImgRootFDA);
        if CopyResult = K_edImageFilesMoving then
          N_Dump2Str
            ('D4W>> Old CopyMove Src Patient Slide  file is absent ' + SrcFName);
        if (CopyResult <> K_edFails) and
          (cmsfHasSrcImg in PSlideFields.CMSDB.SFlags) then
        begin
          SrcFName := SrcUDSlide.GetSrcImgFileName(SrcFPath);
          DstFName := DstUDSlide.GetSrcImgFileName(DstFPath);
          CopyResult := EDACopyFileOnServer(SrcFName, DstFName,
            SlidesImgRootFDA);
        end;
      end; // if not (cmsfIsMediaObj in PSlideFields.CMSDB.SFlags) then

      if CopyResult = K_edImageFilesMoving then
        N_Dump2Str
          ('D4W>> Old CopyMove Src Patient Slide  files are absent ' + SrcFName)
      else
      if CopyResult = K_edFails then
      begin
        N_Dump2Str('D4W>> Old CopyMove Dst Patient Slide files fails at ' +
            DstFName);
        Result := -3;
        break; // Clear copied files should be done
      end; // if CopyResult = K_edFails then
    end; // for i := 0 to LockResCount - 1 do

    if Result = -3 then
    begin
      ///////////////////////////////////////////////
      // Copy Files Error - remove already copied
      //
      N_Dump2Str(format(
          'D4W>> Old CopyMove remove %d files of %d from Dst Patient',
          [Ind, LockResCount]));
      EDABuildSelectSQLBySlidesList( @DstSlides[0], Ind, @SQLStr, nil );

      if ACopyFlag <> 0 then // Unlock and Delete Created Slides if Copy
      begin
        try
          with CurSQLCommand1 do
          begin
            ExtDataErrorCode := K_eeFilesPocessing;
            Connection := LANDBConnection;

            LANDBConnection.BeginTrans;
            // Lock Active Instance Table in exclusive mode
            ExtDataErrorCode := K_eeDBLock;
            //Code Not used now
            CommandText := 'LOCK TABLE ' + K_CMENDBLockSlidesTable + ' IN EXCLUSIVE MODE;';
            Execute;

            ExtDataErrorCode := K_eeDBDel;
            // Delete Slides Lock Info
            CommandText := 'DELETE FROM ' + K_CMENDBLockSlidesTable +
              ' WHERE ' + K_CMENDBLSlidesTFActRTID + '=' + IntToStr
              (AppRTID) + ' and  ( ' + SQLStr + ' )';
            Execute;

            // Delete Slides
            CommandText := 'DELETE FROM ' + K_CMENDBSlidesTable + ' WHERE ' +
              SQLStr;
            Execute;

            LANDBConnection.CommitTrans;
          end;
        except
          on E: Exception do
          begin
            ExtDataErrorCode := K_eeDBUpdate;
            ExtDataErrorString := 'K_CMSlidesCopyMoveByPatOld ' + E.Message;
            EDAShowErrMessage(TRUE);
            FreeSlides();
            Exit;
          end;
        end;
      end; // if ACopyFlag <> 0 then

      // Already Copied Files at Dst Patient Folder are not deleted
      // !!! Files deletion is needed for proper operation Rollback

      FreeSlides();
      Exit;
      //
      // End of Copy Files Error
      //////////////////////////////////////////////
    end; // if Result = -3 then

    if ACopyFlag = 0 then
    begin
      ///////////////////////////////////////////////
      // Move Slides to Dst Patient in DB
      //
      try
        with CurSQLCommand1 do
        begin
          ExtDataErrorCode := K_eeFilesPocessing;
          Connection := LANDBConnection;
          CommandText := 'UPDATE ' + K_CMENDBSlidesTable + ' SET ' +
            K_CMENDBSTFPatID + ' = ' + IntToStr(ADstPatID)
            + ' WHERE ' + K_CMENDBSlidesTable + '.' + K_CMENDBSTFPatID +
            ' = ' + IntToStr(ASrcPatID) + ';';
          Execute;
        end;
      except
        on E: Exception do
        begin
          ExtDataErrorCode := K_eeDBUpdate;
          ExtDataErrorString := 'K_CMSlidesCopyMoveByPatOld ' + E.Message;
          EDAShowErrMessage(TRUE);
          Result := -3;
          FreeSlides();
          Exit;
        end;
      end;

      ///////////////////////////////////////////////
      // Save History
      //
      EDABuildSelectSQLBySlidesList( @SrcSlides[0], LockResCount, @SQLStr, nil );
      EDASaveSlidesHistory( SQLStr, EDABuildHistActionCode(K_shATChange, Ord(K_shCAPat)) );

      ///////////////////////////////////////////////
      // Remove Remove Src Patient Files
      //
      N_Dump2Str(format(
          'D4W>> Old CopyMove remove %d files of %d from Dst Patient',
          [Ind, LockResCount]));
      for i := 0 to Ind - 1 do
      begin
        SrcUDSlide := SrcSlides[i];
        with SrcUDSlide, P^ do
        begin
          CMSPatId := ASrcPatID;
          if cmsfIsMediaObj in CMSDB.SFlags then
            // Delete Video Files
            EDADelSlideMediaFiles(SrcUDSlide)
          else
{ !!! Img3D processing not needed because
  this routine is actual for K_CMEDDBVersion < 28 and
  Img3D is actual for K_CMEDDBVersion >= 34
          if cmsfIsImg3DObj in CMSDB.SFlags then
          begin
          end
          else
}
            // Delete IMG Files
            EDADelSlideImgFiles(SrcUDSlide);
        end; // for ... with SrcUDSlide, P^
      end;
    end  // if ACopyFlag = 0 then
    else // if ACopyFlag <> 0 then
      EDAUnlockAllLockedSlides(K_cmlrmDeleteLock);
//      EDAUnlockSlides(@DstSlides[0], LockResCount, K_cmlrmDeleteLock);

   ///////////////////////////////////
   //  Files Deletion Check is Needed
   //

  //////////////////////////////////
  // Restore History Session Context
  //
    FreeSlides();
  end; // with TK_CMEDDBAccess(K_CMEDAccess) do

end; // K_CMSlidesCopyMoveByPatOld

//************************************************* K_CMSlidesCopyMoveByPat ***
// Copy/move all slides from one patient to another
//
//     Parameters
// ASrcPatID - given source patient ID
// ASrcPatID - given destination patient ID
// ACopyFlag - copy/move slides mode (=0 means move mode, <> 0 copy mode
// AShowResDlgFlag - show resulting dialog flag
// Result    - number of copied Slides, or
//#F
//   -1 - CMS works with Source or Destination Patient on some computer
//   -2 - Source  or Destination Patients are used in some Copy/Move operation
//   -3 - Copy files error
//#/F
//
function K_CMSlidesCopyMoveByPat(ASrcPatID, ADstPatID, ACopyFlag: Integer;
                                 AShowResDlgFlag : Boolean) : Integer;
var
  CMPProcID : Integer;
  CurPatientID : Integer;
begin
  N_Dump2Str( 'DB >> K_CMSlidesCopyMoveByPat start');
  if not (K_CMEDAccess is TK_CMEDDBAccess) or
     (K_CMEDDBVersion < 28) or
     not TK_CMEDDBAccess(K_CMEDAccess).SlidesImgRootFDA or
     not TK_CMEDDBAccess(K_CMEDAccess).SlidesMediaRootFDA or
     K_CMEnterpriseModeFlag then
    Result := K_CMSlidesCopyMoveByPatOld(ASrcPatID, ADstPatID, ACopyFlag )
  else
  begin // New Copy/Move Code

    N_Dump2Str( 'DB >> Try to resume all CopyMove before launch new');
    K_CMAllPatObjCopyMoveProcResume( 0 );

    N_Dump2Str(format(
        'DB>> New CopyMove Slides from Patient %d to %d mode=%d is started',
        [ASrcPatID, ADstPatID, ACopyFlag]));

    CurPatientID := 0;
    if (K_CMEDAccess.CurPatID = ASrcPatID) or (K_CMEDAccess.CurPatID = ADstPatID) then
    begin
      N_Dump2Str( 'DB >> Free Self Patient for CopyMove');
      CurPatientID := K_CMEDAccess.CurPatID;
      K_CMGAModeSkipAutoClearFlag := TRUE;
      K_CMSetCurSessionContext( 0, K_CMEDAccess.CurProvID, K_CMEDAccess.CurLocID );
    end;

    TK_CMEDDBAccess(K_CMEDAccess).EDAPatObjCopyMoveProcLaunch( CMPProcID,
                                         ASrcPatID, ADstPatID, ACopyFlag = 0 );
    Result := CMPProcID;
    if CMPProcID > 0 then  // Patients are busy
    begin
      // Resume Lanched CopyMove
      Result := TK_CMEDDBAccess(K_CMEDAccess).EDAPatObjCopyMoveProcResume( CMPProcID, AShowResDlgFlag );
      if Result < 0 then
        Result := -3;
    end;

    if CurPatientID <> 0 then
    begin
      // Return current patient
      if -1 = K_CMSetCurSessionContext( CurPatientID, K_CMEDAccess.CurProvID, K_CMEDAccess.CurLocID ) then
      begin
        N_Dump1Str('K_CMSlidesCopyMoveByPat >> CMS is finished by user because Patient was locked');
        N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServCloseCMS, TRUE );
      end;

      K_CMGAModeSkipAutoClearFlag := FALSE;
    end;

  end; // New Copy/Move Code
end; // function K_CMSlidesCopyMoveByPat

//******************************************* K_CMPatObjCopyMoveProcWaitDlg ***
// Copy/Move Patient data procedure wait dialog
//
//     Parameters
// ACMPProcID - Copy/Move procedure record ID
// AMessage   - user message text
// Result     - =TRUE if Copy/Move procedure is finished, = FALSE if user
//              interrupt waiting dialog
//
function K_CMPatObjCopyMoveProcWaitDlg( ACMPProcID : Integer; const AMessage : string ) : Boolean;
begin
  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    WaitCMPProcID := ACMPProcID;
    Result := -1 = EDAWaitForEventUserDlg( EDAPatObjCopyMoveProcCheck, AMessage,
                                    mtInformation );
  end;
end; // function K_CMPatObjCopyMoveProcWaitDlg

//***************************************** K_CMAllPatObjCopyMoveProcResume ***
// Resume All uncompleted Copy/Move Patient data procedures
//
//     Parameters
// APatID - patient ID
//
function K_CMAllPatObjCopyMoveProcResume( APatID : Integer ) : Boolean;
var
  CMPProcID : Integer;
begin
  Result := TRUE;
  if not (K_CMEDAccess is TK_CMEDDBAccess) or (K_CMEDDBVersion < 28) then Exit; // precaution
  while Result do
  begin
    TK_CMEDDBAccess(K_CMEDAccess).EDAPatObjCopyMoveProcGet( CMPProcID, APatID, 0 );

    if CMPProcID = 0 then Break;

    if TK_CMEDDBAccess(K_CMEDAccess).EDAPatObjCopyMoveProcResume( CMPProcID, FALSE ) < 0 then
      Result := FALSE;
  end; // while Result do
end; // procedure K_CMAllPatObjCopyMoveProcResume

//******************************************* K_CMAllPatObjCopyMoveProcWait ***
// Wait All Busy Copy/Move Patient data procedures
//
//     Parameters
// APatID - patient ID
// AWaitMessage -  wait dialog message
// Result - Returns TRUE if all CopyMove were finished, FALSE if user break wait dialog
//
function K_CMAllPatObjCopyMoveProcWait( APatID : Integer;
                                            AWaitMessage : string ) : Boolean;
var
  CMPProcID : Integer;
begin
  Result := TRUE;
  if not (K_CMEDAccess is TK_CMEDDBAccess) or (K_CMEDDBVersion < 28) then Exit; // precaution
  while TRUE do
  begin
    TK_CMEDDBAccess(K_CMEDAccess).EDAPatObjCopyMoveProcGet( CMPProcID, APatID, 1 );

    if CMPProcID = 0 then Break;

    N_Dump1Str( 'DB >> Wait for CopyMove ID=' + IntToStr(CMPProcID) );

    Result := K_CMPatObjCopyMoveProcWaitDlg( CMPProcID, AWaitMessage );
    if not Result then break;
  end;
end; // function K_CMAllPatObjCopyMoveProcWait

//************************************** K_CMAllPatObjCopyMoveResumeAndWait ***
// Resume all uncompleted and wait for all executed Copy/Move Patient data procedures
//
//     Parameters
// APatID - patient ID
// Result - Returns TRUE if all CopyMove were finished, FALSE if user break
//          CopyMove wait dialog
//
function K_CMAllPatObjCopyMoveResumeAndWait( APatID : Integer ) : Boolean;
var
  SMessage : string;
begin

  Result := TRUE;
  if not (K_CMEDAccess is TK_CMEDDBAccess) or (K_CMEDDBVersion < 28) then Exit; // precaution
  if APatID <> 0 then
    SMessage := IntToStr( APatID );
  N_Dump2Str( 'K_CMAllPatObjCopyMoveBusyProcWait >> Try to resume all CopyMove Patient ID=' + SMessage );
  Result := K_CMAllPatObjCopyMoveProcResume( APatID );

  if not Result then Exit;

  N_Dump2Str( 'K_CMAllPatObjCopyMoveBusyProcWait >> Try to wait for busy CopyMove Patient ID=' + SMessage );
  if APatID = 0 then
    SMessage := K_CML1Form.LLLCopyMovePatData2.Caption
//    'Some patient(s) data are locked now. Please wait a little and Media Suite will continue automatically.' + #13#10
//    '               Click OK or close this window to stop starting procedure.'

  else
    SMessage := K_CML1Form.LLLCopyMovePatData1.Caption;
//    'This patient data are locked now. Please wait a little and Media Suite will continue automatically.' + #13#10
//    '               Click OK or close this window if you wish to select other patient.'
  Result := K_CMAllPatObjCopyMoveProcWait( APatID, SMessage );

end; // function K_CMAllPatObjCopyMoveBusyProcWait

//******************************************* K_CMSlidesCopyMoveLaunchByPat ***
// Launch Copy/move operation all slides from one patient to another
//
//     Parameters
// ASrcPatID - given source patient ID
// ASrcPatID - given destination patient ID
// ACopyFlag - copy/move slides mode (=0 means move mode, <> 0 copy mode
//
// Real Copy/move will be done when CMSuite will be ready to do it
//
procedure K_CMSlidesCopyMoveLaunchByPat(ASrcPatID, ADstPatID, ACopyFlag: Integer );
begin
  if K_CMSlidesCopyMoveLaunchTasksList = nil then
    K_CMSlidesCopyMoveLaunchTasksList := TStringList.Create;
  K_CMSlidesCopyMoveLaunchTasksList.Add( format( '%d,%d,%d,1', [ASrcPatID, ADstPatID, ACopyFlag] ) );
  N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServPatCopyMove,
                                      (K_CMD4WWaitApplyDataCount = 0) and K_CMEDAccess.AccessReady );
end; // procedure K_CMSlidesCopyMoveLaunchByPat

function K_CMSlidesCopyMoveArchivedCheck( ASrcPatID : Integer ) : Boolean;
begin
  Result := K_CMEDDBVersion >= 41;
  if not Result then Exit;
  with TK_CMEDDBAccess(K_CMEDAccess), CurDSet1 do
  begin
    ExtDataErrorCode := K_eeDBSelect;
    Connection := LANDBConnection;
    SQL.Text := 'SELECT Count(*)' +
    ' FROM ' + K_CMENDBSlidesTable +
    ' WHERE ' + K_CMENDBSTFPatID + '=' + IntToStr(ASrcPatID) +
    ' AND ' + K_CMENDBSTFSlideThumbnail + ' IS NULL';
    Filtered := false;
    Open;
    Result := Fields[0].AsInteger > 0;
    Close;
  end;
end; // function  K_CMSlidesCopyMoveArchivedCheck

//***************************************************** K_CMImportBuildInfo ***
// Build Import Slides Info string from Import Slides state for saving in CMS DB
//
//     Parameters
// APCMIState - pointer to Import Slides State Record
// Result    - Returns Info String for CMS DB
//
function K_CMImportBuildInfo(APCMIState: TK_PCMImportState): string;
var
  ICurID: Integer;
  WStr: string;
begin
  with APCMIState^ do
  begin
    ICurID := StrToInt(CMILastSlideSID);
    if CMILastSlideID <> ICurID - 1 then
    begin
      if CMILastSlidesInfo <> '' then
        CMILastSlidesInfo := CMILastSlidesInfo + ',';
      CMILastSlidesInfoM1 := CMILastSlidesInfo + CMILastSlideSID + ',';
    end;
    CMILastSlidesInfo := CMILastSlidesInfoM1 + CMILastSlideSID;
    CMILastSlideID := ICurID;

    // Prep CMIXMLSlidesFName for quoting
    WStr := N_QuoteString(CMIXMLSlidesFName, '"');

    Result := format('%s,%s,%d,%d,%d,%d,#FAPIE', [CMILastSlidesInfo, WStr,
      CMIAllCount, CMIProcCount, CMIImpCount, CMIErrCount]);
  end;
end;

// function  K_CMImportBuildInfo
//***************************************************** K_CMImportBuildInfo ***
// Clear Import Slides state record
//
//     Parameters
// APCMIState - pointer to Import Slides State Record
// ASaveDBInfo - save DB ID ans Date
//
procedure K_CMImportClear(APCMIState: TK_PCMImportState;
  ASaveDBInfo: Boolean = false);
begin
  with APCMIState^ do
  begin
    CMIXMLSlidesFName := ''; // Path to XML Slides file
    CMIAllCount := 0; // All importing slides counter
    CMIProcCount := 0; // Processed slides counter
    CMIImpCount := 0; // Imported slides counter
    CMIErrCount := 0; // Import Errors counter
    CMILastSlideID := -1; // Last Imported Slide ID
    CMILastSlidesInfo := ''; // Last Imported Slides DB Info
    CMILastSlidesInfoM1 := ''; // Last Imported Slides DB Info without last Slide ID
    if ASaveDBInfo then
      Exit;
    CMIDBID := -1; // Last Import DB ID
    CMIDate := 0; // Last Import Date
  end;
end; // procedure K_CMImportParseInfo

//***************************************************** K_CMImportBuildInfo ***
// Parse Import Slides state from Info string
//
//     Parameters
// AImportInfo - Info String from CMS DB
// APCMIState - pointer to Import Slides State Record
// APSlidesIDArr - pointer to Imported Slides IDs Array
//
procedure K_CMImportParseInfo(const AImportInfo: string;
  APCMIState: TK_PCMImportState; APSlidesIDArr: TN_PIArray);
var
  SL: TStringList;
  InfoFormat: string;
  n, i, K, m, j, Ind, SID, FLength: Integer;
begin
  K_CMImportClear(APCMIState, TRUE);
  with APCMIState^ do
  begin
    // Parse Import Info
    SL := TStringList.Create;
    SL.CommaText := AImportInfo;
    n := SL.Count - 1;
    if n < 0 then
      Exit;
    InfoFormat := SL[n];
    if InfoFormat[1] = '#' then
    begin
      // Parse Import Common Info
      FLength := Length(InfoFormat);

      // Check if parse to Strings is correct (needed to old - not Quoted FPath format)
      K := n - FLength + 1;
      repeat
        Dec(K);
      until StrToIntDef(SL[K], -1) <> -1;

      if K < n - FLength then
      begin
        // Error in ImportInfo because of not Quoted Path - try to correct
        m := Pos(SL[K + 1], AImportInfo); // FPath strat Position
        // Search end of FPath
        i := Length(AImportInfo);
        for j := 1 to 5 do
        begin
          while (i > 0) and (AImportInfo[i] <> ',') do
            Dec(i);
          Dec(i)
        end;
        SL[K + 1] := Copy(AImportInfo, m, i - m + 1); // Save correct FPath
        for j := n - FLength + 1 downto K + 2 do // Remove FPath parts
          SL.Delete(j);
        n := SL.Count - 1;
      end;

      SL.Delete(n);
      Dec(n);
      for i := FLength downto 2 do
      begin
        case InfoFormat[i] of
          'E':
            CMIErrCount := StrToIntDef(SL[n], 0);
          'I':
            CMIImpCount := StrToIntDef(SL[n], 0);
          'P':
            CMIProcCount := StrToIntDef(SL[n], 0);
          'A':
            CMIAllCount := StrToIntDef(SL[n], 0);
          'F':
            CMIXMLSlidesFName := SL[n];
        end;
        SL.Delete(n);
        Dec(n);
      end; // for i := Length(InfoFormat) downto 2 do begin
      CMILastSlideID := StrToIntDef(SL[n], 0);
      CMILastSlidesInfo := SL.CommaText;
      CMILastSlidesInfoM1 := CMILastSlidesInfo;
      i := Length(CMILastSlidesInfoM1);
      if i > 0 then
      begin // build CMILastSlidesInfoM1
        while CMILastSlidesInfoM1[i] <> ',' do Dec(i);
        SetLength( CMILastSlidesInfoM1, i );
      end;
    end; // if InfoFormat[1] = '#'

    // Parse imported Slides IDs or Calc Imported in old format
    if (APSlidesIDArr <> nil) or (CMIXMLSlidesFName = '') then
    begin
      n := (SL.Count shr 1) - 1;
      if (APSlidesIDArr <> nil) and (CMIImpCount > 0) then
        SetLength(APSlidesIDArr^, CMIImpCount);
      CMIImpCount := 0;
      Ind := 0;
      for i := 0 to n do
      begin
        K := i shl 1;
        SID := StrToInt(SL[K]);
        m := StrToInt(SL[K + 1]) - SID + 1;
        CMIImpCount := CMIImpCount + m;
        if APSlidesIDArr = nil then
          Continue; // Only Calc Imported
        if Length(APSlidesIDArr^) < CMIImpCount then
          // for compatibility with old format without Import Common Info
          SetLength(APSlidesIDArr^, CMIImpCount);
        for j := 0 to m - 1 do
        begin
          APSlidesIDArr^[Ind] := SID + j;
          Inc(Ind);
        end;
      end; // for i := 0 to n do begin
    end; // if (APSlidesIDArr <> nil) or (CMIXMLSlidesFName = '')

    SL.Free;
  end; // with APCMIState^
end; // procedure K_CMImportParseInfo

{ *** TK_DICOMAccess *** }

//*************************************************** TK_DICOMAccess.Create ***
// DICOM access class denstructor
//
//     Parameters
// Result - Returns DICOM file stream
//
destructor TK_DICOMAccess.Destroy;
begin
  if not DCNotStreamOwner then
    DCStream.Free; // DICOM file stream
end; // TK_DICOMAccess.Destroy

//********************************************************* TK_DICOMAccess.DCFileOpen ***
// Start DICOM parsing from given stream
//
//     Parameters
// ADCStream - DICOM stream
// Result - Returns TRUE if proper stream is given, FALSE if stream has not proper format
//
function TK_DICOMAccess.DCStreamStart(const ADCStream: TStream): Boolean;
var
  i: Integer;
begin
  if not DCNotStreamOwner and (DCStream <> ADCStream) then
    DCStream.Free;
  DCNotStreamOwner := false;
  Result := false;
  SetLength(DCDataBuf, 128 + 4); // Data Element Buffer
  DCNotStreamOwner := DCStream <> ADCStream;
  DCStream := ADCStream;
  DCStream.Read(DCDataBuf[0], 128 + 4);
  i := 0;
  while i < 128 do
  begin
    if PInt64(@DCDataBuf[i])^ <> 0 then
      Exit;
    i := i + 8;
  end;
  Result := (DCDataBuf[128] = Ord('D')) and (DCDataBuf[129] = Ord('I')) and
    (DCDataBuf[130] = Ord('C')) and (DCDataBuf[131] = Ord('M'));
  if not Result then
    Exit;
  DCEncType := K_dcmetExpLitEnd;
  DCETag.TGID := 0; // for group lehgth auto detection
  Result := DCFileElemRead();
  if Result then
  begin
    Result := (DCETag.TGID = 2) and (DCETag.TEID = 0);
    if Result then
      Exit;
  end;
  if not DCNotStreamOwner then
    Exit;
  DCStream := nil;
end; // TK_DICOMAccess.DCStreamStart

//*********************************************** TK_DICOMAccess.DCFileOpen ***
// Open DICOM file for data read
//
//     Parameters
// ADICOMFName - DICOM file name
// Result - Returns TRUE if proper file is open, FALSE if file couldn't be open or has not proper format
//
function TK_DICOMAccess.DCFileOpen(const ADICOMFName: string): Boolean;
// var
// i : Integer;
begin
  if not DCNotStreamOwner then
    DCStream.Free;
  DCNotStreamOwner := false;
  Result := false;
  try
    DCStream := TFileStream.Create(ADICOMFName, fmOpenRead);
  except
    Exit;
  end;
  Result := DCStreamStart(DCStream);
  if not Result then
    FreeAndNil(DCStream);
  {
    SetLength( DCDataBuf, 128 + 4 ); // Data Element Buffer
    DCStream.Read( DCDataBuf[0], 128 + 4 );
    i := 0;
    while i < 128 do begin
    if PInt64(@DCDataBuf[i])^ <> 0 then Exit;
    i := i + 8;
    end;
    Result := (DCDataBuf[128] = Ord('D')) and (DCDataBuf[129] = Ord('I')) and
    (DCDataBuf[130] = Ord('C')) and (DCDataBuf[131] = Ord('M'));
    if not Result then Exit;
    DCEncType := K_dcmetExpLitEnd;
    Result := DCFileElemRead();
    if not Result then Exit;
    //  Result := (DCETag.TGID = 2) and (DCETag.TEID = 0);
    Result := (DCETag.TGID = 2);
    if Result then Exit;
    FreeAndNil( DCStream );
  }
end; // TK_DICOMAccess.DCFileOpen

//********************************************* TK_DICOMAccess.DCFileCreate ***
// Create file stream for DICOM data write
//
//     Parameters
// ADICOMFName - DICOM file name
// Result - Returns TRUE if proper file stream is created, FALSE if file couldn't be created
//
function TK_DICOMAccess.DCFileCreate(const ADICOMFName: string): Boolean;
begin
  if not DCNotStreamOwner then
    DCStream.Free;
  DCNotStreamOwner := false;
  Result := TRUE;
  try
    DCStream := TFileStream.Create(ADICOMFName, fmCreate);
    K_SetBArrayCapacity(DCDataBuf, 132);
    FillChar(DCDataBuf[0], 128, 0);
    DCDataBuf[128] := Ord('D');
    DCDataBuf[129] := Ord('I');
    DCDataBuf[130] := Ord('C');
    DCDataBuf[131] := Ord('M');
    DCStream.Write(DCDataBuf[0], 132);
  except
    Result := false;
  end;
end; // TK_DICOMAccess.DCFileCreate

//*********************************************** TK_DICOMAccess.DCFileOpen ***
// Read next DICOM element header
//
procedure TK_DICOMAccess.DCFileClose;
begin
  if DCNotStreamOwner then
    DCStream := nil;
  FreeAndNil(DCStream);
  DCNotStreamOwner := false;
end; // TK_DICOMAccess.DCFileClose

//***************************************** TK_DICOMAccess.DCFileGroupStart ***
// Start DICOM Group
//
//     Parameters
// AGroupID - Tag Group ID
// ASkipGroup - skip Group Length Element
//
procedure TK_DICOMAccess.DCFileGroupStart(AGroupID: Word;
  ASkipGroup: Boolean = false);
var
  GroupLength: Integer;
begin
  DCETag.TGID := AGroupID;
  DCGroupLengthStreamOffs := 0;
  if ASkipGroup then
    Exit;
  GroupLength := 0;
  DCFileElemWrite($0, GroupLength, 4, K_DCT_UL);
  // (0002,0000) File Meta Information Group
  DCGroupLengthStreamOffs := DCStream.Position;
end; // TK_DICOMAccess.DCFileGroupStart

//******************************************* TK_DICOMAccess.DCFileGroupFin ***
// Finish DICOM Current Group
//
//     Parameters
// AGroupID - Tag Group ID
//
procedure TK_DICOMAccess.DCFileGroupFin();
var
  GroupLength: Integer;
begin
  if DCGroupLengthStreamOffs = 0 then
    Exit;
  GroupLength := Integer(DCStream.Position - DCGroupLengthStreamOffs);
  DCStream.Seek(DCGroupLengthStreamOffs - 4, soBeginning);
  DCStream.Write(GroupLength, 4);
  DCStream.Seek(0, soEnd);
end; // TK_DICOMAccess.DCFileGroupFin

//*************************************** TK_DICOMAccess.DCFileGroupElemAdd ***
// Set DICOM element Header attributes
//
//     Parameters
// ATElemID - Tag Element ID
// APValue - Pointer to Tag Value
// ASize - element data length (if =0, then real length is defined by Tag Format Code)
// ATagVR - Tag Value Representation Code
//
procedure TK_DICOMAccess.DCFileElemHeaderSet(APElemHeader: Pointer;
  ATElemID: Word; ATagVR: Word);
begin
  with TK_PDICOMDataHead1(APElemHeader)^ do
  begin
    HTag.TGID := DCETag.TGID;
    HTag.TEID := ATElemID;
    HVR := ATagVR;
  end;
end; // TK_DICOMAccess.DCFileElemHeaderSet

//********************************** TK_DICOMAccess.DCFileElemHeaderSetSise ***
// Set Element Header Data Size
//
//     Parameters
// APElemHeader - pointer to Element Header
// ASize - Element Value Size
//
function TK_DICOMAccess.DCFileElemHeaderSetSise(APElemHeader: Pointer;
  ASize: Integer): Integer;
begin
  with TK_PDICOMDataHead1(APElemHeader)^, TK_PDICOMDataHead2(APElemHeader)^ do
  begin
    if (HVR = K_DCT_OB) or (HVR = K_DCT_OF) or (HVR = K_DCT_OW) or
      (HVR = K_DCT_SQ) or (HVR = K_DCT_UT) or (HVR = K_DCT_UN) then
    begin
      // Long Header
      HLSize := ASize;
      Result := SizeOf(TK_DICOMDataHead2);
    end
    else
    begin
      // Short Header
      HSize := ASize;
      Result := SizeOf(TK_DICOMDataHead1);
    end;
  end;

end; // TK_DICOMAccess.DCFileElemHeaderSetSise

//****************************************** TK_DICOMAccess.DCFileElemWrite ***
// Convert DICOM element and put it to object buffer
//
//     Parameters
// AValue -  Element Value
// ATagVR - Tag Value Representation Code
// Result - Returns Element data length in buffer
//
function TK_DICOMAccess.DCFileConvToBuf(const AValue; ATagVR: Word): Integer;
var
  WStr: AnsiString;
begin
  Result := 0;
  case ATagVR of
    K_DCT_DA:
      begin
        Result := 8;
//        WStr := AnsiString( K_DateTimeToStr(TDateTime(AValue), 'yyyymmdd') );
        WStr := N_StringToAnsi( K_DateTimeToStr(TDateTime(AValue), 'yyyymmdd') );
      end;
    {
      if AFmt = '' then AFmt := 'dd.mm.yyyy hh:nn:ss';
      Result := FormatDateTime( AFmt, ADateTime );
    }
    K_DCT_TM:
      begin
        Result := 6;
//        WStr := AnsiString(K_DateTimeToStr(TDateTime(AValue), 'hhnnss'));
        WStr := N_StringToAnsi(K_DateTimeToStr(TDateTime(AValue), 'hhnnss'));
      end;
  end;
  K_SetBArrayCapacity(DCDataBuf, Result);
  Move(WStr[1], DCDataBuf[0], Result);
end; // TK_DICOMAccess.DCFileConvToBuf

//****************************************** TK_DICOMAccess.DCFileElemWrite ***
// Convert DICOM element and put it to object buffer
//
//     Parameters
// AValue -  Element Value
// ATagVR - Tag Value Representation Code
// Result - Returns Element data as Ansi String
//
function TK_DICOMAccess.DCFileConvToAnsiStr(const AValue; ATagVR: Word ): AnsiString;
begin
  Result := '';
  case ATagVR of
    K_DCT_DA:
      begin
//        Result := AnsiString(K_DateTimeToStr(TDateTime(AValue), 'yyyymmdd'));
        Result := N_StringToAnsi(K_DateTimeToStr(TDateTime(AValue), 'yyyymmdd'));
      end;
    {
      if AFmt = '' then AFmt := 'dd.mm.yyyy hh:nn:ss';
      Result := FormatDateTime( AFmt, ADateTime );
    }
    K_DCT_TM:
      begin
//        Result := AnsiString(K_DateTimeToStr(TDateTime(AValue), 'hhnnss'));
        Result := N_StringToAnsi(K_DateTimeToStr(TDateTime(AValue), 'hhnnss'));
      end;
  end;
end; // TK_DICOMAccess.DCFileConvToBuf

//************************************ TK_DICOMAccess.DCFileElemHeaderWrite ***
// Write DICOM element Header to File Stream
//
//     Parameters
// ATElemID - Tag Element ID
// ASize - Element data length (if =0, then real length is defined by Tag Format Code)
// ATagVR - Tag Value Representation Code
// Result - Returns Element Length add to odd value
//
function TK_DICOMAccess.DCFileElemHeaderWrite(ATElemID: Word; ASize: Integer;
  ATagVR: Word): Integer;
var
  HSize: Integer;
  PH: Pointer;
begin
  PH := @DCDataBuf[0];
  DCFileElemHeaderSet(PH, ATElemID, ATagVR);

  Result := ASize;
  if ASize > 0 then
    Result := (ASize + 1) and $FFFFFFFE;

  HSize := DCFileElemHeaderSetSise(PH, Result);
  // Write Element Header
  DCStream.Write(PH^, HSize);
end; // TK_DICOMAccess.DCFileElemHeaderWrite

//************************************** TK_DICOMAccess.DCFileElemTailWrite ***
// Write DICOM element Tail to File Stream
//
//     Parameters
// ATElemID - Tag Element ID
// AValue -  Element Value
// ASize - Element data length (if =0, then real length is defined by Tag Format Code)
// ATagVR - Tag Value Representation Code
//
procedure TK_DICOMAccess.DCFileElemTailWrite(ASize: Integer; ARSize: Integer);
begin
  if ARSize = ASize then
    Exit;
  ASize := 0;
  // Write Element Value Trailing Zero
  DCStream.Write(ASize, 1);
end; // TK_DICOMAccess.DCFileElemTailWrite

//****************************************** TK_DICOMAccess.DCFileElemWrite ***
// Write DICOM element to File Stream
//
//     Parameters
// ATElemID - Tag Element ID
// AValue -  Element Value
// ASize - Element data length (if =0, then real length is defined by Tag Format Code)
// ATagVR - Tag Value Representation Code
//
procedure TK_DICOMAccess.DCFileElemWrite(ATElemID: Word; const AValue;
  ASize: Integer; ATagVR: Word);
var
  RSize: Integer;
  // HSize : Integer;
  // PH : pointer;
begin
  RSize := DCFileElemHeaderWrite(ATElemID, ASize, ATagVR);
  { !!!
    PH := @DCDataBuf[0];
    DCFileElemHeaderSet( PH, ATElemID, ATagVR );

    RSize := ASize;
    if ASize > 0 then
    RSize := (ASize + 1) and $FFFFFFFE;

    HSize := DCFileElemHeaderSetSise( PH, RSize );
    // Write Element Header
    DCStream.Write( PH^, HSize );
  }
  if ASize <= 0 then
    Exit;
  // Write Element Value
  DCStream.Write(AValue, ASize);
  DCFileElemTailWrite(ASize, RSize);
  { !!!
    if RSize = ASize then Exit;
    PH := nil;
    // Write Element Value Trailing Zero
    DCStream.Write( PH, 1 );
  }
end; // TK_DICOMAccess.DCFileElemWrite

//********************************* TK_DICOMAccess.DCFileSeqItemHeaderWrite ***
// Write DICOM Sequence Item Heaser to File Stream
//
//     Parameters
// AValue -  Item Value
// ASize - Item data length (if =0, then real length is defined by Tag Format Code)
//
procedure TK_DICOMAccess.DCFileSeqItemHeaderWrite(ASize: Integer);
var
  Header: LongWord;
begin
  Header := $E000FFFE;
  DCStream.Write(Header, 4);
  DCStream.Write(ASize, 4);
end; // TK_DICOMAccess.DCFileSeqItemHeaderWrite

//*************************************** TK_DICOMAccess.DCFileSeqItemWrite ***
// Write DICOM Sequence Item to File Stream
//
//     Parameters
// AValue -  Item Value
// ASize - Item data length (if =0, then real length is defined by Tag Format Code)
//
procedure TK_DICOMAccess.DCFileSeqItemWrite(const AValue; ASize: Integer);
var
  RSize: Integer;
begin
  DCFileSeqItemHeaderWrite(ASize);
  if ASize <= 0 then
    Exit;
  // Write Element Value
  DCStream.Write(AValue, ASize);
  RSize := ASize;
  if ASize > 0 then
    RSize := (ASize + 1) and $FFFFFFFE;
  DCFileElemTailWrite(ASize, RSize);
end; // TK_DICOMAccess.DCFileSeqItemWrite

//*************************************** TK_DICOMAccess.DCFileSeqItemStart ***
// Start Writing DICOM Sequence Item Header to File Stream
//
procedure TK_DICOMAccess.DCFileSeqItemStart();
var
  Header: LongWord;
begin
  Header := $E000FFFE;
  DCStream.Write(Header, 4);

  // Reserve place for future Item Length in stream
  Header := 0;
  DCStream.Write(Header, 4);

  // Add Stream position to Stack
  Inc(DCItemsStreamOffsStackLevel);
  if Length(DCItemsStreamOffsStack) < DCItemsStreamOffsStackLevel then
    SetLength(DCItemsStreamOffsStack, DCItemsStreamOffsStackLevel + 4);
  DCItemsStreamOffsStack[DCItemsStreamOffsStackLevel - 1] := DCStream.Position;
end; // TK_DICOMAccess.DCFileSeqItemWrite

//***************************************** TK_DICOMAccess.DCFileSeqItemFin ***
// Finish Writing DICOM Sequence Item Header to File Stream
//
procedure TK_DICOMAccess.DCFileSeqItemFin();
var
  ItemLength: LongWord;
  LengOffs: Int64;
begin
  Dec(DCItemsStreamOffsStackLevel);
  LengOffs := DCItemsStreamOffsStack[DCItemsStreamOffsStackLevel];
  ItemLength := DCStream.Position - LengOffs;
  DCStream.Seek(LengOffs - 4, soBeginning);
  DCStream.Write(ItemLength, 4);
  DCStream.Seek(0, soEnd);
end; // TK_DICOMAccess.DCFileSeqItemFin

//*************************************** TK_DICOMAccess.DCFileSeqElemStart ***
// Start Items Sequens Element
//
procedure TK_DICOMAccess.DCFileSeqElemStart(ATElemID: Word);
begin

  DCFileElemHeaderWrite(ATElemID, 0, K_DCT_SQ);

  // Save Items Sequence Length Stream position
  DCSeqElemLengthStreamOffs := DCStream.Position;
end; // TK_DICOMAccess.DCFileSeqItemWrite

//***************************************** TK_DICOMAccess.DCFileSeqElemFin ***
// Finish Items Sequens Element
//
procedure TK_DICOMAccess.DCFileSeqElemFin();
var
  SeqElemLength: LongWord;
begin
  SeqElemLength := DCStream.Position - DCSeqElemLengthStreamOffs;
  DCStream.Seek(DCSeqElemLengthStreamOffs - 4, soBeginning);
  DCStream.Write(SeqElemLength, 4);
  DCStream.Seek(0, soEnd);
end; // TK_DICOMAccess.DCFileSeqElemFin

//******************************************** TK_DICOMAccess.DCSlideExport ***
// Export Slide to given file in DICOM format
//
//     Parameters
// ADICOMFName - file name for storing slide data in DICOM format
// AUDSlide - slide to Export
// Result - Returns TRUE if Slide is successfully exported
//
function TK_DICOMAccess.DCSlideExport(const ADICOMFName: string;
  AUDSlide: TN_UDCMSlide): Boolean;
var
  WI: Integer;
  PixSamples, PixSize, BitsAlloc: Integer;
  WStr: AnsiString;
  CUID: AnsiString;
  CImgUID: AnsiString;
  SOP_Class_UID, SOP_Instance_UID: AnsiString;
  ML: TStrings;
  DSize: Integer;
  PData: Pointer;
  UDMapRoot: TN_UDBase;
  UpperTeethFlags, LowTeethFlags: Int64;

  procedure AddAnatomicInfo(const AnatomicInfo: TK_CMTDICOMInfo);
  begin
    DCFileSeqItemStart();
    WStr := AnsiString(AnatomicInfo.c);
    DCFileElemWrite($100, WStr[1], Length(WStr), K_DCT_SH);
    // (0008,0100) Code Value
    WStr := 'SRT';
    DCFileElemWrite($102, WStr[1], Length(WStr), K_DCT_SH);
    // (0008,0102) Coding Scheme Designator
    WStr := AnsiString(AnatomicInfo.n);
    DCFileElemWrite($104, WStr[1], Length(WStr), K_DCT_SH);
    // (0008,0104) Code Meaning
    DCFileSeqItemFin();
  end;

  procedure AddTeethInfo(TeethFalgs: Int64; SInd, Find: Integer);
  var
    i: Integer;
  begin
    for i := SInd to Find do
      if K_SetGetElementState(i, @TeethFalgs) then
        AddAnatomicInfo(K_CMTeethDICOMInfo[i]);
  end;

begin
  Result := (AUDSlide <> nil) and DCFileCreate(ADICOMFName);
  if not Result then
    Exit;
  with AUDSlide, P^, CMSDB do
  begin
    ////////////////////////////////////
    // DICOM Metainfo Group
    //
    DCFileGroupStart($2);

    WI := 1;
    DCFileElemWrite($1, WI, 2, K_DCT_OB); // (0002,0001) File Meta Information Version = 1

    if cmsfGreyScale in SFlags then
      SOP_Class_UID := '1.2.840.10008.5.1.4.1.1.1.3.1' // Digital Intra-oral X-Ray Image Storage – For Processing
    else
      SOP_Class_UID := '1.2.840.10008.5.1.4.1.1.77.1.4';
    // VL Photographic Image Storage
    DCFileElemWrite($2, SOP_Class_UID[1], Length(SOP_Class_UID), K_DCT_UI);
    // (0002,0002) Media Storage SOP Class UID

    WI := Ord('C') + (Ord('M') shl 8) + (Ord('S') shl 16);
    CUID := '1.2.840.9999999999.' + AnsiString(IntToStr(WI)) + '.';
    // Common UID part
    // Image UID       SlideID
//    CImgUID := CUID + AnsiString(ObjName) + AnsiString(format('.%d.%d.%d.', [CMSPatId, CMSProvIDCreated, CMSLocIDCreated]));
    CImgUID := CUID + N_StringToAnsi(ObjName) + AnsiString(format('.%d.%d.%d.', [CMSPatId, CMSProvIDCreated, CMSLocIDCreated]));

    SOP_Instance_UID := CImgUID + '1.1.1'; // Common UID + '1.1.1'
    DCFileElemWrite($3, SOP_Instance_UID[1], Length(SOP_Instance_UID),
      K_DCT_UI); // (0002,0003) Media Storage SOP Instance UID

    WStr := '1.2.840.10008.1.2.1'; // Explicit VR Little Endian
    DCFileElemWrite($10, WStr[1], Length(WStr), K_DCT_UI);
    // (0002,0010)	Transfer Syntax UID

    WStr := CUID + '0'; // Implementation Class UID
    DCFileElemWrite($12, WStr[1], Length(WStr), K_DCT_UI);
    // (0002,0012)	Implementation Class UID

    WStr := 'CMS_' + AnsiString(N_CMSVersion); // Implementation Version Name
    DCFileElemWrite($13, WStr[1], Length(WStr), K_DCT_SH);
    // (0002,0013)	Implementation Version Name

    DCFileGroupFin();
    {
      WI := 0;
      DCFileGroupElemAdd( $0, WI, 4, K_DCT_UL );  // (0002,0000) File Meta Information Group
      WI := 1;
      DCFileGroupElemAdd( $1, WI, 2, K_DCT_OB );  // (0002,0001) File Meta Information Version = 1
      if cmsfGreyScale in SFlags then
      SOP_Class_UID := '1.2.840.10008.5.1.4.1.1.1.3.1'   // Digital Intra-oral X-Ray Image Storage – For Processing
      else
      SOP_Class_UID := '1.2.840.10008.5.1.4.1.1.77.1.4'; // VL Photographic Image Storage
      DCFileGroupElemAdd( $2, SOP_Class_UID[1], Length(SOP_Class_UID), K_DCT_UI );  // (0002,0002) Media Storage SOP Class UID

      WI := Ord('C') + (Ord('M') shl 8) + (Ord('S') shl 16);
      CUID := '1.2.840.9999999999.' + IntToStr(WI) + '.'; // Common UID part
      // Image UID       SlideID
      CImgUID := CUID + ObjName +
      '.' + IntToStr(CMSPatId) +
      '.' + IntToStr(CMSProvIDCreated) +
      '.' + IntToStr(CMSLocIDCreated) + '.';

      SOP_Instance_UID := CImgUID + '1.1.1'; // Common UID + '1.1.1'
      DCFileGroupElemAdd( $3, SOP_Instance_UID[1], Length(SOP_Instance_UID), K_DCT_UI );  // (0002,0003) Media Storage SOP Instance UID

      WStr := '1.2.840.10008.1.2.1'; // Explicit VR Little Endian
      DCFileGroupElemAdd( $10, WStr[1], Length(WStr), K_DCT_UI );  // (0002,0010)	Transfer Syntax UID

      WStr := CUID + '0'; // Implementation Class UID
      DCFileGroupElemAdd( $12, WStr[1], Length(WStr), K_DCT_UI );  // (0002,0012)	Implementation Class UID

      WStr := 'CMS_' + N_CMSVersion; // Implementation Version Name
      DCFileGroupElemAdd( $13, WStr[1], Length(WStr), K_DCT_SH );  // (0002,0013)	Implementation Version Name
      DCFileGroupWrite( );
    }
    //
    // end of DICOM Metainfo Group
    ////////////////////////////////////

    ////////////////////////////////////
    // DICOM Image Info Group
    //
    DCFileGroupStart($8);

    WStr := 'ORIGINAL\PRIMARY';
    if cmsfHasSrcImg in SFlags then
      WStr := 'DERIVED\PRIMARY';
    DCFileElemWrite($8, WStr[1], Length(WStr), K_DCT_CS);
    // (0008,00016) SOP Class UID

    DCFileElemWrite($16, SOP_Class_UID[1], Length(SOP_Class_UID), K_DCT_UI);
    // (0008,00016) SOP Class UID

    DCFileElemWrite($18, SOP_Instance_UID[1], Length(SOP_Instance_UID),
      K_DCT_UI); // (0008,0018) SOP Instance UID

    WStr := DCFileConvToAnsiStr(CMSDTTaken, K_DCT_DA);
    DCFileElemWrite($20, WStr[1], Length(WStr), K_DCT_DA);
    // (0008,0020) Study Date

    WStr := DCFileConvToAnsiStr(CMSDTTaken, K_DCT_TM);
    DCFileElemWrite($30, WStr[1], Length(WStr), K_DCT_TM);
    // (0008,0030) Study Time

    DCFileElemWrite($50, DCDataBuf[0], 0, K_DCT_SH);
    // (0008,0050) Accession Number

    WStr := K_CMSlideDefDCMModColorXC;
    if cmsfGreyScale in SFlags then
      WStr := 'IO';
    DCFileElemWrite($60, WStr[1], 2, K_DCT_CS); // (0008,0060) Modality

    DCFileElemWrite($70, WStr[1], 0, K_DCT_LO); // (0008,0070) Manufacturer

    DCFileElemWrite($90, WStr[1], 0, K_DCT_PN);
    // (0008,0090) Referring Physician’s Name

    UpperTeethFlags := CMSTeethFlags and K_CMTeethUpperMask;
    LowTeethFlags := CMSTeethFlags and K_CMTeethLowMask;
    if (UpperTeethFlags <> 0) or (LowTeethFlags <> 0) then
    begin

      // Add Anatomic Region Info
      DCFileSeqElemStart($2218);
      if UpperTeethFlags <> 0 then
        AddAnatomicInfo(K_CMTeethRegDICOMInfo[0]);

      if LowTeethFlags <> 0 then
        AddAnatomicInfo(K_CMTeethRegDICOMInfo[1]);
      DCFileSeqElemFin();

      // Add Anatomic Structure Info
      DCFileSeqElemStart($2228);
      AddTeethInfo(CMSTeethFlags, 0, 12);
      AddTeethInfo(CMSTeethFlags, 14, 26);
      AddTeethInfo(CMSTeethFlags, 32, 44);
      AddTeethInfo(CMSTeethFlags, 46, 58);
      DCFileSeqElemFin();
    end;

    DCFileGroupFin();
    //
    // end of DICOM Image Info  Group
    ////////////////////////////////////

    ////////////////////////////////////
    // CMS Slide Private Info Group
    //
    DCFileGroupStart($D);
    WStr := K_CMS_DICOM_DATA_SIGNATURE;
    DCFileElemWrite($10, WStr[1], Length(WStr), K_DCT_LO);
    // (000D,0010) CMS DATA SIGNATURE

//  UDMapRoot := GetMapRoot(false, TRUE);
    K_UDCMSlideGetMapRootFlags := [K_gmrfSkipMapImgBuild];
    UDMapRoot := GetMapRoot();
    K_UDCMSlideGetMapRootFlags := [];

    // Ñlear Slide ROI Refs
    PrepROIView([K_roiClearRefs]);
    K_SaveTreeToText(UDMapRoot, K_SerialTextBuf);
    // Restore Slide ROI Refs
    PrepROIView([K_roiRestoreIfImage]);
    DSize := K_CMEDAccess.EDAStringsToAnsiText(K_SerialTextBuf.TextStrings,
      PData);
    DCFileElemWrite($1000, PData^, DSize, K_DCT_OB);
    // (000D,1000) CMS Slide MapRoot

    WStr := AnsiString(K_SaveSPLDataToText(R.P^, R.ElemType.All));
    DCFileElemWrite($1001, WStr[1], Length(WStr), K_DCT_OB);
    // (000D,1001) CMS Slide Fields

    DCFileGroupFin();
    //
    // end of CMS Slide Private Info  Group
    ////////////////////////////////////

    ////////////////////////////////////
    // DICOM Patient Info Group
    //
    DCFileGroupStart($10);

    ML := K_CMEDAccess.EDAGetPatientMacroInfo();
//    WStr := AnsiString(K_StringMListReplace(K_CMENPTDICOMPatientDetails1, ML,
//        K_ummRemoveMacro));
    WStr := N_StringToAnsi(K_StringMListReplace(K_CMENPTDICOMPatientDetails1, ML,
                           K_ummRemoveMacro));
    if WStr = '^' then
      WStr := 'PatientName^PatientSurname';
    DCFileElemWrite($10, WStr[1], Length(WStr), K_DCT_PN);
    // (0010,0010) Patient Name

//    WStr := AnsiString(K_StringMListReplace(K_CMENPTDICOMPatientDetails2, ML,
//        K_ummRemoveMacro));
    WStr := N_StringToAnsi(K_StringMListReplace(K_CMENPTDICOMPatientDetails2, ML,
        K_ummRemoveMacro));
    if WStr = '' then
      WStr := 'PatientID';
    DCFileElemWrite($20, WStr[1], Length(WStr), K_DCT_LO);
    // (0010,0020) Patient ID

//    WStr := AnsiString(K_StringMListReplace(K_CMENPTDICOMPatientDetails3, ML,
//        K_ummRemoveMacro));
    WStr := N_StringToAnsi(K_StringMListReplace(K_CMENPTDICOMPatientDetails3, ML,
        K_ummRemoveMacro));
    if WStr = '' then
      WStr := 'PatientDOB';
    DCFileElemWrite($30, WStr[1], 0, K_DCT_DA);
    // (0010,0030) Patient's Birth Date

    DCFileGroupFin();
    //
    // end of DICOM Image Info  Group
    ////////////////////////////////////

    ////////////////////////////////////
    // DICOM Study Info Group
    //
    // DCFileGroupStart( $20 );
    // DCFileGroupFin( );
    //
    // end of DICOM Study Info  Group
    ////////////////////////////////////

    ////////////////////////////////////
    // DICOM Image Pixels Info Group
    //
    DCFileGroupStart($28);
    PixSamples := 3;
    WStr := 'RGB';
    if cmsfGreyScale in SFlags then
    begin
      PixSamples := 1;
      WStr := 'MONOCHROME2';
    end;
    DCFileElemWrite($2, PixSamples, 2, K_DCT_US);
    // (0028,0002) Samples per Pixel

    DCFileElemWrite($4, WStr[1], Length(WStr), K_DCT_CS);
    // (0028,0004) Photometric Interpretation

    if not(cmsfGreyScale in SFlags) then
    begin
      WI := 0;
      DCFileElemWrite($6, WI, 2, K_DCT_US); // (0028,0006) Planar Configuration
    end;

    BitsAlloc := 8;
    with GetCurrentImage(), DIBObj do
    begin
      if cmsfGreyScale in SFlags then
        if DIBExPixFmt = epfGray16 then
          BitsAlloc := 16;
      DCFileElemWrite($10, DIBSize.Y, 2, K_DCT_US); // (0028,0010) Rows

      DCFileElemWrite($11, DIBSize.X, 2, K_DCT_US); // (0028,0011) Columns

      PixSize := DIBSize.Y * DIBSize.X * PixSamples * (BitsAlloc shr 3);

      DCFileElemWrite($100, BitsAlloc, 2, K_DCT_US);
      // (0028,00100) Bits Allocated

      DCFileElemWrite($101, BitsAlloc, 2, K_DCT_US); // (0028,00101) Bits Stored

      WI := BitsAlloc - 1;
      DCFileElemWrite($102, WI, 2, K_DCT_US); // (0028,00102) High Bit

      WI := 0;
      DCFileElemWrite($103, WI, 2, K_DCT_US);
      // (0028,0103) Pixel Representation

      DCFileGroupFin();
      //
      // end of DICOM Image Pixels Info Group
      ////////////////////////////////////

      ////////////////////////////////////
      // DICOM Image Pixels
      //
      {
        if cmsfGreyScale in SFlags then begin
        // Histogram
        DCFileGroupStart( $60 );
        DCFileElemHeaderWrite( $3000, 68, K_DCT_SQ );  // (0060,3000) 68 Histogram Sequence

        DCFileSeqItemHeaderWrite( 60 );  // (FFFE,E000) 60 Sequence Item Header

        WI := 1;
        DCFileElemWrite( $3002, WI, 2, K_DCT_US );  // (0060,3002) Histogram Number of Bins

        WI := 0;
        DCFileElemWrite( $3004, WI, 2, K_DCT_US );  // (0060,3004) Histogram First Bin Value

        WI := (1 shl BitsAlloc) - 1;
        DCFileElemWrite( $3006, WI, 2, K_DCT_US );  // (0060,3006) Histogram Last Bin Value

        WI := WI + 1;
        DCFileElemWrite( $3008, WI, 2, K_DCT_US );  // (0060,3008) Histogram Bin Width

        DCFileElemWrite( $3010, WI, 0, K_DCT_LO );  // (0060,3010) Histogram Explanation

        WI := DIBSize.Y * DIBSize.X;
        DCFileElemWrite( $3020, WI, 4, K_DCT_UL );  // (0060,3020) Histogram Data

        DCFileGroupStart( $2050 );
        WStr := 'IDENTITY';
        DCFileElemWrite( $20, WStr[1], 8, K_DCT_CS );  // (2050,0020) Presentation LUT Shape

        end;
      }
      DCFileGroupStart($7FE0, TRUE);

      WI := DCFileElemHeaderWrite($10, PixSize, K_DCT_OW);
      PixelsToStream(DCStream);
      DCFileElemTailWrite(PixSize, WI);
    end;
    //
    // end of DICOM Image Pixels
    ////////////////////////////////////

  end;

  DCFileClose;
end; // TK_DICOMAccess.DCSlideExport

//******************************************** TK_DICOMAccess.DCSlideImport ***
// Import Slide from given file in DICOM format or current stream
//
//     Parameters
// ADICOMFName - name of file in DICOM format, if = '' then import from current stream
// AUDSlide - resulting SLide created using file DICOM content
// Result - Returns creating code:
//#F
// 0 - slide was successfully imported
// 1 - not DICOM file
// 2 - (0002,0010) Uknown Data Syntax
// 3 - (0002,0010) Data Syntax is not implemented
// 4 - (0028,0004) )DICOM Photometric Interpretation is not implemented
// 5 - (0028,0100) Pixels storing format is not implemented
// 6 - (0028,0103) Pixel Representation is not implemented
// 7 - (7FE0,0010) Pixels are not found
// 8 - (7FE0,0010) Pixels format is not implemented
//#/F
//
function TK_DICOMAccess.DCSlideImport(const ADICOMFName: string;
  out AUDSlide: TN_UDCMSlide): Integer;
const
  RDataSize = 200;
var
  AnsiText: AnsiString;
  AnsiText1: AnsiString;
  DCDTTaken: TDateTime;
  CMSDICOMFlag: Boolean;
  UDMapRoot: TN_UDBase;
  SlideFields: TN_CMSlide;
  SerMapRoot, SerSlideFields: string;
  PixSamples, BitsAlloc, PixRows, PixCols: Integer;
  // BitsStored, HighBit : Integer;
  PixPhotometric: string;
  PixelsOffs: Int64;
  DIBObj: TN_DIBObj;
  PixFmt: TPixelFormat;
  ExPixFmt: TN_ExPixFmt;
  EndSeqElemOffs: Int64;
  EndItemOffs: Int64;
  CurTeethFlags: Int64;
  WI: Integer;

//  GPCWrapper: TK_GPDIBCodecsWrapper;
  DIBStoreFormat: TN_UDDIBDataFormat;
  Stream: TStream;

  // FStream : TFileStream;

label LExit, WrongPixels;

  procedure GetElemAnsiText();
  var
    i: Integer;
  begin
    DCFileElemValueRead();
    i := DCESize;
    while (i > 0) and (DCDataBuf[i - 1] = 0) do
      Dec(i);
    SetLength(AnsiText, i);
    if i > 0 then
      Move(DCDataBuf[0], AnsiText[1], i);
  end;

  procedure StepToNextGroup(AStepToValueEnd: Boolean);
  begin
    if DCNextGroupStreamOffs > 0 then
      DCStream.Seek(DCNextGroupStreamOffs, soBeginning) // Step To Next Group
    else if AStepToValueEnd then
      DCStream.Seek(DCESize, soCurrent);

  end;

begin
  Result := 1;
  DCLastImportInfo := 'not DICOM file';
  if (ADICOMFName <> '') and not DCFileOpen(ADICOMFName) then
    Exit;
  DCLastImportInfo := '';
  DCDTTaken := Now();
  CMSDICOMFlag := false;
  // Warning precaution
  PixSamples := 0;
  BitsAlloc := 0;
  PixRows := 0;
  PixCols := 0;

  CurTeethFlags := 0;
  Result := 0;
  repeat
    if not DCFileElemHeadRead() then
      break;
    if DCETag.TEID = $0 then
    begin
      // Group Legth Element
      DCFileElemValueRead();
      Continue;
    end;

    case DCETag.TGID of // DICOM Tag Groups Case
      $2:
        begin
          ////////////////////////////////////
          // DICOM Metainfo Group
          //
          if DCETag.TEID = $10 then
          begin
            DCFileElemValueRead();
            if (DCEncType <> K_dcmetImpLitEnd) and
              (DCEncType <> K_dcmetExpLitEnd) then
            begin
              GetElemAnsiText();
              {
                DCLastImportInfo := '(0002,0010) Data Syntax is not implemented - ' + AnsiText;
                Result := 3; // Not implemented Syntax
                break;
              }
              DCEncType := K_dcmetExpLitEnd;
            end;
            StepToNextGroup(false); // Step to Next Group if possible
          end
          else
            DCStream.Seek(DCESize, soCurrent);
          //
          // end of DICOM Metainfo Group
          ////////////////////////////////////
        end;

      $8:
        begin
          ////////////////////////////////////
          // DICOM Image Info Group
          //
          if DCETag.TEID = $20 then
          begin
            // Get Slide Date
            GetElemAnsiText();
            if Length(AnsiText) = 8 then
            begin
              AnsiText1 := '1234-56-78';
              Move(AnsiText[1], AnsiText1[1], 4);
              Move(AnsiText[5], AnsiText1[6], 2);
              Move(AnsiText[7], AnsiText1[9], 2);
            end
            else
              AnsiText1 := AnsiText;
            DCDTTaken := K_StrToDateTime(String(AnsiText1));
          end
          else if DCETag.TEID = $30 then
          begin
            // Get Slide Time
            GetElemAnsiText();
            if Length(AnsiText) = 6 then
            begin
              AnsiText1 := '12:34:56';
              Move(AnsiText[1], AnsiText1[1], 2);
              Move(AnsiText[3], AnsiText1[4], 2);
              Move(AnsiText[5], AnsiText1[7], 2);
            end
            else
              AnsiText1 := AnsiText;
            DCDTTaken := DCDTTaken + K_StrToDateTime(String(AnsiText1), TRUE);
          end
          else if DCETag.TEID = $2228 then
          begin
            // Get teeth Info
            EndSeqElemOffs := DCStream.Position + DCESize;
            while EndSeqElemOffs > DCStream.Position do
            begin
              // if not DCFileElemHeadRead() then begin
              DCFileElemHeadRead(); // Read Seqence Item Header
              EndItemOffs := DCStream.Position + DCESize;
              while EndItemOffs > DCStream.Position do
              begin
                DCFileElemHeadRead(); // Read Seqence Item Header
                if DCETag.TEID = $100 then
                begin
                  GetElemAnsiText();
                  WI := K_IndexOfStringInRArray(TrimRight(String(AnsiText)),
                    @(K_CMTeethDICOMInfo[0].c), Length(K_CMTeethDICOMInfo),
                    SizeOf(TK_CMTDICOMInfo));
                  if WI >= 0 then
                    K_SetInclude(WI - 1, @CurTeethFlags);

                  DCStream.Seek(EndItemOffs, soBeginning);
                  break;
                end
                else
                  DCStream.Seek(DCESize, soCurrent);
              end;
            end;
            // StepToNextGroup( FALSE ); //  Step to Next Group if possible
          end
          else
            DCStream.Seek(DCESize, soCurrent);
          //
          // end of DICOM Image Info Group
          ////////////////////////////////////
        end;

      $D:
        begin
          ////////////////////////////////////
          // CMS Slide Private Info Group
          //
          if DCETag.TEID = $10 then
          begin
            // Get Slide Date
            GetElemAnsiText();
//            CMSDICOMFlag := AnsiSameText(AnsiText, K_CMS_DICOM_DATA_SIGNATURE);
            CMSDICOMFlag := SameText(String(AnsiText), K_CMS_DICOM_DATA_SIGNATURE);
            if not CMSDICOMFlag then
              StepToNextGroup(false); // Step to Next Group if possible
          end
          else if CMSDICOMFlag then
          begin
            if DCETag.TEID = $1000 then
            begin
              // Get Slide MapRoot
              GetElemAnsiText();
              SerMapRoot := String(AnsiText);
              // UDMapRoot := N_LoadUObjFromMem( @Text[1], DCESize );
            end
            else if DCETag.TEID = $1001 then
            begin
              // Get Slide Fields
              GetElemAnsiText();
              SerSlideFields := String(AnsiText);
              // K_LoadSPLDataFromText( SlideFields, K_GetTypeCodeSafe( 'TN_CMSlide' ).All, AnsiText );
            end
            else
              DCStream.Seek(DCESize, soCurrent);
          end
          else
            DCStream.Seek(DCESize, soCurrent);

          //
          // end of CMS Slide Private Info Group
          ////////////////////////////////////
        end;

      $10:
        begin
          ////////////////////////////////////
          // DICOM Patient Info Group
          //
          StepToNextGroup(TRUE); // Step to Next Group if possible or to Next Element
          //
          // end of DICOM Patient Info Group
          ////////////////////////////////////
        end;

      $20:
        begin
          ////////////////////////////////////
          // DICOM Study Info Group
          //
          StepToNextGroup(TRUE); // Step to Next Group if possible  or to Next Element
          //
          // end of DICOM Study Info  Group
          ////////////////////////////////////
        end;

      $28:
        begin
          ////////////////////////////////////
          // DICOM Image Pixels Info Group
          //
          case DCETag.TEID of
            $2:
              begin
                DCFileElemValueRead();
                PixSamples := PWORD(@DCDataBuf[0])^;
              end;
            $4:
              begin
                GetElemAnsiText();
                PixPhotometric := String(AnsiText);
                if not K_StrStartsWith('MONOCHROME', PixPhotometric)
                  and not K_StrStartsWith('RGB', PixPhotometric) then
                begin
                  DCLastImportInfo :=
                    '(0028,0004) Photometric Interpretation is not implemented - '
                    + PixPhotometric;
                  Result := 4; // Photometric Interpretation is Not implemented
                  break;
                end;
              end;
            $10:
              begin
                DCFileElemValueRead();
                PixRows := PWORD(@DCDataBuf[0])^;
              end;
            $11:
              begin
                DCFileElemValueRead();
                PixCols := PWORD(@DCDataBuf[0])^;
              end;
            $100:
              begin
                DCFileElemValueRead();
                BitsAlloc := PWORD(@DCDataBuf[0])^;
                if (BitsAlloc <> 8) and (BitsAlloc <> 16) then
                begin
                  DCLastImportInfo :=
                    '(0028,0100) Pixels storing format is not implemented';
                  Result := 5; // Not implemented Pixels storing format
                  break;
                end;
              end;
            {
              $101: begin
              DCFileElemValueRead( );
              BitsStored := PWord(@DCDataBuf[0])^;
              end;
              $102: begin
              DCFileElemValueRead( );
              HighBit := PWord(@DCDataBuf[0])^;
              end;
            }
            $103:
              begin
                DCFileElemValueRead();
                if PWORD(@DCDataBuf[0])^ <> 0 then
                begin
                  DCLastImportInfo :=
                    '(0028,0103) Pixel Representation is not implemented - ' +
                    IntToStr(PWORD(@DCDataBuf[0])^);
                  Result := 6; // Pixel Representation is not implemented
                  break;
                end;
                StepToNextGroup(TRUE); // Step to Next Group if possible  or to Next Element
              end;
          else
            DCStream.Seek(DCESize, soCurrent);
          end;
          //
          // end of DICOM Image Pixels Info Group
          ////////////////////////////////////
        end;

      $7FE0:
        begin
          ////////////////////////////////////
          // DICOM Image Pixels
          //
          if DCETag.TEID = $10 then
          begin
            if DCESize > 0 then
            begin
              // Native Paixels - Create DIB and Get it's Pixels directly from DICOM
              if PixSamples = 3 then
              begin
                PixFmt := pf24bit;
                ExPixFmt := epfBMP;
              end
              else
              begin
                PixFmt := pfCustom;
                ExPixFmt := epfGray8;
                if BitsAlloc = 16 then
                  ExPixFmt := epfGray16
              end;
              DIBObj := TN_DIBObj.Create(PixCols, PixRows, PixFmt, -1,
                ExPixFmt);
              DIBObj.StreamToPixels(DCStream);
              AUDSlide := K_CMSlideCreateFromDIBObj(DIBObj, nil);
              if SerMapRoot <> '' then
              begin
                UDMapRoot := N_LoadUObjFromMem(@SerMapRoot[1],
                  Length(SerMapRoot));
                AUDSlide.PutDirChildSafe(K_CMSlideIndMapRoot, UDMapRoot);
                AUDSlide.RebuildMapImageByDIB();
                AUDSlide.CreateThumbnail();
              end;

              with AUDSlide.P()^ do
              begin
                CMSTeethFlags := CurTeethFlags;
                if SerSlideFields <> '' then
                begin
                  K_LoadSPLDataFromText(SlideFields,
                    K_GetTypeCodeSafe('TN_CMSlide').All, SerSlideFields);
                  CMSDTTaken := SlideFields.CMSDTTaken; // Slide DateTime Taken
                  CMSDTCreated := SlideFields.CMSDTCreated;
                  // Slide DateTime Created
                  CMSDTImgMod := SlideFields.CMSDTImgMod;
                  // Slide DateTime Image Modified
                  CMSDTMapRootMod := SlideFields.CMSDTMapRootMod;
                  // Slide DateTime MapRoot Modified
                  CMSDTPropMod := SlideFields.CMSDTPropMod;
                  // Slide DateTime Properties/Diagnoses Modified

                  CMSProvIDCreated := SlideFields.CMSProvIDCreated;
                  // Provider ID that Creates Slide
                  CMSProvIDModified := SlideFields.CMSProvIDModified;
                  // Provider ID that (last) Modifies Slide

                  CMSLocIDCreated := SlideFields.CMSLocIDCreated;
                  // Location ID where Slide was Created
                  CMSLocIDModified := SlideFields.CMSLocIDModified;
                  // Location ID where Slide was Modified

                  CMSCompIDCreated := SlideFields.CMSCompIDCreated;
                  // Computer Name where Slide was Created
                  CMSCompIDModified := SlideFields.CMSCompIDModified;
                  // Computer Name where Slide was Modified

                  CMSMediaType := SlideFields.CMSMediaType; // Slide Media Type (Media Category) (global to all Patients)
                  CMSTeethFlags := SlideFields.CMSTeethFlags;
                  // Slide Teeth Flags

                  CMSDiagn := SlideFields.CMSDiagn; // Slide Diagnoses
                  CMSSourceDescr := SlideFields.CMSSourceDescr; // Slide Source

                  CMSPatId := SlideFields.CMSPatId; // Patient Id (to be used to retrieve from external DB)
                  CMSDB := SlideFields.CMSDB; // Slide Fields stored as single DB field
//                  CMSDB.SFlags := CMSDB.SFlags - [cmsfHasSrcImg,cmsfSaveSrcImg]; // Is it really needed
                  CMSDB.SFlags := CMSDB.SFlags - [cmsfHasSrcImg];  //!!! 11-07-2010
                  CMSDB.SFlags := CMSDB.SFlags + [cmsfSaveSrcImg]; //!!! 11-07-2010
                end;
              end;

            end
            else
            begin
              // Search for first Actual Item
              if not DCFileElemHeadRead() then
              begin
              LExit :
                DCLastImportInfo := '(7FE0,0010) Pixels are not found';
                Result := 7; // Not implemented Syntax
                break;
              end;
              PixelsOffs := 0;
              if DCESize > 0 then
              begin
                // Get Pixels Offset
                DCFileElemValueRead();
                Move(DCDataBuf[0], PixelsOffs, DCESize);
              end;
              if not DCFileElemHeadRead() then
                goto LExit;
              // Create DIB and try to read compressed data from DICOM stream by GDI+
              DCStream.Seek(PixelsOffs, soCurrent);
              DCNextGroupStreamOffs := DCStream.Position;
              {
                // Copy Stream Tail to File
                FStream := TFileStream.Create( 'c:\Delphi_prj_new\DTMP\DICOM_Samples\99.jpg', fmCreate );
                FStream.CopyFrom( DCStream, DCStream.Size - DCStream.Position );
                FStream.Free;
                DCStream.Seek( DCNextGroupStreamOffs, soFromBeginning );
              }
{
              GPCWrapper := TK_GPDIBCodecsWrapper.Create;
              if Ok = GPCWrapper.GPLoadFromStream(DCStream) then
              begin
                DIBObj := TN_DIBObj.Create(1, 1, pf24bit);
                if Ok <> GPCWrapper.GPGetFrameToDIBObj(DIBObj, 0,
                  K_CMImgMaxPixelsSize) then
                begin
                  DIBObj.Free;
                WrongPixels :
                  DCLastImportInfo :=
                    '(7FE0,0010) Pixels format is not implemented';
                  Result := 8; // Not implemented Syntax
                  break;
                end
                else
                begin
                  Stream := DCStream;
                  DCStream.Seek(DCNextGroupStreamOffs, soFromBeginning);
                  DIBStoreFormat := K_CMEDAccess.SlidesDIBFormat;
                  if not CompareMem(@GPCWrapper.GPFrameSize, @DIBObj.DIBSize,
                    SizeOf(TPoint)) then
                  begin
                    Stream := nil;
                    DIBStoreFormat := uddfJPEG;
                    // Set Initial Image Data Save Format
                  end;
                  AUDSlide := K_CMSlideCreateFromDIBObj(DIBObj, nil, Stream,
                    DIBStoreFormat);
                  with AUDSlide.P()^ do
                    CMSTeethFlags := CurTeethFlags;
                end;
              end
              else
                goto WrongPixels;

              GPCWrapper.Free;
}
              if K_RIOBj.RIOpenStream(DCStream) = rirOK then
              begin
                DIBObj := nil;
                K_RIOBj.RIMaxPixelsCount := K_CMImgMaxPixelsSize;
                if K_RIOBj.RIGetDIB( 0, DIBObj ) <> rirOK then
                begin
                  DIBObj.Free;
                  K_RIObj.RIClose();

WrongPixels:
                  DCLastImportInfo :=
                    '(7FE0,0010) Pixels format is not implemented';
                  Result := 8; // Not implemented Syntax
                  break;
                end
                else
                begin
                  Stream := DCStream;
//                  DCStream.Seek(DCNextGroupStreamOffs, soFromBeginning); // in Delphi XE5 warning W1000 Symbol 'Seek' is deprecated
                  DCStream.Seek(Integer(DCNextGroupStreamOffs), soFromBeginning);
                  DIBStoreFormat := K_CMEDAccess.SlidesDIBFormat;
                  with K_RIObj.RILastImageSize do
                  if (X <> DIBObj.DIBSize.X) or (Y <> DIBObj.DIBSize.Y) then
                  begin
                    Stream := nil;
                    DIBStoreFormat := uddfJPEG;
                    // Set Initial Image Data Save Format
                  end;
                  AUDSlide := K_CMSlideCreateFromDIBObj(DIBObj, nil, Stream,
                    DIBStoreFormat);
                  with AUDSlide.P()^ do
                    CMSTeethFlags := CurTeethFlags;
                  K_RIObj.RIClose();
                end;
              end
              else
                goto WrongPixels;

//              K_RIObj.RIClear();
              K_RIObj.RIClose();
              break;
            end;
          end;
          //
          // end of DICOM Image Pixels
          ////////////////////////////////////
        end;
    else
      DCStream.Seek(DCESize, soCurrent);
    end; // case DCETag.TGID of // DICOM Tag Groups Case

  until false;
  DCFileClose();
  K_RIOBj.RIMaxPixelsCount := 0;
end; // TK_DICOMAccess.DCSlideImport

//*************************************** TK_DICOMAccess.DCFileElemHeadRead ***
// Read next DICOM element header
//
//     Parameters
// Result - Returns TRUE if next DICOM data element header was read
//
// Element Header is put to DCEHead
//
function TK_DICOMAccess.DCFileElemHeadRead: Boolean;
var
  CurEncType: TK_DICOMEncType; // Data Encoding Type
  PrevGroupID: Word;
begin
  DCEFpos := DCStream.Position; // Current Element Start File Position
  PrevGroupID := DCETag.TGID;
  Result := DCStream.Read(DCETag, SizeOf(TK_DICOMDataTag)) = SizeOf
    (TK_DICOMDataTag);
  if not Result then
    Exit;
  if PrevGroupID <> DCETag.TGID then
    DCNextGroupStreamOffs := 0; // Clear Next Group Stream Offset

  CurEncType := DCEncType;
  if DCETag.TGID = 2 then // Meta Data Group
    CurEncType := K_dcmetExpLitEnd;
  DCEHType := K_dcmehElem;
  if DCETag.TGID = $FFFE then
  begin // Elemennts Set
    case DCETag.TEID of
      $E000:
        DCEHType := K_dcmehSQElemS;
      $E00D:
        DCEHType := K_dcmehSQElemF;
      $E0DD:
        DCEHType := K_dcmehSQF;
    end;
  end;
  if (DCEncType = K_dcmetUnKnownFormat) then
  begin
    Result := DCStream.Read(DCEVR, SizeOf(DCEVR)) = SizeOf(DCEVR);
    if not Result then
      Exit;
    if DCEVR = 0 then
      DCEncType := K_dcmetImpLitEnd
    else
      DCEncType := K_dcmetExpLitEnd;
    CurEncType := DCEncType;
    DCStream.Seek(-SizeOf(DCEVR), soFromCurrent);
  end;
  if (CurEncType = K_dcmetImpLitEnd) or (DCETag.TGID = $FFFE) then
  begin
    Result := DCStream.Read(DCESize, SizeOf(Integer)) = SizeOf(Integer);
    if DCESize = -1 then
      DCEHType := K_dcmehSQS;
    DCEVR := 0;
  end
  else
  begin
    // Result := CurEncType <> K_dcmetUnKnownFormat;
    // if not Result then Exit;
    Result := DCStream.Read(DCEVR, SizeOf(DCEVR)) = SizeOf(DCEVR);
    if not Result then
      Exit;
    Result := DCStream.Read(DCESize, SizeOf(Word)) = SizeOf(Word);
    if not Result then
      Exit;
    if (DCEVR = K_DCT_OB) or (DCEVR = K_DCT_OF) or (DCEVR = K_DCT_OW) or
      (DCEVR = K_DCT_SQ) or (DCEVR = K_DCT_UT) or (DCEVR = K_DCT_UN) or
      (DCEVR = 0) then
      Result := DCStream.Read(DCESize, SizeOf(Integer)) = SizeOf(Integer);
    if DCEVR = K_DCT_SQ then
      DCEHType := K_dcmehSQS;
  end;
end; // TK_DICOMAccess.DCFileElemHeadRead

//*********************************************** TK_DICOMAccess.DCFileOpen ***
// Read next DICOM element header and data
//
//     Parameters
// AMaxLength - maximal element data length to read
// Result - Returns TRUE if next DICOM element data was read
//
// Element Header is put to DCEHead and Element Value to DCDataBuf
//
function TK_DICOMAccess.DCFileElemValueRead(AMaxLength: Integer = 0): Boolean;
var
  EncTypeUI: AnsiString;
begin
  // Data Read
  if AMaxLength = 0 then
    AMaxLength := DCESize
  else
    AMaxLength := Min(DCESize, AMaxLength);
  K_SetBArrayCapacity(DCDataBuf, AMaxLength + 1);
  // if Length(DCDataBuf) < AMaxLength + 1 then
  // SetLength( DCDataBuf, AMaxLength + 1 );
  Result := DCStream.Read(DCDataBuf[0], AMaxLength) = AMaxLength;
  if not Result then
    Exit;

  DCDataBuf[AMaxLength] := 0; // End String Mark
  if (DCETag.TGID = 2) and (DCETag.TEID = $10) then
  begin // File Encoding Type
    SetString(EncTypeUI, PAnsiChar(@DCDataBuf[0]), AMaxLength);
{$IF CompilerVersion >= 26.0} // Delphi >= XE5
    // StrComp in Delphi XE5 was moved to AnsiStrings unit
    if AnsiStrings.StrComp(@EncTypeUI[1], '1.2.840.10008.1.2') = 0 then
      DCEncType := K_dcmetImpLitEnd
    else if AnsiStrings.StrComp(@EncTypeUI[1], '1.2.840.10008.1.2.1') = 0 then
      DCEncType := K_dcmetExpLitEnd
    else if AnsiStrings.StrComp(@EncTypeUI[1], '1.2.840.10008.1.2.2') = 0 then
      DCEncType := K_dcmetExpBigEnd
    else
      DCEncType := K_dcmetUnKnownFormat;
{$ELSE}
    if SysUtils.StrComp(@EncTypeUI[1], '1.2.840.10008.1.2') = 0 then
      DCEncType := K_dcmetImpLitEnd
    else if SysUtils.StrComp(@EncTypeUI[1], '1.2.840.10008.1.2.1') = 0 then
      DCEncType := K_dcmetExpLitEnd
    else if SysUtils.StrComp(@EncTypeUI[1], '1.2.840.10008.1.2.2') = 0 then
      DCEncType := K_dcmetExpBigEnd
    else
      DCEncType := K_dcmetUnKnownFormat;
{$IFEND CompilerVersion >= 26.0}

  end;

  if AMaxLength < DCESize then
    DCStream.Seek(DCESize - AMaxLength, soCurrent);

  if DCETag.TEID = 0 then
    // Group Length Element
    DCNextGroupStreamOffs := DCStream.Position + PInteger(@DCDataBuf[0])^;

end; // TK_DICOMAccess.DCFileElemValueRead

//******************************************* TK_DICOMAccess.DCFileElemRead ***
// Read next DICOM element header and data
//
//     Parameters
// AMaxLength - maximal element data length to read
// Result - Returns TRUE if next DICOM element data was read
//
// Element Header is put to DCEHead and Element Data to DCDataBuf
//
function TK_DICOMAccess.DCFileElemRead(AMaxLength: Integer = 0): Boolean;
begin
  Result := DCFileElemHeadRead();
  if not Result then
    Exit;
  if DCESize = -1 then
    Exit;
  Result := DCFileElemValueRead(AMaxLength);
end; // TK_DICOMAccess.DCFileElemRead

//*********************************************** TK_DICOMAccess.DCFileOpen ***
// Dump DICOM file to text file
//
//     Parameters
// ADICOMFName - DICOM file name
// ADumpFName - dump text file name
//
procedure TK_DICOMAccess.DCFileDump(const ADICOMFName, ADumpFName: string);
const
  RDataSize = 200;
var
  SL: TStringList;
  DataText: AnsiString;
  SEType: AnsiString;
  RS: TStringList;
  SQFinPos: Int64;
  SQShift: AnsiString;

label SetTagOut;

begin
  if not DCFileOpen(ADICOMFName) then
    Exit;
  SL := TStringList.Create;
  RS := TStringList.Create;
  SL.Add(ADICOMFName + ' file dump');
  SQFinPos := -1;
  repeat
    if (SQFinPos > 0) and (DCEFpos = SQFinPos) then
      SQFinPos := -1;

    if SQFinPos < 0 then // Needed for return SQ Control Tags Shift
      SQShift := '';
    {
      if SQFinPos > 0 then // Needed for return SQ Control Tags Shift
      SQShift := '  '
      else
      SQShift := '';
    }
    SetLength(SEType, 2);
    PWORD(@SEType[1])^ := DCEVR;

    case DCEVR of
      K_DCT_AT:
        DataText := AnsiString(format('(%0.4x,%0.4x)', [PWORD(@DCDataBuf[0])^,
            PWORD(@DCDataBuf[2])^]));
      K_DCT_FL:
        DataText := AnsiString(format('%g', [PFloat(@DCDataBuf[0])^]));
      K_DCT_FD:
        DataText := AnsiString(format('%g', [PDouble(@DCDataBuf[0])^]));
      K_DCT_OF, K_DCT_OW:
        begin
          RS.Clear;
          N_ConvMemToHex(@DCDataBuf[0], 16, DCEFpos, RS);
          DataText := AnsiString(Copy(RS[0], 9, Length(RS[0])));
        end;
      K_DCT_SL:
        DataText := AnsiString(format('%d', [PInteger(@DCDataBuf[0])^]));
      K_DCT_SQ:
        begin
          DataText := '';
          SQFinPos := DCEFpos + DCESize + 12;
        end;
      K_DCT_SS:
        DataText := AnsiString(format('%d', [PSmallInt(@DCDataBuf[0])^]));
      K_DCT_UL:
        DataText := AnsiString(format('%u', [PLongWord(@DCDataBuf[0])^]));
      K_DCT_US:
        DataText := AnsiString(format('%u', [PWORD(@DCDataBuf[0])^]));
    else
      SetString(DataText, PAnsiChar(@DCDataBuf[0]), Min(DCESize, RDataSize));
    end;

  SetTagOut :
    // FPos        Tag     Type Size Data
    SL.Add(format('%0.8x' + Chr($09) + '%s(%0.4x,%0.4x) %s %8d' + Chr($09)
          + '%s', [DCEFpos, SQShift, DCETag.TGID, DCETag.TEID, SEType,
        DCESize, DataText]));
    if not DCFileElemHeadRead() then
      break;

    if SQFinPos > 0 then // Needed for SQ Control Tags Shift
      SQShift := '  ';
    {
      if SQFinPos > 0 then // Needed for SQ Control Tags Shift
      SQShift := '  '
      else
      SQShift := '';
    }
    if DCEHType = K_dcmehElem then
    begin
      DCFileElemValueRead();
      if (DCETag.TGID = $D) and (DCETag.TEID = $1000) then
      begin
        SetString(DataText, PChar(@DCDataBuf[0]), DCESize);
        SL.Add(String(DataText));
      end;
      // DCFileElemValueRead( RDataSize )
    end
    else if DCEHType = K_dcmehSQS then
      Continue
    else
    begin
      SEType := '  ';
      goto SetTagOut;
    end;

  until false;
  K_ForceFilePath(ADumpFName);
  SL.SaveToFile(ADumpFName);
  SL.Free;
  RS.Free;
  DCFileClose();
end; // TK_DICOMAccess.DCFileDump

{ *** end of  TK_DICOMAccess *** }

{*** TK_CMSImportNotes ***}

//************************************************ TK_CMSImportNotes.Create ***
// Import Notes Class Constructor
//
constructor TK_CMSImportNotes.Create;
begin
  SINUDRoot := TK_UDStringList.Create;
  SINImportDumpChanel := -1;
  SINSlideList := TStringList.Create;
  SINSlideList.Sorted := FALSE;
  SINWSL := TStringList.Create;
end; // TK_CMSImportNotes.Create

//*************************************** TK_CMSImportNotes.Destroy ***
// Import Notes Class Destructor
//
destructor TK_CMSImportNotes.Destroy;
begin
  SINSlideList.Free();
  SINWSL.Free();
  SINUDRoot.UDDelete();
end; // TK_CMSImportNotes.Destroy

//************************************** TK_CMSImportNotes.SINAddSlideNotes ***
// Add notes to given Slide
//
//     Parameters
// AUDSlide - given slide object
// ASImpSlideID - imported slide ID (string)
//
procedure TK_CMSImportNotes.SINAddSlideNotes( AUDSlide: TN_UDCMSlide;
                                              const ASImpSlideID: string );
var
  VObjCompRoot : TN_UDCompVis;
  POneTextBlock : TN_POneTextBlock;
  N1Ind, NMax : Integer;
  Mes : string;
  NoteUDInfo : TK_UDStringList;
  CNoteID : Integer;
  SCNoteID : string;
  PFont : TN_PNFont;
  PUPColor : TN_POneUserParam;
  NoteBP : TFPoint;
  SlideFontHeight : Float;
  SlidePixWidth, SlidePixHeight : Integer;
begin
  if (Self = nil) or (SINUDNotes = nil) then Exit;
  // Search for Slide 1-st Note
  if not SINSlideList.Find( ASImpSlideID, N1Ind ) then
  begin
    Mes := 'Start Note for SlideID=' + ASImpSlideID + ' is not found';
    SINImportDump( Mes );
//    K_CMShowMessageDlg1( Mes, mtWarning, [], '', 10 );
    Exit;
  end;
  N1Ind := Integer(SINSlideList.Objects[N1Ind]);
  SINWSL.Clear;
  Mes := AUDSlide.P.CMSDiagn;
  if Mes <> '' then
  begin
    SINWSL.Add( Mes );
    SINWSL.Add( '' );
  end;
  SINWSL.Add( 'Media Object Notes:' );
 // Add Notes Loop
  with AUDSlide.P().CMSDB do
  begin
    SlidePixWidth  := PixWidth;
    SlidePixHeight := PixHeight;
  end;

  NMax := SINUDNotes.DirLength;
  CNoteID := 0;
  SlideFontHeight := 0;
  if SINFontAttrs.NFLLWHeight <> 0 then
    SlideFontHeight := SlidePixHeight * SINFontAttrs.NFLLWHeight / 1000;

  while TRUE do
  begin
    if N1Ind >= NMax then break; // End of Notes Dir
    NoteUDInfo := TK_UDStringList(SINUDNotes.DirChild(N1Ind));
    if NoteUDInfo.SL.Values['SlideID'] <> ASImpSlideID then Break; // All Slide Notes Done

    Inc(N1Ind);

    VObjCompRoot := AUDSlide.AddNewMeasurement( 'TNote' );
//    VObjCompRoot := AUDSlide.AddNewMeasurement( 'Text' );
    POneTextBlock := TN_UDParaBox(VObjCompRoot).PSP.CParaBox.CPBTextBlocks.P();
    Inc(CNoteID);
    SCNoteID := NoteUDInfo.SL.Values['Number'];
    if SCNoteID = '' then
      SCNoteID := IntToStr( CNoteID );

   // Set Note ID and Font
    with POneTextBlock^ do
    begin
      OTBMText := SCNoteID;
      PFont := K_GetPVRArray( OTBNFont ).P();
      if PFont <> nil then
      begin
        DeleteObject( PFont.NFHandle );
        if SINFontAttrs.NFFaceName <> '' then
          PFont^.NFFaceName := SINFontAttrs.NFFaceName;
        if SlideFontHeight <> 0 then
          PFont^.NFLLWHeight := SlideFontHeight;
        if SINUseFontStyle then
        begin
          PFont^.NFBold := SINFontAttrs.NFBold;
          PFont^.NFWin.lfItalic := SINFontAttrs.NFWin.lfItalic;
          PFont^.NFWin.lfUnderline := SINFontAttrs.NFWin.lfUnderline;
          PFont^.NFWin.lfStrikeOut := SINFontAttrs.NFWin.lfStrikeOut;
        end;
      end;
    end; // with POneTextBlock^ do

    // Set Note Text Color
    if SINTextColor <> -1 then
    begin
      PUPColor := K_CMGetVObjPAttr( VObjCompRoot, 'MainColor' );
      if PUPColor <> nil then
        PColor(PUPColor.UPValue.P)^ := SINTextColor;
    end;

    // Note Text to Diagnoses
    Mes := NoteUDInfo.SL.Values['Text'];
    SINWSL.Add( SCNoteID + ' - ' + Mes );

    // Note Text to Note.ObjInfo for Future Auto convertion to new special Annotation
    VObjCompRoot.ObjInfo := Mes;

    // Note Coords Set

    Mes := N_ReplaceDecSepByPoint( NoteUDInfo.SL.Values['X'] );
    NoteBP.X := ( 100 * StrToFloatDef( Mes, SlidePixWidth / 2 ) / SlidePixWidth );
    Mes := N_ReplaceDecSepByPoint( NoteUDInfo.SL.Values['Y'] );
    NoteBP.Y := ( 100 * StrToFloatDef( Mes, SlidePixHeight / 2 ) / SlidePixHeight );
    VObjCompRoot.PSP.CCoords.BPCoords := NoteBP;

    // Add Stat Info
    with K_CMEDAccess do
      EDAAddHistActionToSlideBuffer(AUDSlide,
                 EDABuildHistActionCode(K_shATChange, Ord(K_shCAVOObject),
                                        Ord(K_shVOActAdd), Ord(K_shVOTypeText)));

  end; // end of Add Notes Loop

  AUDSlide.P.CMSDiagn := SINWSL.Text; // Add Notes Texts to Slide.Diagnoses

end; // TK_CMSImportNotes.SINAddSlideNotes

//*************************************** TK_CMSImportNotes.SINLoadNotesXML ***
// Load notes XML file structure
//
//     Parameters
// AXMLFName - XML file with notes
//
procedure TK_CMSImportNotes.SINLoadNotesXML( const AXMLFName: string );
var
  ProperXMLFlag : Boolean;
  Mes : string;
  NoteUDInfo : TK_UDStringList;
  PrevSlideID, CurSlideID : string;
  i : Integer;
  FAttr : string;
begin
  N_Dump1Str( 'SIN>> Import Notes from ' + AXMLFName );
  ProperXMLFlag := FALSE;
  Mes := '';
  SINTextColor := -1;
  try
    K_DFStreamReadShareFlags := fmShareDenyNone;
    K_ParseXMLFromFile( SINUDRoot, AXMLFName );
    K_DFStreamReadShareFlags := 0;
    SINUDNotes := SINUDRoot.DirChild(0);
    ProperXMLFlag := (SINUDNotes <> nil) and SameText( SINUDNotes.ObjName, 'Note' );
    if ProperXMLFlag then
      SINUDNotes := SINUDRoot
    else
      ProperXMLFlag := (SINUDNotes <> nil) and  SameText(SINUDNotes.ObjName, 'Notes' );
  except
    on E: Exception do begin
      Mes := E.Message;
      N_Dump1Str( 'SIN>> XML File Error >> ' + E.Message );
    end
  end;

  if not ProperXMLFlag then begin
    if Mes <> '' then Mes := #13#10 + Mes;
    Mes := format( K_CML1Form.LLLImportNotes.Caption,
//      'File %s doesn''t contain proper data',
       [AXMLFName] );
    SINImportDump( Mes );
    K_CMShowMessageDlg1( Mes, mtWarning );
    SINUDNotes := nil;
  end
  else
  begin
  // Parse Common Text Attributes
    FAttr := TK_UDStringList(SINUDNotes).SL.Values['FontFace'];
    if FAttr <> '' then
      SINFontAttrs.NFFaceName := FAttr;

    FAttr := TK_UDStringList(SINUDNotes).SL.Values['FontSize'];
    if FAttr <> '' then
      SINFontAttrs.NFLLWHeight := StrToIntDef( FAttr, 20 );

    FAttr := TK_UDStringList(SINUDNotes).SL.Values['FontStyle'];
    if FAttr <> '' then
    begin
      SINWSL.Delimiter := ' ';
      SINWSL.DelimitedText := FAttr;
      if SINWSL.IndexOf( 'Bold' ) >= 0 then
        SINFontAttrs.NFBold := 1;
      if SINWSL.IndexOf( 'Italic' ) >= 0 then
        SINFontAttrs.NFWin.lfItalic := 1;
      if SINWSL.IndexOf( 'Underline' ) >= 0 then
        SINFontAttrs.NFWin.lfUnderline := 1;
      if SINWSL.IndexOf( 'StrikeOut' ) >= 0 then
        SINFontAttrs.NFWin.lfStrikeOut := 1;
      SINUseFontStyle := TRUE;
    end;

    FAttr := TK_UDStringList(SINUDNotes).SL.Values['TextColor'];
    if FAttr <> '' then
      SINTextColor := N_StrToColor( FAttr );

    // Build Notes Index
    PrevSlideID := '';
    for i := 0 to SINUDNotes.DirHigh do
    begin
      NoteUDInfo := TK_UDStringList(SINUDNotes.DirChild(i));
      CurSlideID := NoteUDInfo.SL.Values['SlideID'];
      if CurSlideID = PrevSlideID then Continue;
      PrevSlideID := CurSlideID;
      // Add New Slide to Search Notes List
      SINSlideList.AddObject( CurSlideID, TObject(i) );
    end;
    SINSlideList.Sort();
  end;

end; // TK_CMSImportNotes.SINLoadNotesXML

//***************************************** TK_CMSImportNotes.SINImportDump ***
// Put string to Import Data DUMP
//
//     Parameters
// AXMLFName - given dump string
//
procedure TK_CMSImportNotes.SINImportDump(const AMessage: string);
begin
  if SINImportDumpChanel < 0 then Exit;
  N_LCAdd( SINImportDumpChanel, AMessage );
end; // TK_CMSImportNotes.SINImportDump

{*** end of TK_CMSImportNotes ***}

//******************************************************** K_CMSAddCurState ***
// Add to given strings CMS current K_ related state params
//
//     Parameters
// AStrings - given strings
// AIndent  - number of spaces to add before all strings
//
// Is called from N_CMSCreateDumpFiles
//
procedure K_CMSAddCurState(AStrings: TStrings; AIndent: Integer);
var
  Prefix: string;
  i: Integer;
begin
  Prefix := DupeString(' ', AIndent + 2);
  if K_CMEDAccess <> nil then
    with K_CMEDAccess do
    begin
      // AStrings.Add( Prefix + '*** ... info:' );
      AStrings.Add(Prefix + '*** CurSlides info:');
      if Assigned(CurSlidesList) then
        for i := 0 to CurSlidesList.Count - 1 do
          TN_UDCMBSlide(CurSlidesList[i]).CMSlideAddCurState(AStrings,
            AIndent + 2);

      AStrings.Add(Prefix + '*** End of CurSlides info');
    end // with K_CMEDAccess do
  else
    AStrings.Add(Prefix + '*** K_CMEDAccess = nil');
  AStrings.Add('');
end; // procedure K_CMSAddCurState

//*********************************************** K_CMSCheckMemFreeSpaceDlg ***
// Check Memory Free Space and show Warning if not enough space
//
//     Parameters
// AMes   - warning message
// Result - Returns TRUE if free memory space is enough to continue CMS
//
function K_CMSCheckMemFreeSpaceDlg( const AMes : string ) : Boolean;
begin
  Result := N_CheckDIBFreeSpace( K_CMSCheckMemFreeDIBSize );
  if not Result then
    N_Dump1Str( format( 'MemFreeSpace >> not enough space for DIB %d', [K_CMSCheckMemFreeDIBSize] ) )
  else
  begin
    Result := K_FreeSpaceBufCheck( K_CMSCheckMemFreeBufSize );
    if not Result then
      N_Dump1Str( format( 'MemFreeSpace >> not enough space for Array %d', [K_CMSCheckMemFreeBufSize] ) );
  end;
  if Result then Exit;
  K_CMShowMessageDlg1( K_CML1Form.LLLMemory9.Caption + #13#10 + AMes,
//           'There is not enough memory to continue.'#13#10 + AMes,
                       mtWarning, [mbOK] );
end; // function K_CMSCheckMemFreeSpace

//************************************************* K_CMSlidesDelConfirmDlg ***
// Show Delete confirmation dialog for given Slides
//
//     Parameters
// APSlide - pointer to slides array start element to delete
// ASlidesCount - number of slides to delete
// Result - Returns TRUE if deletion is confirm by user
//
function  K_CMSlidesDelConfirmDlg( APSlide : TN_PUDCMSlide; ASlidesCount : Integer;
                                   AMarkAsDelFlag : Boolean ) : Boolean;
var
  MessageText : string;
  FocusInd : Integer;
begin
{
    if not AMarkAsDelFlag then
      MessageText :=
                    format( 'Do you confirm that you really want to delete (%d) selected object(s)?#13#10', [ASlidesCount] ) +
                            '              This action is irreversible. Proceed?'
    else
      MessageText :=
                    format( 'Do you confirm that you really want to delete (%d) selected object(s)?', [ASlidesCount] );
}
  MessageText := format( K_CML1Form.LLLDelObjs1.Caption, [ASlidesCount] );
  FocusInd := 0;
  if not AMarkAsDelFlag then
  begin
    FocusInd := 1;
    MessageText := MessageText + #13#10 +
                   K_CML1Form.LLLActProceed1.Caption + ' ' + K_CML1Form.LLLProceed.Caption;
  end;

  Result := K_CMSlideIconsDlg( APSlide, ASlidesCount, K_CML1Form.LLLDelConfirm.Caption, // 'Objects deletion confirmation',
                               MessageText, mtConfirmation, [], FocusInd );
end; // function  K_CMSlidesDelConfirmDlg

//************************************************* K_CMSlidesDelConfirmDlg ***
// Show Delete confirmation dialog for given Slide
//
//     Parameters
// ASlide - slide delete
// Result - Returns TRUE if deletion is confirm by user
//
function  K_CMSlideDelConfirmDlg( ASlide : TN_UDCMSlide ) : Boolean;
begin
  Result := K_CMSlideIconDlg( ASlide, K_CML1Form.LLLDelConfirm.Caption, //'Objects deletion confirmation',
           K_CML1Form.LLLECache3.Caption + ' ' +
           K_CML1Form.LLLActProceed1.Caption + #13#10#13#10 + K_CML1Form.LLLProceed.Caption
//           'Do you confirm that you really want to delete'#13#10 +
//           'the selected object? This action is irreversible.'#13#10 +
//           #13#10 + 'Proceed?'
            );
end; // function  K_CMSlideDelConfirmDlg

//******************************************************* K_CMCheckMasterLP ***
// Check Master Login and Password
//
//     Parameters
// ALogin    - login string to check
// APassword - password string to check
// Result - Returns TRUE if Master Login and Password are correct
//
function  K_CMCheckMasterLP( const ALogin, APassword : string ) : Boolean;
var
  CDate : TDateTime;
  FDayOfWeek : Integer;
begin

  CDate := Date();
  FDayOfWeek := DayOfTheWeek(CDate) + 1;
  if FDayOfWeek = 8 then FDayOfWeek := 1;
  Result := SameText( ALogin, 'CMS' + IntToStr( FDayOfWeek * 4 - 1 ) ) and
            SameText( APassword, 'CMS' + IntToStr( DayOfTheMonth(CDate) * 3 - 2 ) );
end; // function  K_CMCheckMasterLP

//**************************************************** K_CMHistReportCreate ***
// Create CMSuit History Report
//
//     Parameters
// AReportDataSMatr - resulting Strings Matrix
// ARepAtttrs - report parameters set
//
procedure K_CMHistReportCreate( var AReportDataSMatr: TN_ASArray; var ARepAtttrs : TK_CMHistRepAtttrs );

type TK_CompCurCont = record
  Count : Integer; // Number of elements in comp result
  IndM1 : Integer; // Source Report index for previous line
  IndM2 : Integer; // Source Report index for previous previous line
  IndM3 : Integer; // Source Report index for previous previous line
  IndM4 : Integer; // Source Report index for previous previous line
end;

var
  i, Ind, CCInd, IActCode : Integer;
  SQLText : string;
  WSTR, StartFinSQL,
  HistActSQL, HistActSQL1, HistActSQL2,
  CaptFieldsSQL, CaptFieldsSQL1, CaptFieldsSQL2, AddSelectSQL, AddSelectSQL1, AddSelectSQL2,
  TimeSQL1, TimeSQL2 : string;
  WDT : TDateTime;
  SavedCursor: TCursor;
  SHACreateCode, SHADeleteCode, SHAMarkDelCode, SHAUnMarkDelCode: string;
  SHACreateIACCode, SHADeleteIACCode : string;
  HACreateCode : Integer;
  HADeleteCode : Integer;
  HAMarkDelCode : Integer;
  HAUnMarkDelCode : Integer;
  HACMSStartCode : Integer;
  HACMSCloseCode : Integer;
  HASessionStartCode : Integer;
  HASessionFinCode : Integer;
  HACreateIACCode : Integer;
  HADeleteIACCode : Integer;

  SExpFExt, SSrcDescr, SysInfo : string;
  IsDel, IsMedia : Boolean;
  IsSlideSelected : Boolean;
  SkipFromResult : Boolean;
  SL : TStringList;
//  AllActsFlagFlag : Boolean;
  FReportDataSMatr: TN_ASArray;
  RMarks : array of boolean;
  CCCArr : array of TK_CompCurCont;

  RadilogicalLogDS,
  SlideNumPerDayDS,
  LastRadioDateDS: TADOQuery;

  SlideSysInfo: TN_CMSlideSDBF;
  SlideNumPerDay: integer;

  procedure RemovePrevRLine( ARCount : Integer );
  begin
  // Remove Prev Session Fin
    RMarks[CCCArr[CCInd].IndM1] := FALSE;
    if ARCount = 1 then
    begin
      CCCArr[CCInd].IndM1 := CCCArr[CCInd].IndM2;
      CCCArr[CCInd].IndM2 := CCCArr[CCInd].IndM3;
      CCCArr[CCInd].IndM3 := CCCArr[CCInd].IndM4;
      Dec(CCCArr[CCInd].Count);
    end else
    begin
      RMarks[CCCArr[CCInd].IndM2] := FALSE;
      CCCArr[CCInd].IndM1 := CCCArr[CCInd].IndM3;
      CCCArr[CCInd].IndM2 := CCCArr[CCInd].IndM4;
      CCCArr[CCInd].Count := CCCArr[CCInd].Count - 2;
    end;
  end;

  function BuildStartFinHistActSQL( const ActCodeFieldName : string ): string;
  begin
    Result := '';
    if K_srfAllSlideActs in ARepAtttrs.HRFlags then
      Result :=
        '(' + ActCodeFieldName + ' = ' +
           IntToStr(HASessionStartCode) +
        ') or (' + ActCodeFieldName + ' = ' +
           IntToStr(HASessionFinCode) +
        ') or (' + ActCodeFieldName + ' = ' +
           IntToStr(HACMSStartCode) +
        ') or (' + ActCodeFieldName + ' = ' +
           IntToStr(HACMSCloseCode) + ')';
  end; // function BuildStartFinHistActSQL

  function BuildHistActSQL( const ActCodeFieldName : string ): string;
  begin
    Result := '';
    with TK_CMEDDBAccess(K_CMEDAccess), ARepAtttrs do
    begin
      if HRFlags * [K_srfAllSlideActs] <> [] then
      begin
        Result := '(' + ActCodeFieldName + ' = ' + IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCAHLoc))) +
                      ') or (' + ActCodeFieldName + ' = ' + IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCAPat))) + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideCreate] <> [] then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + '(' + ActCodeFieldName + ' = ' + SHACreateCode + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideDelete] <> [] then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + '(' + ActCodeFieldName + ' = ' + SHADeleteCode +
                              ') or (' + ActCodeFieldName + ' = ' + SHAMarkDelCode +
                              ') or (' + ActCodeFieldName + ' = ' + SHAUnMarkDelCode + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideModify] <> [] then
      begin
        WSTR := '((' + ActCodeFieldName + ' & 0x70000000) > 0) and ((' + ActCodeFieldName + ' & 0x70000000) < 0x40000000)';
        if HRFlags * [K_srfAllSlideActs,K_srfSlideCreate] = [] then
          WSTR := WSTR + ' and (' + ActCodeFieldName + ' <> ' + SHACreateCode + ')';
        if HRFlags * [K_srfAllSlideActs,K_srfSlideDelete] = [] then
          WSTR := WSTR + ' and (' + ActCodeFieldName + ' <> ' + SHADeleteCode +
                        ') and (' + ActCodeFieldName + ' <> ' + SHAMarkDelCode +
                        ') and (' + ActCodeFieldName + ' <> ' + SHAUnMarkDelCode + ')';
        if not (K_srfSAImportAC in HRFlags) then
          WSTR := WSTR + ' and (' + ActCodeFieldName + ' <> ' + SHACreateIACCode +  ')';
        if not (K_srfSAUndoImportAC in HRFlags) then
          WSTR := WSTR + ' and (' + ActCodeFieldName + ' <> ' + SHADeleteIACCode +  ')';

        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + '(' + WSTR + ')';
      end;

      if K_srfSAUndoImportAC in HRFlags then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + '(' + ActCodeFieldName + ' = ' + SHADeleteIACCode + ')';
      end;

      if K_srfSAImportAC in HRFlags then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + '(' + ActCodeFieldName + ' = ' + SHACreateIACCode + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideExport] <> [] then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result +
          '((' + ActCodeFieldName + ' & 0x7F000000) = ' +
             IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAExportFile))) +
          ') or (' + ActCodeFieldName + ' = ' +
             IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAExportWClipboard))) + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlidePrint] <> [] then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + '(' + ActCodeFieldName + ' = ' +
             IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAPrint))) + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideEmail] <> [] then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + '(' + ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAEmail))) + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideArchRest] <> [] then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + '(' + ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAArchive),Ord(K_shNCAArchMoveTo))) +
            ' or ' +  ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAArchive),Ord(K_shNCAArchRestFrom))) +
            ' or ' +  ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAArchive),Ord(K_shNCAArchQAdd))) +
            ' or ' +  ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAArchive),Ord(K_shNCAArchQDel))) + ')';
      end;

      if HRFlags * [K_srfAllSlideActs] <> [] then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + '(' + ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCADICOM),Ord(K_shNCADCMStore))) +
            ' or ' +  ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCADICOM),Ord(K_shNCADCMStoreErr))) +
            ' or ' +  ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCADICOM),Ord(K_shNCADCMComm))) +
            ' or ' +  ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCADICOM),Ord(K_shNCADCMCommErr))) +
            ' or ' +  ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCADICOM),Ord(K_shNCADCMExists))) +
            ' or ' +  ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCADICOM),Ord(K_shNCADCMAbsent))) +
            ' or ' +  ActCodeFieldName + ' = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCADICOM), Ord(K_shNCADCMImport))) + ')';
      end;

      StartFinSQL := BuildStartFinHistActSQL( ActCodeFieldName );
      if StartFinSQL <> '' then
      begin
        if Result <> '' then
          Result := Result + ' or ';
        Result := Result + StartFinSQL;
      end;

      // Add ActCode conditions for User/Patient (not slide) Statistics
      if not IsSlideSelected then
      begin
        if K_srfSACMSSetup in HRFlags then
        begin
          if Result <> '' then
            Result := Result + ' or ';
          Result := Result +
             '(' + ActCodeFieldName + ' = ' + IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAAltShiftM))) + ')';
        end;
        if K_srfSACaptDevSetup in HRFlags then
        begin
          if Result <> '' then
            Result := Result + ' or ';
          Result := Result +
             '(' + ActCodeFieldName + ' = ' + IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCACapDevSetup))) + ')';
        end;
        if K_srfSAAFilterSetup in HRFlags then
        begin
          if Result <> '' then
            Result := Result + ' or ';
          Result := Result +
             '((' + ActCodeFieldName + ' & 0x7FFF0000) = ' +
              IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAOther1),Ord(K_shNCA1UAFilterChange))) + ') or ' +
             '((' + ActCodeFieldName + ' & 0x7FFF0000) = ' +
              IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAOther1),Ord(K_shNCA1GAFilterChange))) + ')';
        end;
      end; // if not IsSlideSelected then

      if Result <> '' then
        Result := ' and (' + Result + ')';
    end; // with TK_CMEDDBAccess(K_CMEDAccess), ARepAtttrs do
  end; // BuildHistActSQL


  function BuildCaptFieldsSQL( const APatFieldName, AProvFieldName, ALocFieldName : string ): string;
  begin
    Result :=
      '(select ' + K_CMENDAHProvCapt + ' from ' + K_CMENDBAllHistProvidersTable +
      ' where ' + K_CMENDAHProvID + '='+AProvFieldName+') as RUserCapt,' +
      '(select ' + K_CMENDAHPatCN + ' from ' + K_CMENDBAllHistPatientsTable +
      ' where ' + K_CMENDAHPatID + '='+APatFieldName+') as RPatCN,' +
      '(select ' + K_CMENDAHPatCapt + ' from ' + K_CMENDBAllHistPatientsTable +
      ' where ' + K_CMENDAHPatID + '='+APatFieldName+') as RPatCapt,' +
      '(select ' + K_CMENDAHLocCapt + ' from ' + K_CMENDBAllHistLocationsTable +
      ' where ' + K_CMENDAHLocID + '='+ALocFieldName+') as RLocCapt,Q.SrcDescr as RSrcDescr';
  end; // function BuildCaptFieldsSQL

  procedure BuildAddSelectSQL0( var AStartSQL: string; const AFieldName, AFieldVal : string );
  begin
    if AStartSQL <> '' then
      AStartSQL := AStartSQL + ' and ';
    WStr := AFieldName+'=' + AFieldVal;
    if IsSlideSelected then
      WStr := '(' + WStr + ' or '+AFieldName+' is null)';
    AStartSQL := AStartSQL + WStr;
  end; // procedure BuildAddSelectSQL0

  function BuildAddSelectSQL( const ASlideFieldName, APatFieldName, AProvFieldName, ALocFieldName, ActCodeFieldName : string ): string;
  begin
    Result := '';
    with TK_CMEDDBAccess(K_CMEDAccess), ARepAtttrs do
    begin
      if IsSlideSelected then
      begin // Single Slide details are needed
        Result := '('+ASlideFieldName+'=' + HRSlideID;
        if StartFinSQL <> '' then
          Result := Result + ' or ' + BuildStartFinHistActSQL(ActCodeFieldName);
        Result := Result + ')';
      end;

      if (HRPatID <> '') and not IsSlideSelected then
        BuildAddSelectSQL0( Result, APatFieldName, HRPatID );

      if HRProvID <> '' then
        BuildAddSelectSQL0( Result, AProvFieldName, HRProvID );

      if HRLocID <> '' then
        BuildAddSelectSQL0( Result, ALocFieldName, HRLocID );

      if Result <> '' then
        Result := ' where ' + Result;
    end;

  end; // function BuildAddSelectSQL

begin

  SavedCursor := Screen.Cursor;
  Screen.Cursor := crHourGlass;

  with TK_CMEDDBAccess(K_CMEDAccess),
       ARepAtttrs do
  begin
  ////////////////////////////
  // Prepare Report SQL
  //
    // Build ActCode conditions for Patient
    HACreateCode := EDABuildHistActionCode(K_shATChange, Ord(K_shCACreate));
    HADeleteCode := EDABuildHistActionCode(K_shATChange, Ord(K_shCADelete));
    HAMarkDelCode := EDABuildHistActionCode(K_shATChange, Ord(K_shCADelMark));
    HAUnMarkDelCode := EDABuildHistActionCode(K_shATChange, Ord(K_shCADelUnMark));
    HACreateIACCode := EDABuildHistActionCode(K_shATChange, Ord(K_shCACreateIAC));
    HADeleteIACCode := EDABuildHistActionCode(K_shATChange, Ord(K_shCADeleteIAC));

    SHACreateCode := IntToStr(HACreateCode);
    SHADeleteCode := IntToStr(HADeleteCode);
    SHAMarkDelCode := IntToStr(HAMarkDelCode);
    SHAUnMarkDelCode := IntToStr(HAUnMarkDelCode);
    SHACreateIACCode := IntToStr(HACreateIACCode);
    SHADeleteIACCode := IntToStr(HADeleteIACCode);

    // Add ActCode conditions Common to all cases
    HACMSStartCode := EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCACMSStart));
    HACMSCloseCode := EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCACMSClose));
    HASessionStartCode := EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAStartSession));
    HASessionFinCode := EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAFinishSession));

    IsSlideSelected := HRSlideID <> '';
    if IsSlideSelected then
    begin // Add CreateIAC and DeleteIAC programatically
      if K_srfSlideCreate in HRFlags then
        Include( HRFlags, K_srfSAImportAC );
      if K_srfSlideDelete in HRFlags then
        Include( HRFlags, K_srfSAUndoImportAC );
    end;

    if not K_CMEDAMSSQL then
    begin // Sybase
      //////////////////////////////
      // Build where SQL by ActCode
  {
      HistActSQL := '';
      if HRFlags * [K_srfAllSlideActs] <> [] then
      begin
        HistActSQL := '(ActCode = ' + IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCAHLoc))) +
                      ') or (ActCode = ' + IntToStr(EDABuildHistActionCode(K_shATChange, Ord(K_shCAPat))) + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideCreate] <> [] then
      begin
        if HistActSQL <> '' then
          HistActSQL := HistActSQL + ' or ';
        HistActSQL := HistActSQL + '(ActCode = ' + SHACreateCode + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideDelete] <> [] then
      begin
        if HistActSQL <> '' then
          HistActSQL := HistActSQL + ' or ';
        HistActSQL := HistActSQL + '(ActCode = ' + SHADeleteCode +
                              ') or (ActCode = ' + SHAMarkDelCode +
                              ') or (ActCode = ' + SHAUnMarkDelCode + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideModify] <> [] then
      begin
        WSTR := '((ActCode & 0x70000000) > 0) and ((ActCode & 0x70000000) < 0x40000000)';
        if HRFlags * [K_srfAllSlideActs,K_srfSlideCreate] = [] then
          WSTR := WSTR + ' and (ActCode <> ' + SHACreateCode + ')';
        if HRFlags * [K_srfAllSlideActs,K_srfSlideDelete] = [] then
          WSTR := WSTR + ' and (ActCode <> ' + SHADeleteCode +
                        ') and (ActCode <> ' + SHAMarkDelCode +
                        ') and (ActCode <> ' + SHAUnMarkDelCode + ')';
        if not (K_srfSAImportAC in HRFlags) then
          WSTR := WSTR + ' and (ActCode <> ' + SHACreateIACCode +  ')';
        if not (K_srfSAUndoImportAC in HRFlags) then
          WSTR := WSTR + ' and (ActCode <> ' + SHADeleteIACCode +  ')';

        if HistActSQL <> '' then
          HistActSQL := HistActSQL + ' or ';
        HistActSQL := HistActSQL + '(' + WSTR + ')';
      end;

      if K_srfSAUndoImportAC in HRFlags then
      begin
        if HistActSQL <> '' then
          HistActSQL := HistActSQL + ' or ';
        HistActSQL := HistActSQL + '(ActCode = ' + SHADeleteIACCode + ')';
      end;

      if K_srfSAImportAC in HRFlags then
      begin
        if HistActSQL <> '' then
          HistActSQL := HistActSQL + ' or ';
        HistActSQL := HistActSQL + '(ActCode = ' + SHACreateIACCode + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideExport] <> [] then
      begin
        if HistActSQL <> '' then
          HistActSQL := HistActSQL + ' or ';
        HistActSQL := HistActSQL +
          '((ActCode & 0x7F000000) = ' +
             IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAExportFile))) +
          ') or (ActCode = ' +
             IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAExportWClipboard))) + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlidePrint] <> [] then
      begin
        if HistActSQL <> '' then
          HistActSQL := HistActSQL + ' or ';
        HistActSQL := HistActSQL + '(ActCode = ' +
             IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAPrint))) + ')';
      end;

      if HRFlags * [K_srfAllSlideActs,K_srfSlideEmail] <> [] then
      begin
        if HistActSQL <> '' then
          HistActSQL := HistActSQL + ' or ';
        HistActSQL := HistActSQL + '(ActCode = ' +
            IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAEmail))) + ')';
      end;

      if K_srfAllSlideActs in HRFlags then
      begin
        StartFinSQL :=
          '(ActCode = ' +
             IntToStr(HASessionStartCode) +
          ') or (ActCode = ' +
             IntToStr(HASessionFinCode) +
          ') or (ActCode = ' +
             IntToStr(HACMSStartCode) +
          ') or (ActCode = ' +
             IntToStr(HACMSCloseCode) + ')';

        if HistActSQL <> '' then
          HistActSQL := HistActSQL + ' or ';

        HistActSQL := HistActSQL + StartFinSQL;
      end;

      // Add ActCode conditions for User/Patient (not slide) Statistics
      if not IsSlideSelected then
      begin
        if K_srfSACMSSetup in HRFlags then
        begin
          if HistActSQL <> '' then
            HistActSQL := HistActSQL + ' or ';
          HistActSQL := HistActSQL +
             '(ActCode = ' + IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAAltShiftM))) + ')';
        end;
        if K_srfSACaptDevSetup in HRFlags then
        begin
          if HistActSQL <> '' then
            HistActSQL := HistActSQL + ' or ';
          HistActSQL := HistActSQL +
             '(ActCode = ' + IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCACapDevSetup))) + ')';
        end;
        if K_srfSAAFilterSetup in HRFlags then
        begin
          if HistActSQL <> '' then
            HistActSQL := HistActSQL + ' or ';
          HistActSQL := HistActSQL +
             '((ActCode & 0x7FFF0000) = ' +
              IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAOther1),Ord(K_shNCA1UAFilterChange))) + ') or ' +
             '((ActCode & 0x7FFF0000) = ' +
              IntToStr(EDABuildHistActionCode(K_shATNotChange, Ord(K_shNCAOther1),Ord(K_shNCA1GAFilterChange))) + ')';
        end;
      end; // if not IsSlideSelected then

      if HistActSQL <> '' then
        HistActSQL := ' and (' + HistActSQL + ')';
  {}
      HistActSQL := BuildHistActSQL( 'ActCode' );
      if IsSlideSelected then
        HistActSQL1 := HistActSQL;
      HistActSQL2 := HistActSQL;


      //////////////////////////////
      // Build Slide, Patient, Provider, Location captions SQL
  {
      CaptFieldsSQL :=
        '(select ' + K_CMENDAHProvCapt + ' from ' + K_CMENDBAllHistProvidersTable +
        ' where ' + K_CMENDAHProvID + '=RProvID) as RUserCapt,' +
        '(select ' + K_CMENDAHPatCN + ' from ' + K_CMENDBAllHistPatientsTable +
        ' where ' + K_CMENDAHPatID + '=RPatID) as RPatCN,' +
        '(select ' + K_CMENDAHPatCapt + ' from ' + K_CMENDBAllHistPatientsTable +
        ' where ' + K_CMENDAHPatID + '=RPatID) as RPatCapt,' +
        '(select ' + K_CMENDAHLocCapt + ' from ' + K_CMENDBAllHistLocationsTable +
        ' where ' + K_CMENDAHLocID + '=RLocID) as RLocCapt,Q.SrcDescr';
  {}
      CaptFieldsSQL := BuildCaptFieldsSQL( 'RPatID', 'RProvID', 'RLocID' );
  {
      if IsSlideSelected then
        CaptFieldsSQL := CaptFieldsSQL + ',0'
      else
        CaptFieldsSQL := CaptFieldsSQL + ',S.SessionID';
  }
      if IsSlideSelected then
        CaptFieldsSQL1 := CaptFieldsSQL + ',0';
      CaptFieldsSQL2 := CaptFieldsSQL + ',S.SessionID';


  {
      if IsSlideSelected then
      begin // Single Slide details are needed
        AddSelectSQL2 := '(RSlideID=' + HRSlideID;
        if StartFinSQL <> '' then
          AddSelectSQL2 := AddSelectSQL2 + ' or ' + StartFinSQL;
        AddSelectSQL2 := AddSelectSQL2 + ')';
        CaptFieldsSQL := CaptFieldsSQL + ',0';
      end
      else
        CaptFieldsSQL := CaptFieldsSQL + ',S.SessionID';
  }
      //////////////////////////////
      // Build aditional select SQL by Slide, Patient, Provider, Location ID
  {
      AddSelectSQL := '';
      if IsSlideSelected then
      begin // Single Slide details are needed
        AddSelectSQL := '(RSlideID=' + HRSlideID;
        if StartFinSQL <> '' then
          AddSelectSQL := AddSelectSQL + ' or ' + StartFinSQL;
        AddSelectSQL := AddSelectSQL + ')';
      end;

      if (HRPatID <> '') and not IsSlideSelected then
      begin
        if AddSelectSQL <> '' then
          AddSelectSQL := AddSelectSQL + ' and ';
        WStr := 'RPatID=' + HRPatID;
        if IsSlideSelected then
          WStr := '(' + WStr + ' or RPatID is null)';
        AddSelectSQL := AddSelectSQL + WStr;
      end;

      if HRProvID <> '' then
      begin
        if AddSelectSQL <> '' then
          AddSelectSQL := AddSelectSQL + ' and ';
        WStr := 'RProvID=' + HRProvID;
        if IsSlideSelected then
          WStr := '(' + WStr + ' or RProvID is null)';
        AddSelectSQL := AddSelectSQL + WStr;
      end;

      if HRLocID <> '' then
      begin
        if AddSelectSQL <> '' then
          AddSelectSQL := AddSelectSQL + ' and ';
        WStr := 'RLocID=' + HRLocID;
        if IsSlideSelected then
          WStr := '(' + WStr + ' or RLocID is null)';
        AddSelectSQL := AddSelectSQL + WStr;
      end;

      if AddSelectSQL <> '' then
        AddSelectSQL := ' where ' + AddSelectSQL;
  {}
      AddSelectSQL := BuildAddSelectSQL( 'RSlideID', 'RPatID', 'RProvID', 'RLocID', 'ActCode' );

      AddSelectSQL2 := AddSelectSQL;
      if IsSlideSelected then
        AddSelectSQL1 := AddSelectSQL;

      //////////////////////////////
      // Build where SQL by time
      TimeSQL2 := 'ActTS >= ' + EDADBDateTimeToSQL( HRStartTS ) + ' and ' +
                  'ActTS <= ' + EDADBDateTimeToSQL( HRFinTS );
      if IsSlideSelected then
        TimeSQL1 := TimeSQL2;
    end   // if not K_CMEDAMSSQL then
    else
    begin // if K_CMEDAMSSQL then
      if IsSlideSelected then
        HistActSQL1 := BuildHistActSQL( 'ActID' );
      HistActSQL2 := BuildHistActSQL( 'SLT.AHActCode' );

      if IsSlideSelected then
        CaptFieldsSQL1 := BuildCaptFieldsSQL( 'Q.PatID', 'S.ProvID', 'Q.LocID' ) + ',0';
      CaptFieldsSQL2 := BuildCaptFieldsSQL( 'S.PatID', 'S.ProvID', 'S.LocID' ) + ',S.SessionID';

      AddSelectSQL2 := BuildAddSelectSQL( 'S.SlideID', 'S.PatID', 'S.ProvID', 'S.LocID', 'S.ActCode' );
      if IsSlideSelected then
        AddSelectSQL1 := BuildAddSelectSQL( 'S.SlideID', 'S.PatID', 'Q.ProvID', 'Q.LocID', 'S.ActCode' );

      TimeSQL2 := 'SLT.AHActTS >= ' + EDADBDateTimeToSQL( HRStartTS ) + ' and ' +
                  'SLT.AHActTS <= ' + EDADBDateTimeToSQL( HRFinTS );
      if IsSlideSelected then
        TimeSQL1 := 'ActTS >= ' + EDADBDateTimeToSQL( HRStartTS ) + ' and ' +
                    'ActTS <= ' + EDADBDateTimeToSQL( HRFinTS );
    end;  // if K_CMEDAMSSQL then

    SQLText := '';
{}
    if IsSlideSelected and not K_CMEDAMSSQL then
      // SQL for Query from Old Hist Table
      SQLText := 'SELECT ' +  // Display the last data available
        'S.ActTS as RActTS,' +
        'Q.PatID as RPatID,' +
        'S.ProvID as RProvID,' +
        'S.ActCode as RActCode,' +
        'Q.CompName as RCompName,' +
        'Q.LocID as RLocID,' +
        'S.SlideID as RSlideID,' +
        'Q.SysInfo as RSysInfo,' +
        CaptFieldsSQL1 +
        ' FROM (SELECT ' +
          K_CMENDBSlidesHTFSlideID + ' as SlideID,' +
          K_CMENDBSlidesHTFProvID + ' as ProvID,' +
          K_CMENDBSlidesHTFActID  + ' as ActCode,' +
          K_CMENDBSlidesHTFActTS  + ' as ActTS' +
          ' FROM ' + K_CMENDBSlidesHistTable +
          ' WHERE ' +
            TimeSQL1 +
//            'ActTS >= ' + EDADBDateTimeToSQL( HRStartTS ) + ' and ' +
//            'ActTS <= ' + EDADBDateTimeToSQL( HRFinTS ) +
            HistActSQL1 +
            ') S LEFT OUTER JOIN (SELECT ' +
            K_CMENDBSTFSlideID + ' as SlideID,' +
            K_CMENDBSTFPatID + ' as PatID,' +
            K_CMENDBSTFSlideLocIDMod + ' as LocID,' +
            K_CMENDBSTFSlideCompMod + ' as CompName,' +
            K_CMENDBSTFSlideSrcDescr + ' as SrcDescr,' +
            K_CMENDBSTFSlideSysInfo + ' as SysInfo' +
            ' FROM ' + K_CMENDBSlidesTable + ') Q' +
            ' ON S.SlideID = Q.SlideID ' +
            AddSelectSQL1 +
          ' union ';
{}
    // SQL for Query from New Hist Tables
    SQLText := SQLText +
    'SELECT ' +  // Display the last data available
      'S.ActTS as RActTS,' +
      'S.PatID as RPatID,' +
      'S.ProvID as RProvID,' +
      'S.ActCode as RActCode,' +
      '(select ' + K_CMENDBGAInstsTFCName + ' from ' + K_CMENDBGAInstsTable +
      ' where ' + K_CMENDBGAInstsTFGlobID + '=S.CompID) as RCompName,' +
      'S.LocID as RLocID,' +
      'S.SlideID as RSlideID,' +
      'Q.SysInfo as RSysInfo,' +
      CaptFieldsSQL2 +
      ' FROM (SELECT ' +
        'SLT.' + K_CMENDBSlidesNHTFSlideID + ' as SlideID,' +
        'SLT.' + K_CMENDBSlidesNHTFActCode + ' as ActCode,' +
        'SLT.' + K_CMENDBSlidesNHTFActTS   + ' as ActTS,' +
        'SST.' + K_CMENDBSessionsHTFProvID + ' as ProvID,' +
        'SST.' + K_CMENDBSessionsHTFPatID  + ' as PatID,' +
        'SST.' + K_CMENDBSessionsHTFLocID  + ' as LocID,' +
        'SST.' + K_CMENDBSessionsHTFCompID + ' as CompID,' +
        'SLT.' + K_CMENDBSlidesNHTFSessionID + ' as SessionID' +
        ' FROM ' + K_CMENDBSessionsHistTable + ' SST, ' + K_CMENDBSlidesNewHistTable + ' SLT ' +
        ' WHERE ' +
          'SLT.' + K_CMENDBSlidesNHTFSessionID + '=' + 'SST.' + K_CMENDBSessionsHTFSessionID + ' and ' +
//          'ActTS >= ' + EDADBDateTimeToSQL( HRStartTS ) + ' and ' +
//          'ActTS <= ' + EDADBDateTimeToSQL( HRFinTS ) +
          TimeSQL2 +
          HistActSQL2 +
          ') S LEFT OUTER JOIN (SELECT ' +
          K_CMENDBSTFSlideID + ' as SlideID,' +
          K_CMENDBSTFSlideSrcDescr + ' as SrcDescr,' +
          K_CMENDBSTFSlideSysInfo + ' as SysInfo,' +
          K_CMENDBSTFSlideSrcDescr + ' as SrcDescr1' +
          ' FROM ' + K_CMENDBSlidesTable + ') Q' +
          ' ON S.SlideID = Q.SlideID ' +
          AddSelectSQL2 +
        ' order by RActTS asc';
{}
  //
  // end of Prepare Report SQL
  ////////////////////////////

  // Debug Code to View and Edit SQL
  //    with TK_FormTextEdit.Create(Application) do
  //      EditText( SQLText );

{ // MSSQL error in Fields[12] - wrong value
with CurDSet2 do
begin
  Connection := LANDBConnection;
  ExtDataErrorCode := K_eeDBSelect;
  SQL.Text := 'select ' +
      K_CMENDBSTFSlideID + ',' +
      K_CMENDBSTFSlideSrcDescr +
      ' FROM ' + K_CMENDBSlidesTable;
  Filtered := false;
  Open;
  First;
  with TK_DumpObj.Create( 'D:\Delphi_prj_new\DTmp\ErrLogs\DT\DT00020842\ADORes11.txt' ) do
  begin
    while not EOF do
    begin
      DumpStr0(
              FieldList.Fields[0].AsString + #9 +
              FieldList.Fields[1].AsString );
      Next;
    end;
    Free();
  end;
  Close;
end;

{}


{ experiments with SrcDescr in MSSQL
    with CurDSet2 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBSelect;
      SQL.Text := 'select ' +
          K_CMENDBSTFSlideID + ',' +
          K_CMENDBSTFSlideSrcDescr +
          ' FROM ' + K_CMENDBSlidesTable;
      Filtered := false;
      Open;
    end;
{}
   {$R-}
   if A_srfRadiologyLog in HRFlags then
   begin
     RadilogicalLogDS := TADOQuery.Create(nil);

     try
       RadilogicalLogDS.Connection := LANDBConnection;
       RadilogicalLogDS.SQL.Text := 'SELECT s.SlideID, date(s.DTTaken) as DateOnly, s.DTTaken, s.SysInfo, (p.APFirstname + '' '' + p.APSurname) as Patient, s.PatID, p.APCardNum, (pr.AUFirstname + '' '' + pr.AUSurname) as Provider FROM AllSlides s ' +
                                    'left join AllPatients p on s.PatID = p.APBridgeID ' +
                                    'left join AllProviders pr on s.ProvIDCr = pr.AUBridgeID ' +
                                    'WHERE ' +
                                    '((s.SysInfo like ''%DCMModality=IO%'') OR ' +
                                    '(s.SysInfo like ''%DCMModality=CR%'') OR ' +
                                    '(s.SysInfo like ''%DCMModality=DX%'') OR ' +
                                    '(s.SysInfo like ''%DCMModality=PX%'') OR ' +
                                    '(s.SysInfo like ''%DCMModality=CT%'')) AND ' +
                                    '(DateOnly >= :startDate AND DateOnly <= :finishDate) ';

       if not HRPatID.IsEmpty then
         RadilogicalLogDS.SQL.Text := RadilogicalLogDS.SQL.Text +
                                      'AND PatID = :patID ';

       RadilogicalLogDS.SQL.Text := RadilogicalLogDS.SQL.Text + 'ORDER BY s.DTTaken ASC';

       RadilogicalLogDS.Parameters.ParamByName('startDate').DataType := ftDate;
       RadilogicalLogDS.Parameters.ParamByName('startDate').Value := TDateTime(trunc(HRStartTS).ToDouble);
       RadilogicalLogDS.Parameters.ParamByName('finishDate').DataType := ftDate;
       RadilogicalLogDS.Parameters.ParamByName('finishDate').Value := TDateTime(trunc(HRFinTS).ToDouble);

       if not HRPatID.IsEmpty then
         RadilogicalLogDS.Parameters.ParamByName('patID').Value := HRPatID;

       RadilogicalLogDS.Open;

       if RadilogicalLogDS.RecordCount > 0 then
       begin
         SetLength(FReportDataSMatr, 1);

         RadilogicalLogDS.First;

         while not RadilogicalLogDS.Eof do
         begin
           K_CMEDAGetSlideSysFieldsData(RadilogicalLogDS.FieldByName('SysInfo').AsString, @SlideSysInfo);

           SetLength(FReportDataSMatr, Length(FReportDataSMatr)+1);
           SetLength(FReportDataSMatr[Length(FReportDataSMatr)-1], 10);

           SlideNumPerDayDS := TADOQuery.Create(nil);

           try
             SlideNumPerDayDS.Connection := LANDBConnection;
             SlideNumPerDayDS.SQL.Text := 'SELECT s.SlideID, date(s.DTTaken) as DateOnly from AllSlides s ' +
                                          'WHERE ' +
                                          's.PatID = :patid AND ' +
                                          'DateOnly = :dateTaken AND ' +
                                          '((s.SysInfo like ''%DCMModality=IO%'') OR ' +
                                          '(s.SysInfo like ''%DCMModality=CR%'') OR ' +
                                          '(s.SysInfo like ''%DCMModality=DX%'') OR ' +
                                          '(s.SysInfo like ''%DCMModality=PX%'') OR ' +
                                          '(s.SysInfo like ''%DCMModality=CT%'')) ' +
                                          'ORDER BY s.DTTaken ASC';

             SlideNumPerDayDS.Parameters.ParamByName('patid').Value := RadilogicalLogDS.FieldByName('PatID').AsString;

             SlideNumPerDayDS.Parameters.ParamByName('dateTaken').DataType := ftDate;
             SlideNumPerDayDS.Parameters.ParamByName('dateTaken').Value := TDateTime(trunc(RadilogicalLogDS.FieldByName('DTTaken').AsDateTime).ToDouble);//DateToStr(RadilogicalLogDS.FieldByName('DTTaken').AsDateTime, SlideDateFormat);

             SlideNumPerDayDS.Open;

             if SlideNumPerDayDS.RecordCount > 0 then
             begin
               if SlideNumPerDayDS.Locate('SlideID', RadilogicalLogDS.FieldByName('SlideID').AsInteger, [loCaseInsensitive]) then
                 SlideNumPerDay := SlideNumPerDayDS.RecNo
               else
                 SlideNumPerDay := -1;
             end
             else
               SlideNumPerDay := 1;
           finally
             FreeAndNil(SlideNumPerDayDS);
           end;

           FReportDataSMatr[Length(FReportDataSMatr)-1][0] := RadilogicalLogDS.FieldByName('DTTaken').AsString;
           FReportDataSMatr[Length(FReportDataSMatr)-1][1] := RadilogicalLogDS.FieldByName('Patient').AsString;
           FReportDataSMatr[Length(FReportDataSMatr)-1][2] := RadilogicalLogDS.FieldByName('APCardNum').AsString;
           FReportDataSMatr[Length(FReportDataSMatr)-1][3] := SlideNumPerDay.ToString;
           FReportDataSMatr[Length(FReportDataSMatr)-1][4] := RadilogicalLogDS.FieldByName('Provider').AsString;
           FReportDataSMatr[Length(FReportDataSMatr)-1][5] := SlideSysInfo.DCMModality.ToUpper;

           if SlideNumPerDay > 1 then
             FReportDataSMatr[Length(FReportDataSMatr)-1][6] := DateToStr(trunc(RadilogicalLogDS.FieldByName('DTTaken').AsDateTime))//DateToStr(RadilogicalLogDS.FieldByName('DTTaken').AsDateTime)
           else
           begin
             LastRadioDateDS := TADOQuery.Create(nil);

             try
               LastRadioDateDS.Connection := LANDBConnection;
               LastRadioDateDS.SQL.Text := 'select top 1 SlideID, date(s.DTTaken) as DateOnly, s.DTTaken from AllSlides s ' +
                                           'where ' +
                                           's.PatID = :patid AND ' +
                                           '(DateOnly < :CurrDate) AND ' +
                                           '((s.SysInfo like ''%DCMModality=IO%'') OR ' +
                                           '(s.SysInfo like ''%DCMModality=CR%'') OR ' +
                                           '(s.SysInfo like ''%DCMModality=DX%'') OR ' +
                                           '(s.SysInfo like ''%DCMModality=PX%'') OR ' +
                                           '(s.SysInfo like ''%DCMModality=CT%'')) ' +
                                           'ORDER BY DTTaken DESC';

               LastRadioDateDS.Parameters.ParamByName('patid').Value := RadilogicalLogDS.FieldByName('PatID').AsString;

               LastRadioDateDS.Parameters.ParamByName('CurrDate').DataType := ftDate;
               LastRadioDateDS.Parameters.ParamByName('CurrDate').Value := TDateTime(trunc(RadilogicalLogDS.FieldByName('DTTaken').AsDateTime).ToDouble);//DateToStr(RadilogicalLogDS.FieldByName('DTTaken').AsDateTime, SlideDateFormat);

               LastRadioDateDS.Open;

               if LastRadioDateDS.RecordCount > 0 then
                 FReportDataSMatr[Length(FReportDataSMatr)-1][6] := DateToStr(trunc(LastRadioDateDS.FieldByName('DTTaken').AsDateTime));//DateToStr(LastRadioDateDS.FieldByName('DTTaken').AsDateTime);
             finally
               FreeAndNil(LastRadioDateDS);
             end;
           end;

           FReportDataSMatr[Length(FReportDataSMatr)-1][7] := SlideSysInfo.DCMKVP.ToString;
           FReportDataSMatr[Length(FReportDataSMatr)-1][8] := SlideSysInfo.DCMTubeCur.ToString;
           FReportDataSMatr[Length(FReportDataSMatr)-1][9] := SlideSysInfo.DCMExpTime.ToString;

           RadilogicalLogDS.Next;
         end;
       end;

       if Length(FReportDataSMatr) = 0 then
         SetLength(FReportDataSMatr, 1);

       SetLength(FReportDataSMatr[0], 10);

       FReportDataSMatr[0][0] := 'Date';
       FReportDataSMatr[0][1] := 'Patient';
       FReportDataSMatr[0][2] := 'Card Num';
       FReportDataSMatr[0][3] := 'Accession no.';
       FReportDataSMatr[0][4] := 'Provider';
       FReportDataSMatr[0][5] := 'Modality';
       FReportDataSMatr[0][6] := 'Last Radio date';
       FReportDataSMatr[0][7] := 'kV';
       FReportDataSMatr[0][8] := 'mA';
       FReportDataSMatr[0][9] := 'ms';
     finally
       FreeAndNil(RadilogicalLogDS);
     end;
   {$R+}
   end
   else
   begin
     with CurDSet1 do
    begin
      Connection := LANDBConnection;
      ExtDataErrorCode := K_eeDBSelect;
//K_GetFormTextEdit.EditText(SQLText);
      SQL.Text := SQLText;
      Filtered := false;
      Open;
      SetLength( FReportDataSMatr, RecordCount + 1 );

{ // MSSQL error in Fields[12] - wrong value
First;
with TK_DumpObj.Create( 'D:\Delphi_prj_new\DTmp\ErrLogs\DT\DT00020842\ADORes.txt' ) do
begin
  while not EOF do
  begin
    DumpStr0(
            FieldList.Fields[0].AsString + #9 +
            FieldList.Fields[1].AsString + #9 +
            FieldList.Fields[2].AsString + #9 +
            FieldList.Fields[3].AsString + #9 +
            FieldList.Fields[4].AsString + #9 +
            FieldList.Fields[5].AsString + #9 +
            FieldList.Fields[6].AsString + #9 +
            FieldList.Fields[7].AsString + #9 +
            FieldList.Fields[8].AsString + #9 +
            FieldList.Fields[9].AsString + #9 +
            FieldList.Fields[10].AsString + #9 +
            FieldList.Fields[11].AsString + #9 +
            FieldList.Fields[12].AsString + #9 +
            FieldList.Fields[13].AsString );
    Next;
  end;
  Free();
end;
{}

    // Get  Selected Data
      i := High(FReportDataSMatr);
      SL := TStringList.Create;
      SL.Sorted := TRUE;


      ////////////////////////
      // Records Parsing Loop
      if HistActSQL2 <> '' then
        Last;
      while not BOF do
      begin
        IActCode := FieldList.Fields[3].AsInteger;
        // Prepare Skip Resulting Row Flag - because single modify action in  session is needed
        SkipFromResult := not IsSlideSelected                    and
                          ((IActCode and $70000000) > 0)         and // Modify
                          ((IActCode and $70000000) < $40000000) and // Modify
                          (IActCode <> HACreateCode)             and // not Create
                          (IActCode <> HADeleteCode)             and // not Detlete
                          (IActCode <> HACreateIACCode)          and // not Create
                          (IActCode <> HADeleteIACCode);             // not Detlete
        if SkipFromResult then
        begin
          WSTR := format( '%d_%d', [FieldList.Fields[6].AsInteger, FieldList.Fields[13].AsInteger] );
          SkipFromResult := SL.Find( WSTR, Ind );
          if not SkipFromResult then
            SL.Add(WSTR);
        end;




        if not SkipFromResult then
        begin
        // Add to Resulting SMatr
          SetLength( FReportDataSMatr[i], 9 );
          IsDel := FieldList.Fields[7].IsNull;
          WDT := TDateTimeField(FieldList.Fields[0]).Value;

          //***** Date
          FReportDataSMatr[i][0] := K_DateTimeToStr( WDT, 'dd.mm.yyyy' );

          //***** Time
          FReportDataSMatr[i][1] := K_DateTimeToStr( WDT, 'hh:nn:ss AM/PM' );

          //***** Patient
          if FieldList.Fields[10].IsNull then
          begin
            if FieldList.Fields[1].IsNull then
              FReportDataSMatr[i][2] := ''
            else
              FReportDataSMatr[i][2] := K_CMGetPatientDetails( FieldList.Fields[1].AsInteger )
          end
          else
            FReportDataSMatr[i][2] := EDAGetStringFieldValue(FieldList.Fields[10]);

          //***** Card Num
          if FieldList.Fields[9].IsNull then
          begin
            if FieldList.Fields[1].IsNull then
              FReportDataSMatr[i][3] := ''
            else
              FReportDataSMatr[i][3] := 'ID='+ FieldList.Fields[1].AsString;
          end
          else
            FReportDataSMatr[i][3] := EDAGetStringFieldValue(FieldList.Fields[9]);

         //***** User
          if FieldList.Fields[8].IsNull then
            FReportDataSMatr[i][4] := K_CMGetProviderDetails( FieldList.Fields[2].AsInteger )
          else
            FReportDataSMatr[i][4] := EDAGetStringFieldValue(FieldList.Fields[8]);

         //***** Action
          SExpFExt := '';
          IsMedia := IsDel; // to Skip format
          if not IsDel then
          begin
            SysInfo := EDAGetStringFieldValue(FieldList.Fields[7]);
            IsMedia := Pos( 'cmsfIsMediaObj', SysInfo ) > 0;
            if IsMedia then
            begin
              Ind := Pos( 'MediaFExt=', SysInfo );
              SExpFExt := Trim( copy( SysInfo, Ind + 11, 4 ) );
            end;
          end;

         // Object ID
          Ind := FieldList.Fields[6].AsInteger;
          if Ind > 0 then
            FReportDataSMatr[i][8] := FieldList.Fields[6].AsString
          else
            FReportDataSMatr[i][8] := '';

          //***** Source Description
{ experiments with SrcDescr in MSSQL
          SSrcDescr := '';
          if (Ind > 0) and ((IActCode = HACreateCode) or (IActCode = HACreateIACCod))then
          with CurDSet2 do
          begin
            Filter := K_CMENDBSTFSlideID+ '=' + IntToStr(Ind);
            Filtered := TRUE;
            SSrcDescr := EDAGetStringFieldValue(FieldList.Fields[1]);
            Filtered := FALSE;
          end;
{}
          SSrcDescr := EDAGetStringFieldValue(FieldList.Fields[12]);
          if SSrcDescr = '' then
            SSrcDescr := 'object is deleted forever now';
          FReportDataSMatr[i][5] := EDAGetHistActionText( IActCode,
                                          FALSE, not IsMedia or not IsDel,
                                          SExpFExt, SSrcDescr );
         //***** PC name
          if FieldList.Fields[4].IsNull then
            FReportDataSMatr[i][6] := ''
          else
            FReportDataSMatr[i][6] := EDAGetStringFieldValue(FieldList.Fields[4]);

          // Store Computers where Slide were processed
          if IsSlideSelected                 and
            (IActCode <> HACMSStartCode)     and
            (IActCode <> HACMSCloseCode)     and
            (IActCode <> HASessionStartCode) and
            (IActCode <> HASessionFinCode)   and
            not SL.Find( FReportDataSMatr[i][6], Ind ) then
              SL.Add(FReportDataSMatr[i][6]);

         //***** Location
          if FieldList.Fields[11].IsNull then
          begin
            if FieldList.Fields[5].IsNull then
              FReportDataSMatr[i][7] := ''
            else
              FReportDataSMatr[i][7] := K_CMGetLocationDetails( FieldList.Fields[5].AsInteger );
          end
          else
            FReportDataSMatr[i][7] := EDAGetStringFieldValue(FieldList.Fields[11]);

          Dec(i);
        end; // if not SkipFromResult then
        Prior;

{
0      'S.ActTS as RActTS,' +
1      'S.PatID as RPatID,' +
2      'S.ProvID as RProvID,' +
3      'S.ActCode as RActCode,' +
4      '(select ' + K_CMENDBGAInstsTFCName + ' from ' + K_CMENDBGAInstsTable +
      ' where ' + K_CMENDBGAInstsTFGlobID + '=S.CompID) as RCompName,' +
5      'S.LocID as RLocID,' +
6      'S.SlideID as RSlideID,' +
7      'Q.SysInfo as RSysInfo,' +
8       '(select ' + K_CMENDAHProvCapt + ' from ' + K_CMENDBAllHistProvidersTable +
      ' where ' + K_CMENDAHProvID + '=RProvID) as RUserCapt,' +
9       '(select ' + K_CMENDAHPatCN + ' from ' + K_CMENDBAllHistPatientsTable +
      ' where ' + K_CMENDAHPatID + '=RPatID) as RPatCN,' +
10       '(select ' + K_CMENDAHPatCapt + ' from ' + K_CMENDBAllHistPatientsTable +
      ' where ' + K_CMENDAHPatID + '=RPatID) as RPatCapt,' +
11       '(select ' + K_CMENDAHLocCapt + ' from ' + K_CMENDBAllHistLocationsTable +
      ' where ' + K_CMENDAHLocID + '=RLocID) as RLocCapt';
12 Q.SrcDescr
13 S.SessionID
}
      end; // while not BOF do
      // End of Records Parsing Loop
      ////////////////////////////
      Close;
{ experiments with SrcDescr in MSSQL
      CurDSet2.Close;
{}

//if not N_KeyIsDown(VK_CONTROL) then

      if IsSlideSelected  then
      begin // One Slide Report
      // Remove  unnecessary Start/Fin Lines

        // Remove Lines for Sessions without Slide actions from Beg to End

        SetLength(RMarks, Length(FReportDataSMatr));
        if SL.Count > 0 then
        begin
          SetLength( CCCArr, SL.Count );
          for Ind := 1 to High(FReportDataSMatr) do
          begin
            if not SL.Find( FReportDataSMatr[Ind][6], CCInd ) then Continue;
            WStr := FReportDataSMatr[Ind][5];
            if WStr = K_CMSHistNCActTexts[Ord(K_shNCACMSClose)] then
            begin
              if (CCCArr[CCInd].Count = 0) or //
                 (FReportDataSMatr[CCCArr[CCInd].IndM1][5] = K_CMSHistNCActTexts[Ord(K_shNCACMSClose)]) then
               Continue; // Skip all start CMS Close and all Skip CMS Close just after CMS Close
              if FReportDataSMatr[CCCArr[CCInd].IndM1][5] = K_CMSHistNCActTexts[Ord(K_shNCACMSStart)] then
              begin
              // Remove Prev CMS Close
                RemovePrevRLine(1);
                Continue;
              end;
            end
            else if WStr = K_CMSHistNCActTexts[Ord(K_shNCAFinishSession)] then
            begin
              if (CCCArr[CCInd].Count = 0) or
                 (FReportDataSMatr[CCCArr[CCInd].IndM1][5] = K_CMSHistNCActTexts[Ord(K_shNCAFinishSession)]) then
                Continue; // Skip all start CMS Fin Session and all CMS Session after CMS Session
              if FReportDataSMatr[CCCArr[CCInd].IndM1][5] = K_CMSHistNCActTexts[Ord(K_shNCAStartSession)]  then
              begin
              // Remove Prev Session Fin
                RemovePrevRLine(1);
                Continue;
              end;
            end
            else if WStr = K_CMSHistNCActTexts[Ord(K_shNCAStartSession)] then
            begin
              if (CCCArr[CCInd].Count > 0) and (FReportDataSMatr[CCCArr[CCInd].IndM1][5] = K_CMSHistNCActTexts[Ord(K_shNCAStartSession)]) then
              begin
              // Replace Prev Session start
                RemovePrevRLine(1);
//??                Continue;
              end;
            end
            else if WStr = K_CMSHistNCActTexts[Ord(K_shNCACMSStart)] then
            begin
              if (CCCArr[CCInd].Count > 0) and (FReportDataSMatr[CCCArr[CCInd].IndM1][5] = K_CMSHistNCActTexts[Ord(K_shNCAStartSession)]) then
              begin
                if(CCCArr[CCInd].Count > 1) and (FReportDataSMatr[CCCArr[CCInd].IndM2][5] = K_CMSHistNCActTexts[Ord(K_shNCACMSStart)]) then
                begin // Replace Prev Session start and PrevPrev CMS Start
                  RemovePrevRLine(2);
                end
                else
                begin // Replace Prev Session start
                  RemovePrevRLine(1);
                end;
              end;
            end;
            RMarks[Ind] := TRUE;
            CCCArr[CCInd].IndM4 := CCCArr[CCInd].IndM3;
            CCCArr[CCInd].IndM3 := CCCArr[CCInd].IndM2;
            CCCArr[CCInd].IndM2 := CCCArr[CCInd].IndM1;
            CCCArr[CCInd].IndM1 := Ind;
            Inc(CCCArr[CCInd].Count);
          end;
        end;
        // Remove not needed Lines
        i := 1;
        for Ind := 1 to High(FReportDataSMatr) do
        begin
          if not RMarks[Ind] then Continue;
          FReportDataSMatr[i] := FReportDataSMatr[Ind];
          Inc(i);
        end;
        SetLength( FReportDataSMatr, i );

        // Clear Last CMS Start
        if (i > 1) and not (K_srfSASaveResCurSession in HRFlags) then
        begin
          if FReportDataSMatr[i-1][5] = K_CMSHistNCActTexts[Ord(K_shNCAStartSession)] then
            Dec(i); // Skip Last Session Start
          if (i > 1) and (FReportDataSMatr[i-1][5] = K_CMSHistNCActTexts[Ord(K_shNCACMSStart)]) then
            Dec(i); // Skip Last CMS Start
          SetLength( FReportDataSMatr, i );
        end;

      end // if IsSlideSelected  then
      else
      if i > 0 then
      begin // Get SMatr Used Lines for not One Slide Report
        FReportDataSMatr := Copy( FReportDataSMatr, i, Length(FReportDataSMatr) - i );
      end;

      SetLength( FReportDataSMatr[0], 9 );

      FReportDataSMatr[0][0] := K_CML1Form.LLLReportHeaderTexts.Items[0]; //'Date';
      FReportDataSMatr[0][1] := K_CML1Form.LLLReportHeaderTexts.Items[1]; //'Time';
      FReportDataSMatr[0][2] := K_CML1Form.LLLReportHeaderTexts.Items[2]; //'Patient';
      FReportDataSMatr[0][3] := K_CML1Form.LLLReportHeaderTexts.Items[3]; //'Card Num';
      FReportDataSMatr[0][4] := K_CML1Form.LLLReportHeaderTexts.Items[4]; //'User';
      FReportDataSMatr[0][5] := K_CML1Form.LLLReportHeaderTexts.Items[5]; //'Action';
      FReportDataSMatr[0][6] := K_CML1Form.LLLReportHeaderTexts.Items[6]; //'PC name';
      FReportDataSMatr[0][7] := K_CML1Form.LLLReportHeaderTexts.Items[7]; //'Location';
      FReportDataSMatr[0][8] := K_CML1Form.LLLReportHeaderTexts.Items[8]; //'Object ID';

      SL.Free;
    end;
   end;
  end;

  Screen.Cursor := SavedCursor;
  AReportDataSMatr := FReportDataSMatr;
end; // K_CMHistReportCreate

//********************************************* K_CMCreateUDDIBBySData ***
// Create Image TN_UDDIB by Serialized Data
//
//     Parameters
// AMemPtr  - pointer to buffer with Image Serialized data
// ADSize   - Image Serialized data size in bytes
// AFreeBufProc - free buffer memory proocedure
//
function K_CMCreateUDDIBBySData( AMemPtr: Pointer;
               ADSize: Integer; AFreeBufProc: TK_FreeBuffer = nil): TN_UDDIB;
const
  SPLTypeInfoShift = 83;
  UDDIBDataShift       = 230;
  CDIBFlagsNShift      = 235;
  CDIBFNameNShift      = 239;
  CDIBDataFormatShift  = 24; // CDIBFNameNShift + 24 + FieldSize(CDIBFNameN) + FieldSize(CDIBInfo)
  CDIBJPEGQualityShift = 25; // CDIBFNameNShift + 25 + FieldSize(CDIBFNameN) + FieldSize(CDIBInfo)
  UDDataShift = 34; // CDIBFNameNShift + 34 + FieldSize(CDIBFNameN) + FieldSize(CDIBInfo)
  SPLTypeInfo : AnsiString = '@:\SPL\N_Comps\TN_RDIBN';

var
  PAC1 : PAnsiChar;
  PUDData : Pointer;
  PCDIBN : TN_PCDIBN;
  UDDataSize : Integer;
  DataShift : Integer;
  GetChildTree: boolean;
  DE: TN_DirEntryPar;

label LExit;

  procedure CreateUDDIB ();
  begin
    Result := N_CreateUDDIB( FRect(100,100), [], '', 'CurImg' );
  end;

begin
//*** Try CMS DIB File format
  if CompareMem( @K_CMDIBFileSignatue[1], TN_BytesPtr(AMemPtr), Length(K_CMDIBFileSignatue) ) and
     (TK_PCMDIBFileHeader1(AMemPtr).DIBFFormatID >= 1) and
     (TK_PCMDIBFileHeader1(AMemPtr).DIBFDataSize + SizeOf(TK_CMDIBFileHeader1) = ADSize)then
  begin
    with TK_PCMDIBFileHeader1(AMemPtr)^ do
    begin
    //CMS DIB File format
      CreateUDDIB();
      with Result, PISP()^ do
      begin
        CDIBFlagsN      := DIBFFlagsN;
        CDIBDataFormat  := DIBFDataFormat;
        CDIBJPEGQuality := DIBFJPEGQuality;
        PUDData := TN_BytesPtr(AMemPtr) + SizeOf(TK_CMDIBFileHeader1);
        // This code is analog of TN_UDDIB.GetFieldsFromSBuf
        if uddfnUseUDData in CDIBFlagsN then // load from UDData field (DIBObj content in external format)
        begin
          SetLength( UDData, DIBFDataSize );
          Move( PUDData^, UDData[0], DIBFDataSize );
          if uddfnAutoCreateDIB in CDIBFlagsN then LoadDIBObj();
        end // if uddfnUseUDData in CDIBFlagsN
        else
        begin // load DIBObj field from internal DIBObj format
          if DIBFDataSize > 0 then
          begin
            DIBObj := TN_DIBObj.Create();
            DIBObj.DeSerializeSelf( PUDData );
          end; // if DIBDataSize > 0 then
        end; // load DIBObj from internal DIBObj format
      end; // with Result, PISP()^ do
    end; // with TK_PCMDIBFileHeader1(AMemPtr)^ do
  end // if not OldFormatFlag then
  else
  begin
//*** Try to Extract DIB Info from Serialized TN_UDDIB
    PAC1 := PAnsiChar(TN_BytesPtr(AMemPtr) + SPLTypeInfoShift);
    if (PByte(PAC1)^ = Length(SPLTypeInfo)) and
       CompareMem( @SPLTypeInfo[1], PAC1 + 1, Length(SPLTypeInfo) ) then
    begin
    // Extract DIB Info from Serialized TN_UDDIB
      Result := N_CreateUDDIB( FRect(100,100), [], '', 'CurImg' );
      PCDIBN := Result.PISP();
      with Result, PCDIBN^ do
      begin
        CDIBFlagsN      := TN_UDDIBFlagsN(PWord(TN_BytesPtr(AMemPtr) + CDIBFlagsNShift)^);
        DataShift := CDIBFNameNShift;
        // Add CDIBFNameN Size
        DataShift := DataShift + PByte(TN_BytesPtr(AMemPtr) + DataShift)^ + 1;
        // Add CDIBInfo Size
        DataShift := DataShift + PByte(TN_BytesPtr(AMemPtr) + DataShift)^ + 1;

        CDIBDataFormat  := TN_UDDIBDataFormat(PByte(TN_BytesPtr(AMemPtr) + DataShift + CDIBDataFormatShift)^);
        CDIBJPEGQuality := PInteger(TN_BytesPtr(AMemPtr) + DataShift + CDIBJPEGQualityShift)^;

        PUDData := TN_BytesPtr(AMemPtr) + DataShift + UDDataShift;
        UDDataSize := PInteger(PUDData)^;
        PUDData := TN_BytesPtr(PUDData) + SizeOf(Integer);

        // This code is analog of TN_UDDIB.GetFieldsFromSBuf
        if uddfnUseUDData in CDIBFlagsN then // load from UDData field (DIBObj content in external format)
        begin
          SetLength( UDData, UDDataSize );
          move( PUDData^, UDData[0], UDDataSize );
          if uddfnAutoCreateDIB in CDIBFlagsN then LoadDIBObj();
        end else // load DIBObj field from internal DIBObj format
        begin
          if UDDataSize > 0 then
          begin
            DIBObj := TN_DIBObj.Create();
            try
              DIBObj.DeSerializeSelf( PUDData );
            except
              FreeAndNil(Result);
            end;
          end; // if UDDataSize > 0 then
        end;
      end;
    end
    else
    begin
//*** Ordinary deserialization
      N_SerialBuf.LoadFromMem(AMemPtr^, ADSize);
      // N_SerialBuf.SBGetWideString
      Include( K_UDGControlFlags, K_gcfSkipErrMessages);
      Result := TN_UDDIB(K_LoadTreeFromMem(N_SerialBuf));

      if Result = nil then
      begin
      // Try to Parse w/o Types Control For Old Format
        // Insert Space for TN_CompCoords.CCRotateAngle new field
        N_SerialBuf.SetCapacity( ADSize + 4 );
        N_SerialBuf.OfsFree := N_SerialBuf.OfsFree + 4;
        // 230 is shift to CCRotateAngle in new TN_CompCoords
        Move( N_SerialBuf.Buf1[UDDIBDataShift],
              N_SerialBuf.Buf1[UDDIBDataShift + 4], ADSize - UDDIBDataShift );
        try
          K_GetDEFromSBuf( N_SerialBuf, DE, GetChildTree );
          Result := TN_UDDIB( DE.Child );
        except
        end;
      end;
      N_SerialBuf.Init0();
      Exclude( K_UDGControlFlags, K_gcfSkipErrMessages);

    end;
  end;

LExit:
  if Assigned(AFreeBufProc) then
    AFreeBufProc(AMemPtr);
end; // function K_CMCreateUDDIBBySData

//********************************************* K_CMGetUDDIBSData ***
// Get Image TN_UDDIB Serialized Data
//
//     Parameters
// AFormatID - Seriailise Format
// AUDDIB   - Image TN_UDDIB object
// AMemPtr  - pointer to buffer with Image Serialized data
// ADSize   - Image Serialized data size in bytes
//
//  Was created in 2.795
//
procedure K_CMGetUDDIBSData( AUDDIB : TN_UDDIB; out AMemPtr: Pointer;
                             out ADSize: Integer );
var
  DSize, DataShift : Integer;

  procedure PrepareBufMem();
  begin
    ADSize := DSize + DataShift;
//    with TK_CMEDDBAccess(K_CMEDAccess) do
    with K_CMEDAccess do
    begin
      if Length(BlobBuf) < ADSize then
      begin
        BlobBuf := nil;
        SetLength(BlobBuf, ADSize + ADSize div 4);
      end;
      AMemPtr := @BlobBuf[0];
    end;
  end;


  procedure PrepareSData( );
  begin
//    with TK_CMEDDBAccess(K_CMEDAccess), AUDDIB, PISP()^ do
    with K_CMEDAccess, AUDDIB, PISP()^ do
    begin
      DSize := 0;
      if uddfnUseUDData in CDIBFlagsN then // save UDData field (DIBObj content in external format)
      begin
        if Length(UDData) = 0 then // ctreate UDData from DIBObj, otherwise it should be already OK
        begin
          if DIBObj <> nil then
            CreateUDDataFromDIBObj()
          else
            Assert( False, 'TN_UDDIB.AddFieldsToSBuf: DIBObj is absent!' );
        end; // if Length(UDData) = 0 then // ctrate UDData from DIBObj

        if (uddfnUseFile in CDIBFlagsN) and
           (uddfnAutoSaveToFile in CDIBFlagsN) then // save UDData to CDIBFName File
        begin
          Assert( False, 'TN_UDDIB.AddFieldsToSBuf: not implemented1!' );
          PrepareBufMem();
          Exit;
        end;

        DSize := Length(UDData);
        PrepareBufMem();
        Move( UDData[0], (TN_BytesPtr(AMemPtr) + DataShift)^, DSize );
        if (uddfnFreeUDData in CDIBFlagsN) and
           (DIBObj <> nil) then UDData := nil; // to free memory after saving
      end    // if uddfnUseUDData in CDIBFlagsN then
      else
      begin  // save DIBObj field in internal DIBObj format (not use UDData)
        if (uddfnUseFile in CDIBFlagsN) and
           (uddfnAutoSaveToFile in CDIBFlagsN) then // save DIBObj to CDIBFName File
        begin
          if DIBObj = nil then Exit; // a precaution

          Assert( False, 'TN_UDDIB.AddFieldsToSBuf: not implemented2!' );
          PrepareBufMem();
          Exit;
        end;

        if DIBObj = nil then
        begin
          PrepareBufMem();
          Exit; // all done for empty DIBObj
        end;

        DSize := DIBObj.SerializedSize();
        PrepareBufMem();
        DIBObj.SerializeSelf( TN_BytesPtr(AMemPtr) + DataShift, DSize );
      end; // save DIBObj field in internal DIBObj format (not use UDData)
    end; // with SBuf, PISP()^ do
  end;

begin
  case K_CMDIBFileFormatID of
  0: // Standart serialization
  begin
    if AUDDIB.UDData <> nil then
      DSize := Length(AUDDIB.UDData)
    else
      DSize := AUDDIB.DIBObj.SerializedSize();
    N_SerialBuf.SetCapacity( DSize + 1000 );
    K_SaveTreeToMem( AUDDIB, N_SerialBuf );
    ADSize := N_SerialBuf.OfsFree;
    AMemPtr := @N_SerialBuf.Buf1[0];
  end; // 0: // Standart serialization
  1: // New DIB File Format
  begin
    DataShift := SizeOf( TK_CMDIBFileHeader1 );
    PrepareSData( );
//    with TK_CMEDDBAccess(K_CMEDAccess) do
    with K_CMEDAccess do
    begin
      with TK_PCMDIBFileHeader1(AMemPtr)^, AUDDIB, PISP()^  do
      begin
        Move( K_CMDIBFileSignatue[1], DIBFSignature, Length(K_CMDIBFileSignatue) );
        DIBFFormatID   := K_CMDIBFileFormatID;
        DIBFFlagsN      := CDIBFlagsN;
        DIBFDataFormat  := CDIBDataFormat;
        DIBFJPEGQuality := CDIBJPEGQuality;
        DIBFDataSize    := DSize;
      end;
    end;
  end; // 1: // New DIB File Format
  end;
end; // function K_CMGetUDDIBSData

//***************************************** K_CMBuildTwainDevicesList ***
// Build TWAIN devices list
//
//     Parameters
// ADevList - TStrings for TWAIN device
//
function K_CMBuildTwainDevicesList( ADevList : TStrings ) : Boolean;
var
  TWGlobObj : TK_TWGlobObj;
  CurHWND : HWnd;
begin
  //***  Init Possible TWAIN List

  if K_TWGlobObj <> nil then
    TWGlobObj := K_TWGlobObj
  else
    TWGlobObj := TK_TWGlobObj.Create();

  with TWGlobObj do
  begin
    TWGRetCode := 0;
    if not TWGlobObj.TWGDSMOpened then
    begin
      CurHWND := TWGlobObj.TWGWinHandle;
      if CurHWND = 0 then
        CurHWND := Application.Handle;
      TWGOpenDSManager( @CurHWND );
    end;

    if TWGRetCode <> 0 then
      K_CMShowMessageDlg( //sysout
                         'TWAIN error is detected: '#13#10 +
                         '"' + TWGErrorStr  + '".', mtWarning )
    else
    begin
      TWGGetDataSources( ADevList );
      if TWGRetCode <> 0 then
          K_CMShowMessageDlg( //sysout
                              'TWAIN device error is  detected: '#13#10 +
                              '"' + TWGErrorStr  + '"'#13#10 +
                              'You should uninstall the device driver. Press OK to continue', mtWarning );
    end;
    Result := TWGRetCode = 0;
    if TWGlobObj <> K_TWGlobObj then
      TWGlobObj.Free;
  end; // with TK_TWGlobObj.Create() do
end; // end of K_CMBuildTwainDevicesList

//****************************************** K_CMDeviceProfileAutoTWAINMode ***
// Set device profile TWAIN mode
//
//     Parameters
// ACMDPTWAINMode   - TWAIN mode string
// ACMDPProductName - TWAIN product name
//
procedure K_CMDeviceProfileAutoTWAINMode( var ACMDPTWAINMode : string;
                                          const ACMDPProductName : string );
begin
  if ACMDPTWAINMode = '' then
  begin
    ACMDPTWAINMode := '1';   // Not Cannon Device
    if 0 <> Pos( 'CANO', UpperCase(ACMDPProductName) ) then
      ACMDPTWAINMode := '2'; // Cannon Device
  end;
end; // procedure K_CMDeviceProfileAutoTWAINMode

//***************************************** K_CMRecoverDeviceProfile ***
// Recover device profile Product Name
//
//     Parameters
// AutoRecoverFlag - TStrings for TWAIN device
// AUDProfiles - Device Profiles List UDRArray
// AUDProfileInd - Device Profiles List Index
// APDeviceProfileBuf - Device Profile Edit Buffer
// AEdFormClass - Device Profile Editor Form Class
//
procedure K_CMRecoverDeviceProfile( AutoRecoverFlag : Boolean;
         AUDProfiles : TK_UDRArray; AUDProfileInd : Integer;
         APDeviceProfileBuf : Pointer; AEdFormClass: TN_BaseFormClass );
var
  SavedCursor : TCursor;
  PCMDeviceProfile : TK_PCMDeviceProfile;
begin

  SavedCursor := Screen.Cursor;

  PCMDeviceProfile := AUDProfiles.PDE(AUDProfileInd);

  N_Dump1Str( 'Profile "' + PCMDeviceProfile.CMDPCaption +  '" recovery is needed' );
  if not AutoRecoverFlag then
  begin
    with TK_FormCMProfileTwain(AEdFormClass.Create( Application )) do // Create Editor Form of needed type
    begin
//      BaseFormInit( nil, '', [fvfCenter] );
      BaseFormInit( nil, '', [rspfMFRect,rspfCenter], [rspfAppWAR,rspfShiftAll] );
      PEPCMDeviceProfile := TK_PCMDeviceProfile(APDeviceProfileBuf);
      PEUDProfiles := AUDProfiles;
      PEProfileInd := AUDProfileInd;

      if ShowModal() <> mrOK then Exit; // Show Editor Form (new Profile (if needed) wil be created in it
      N_Dump1Str( 'Profile "' + PCMDeviceProfile.CMDPCaption +  '" manual recovery is done' )
    end; // with TK_FormCMProfileTwain(CurFormClass.Create(Application)) do

    Screen.Cursor := crHourGlass;

//    N_CM_MainForm.CMMCurFMainForm.Refresh();

    N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aServUpdateUIByDeviceProfiles, FALSE );
//    N_CM_MainForm.CMMUpdateUIByDeviceProfiles();
  end
  else
  begin
    with PCMDeviceProfile^ do
      CMDPProductName := CMDPCaption;
      N_Dump1Str( 'Profile "' + PCMDeviceProfile.CMDPCaption +  '" auto recovery is done' )
  end;

// Save Profile Data
//  K_SetChangeSubTreeFlags( AUDProfiles );
//  K_SetArchiveChangeFlag();

  with K_CMEDAccess do
//    if StateSaveMode = K_cmetImmediately then
      EDASaveContextsData( [K_cmssSkipSlides] ); // Save Contexts

  Screen.Cursor := SavedCursor;

end; // end of K_CMRecoverDeviceProfile


//***************************************************** K_CMSetMLineInterimTextsDisplayMode ***
// Set given PolyLine Interim Texts Display Mode
//
//     Parameters
// AUDMLineRoot - measure PolyLine Root Component to rebuild
// ADisplayMode  - if =TRUE then interim texts should be displayed
//
procedure K_CMSetMLineInterimTextsDisplayMode( AUDMLineRoot: TN_UDBase;
                                               ADisplayMode: Boolean );
var
  j, K: Integer;
  SkipSelf : Byte;
begin
  K := AUDMLineRoot.DirHigh() - 1;
  SkipSelf := 255;
  if ADisplayMode then
    SkipSelf := 0;
  for j := 2 to K do
    TN_UDCompVis(AUDMLineRoot.DirChild(j)).PSP.CCompBase.CBSkipSelf := SkipSelf;
  TN_UDCompVis(AUDMLineRoot.DirChild(K+1)).PSP.CCompBase.CBSkipSelf := 0;
end; // end of K_CMSetMLineInterimTextsDisplayMode

//************************************* K_CMGetMLineInterimTextsDisplayMode ***
// Get given PolyLine Interim Texts Display Mode
//
//     Parameters
// AUDMLineRoot - measure PolyLine Root Component to rebuild
// Result - Returns
//#F
//   -2 - annotation is not measure line,
//   -1 - one segment line,
//    0 - line has more then one segment and Display Mode is FALSE,
//    1 - line has more then one segment and Display Mode is TRUE
//#/F
//
function  K_CMGetMLineInterimTextsDisplayMode( AUDMLineRoot: TN_UDBase ) : Integer;
begin
  Result := -2;
  if AUDMLineRoot.ObjName[1] <> 'M' then Exit;
  if AUDMLineRoot.DirHigh() = 2 then
    Result := -1
  else if TN_UDCompVis(AUDMLineRoot.DirChild(2)).PSP.CCompBase.CBSkipSelf = 0 then
    Result := 1
  else
    Result := 0;
end; // end of K_CMGetMLineInterimTextsDisplayMode

{
//************************************************* K_CMSInitRegSettingInfo ***
// Initialized Regional Settings Info container form
//
procedure K_CMSInitRegSettingInfo(  );
var
  RegTextFragms : TN_MemTextFragms;
  FileName : string;
  Ind : Integer;
begin
  N_CMRegSettingsForm := TN_CMRegSettingsForm.Create( Application);

  FileName := K_FindFirstFileNameByPattern( ExtractFilePath( Application.ExeName ) + 'CMSuiteREG_*.*' );
  N_CM_RegSavedLog := 'Default Australien, no regions file';

  if FileName <> '' then // RegionalSettings File exists
  begin
    RegTextFragms  := TN_MemTextFragms.CreateFromVFile( FileName );

    if RegTextFragms.MTFragmsList.Count > 0 then // precaution
    begin
      with RegTextFragms.MTFragmsList do
      begin
        Ind := IndexOf( 'RegionalSettings' );
        if Ind >= 0 then // Find by name - is not compulsory
          K_SetFFCompCurLangTexts0( TStrings(Objects[Ind]), N_CMRegSettingsForm );

        Ind := IndexOf( 'FileInfo' );
        if Ind >= 0 then
          N_CM_RegSavedLog := TStrings(Objects[Ind]).Values['FileInfo'];
      end; // with RegTextFragms.MTFragmsList do
    end; // if RegTextFragms.MTFragmsList.Count > 0 then // precaution

    RegTextFragms.Free();
  end; // if FileName <> '' then // RegionalSettings File exists
end; // procedure K_CMSInitRegSettingInfo
}

//******************************************** K_CMSFileSelfCheckErrMessage ***
// Get given PolyLine Interim Texts Display Mode
//
//     Parameters
// AErrFName - error file name
// AErMode   - error mode first 4 bits:
//#F
//   0 - file is missing or corrupted,
//   1 - file is missing,
//   2 - file is corrupted or outdated,
//#/F
//   error mode next 4 bits:
//#F
//   0 - application will start with limited functionality,
//   1 - application cannot start,
//#/F
//
procedure K_CMSFileSelfCheckErrMessageDlg( const AErrFName : string; AErrMode : Integer ); // local
var
  ErrMessage1 : string;
  ErrMessage2 : string;
//  ErrMessage3 : string;
  ErrMode : Integer;
begin
{}
  ErrMode := AErrMode and $F;
  if ErrMode = 0  then
    ErrMessage1 := 'missing or corrupted'
  else
  if ErrMode = K_CheckFilesCRCNotFound then
    ErrMessage1 := 'missing'
  else
    ErrMessage1 := 'corrupted or out of date';

  ErrMode := (AErrMode shr 4) and $F;
  if ErrMode = 0  then
    ErrMessage2 := 'will start with limited functionality'
  else
    ErrMessage2 := 'cannot start';

  K_CMShowMessageDlg( // specout
    format( 'The Media Suite component "%s" is %s. The software %s.' + //#13#10+
            'Please contact %s on %s or email to %s',
            [AErrFName, ErrMessage1,ErrMessage2,
             N_MemIniToString( 'RegionTexts', 'CompanyDistrName', 'Centaur Software Development Company' ),
             N_MemIniToString( 'RegionTexts', 'Phone', '+61-2-9213-5000' ),
             N_MemIniToString( 'RegionTexts', 'Email', 'techsupport@centaursoftware.com' )] ),
            mtError );
{}
end; // procedure K_CMSFileSelfCheckErrMessageDlg

//******************************************** K_CMSVObjArrowTipLineRebuild ***
// Rebuild Arrow VObject Tip Line
//
//     Parameters
// ALineComp - Arrow Main Line TN_UDPolyline Component
// ATipLength - Arrow Tip Length
//
procedure K_CMSVObjArrowTipLineRebuild( ALineComp : TN_UDPolyline; ATipLength : Double );
var
  PLFPoint1, PLFPoint2 : PFPoint;
  LFPoint1, LFPoint2 : TFPoint;
  LineAngle : double;
  DSin, DCos : Extended;

  function CalcTipVertex( Angle : Double ) : TFPoint;
  begin
    SinCos( N_PI * (Angle) / 180, DSin, DCos );
    LFPoint1.X := LFPoint2.X + ATipLength * DCos; //
    LFPoint1.Y := LFPoint2.Y - ATipLength * DSin;
    Result := N_AffConvF2FPoint( LFPoint1, ALineComp.CompP2U );
  end;

begin

  with ALineComp, PSP.CPolyline.CPCoords do
  begin
    PLFPoint1 := PFPoint(P(0));
    PLFPoint2 := PFPoint(P(1));
    with TN_UDPolyline(Owner.DirChild(1)).PSP.CPolyline.CPCoords do
    begin
      LFPoint1 := N_AffConvF2FPoint( PLFPoint1^, CompU2P );
      LFPoint2 := N_AffConvF2FPoint( PLFPoint2^, CompU2P );
      LineAngle := N_SegmAngle( LFPoint2, LFPoint1 ); // Calc Arrow Pix Angle

      PFPoint(P(1))^ := PLFPoint2^;
      PFPoint(P(0))^ := CalcTipVertex( LineAngle + K_CMArrowLineTipAngle );
      PFPoint(P(2))^ := CalcTipVertex( LineAngle - K_CMArrowLineTipAngle );
    end;
  end;
end; // procedure K_CMSVObjArrowTipLineRebuild

//********************************************* K_CMSVObjRectRebuildByPoint ***
// Rebuild Arrow VObject Tip Line
//
//     Parameters
// ALineComp - Arrow Main Line TN_UDPolyline Component
// APFPoint - Ponter to New Recatngle Point Position
// APointInd - Index of Rectangle Point
//
procedure K_CMSVObjRectRebuildByPoint( ALineComp : TN_UDPolyline; APFPoint : PFPoint; APointInd : Integer );
var
  NP : TFPoint;
begin
  with ALineComp, PISP()^.CPCoords do
  begin
    NP := APFPoint^;

//    APFPoint := PFPoint(P(0)); // is needed for debug only 
    case APointInd of
    0 : begin
      PFPoint(P(4))^ := NP;
      PFPoint(P(1)).Y := NP.Y;
      PFPoint(P(3)).X := NP.X;
    end;
    1 : begin
      PFPoint(P(0)).Y := NP.Y;
      PFPoint(P(4)).Y := NP.Y;
      PFPoint(P(2)).X := NP.X;
    end;
    2 : begin
      PFPoint(P(3)).Y := NP.Y;
      PFPoint(P(1)).X := NP.X;
    end;
    3 : begin
      PFPoint(P(0)).X := NP.X;
      PFPoint(P(4)).X := NP.X;
      PFPoint(P(2)).Y := NP.Y;
    end;
    4 : begin
      PFPoint(P(0))^ := NP;
      PFPoint(P(1)).Y := NP.Y;
      PFPoint(P(3)).X := NP.X;
    end;
    end;
  end;
end; // procedure K_CMSVObjRectRebuildByPoint

//**************************************** K_CMSVObjRectReorderLineVertexes ***
// Reorder Rectangle  Line Vertexes
//
//     Parameters
// ALineComp - Rectangle Line Component
//
procedure K_CMSVObjRectReorderLineVertexes( ALineComp : TN_UDPolyline );
var
  P0, P1, P2 : PFPoint;
  XMin, XMax, YMin, YMax : Float;
begin
  with ALineComp, PISP()^.CPCoords do
  begin
    P0 := PFPoint(P(0));
    P1 := PFPoint(P(1));
    P2 := PFPoint(P(2));
    XMin := Min( Min( P0.X, P1.X ), P2.X );
    XMax := Max( Max( P0.X, P1.X ), P2.X );
    YMin := Min( Min( P0.Y, P1.Y ), P2.Y );
    YMax := Max( Max( P0.Y, P1.Y ), P2.Y );
    P0^ := FPoint(XMin, YMin);
    P1^ := FPoint(XMax, YMin);
    P2^ := FPoint(XMax, YMax);
    PFPoint(P(3))^ := FPoint(XMin, YMax);
    PFPoint(P(4))^ := P0^;
  end;
end; // procedure K_CMSVObjRectReorderLineVertexes

//************************************** K_CMSVObjEllipseRebuildByOuterRect ***
// Rebuild Ellipse Line Coordinates by Outer Rectangle Line
//
//     Parameters
// AEllipsLine - Ellipse Line TN_UDPolyline Component
// ARectLine - Rectangle Line TN_UDPolyline Component
//
procedure K_CMSVObjEllipseRebuildByOuterRect( AEllipsLine, ARectLineComp : TN_UDPolyline );
var
  LFPoint1, LFPoint2, CPoint : TFPoint;
  DSin, DCos : Extended;
  RX, RY : Double;
  i : Integer;
begin

  with ARectLineComp.PSP.CPolyline.CPCoords do
  begin
    LFPoint1 := PFPoint(P(0))^;
    LFPoint2 := PFPoint(P(2))^;
    CPoint.X := (LFPoint1.X + LFPoint2.X) / 2;
    CPoint.Y := (LFPoint1.Y + LFPoint2.Y) / 2;
    RX := Abs( LFPoint2.X - LFPoint1.X ) / 2;
    RY := Abs( LFPoint2.Y - LFPoint1.Y ) / 2;
  end;

  with TN_UDPolyline(AEllipsLine).PSP.CPolyline do
  begin
    CPCoords.ASetLength( 361 );
    PFPoint(CPCoords.P(0))^ := FPoint(CPoint.X + RX, CPoint.Y);
    for i := 1 to 360 do
    begin
      SinCos( N_PI * i / 180, DSin, DCos );
      PFPoint(CPCoords.P(i))^ := FPoint(CPoint.X + RX * DCos, CPoint.Y - RY * DSin  );
    end;
  end;
end; // procedure K_CMSVObjEllipseRebuildByOuterRect

//*************************************************** K_CMInitLogFilesGPath ***
// Ini LogFiles Path and show SplashScreen context
//
//     Parameters
// Result - Returns string with resulting Path log info
//
//
function  K_CMInitLogFilesGPath( ) : string;
var
  UserIniName, LogFiles : string;
  MemIni : TMemIniFile;
  ResLogPath : string;
  CurLogPath : string;
begin

//  Result := 'DEMO MODE';
//  if not N_MemIniToBool('CMS_Main', 'UseExtDB', false) then Exit;
//  K_InitAppDirsList();
  Result := 'LogFiles >> UserIni is not set';
  UserIniName := N_MemIniToString( 'CMSIniFiles', 'User', '' );
  if UserIniName = '' then Exit;
  UserIniName := K_ExpandFileName( UserIniName );
  Result := 'LogFiles >> UserIni file (' + UserIniName + ') is absent ';
  if not FileExists( UserIniName ) then Exit;
  MemIni := TMemIniFile.Create(UserIniName);

  // Try to extract SkipSplashScreen
  K_CMSkipSplashScreen := N_StrToBool( MemIni.ReadString( 'CMS_UserMain', 'SkipSplashScreen', '0' ) );

  // Try to extract Log Path
  Result := format( 'LogFiles >> UserIni file (%s) [%s].LogFiles is absent',
                    [UserIniName,K_FileGPathsIniSection] );
  LogFiles := MemIni.ReadString( K_FileGPathsIniSection, 'LogFiles', '' );
  if LogFiles <> '' then
  begin
    CurLogPath := N_MemIniToString( K_FileGPathsIniSection, 'LogFiles', '' );
    N_StringToMemIni( K_FileGPathsIniSection, 'LogFiles', LogFiles );
    K_InitAppDirsList(); // Rebuild Dirs List using new LogFiles
    ResLogPath := K_GetDirPath( 'LogFiles' );
//    ResLogPath := K_ExpandFileName( '(#LogFiles#)' );
    Result := format( 'LogFiles >> UserIni file [%s].LogFiles=%s',
                      [K_FileGPathsIniSection,ResLogPath] );
    if not DirectoryExists( ExcludeTrailingPathDelimiter( ResLogPath ) ) then
    begin
    // New Path is not exists - return to default
      K_CMShowMessageDlg( // specout
                          '  The folder specified for log files does not exists.'#13#10 +
                          ResLogPath + #13#10 +
                          'The default folder will be used. Press OK to continue.', mtWarning );
      N_StringToMemIni( K_FileGPathsIniSection, 'LogFiles', CurLogPath );
      K_InitAppDirsList(); // Rebuild Dirs List using old LogFiles
      Result := format( 'LogFiles >> UserIni file [%s].LogFiles=%s folder is absent',
                        [K_FileGPathsIniSection,ResLogPath] );
    end
    else
    begin
    // New Log Base Path Exists - Force Real Path for Current Session Logs
    // Real Path for Current Session Logs in (#CMSLogFiles#)
      K_CMSIniLogPath := CurLogPath;
// ForceDir is not neeeded here because it will be done inside Dump routines
//      K_ForceDirPath( K_GetDirPath( 'CMSLogFiles' ) ); // Force
//      OR
//      K_ForceDirPath( K_ExpandFileName( '(#CMSLogFiles#)' ) ); // Force
    end;
  end; // if LogFiles <> '' then
  MemIni.Free;

end; // end of K_CMInitLogFilesGPath
{
//************************************************** K_CMCustomizeGPathProc ***
// Customize TmpFiles, LogFiles, WrkFiles, ECacheFiles and corresponding GPaths
//
procedure K_CMCustomizeGPathProc( );
var
  CurPath : string;
  AddPath : string;
  AddPath1 : string;
  Ind : Integer;

  procedure CustAndCreateRoot( const AGpathName : string );
  var
    CurPath1 : string;
  begin
    CurPath1 := K_AppFileGPathsList.Values[AGpathName];
    if CurPath1 = '' then Exit; // precaution
    K_AppFileGPathsList.Values[AGpathName] := CurPath1 + AddPath1;

    CurPath := K_AppFileGPathsList.Values[AGpathName + 'Root'];
    if CurPath = '' then
    // Create AGpathName + Root Path
      K_AppFileGPathsList.Add(AGpathName + 'Root=' + CurPath1);
  end; // procedure CustAndCreateRoot

begin
  // Not Cloud or TS
  AddPath1 := '';
  AddPath := '%USERNAME%\';
  if K_CMSServerClientInfo.CMSSessionInfo.WTSClientProtocolType <> WTS_PROTOCOL_TYPE_CONSOLE then
  begin // Cloud or TS
    AddPath := K_CMSServerClientInfo.CMSSessionInfo.WTSClientName + '\%USERNAME%\';
    AddPath1 := AddPath;
  end;

  // Customize TmpFiles
  CurPath := K_AppFileGPathsList.Values['TmpFiles'];
  if CurPath <> '' then
    K_AppFileGPathsList.Values['TmpFiles'] := CurPath + AddPath1;

  // Customize CMSLogFiles
  CurPath := K_AppFileGPathsList.Values['CMSLogFiles'];
  if CurPath = '' then
    K_AppFileGPathsList.Add('CMSLogFiles=(#LogFiles#)' + AddPath);


  // Customize CMECacheFiles
  CustAndCreateRoot( 'CMECacheFiles' );

  // Customize WrkFiles
  CustAndCreateRoot( 'WrkFiles' );

  // Customize CMSWrkFiles if WTSClientProtocolType <> WTS_PROTOCOL_TYPE_CONSOLE
  // CMSWrkFiles is used for device only, so it should be used if WTSClientProtocolType = WTS_PROTOCOL_TYPE_CONSOLE only
  // and its real value will be set in K_CMSWrkFilesInit()
  // In the case WTSClientProtocolType <> WTS_PROTOCOL_TYPE_CONSOLE CMSWrkFiles should not be used, the value WrkFiles is set as precaution
  if AddPath = AddPath1 then
  begin
    Ind := K_AppFileGPathsList.IndexOfName('CMSWrkFiles');
    if Ind < 0 then
      K_AppFileGPathsList.Add('CMSWrkFiles=(#WrkFiles#)')
    else
      K_AppFileGPathsList.ValueFromIndex[Ind] := '(#WrkFiles#)';
  end; // if AddPath = AddPath1 then

end; // end of K_CMCustomizeGPathProc

}

//************************************************** K_CMCustomizeGPathProc ***
// Customize TmpFiles, LogFiles, WrkFiles, ECacheFiles and corresponding GPaths
//
procedure K_CMCustomizeGPathProc( );
var
  CurPath : string;
  AddPath : string;
  AddPath1 : string;
  Ind : Integer;
  NewBasePath : string;

  procedure CustAndCreateRoot( const AGpathName : string );
  var
    CurPath1 : string;
  begin
    CurPath1 := K_AppFileGPathsList.Values[AGpathName];
N_Dump2Str( 'K_CMCustomizeGPathProc 1 >>'+ AGpathName + '=' + CurPath1 );
    if CurPath1 = '' then Exit; // precaution
    K_AppFileGPathsList.Values[AGpathName] := CurPath1 + AddPath1;
N_Dump2Str( 'K_CMCustomizeGPathProc 11 >>' + AGpathName + '=' + CurPath1 + AddPath1 );

    CurPath := K_AppFileGPathsList.Values[AGpathName + 'Root'];
N_Dump2Str( 'K_CMCustomizeGPathProc 2 >>' + AGpathName + 'Root=' + CurPath );
    if CurPath = '' then
    // Create AGpathName + Root Path
      K_AppFileGPathsList.Add(AGpathName + 'Root=' + CurPath1);
N_Dump2Str( 'K_CMCustomizeGPathProc 3 >>' + AGpathName + 'Root=' + CurPath1 );
  end; // procedure CustAndCreateRoot

  procedure ReplaseBasePath( const AGpathName : string );
  begin // Replace (#BasePath#)
    CurPath := K_AppFileGPathsList.Values[AGpathName];
    CurPath := NewBasePath + Copy( CurPath, 13, Length(CurPath) );
N_Dump2Str( 'K_CMCustomizeGPathProc 4 >>'+ AGpathName + '=' + CurPath );
    K_AppFileGPathsList.Values[AGpathName] := CurPath;
  end; // procedure ReplaseBasePath

begin
  if not K_CMVUIMode then
  begin // CMSuite
//    NewBasePath := K_WinEnvironmentStrings.Values['CMS_LOGS'];
    NewBasePath := GetEnvironmentVariable( 'CMS_LOGS' );
    if NewBasePath <> '' then
      NewBasePath := IncludeTrailingPathDelimiter(NewBasePath);

    // Not Cloud or TS
    AddPath1 := '';
    AddPath := '%USERNAME%\';
    if K_CMSServerClientInfo.CMSSessionInfo.WTSClientProtocolType <> WTS_PROTOCOL_TYPE_CONSOLE then
    begin // Cloud or TS
      AddPath := K_CMSServerClientInfo.CMSSessionInfo.WTSClientName + '\%USERNAME%\';
      AddPath1 := AddPath;
    end;
  end
  else
  begin // CMSuiteWEB
//    with K_CMSServerClientInfo.CMSSessionInfo do
//      AddPath := WTSClientName + '\' +WTSUserName + '\';
    AddPath := K_CMVUIURLList.Values['CustomerID'] + '_' + K_CMVUIURLList.Values['UserName'] + '\'; //Ura
    AddPath1 := AddPath;
  end;

  // Customize TmpFiles
  CurPath := K_AppFileGPathsList.Values['TmpFiles'];
  if CurPath <> '' then
    K_AppFileGPathsList.Values['TmpFiles'] := CurPath + AddPath1;

  // Customize CMSLogFiles
  CurPath := K_AppFileGPathsList.Values['CMSLogFiles'];
  if CurPath = '' then
    K_AppFileGPathsList.Add('CMSLogFiles=(#LogFiles#)' + AddPath);
  if K_CMVUIMode then //Ura
  begin
    CurPath := K_AppFileGPathsList.Values['LogFiles'];
{$IF CompilerVersion >= 26.0}
    CurPath := CurPath.Replace('(#BasePath#)',K_CMVUICMSRootFolder);
{$IFEND CompilerVersion >= 26.0}
    K_AppFileGPathsList.Values['LogFiles'] := CurPath;
  end;
  // Customize CMECacheFiles
  if K_CMVUIMode then //Ura
  begin
    CurPath := K_AppFileGPathsList.Values['CMECacheFiles'];
{$IF CompilerVersion >= 26.0}
    CurPath := CurPath.Replace('(#BasePath#)',K_CMVUICMSRootFolder);
{$IFEND CompilerVersion >= 26.0}
    K_AppFileGPathsList.Values['CMECacheFiles'] := CurPath;
  end;
  CustAndCreateRoot( 'CMECacheFiles' );

  // Customize WrkFiles
  if K_CMVUIMode then //Ura
  begin
    CurPath := K_AppFileGPathsList.Values['WrkFiles'];
{$IF CompilerVersion >= 26.0}
    CurPath := CurPath.Replace('(#BasePath#)',K_CMVUICMSRootFolder);
{$IFEND CompilerVersion >= 26.0}
    K_AppFileGPathsList.Values['WrkFiles'] := CurPath;
  end;
  CustAndCreateRoot( 'WrkFiles' );

  if not K_CMVUIMode and (NewBasePath <> '') then
  begin // Set new Base Path
    ReplaseBasePath('TmpFiles');
    ReplaseBasePath('LogFiles');
    ReplaseBasePath('CMECacheFiles');
    ReplaseBasePath('CMECacheFilesRoot');
    ReplaseBasePath('WrkFiles');
    ReplaseBasePath('WrkFilesRoot');
  end; // if not K_CMVUIMode and (NewBasePath <> '') then

  // Customize CMSWrkFiles if WTSClientProtocolType <> WTS_PROTOCOL_TYPE_CONSOLE
  // CMSWrkFiles is used for device only, so it should be used if WTSClientProtocolType = WTS_PROTOCOL_TYPE_CONSOLE only
  // and its real value will be set in K_CMSWrkFilesInit()
  // In the case WTSClientProtocolType <> WTS_PROTOCOL_TYPE_CONSOLE CMSWrkFiles should not be used, the value WrkFiles is set as precaution
  if AddPath = AddPath1 then
  begin
    Ind := K_AppFileGPathsList.IndexOfName('CMSWrkFiles');
    if Ind < 0 then
      K_AppFileGPathsList.Add('CMSWrkFiles=(#WrkFiles#)')
    else
      K_AppFileGPathsList.ValueFromIndex[Ind] := '(#WrkFiles#)';
  end; // if AddPath = AddPath1 then

end; // end of K_CMCustomizeGPathProc

//*************************************************** K_CMInstallIniSetInfo ***
// Set CMS Ini-file Info
//
procedure K_CMInstallIniSetInfo( const AFName : string );
var
  ISL, CSL : TStringList;
  ParInd, Ind, ErrCode : Integer;
  WasChangedFalg : Boolean;
  WStr : string;

label LExit;
begin

  N_Dump1Str('SII>> Start info file >> ' + AFName);
  if not FileExists(AFName) then
  begin
    N_Dump1Str('SII>> Info file not found');
    Exit;
  end;

  ISL := TStringList.Create;
  CSL := TStringList.Create;
  CSL.LoadFromFile(AFName);
  try
    N_Dump1Str('SII>> Info file ' + AFName + #13#10
        + CSL.Text);
//    if UpperCase(CSL[0]) <> '[COMMON]' then
//      N_Dump2Str('SII>> Wrong file format')
//    else
    begin // Proper File Format
      WasChangedFalg := FALSE;
      WStr := K_VFLoadStrings1( N_CurMemIni.FileName, ISL, ErrCode );
      if WStr <> '' then
      begin
        N_Dump1Str( format( 'SII>> ini-file read error >> %s', [WStr] ) );
        goto LExit;
      end;

      ParInd := CSL.IndexOfName('CloudSplashScreen');
      if (ParInd >= 0) and (CSL.ValueFromIndex[ParInd] = '1') then
      begin
        ISL.Values['SplashScreenImgFName'] := ISL.Values['SplashScreenImgCloudFName'];
        ISL.Values['SplashScreenImgEFName'] := ISL.Values['SplashScreenImgCloudEFName'];
        N_Dump1Str( 'SII>> Change SplashScreenImg' );
        WasChangedFalg := TRUE;
      end;

      ParInd := CSL.IndexOfName('ConfigDBConStr');
      if (ParInd > 0) then
      begin
        WStr := CSL.ValueFromIndex[ParInd];
        if WStr <> '' then
        begin
          Ind := ISL.IndexOfName('ConfigDBConStr');
          if Ind < 0 then
          begin
            if ISL[ISL.Count-1] <> '' then
              ISL.Add( '' );
            ISL.Add( '[GlobWEBSettings]' );
            ISL.Add( 'ConfigDBConStr=' + WStr );
            ISL.Add( '' );
          end
          else
            ISL.ValueFromIndex[Ind] := WStr;
          N_Dump1Str( 'SII>> Change ConfigDBConStr' );
          WasChangedFalg := TRUE;
        end;
      end;

      if WasChangedFalg then  // Save new IniFile Value
        K_VFSaveStrings( ISL, N_CurMemIni.FileName, K_IniFileCreateParams );

    end; // // Proper File Format
LExit: //****
    N_Dump1Str('SII>> fin');
  finally
    CSL.Free;
    ISL.Free;
  end;
//  N_CurMemIni.FileName;
end; // procedure K_CMInstallIniSetInfo

//******************************************* K_CMParseLiDBTrialExpiredInfo ***
// Parse Licenses exeeded or Trial expired DB Info
//
//     Parameters
// AMList - strings list to parse DB Info
//
procedure K_CMParseLiDBTrialExpiredInfo( AMList : TStrings );
var
  CPos : Integer;
  CPos2 : Integer;
  VL, L : Integer;
  Name, Value : string;
begin

  L := Length(K_CMSLiRegTrialExpiredInfo);
  if L = 0 then Exit;
  CPos := N_PosEx( '#', K_CMSLiRegTrialExpiredInfo, 1, L );

  repeat
    Inc(CPos);
    CPos2 := N_PosEx( ':', K_CMSLiRegTrialExpiredInfo, CPos, L );
    Name := Copy( K_CMSLiRegTrialExpiredInfo, CPos, CPos2 - CPos );
    Inc(CPos2);
    CPos := N_PosEx( '#', K_CMSLiRegTrialExpiredInfo, CPos2, L );
    if CPos = 0 then
      CPos := L + 1;
    VL := CPos - CPos2;
    if VL = 0 then
      Value := '??????'
//        Value := 'QZYHELMN'
    else
      Value := Copy( K_CMSLiRegTrialExpiredInfo, CPos2, VL );
    AMList.Add( Name + '=' + Value )
  until CPos = L + 1;

  AMList.Values['N']  := N_MemIniToString( 'RegionTexts', 'CompanyDistrName', AMList.Values['N'] );
  AMList.Values['PH'] := N_MemIniToString( 'RegionTexts', 'Phone', AMList.Values['PH'] );
  AMList.Values['E']  := N_MemIniToString( 'RegionTexts', 'Email', AMList.Values['E'] );

end; // end of K_CMParseLiDBTrialExpiredInfo


//************************************************** K_CMSetFlashLightAttrs ***
// Set Slide Flashlight Attributes
//
//     Parameters
// AMapImgCursorPos - map image cursor position
// APMapImgPixPos   - pointer to varaible with resulting map image pixel coords
// Result - Returns given pixel color
//
procedure K_CMSetFlashLightAttrs( AUDFlashlight : TN_UDCompVis;
                                          APFLIniData : TK_PCMFlashlightIniData );
var
  PCDIBRect: TN_PCDIBRect;
begin
  with AUDFlashlight, PSP.CCoords, APFLIniData^ do
  begin
    PCDIBRect := @TN_UDDIBRect(AUDFlashlight.DirChild(1)).PSP.CDIBRect;

    PFloat(K_CMGetVObjPAttr(AUDFlashlight, 'ScaleFactor').UPValue.P)^ := CMFLScaleFactor;
    if CMFLNewAttrsFlag = 0 then
    begin
    // Old Flashlight Attributes
      PFloat(K_CMGetVObjPAttr(AUDFlashlight, 'BriFactor').UPValue.P)^ := CMFLBriFactor;
      PFloat(K_CMGetVObjPAttr(AUDFlashlight, 'CoFactor').UPValue.P)^ := CMFLCoFactor;

      PInteger(K_CMGetVObjPAttr(AUDFlashlight, 'SkipScaleFlag').UPValue.P)^ := CMFLSkipScaleFlag;
      PInteger(K_CMGetVObjPAttr(AUDFlashlight,'AutoEqualizeFlag').UPValue.P)^ := CMFLAutoEqualizeFlag;
    end
    else
    begin
    // New Flashlight Attributes
      Include(PCDIBRect.CDRFlags, uddrfNewParams);
      PCDIBRect.CDRGamFactor := CMFLGamFactor;
      PCDIBRect.CDRMode := CMFLMode;
      PCDIBRect.CDREmbAngle := CMFLEmbAngle;
      PCDIBRect.CDREmbCoef  := CMFLEmbCoef;
      PCDIBRect.CDREmbDepth := CMFLEmbDepth;
      PCDIBRect.CDREmbBaseGrey := CMFLEmbBaseGrey;
    end;

    if CMFLRectFlag = 0 then
    begin
      Include(PCDIBRect.CDRFlags, uddrfEllipseMask);
      PInteger(K_CMGetVObjPAttr(AUDFlashlight, 'ShowEllipse').UPValue.P)^ := 1;
      PInteger(K_CMGetVObjPAttr(AUDFlashlight, 'ShowRect').UPValue.P)^ := 0;
    end
    else
    begin
      Exclude(PCDIBRect.CDRFlags, uddrfEllipseMask);
      PInteger(K_CMGetVObjPAttr(AUDFlashlight, 'ShowEllipse').UPValue.P)^ := 0;
      PInteger(K_CMGetVObjPAttr(AUDFlashlight, 'ShowRect').UPValue.P)^ := 1;
    end;
  end; // with AUDFlashlight, PSP.CCoords, APFLIniData^ do
end; // procedure K_CMSetFlashLightAttrs

//************************************************ K_CMFlipRotateSlideImage ***
// Flip and Rotate given Slide Image (without Annotations)
//
//     Parameters
// AUDSlide   - Slide to Flip/Rotate
// AAngle     - rotate angle in degrees
// AFlipFlags - Flip Flags
// AChangeFlags - if TRUE then Slide FlipRotate Flags will be changed else image pixels will be changed
// Result - Returns TRUE if Slide aspect was changed
//
function K_CMFlipRotateSlideImage( AUDSlide : TN_UDCMSlide; AAngle: float;
               AFlipFlags : Integer; AChangeFlags : Boolean = FALSE ) : Boolean;
var
  RFlags : Integer;
  WF : FLoat;
  SaveECacheMode : Integer;
  AppRTID : Integer;
begin
  with AUDSlide, GetPMapRootAttrs^ do
  begin
    with GetMapImage.DIBObj do
    begin
      RFlags := N_RotateFRFlags( 0, AAngle ) xor AFlipFlags;
      FlipAndRotate( RFlags );
    end;

    SaveECacheMode := 1;
    if AChangeFlags then
      MRFlipRotateAttrs := N_RotateFRFlags( MRFlipRotateAttrs, AAngle ) xor AFlipFlags
    else
    begin
      MRFlipRotateAttrs := 0;
      GetCurrentImage.DIBObj.FlipAndRotate( RFlags );
      SaveECacheMode := 2;
    end;

    Result := RFlags >= 4;
    if Result then // Rotate +-90
      with GetMapRoot().PCCS()^, AUDSlide.P^ do
      begin
        WF := SRSize.X;
        SRSize.X := SRSize.Y;
        SRSize.Y := WF;
        CMSDB.PixWidth := Round(SRSize.X);
        CMSDB.PixHeight := Round(SRSize.Y);
      end;

    CreateThumbnail();

    // Save Changed State to ECache
    if (K_CMEDAccess is TK_CMEDDBAccess) or
       (K_CMEDAccess is TK_CMEDCSAccess) then // is actual only for ExtDBMode or CMScan
    begin
      AppRTID := -1;
      if K_CMEDAccess is TK_CMEDDBAccess then
        AppRTID := TK_CMEDDBAccess(K_CMEDAccess).AppRTID;

      ECacheSave( AppRTID, SaveECacheMode );
    end;
  end;

end; // end of K_CMFlipRotateSlideImage

//************************************************ K_CMFlipRotateSlideImage ***
// Replace Slide Image by DIB
//
//     Parameters
// AUDSlide - Slide to Image replace
// ADIB     - New Image DIB to replace
// ASkipSizeChange - skip slide size change according DIB
//
procedure K_CMReplaceSlideDIB( AUDSlide : TN_UDCMSlide; ADIB : TN_DIBObj; ASkipSizeChange : Boolean = FALSE );
var
  SaveECacheMode : Integer;
  AppRTID : Integer;
begin
  with AUDSlide do
  begin
    with GetCurrentImage do
    begin
      DIBObj.Free();
      DIBObj := ADIB;
    end;

    with AUDSlide.P^  do
      if not ASkipSizeChange and
        ((ADIB.DIBSize.X <> CMSDB.PixWidth) or (ADIB.DIBSize.Y <> CMSDB.PixHeight)) then
      begin
        with GetMapRoot().PCCS()^ do
        begin
          SRSize.X := ADIB.DIBSize.X;
          SRSize.Y := ADIB.DIBSize.Y;
        end;
        CMSDB.PixWidth := ADIB.DIBSize.X;
        CMSDB.PixHeight := ADIB.DIBSize.Y;
        with GetPMapRootAttrs^ do
          MRFlipRotateAttrs := 0;
      end; // if ...


    RebuildMapImageByDIB();

    CreateThumbnail();

    // Save Changed State to ECache
    if (K_CMEDAccess is TK_CMEDDBAccess) or
       (K_CMEDAccess is TK_CMEDCSAccess) then // is actual only for ExtDBMode or CMScan
    begin
      AppRTID := -1;
      if K_CMEDAccess is TK_CMEDDBAccess then
        AppRTID := TK_CMEDDBAccess(K_CMEDAccess).AppRTID;

      SaveECacheMode := 2;
      ECacheSave( AppRTID, SaveECacheMode );
    end;
  end;

end; // end of K_CMReplaceSlideDIB

//*********************************************** K_CMAddDeviceProfilesList ***
// Add Device Profiles Info to given Strings
//
//     Parameters
// ASL   - Strings to add Device Profiles Info
//
procedure K_CMAddDeviceProfilesList( ASL : TStrings );
var
  PData : Pointer;
  DSize : Integer;
  ResCode : TK_CMEDResult;
  WInstanceInfo : TN_UDBase;
  UDProfiles : TK_UDRArray;

  procedure AddProfiles();
  var
  i : Integer;
  begin
    for i := 0 to UDProfiles.AHigh() do
      with TK_PCMDeviceProfile(UDProfiles.PDE(i))^ do
      begin
        ASL.Add( 'Profile: ' + CMDPCaption );
        ASL.Add( 'Device : ' + CMDPProductName );
//        if CMDPGroupName <> '' then
//          ASL.Add( 'Device group : ' + CMDPGroupName );
        ASL.Add('');
      end;
  end;

begin
  if not (K_CMEDAccess is TK_CMEDDBAccess) then Exit; // precaution

  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    WInstanceInfo := TN_UDBase.Create;
    try
      with CurDSet1 do
      begin
        ExtDataErrorCode := K_eeDBSelect;
        Connection := LANDBConnection;
        N_Dump2Str( 'DB>> Get Device Profiles Info' );
        SQL.Text :=
           'select ' + K_CMENDBCTFBinData + ',' + K_CMENDBCTFContID + ',' +
                       K_CMENDBGAInstsTFCName +
          ' from ' + K_CMENDBContextsTable + ',' + K_CMENDBGAInstsTable +
          ' where ' + K_CMENDBCTFContTypeID + '=' + IntToStr(Ord(K_actGInstUD)) +
          ' and '   + K_CMENDBGAInstsTFGlobID + '=' + K_CMENDBCTFContID;
        Filtered := false;
        Open;
        First;
        while not Eof do
        begin

          ASL.Add( 'Computer: ' + FieldList.Fields[2].AsString );
          ASL.Add('');

          ResCode := EDAGetBlobFieldValue( CurDSet1, FieldList.Fields[0], PData, DSize);

          if (DSize > 0) and (ResCode = K_edOK) then
          begin
            // K_SerialTextBuf.LoadFromText( PChar(@BlobBuf[0]) );

        {$IF SizeOf(Char) = 2}
        //////////////////////////////////////////////////////////////
        // Special code to correct wrong DeviceProfile field name in SDT format
        //
            AnsiTextBuf := AnsiStrings.AnsiReplaceStr( PAnsiChar(PData), 'CMÂDProductName', 'CMDPProductName' );
            PData := @AnsiTextBuf[1];
        //
        // end of special code to correct wrong DeviceProfile field name in SDT format
        //////////////////////////////////////////////////////////////
        {$IFEND}

            // Instance Data Deserialized
            EDAAnsiTextToString(PData, DSize);
            K_SerialTextBuf.LoadFromText(PChar(PData));
            WInstanceInfo.ClearChilds();
            K_LoadTreeFromText0(WInstanceInfo, K_SerialTextBuf, TRUE);

            // Parse Device Info
            K_UDCursorGet('AI:').SetRoot(WInstanceInfo);
            with K_UDCursorForceDir('AI:DeviceProfiles') do
            begin

              // Add TWAIN Profiles
              UDProfiles := TK_UDRArray(DirChildByObjName('TwainProfiles'));
              if UDProfiles <> nil then AddProfiles();

              // Add OTHER Profiles
              UDProfiles := TK_UDRArray(DirChildByObjName('OtherProfiles'));
              if UDProfiles <> nil then AddProfiles();

              // Add VIDEO Profiles
              UDProfiles := TK_UDRArray(DirChildByObjName('VideoProfiles'));
              if UDProfiles <> nil then AddProfiles();
            end;
          end
          else
          begin
            ASL.Add( 'Data is corrupted' );
            ASL.Add('');
          end;

          ASL.Add('');
          Next;
        end;

        Close;
      end;
      N_Dump2Str('DB>> Get Device Profiles Info fin');
    except
      on E: Exception do
      begin
        ExtDataErrorString := 'K_CMAddDeviceProfilesList ' + E.Message;
        EDAShowErrMessage(TRUE);
      end;
    end;
    WInstanceInfo.UDDelete();
  end;

end; // end of K_CMAddDeviceProfilesList



{*** TK_CMSADialogsHandlers ***}

//**************************** TK_CMSADialogsHandlers.SADCheckLocationAttrs ***
// Check Input Location Attrs
//
//     Parameters
// AForm - parameters form
//
function TK_CMSADialogsHandlers.SADCheckLocationAttrs( AForm : TForm ) : Boolean;
begin
  with TN_EditParamsForm(AForm) do
  begin
    Result := not TLabeledEdit(EPControls[0].CRContr).Enabled or
              (ModalResult <> mrOK) or
              ((TLabeledEdit(EPControls[0].CRContr).Text <> '') and
               (TLabeledEdit(EPControls[0].CRContr).Text <> K_CML1Form.LLLSADialogs2.Caption));
    if Result then Exit;
    K_CMShowMessageDlg1( K_CML1Form.LLLSADialogs1.Caption + ' ' + K_CML1Form.LLLPressOKToContinue.Caption,
//        'Please enter the name of your dental practice. Press OK to continue.',
                         mtWarning, [mbOK] );
    ActiveControl := TLabeledEdit(EPControls[0].CRContr);
  end;

end; // TK_CMSADialogsHandlers.SADCheckLocationAttrs

//************************ TK_CMSADialogsHandlers.SADLocAndProvFormActivate ***
// Check Input Location Attrs
//
//     Parameters
// AForm - parameters form
//
procedure TK_CMSADialogsHandlers.SADLocAndProvFormActivate( AForm : TObject );
begin
  with TN_EditParamsForm(AForm) do
  begin
    TComboBox((EPControls[0].CRContr)).DroppedDown := TRUE;
  end;

end; // TK_CMSImportNotes.SADLocAndProvFormActivate

//************************************** TK_CMSADialogsHandlers.SADKeyPress ***
// Input Location Key Press Handler
//
procedure TK_CMSADialogsHandlers.SADKeyPress( Sender: TObject; var Key: Char );
begin

  if Key <> Char(VK_RETURN) then Exit;
  TForm(TControl(Sender).Owner).ModalResult := mrOK;

end; // TK_CMSADialogsHandlers.SADKeyPress

{*** end of TK_CMSADialogsHandlers ***}

//************************************************* K_CMSAFillLocationsList ***
// Set CMS Standalone Locations Strings
//
//     Parameters
// AStrings - Locations strings
// ALocSID - selected Location ID string
//
function K_CMSAFillLocationsList( AStrings : TStrings; const ALocSID : string ) : Integer;
var
  i : Integer;
begin
  with K_CMEDAccess.LocationsInfo do
  begin
    AStrings.Clear();
    for i := 1 to R.ARowCount - 1 do
    begin
      AStrings.AddObject( PString(R.PME( 1, i))^, TObject(i) );
    end;
    Result := Max( 0, K_IndexOfStringInRArray( ALocSID,
                                          R.PME( 0, 1),
                                          R.ARowCount() - 1,
                                          R.ElemSize * R.AColCount ) );
  end;
end; // function K_CMSAFillLocationsList

//************************************************* K_CMSAFillProvidersList ***
// Set CMS Standalone Providers Strings
//
//     Parameters
// AStrings - providers strings
// AProvSID - selected Provider ID string
//
function K_CMSAFillProvidersList( AStrings : TStrings; const AProvSID : string ) : Integer;
var
  i : Integer;
  WProvID, Ind : Integer;
  SL : TStringList;
  SID : string;
begin
{
  with K_CMEDAccess.ProvidersInfo do
  begin
    AStrings.Clear();
    for i := 1 to R.ARowCount - 1 do
    begin
      WProvID := StrToInt( PString(R.PME( 0, i))^ );
      AStrings.AddObject( K_CMGetProviderDetails( WProvID, K_CMENPTSAProviderDetails ), TObject(i) );
    end;
    Result := Max( 0, K_IndexOfStringInRArray( AProvSID,
                                          R.PME( 0, 1),
                                          R.ARowCount() - 1,
                                          R.ElemSize * R.AColCount ) );
  end;
}
  SL := TStringList.Create;
  with K_CMEDAccess.ProvidersInfo do
  begin
    Result := -1;
    for i := 1 to R.ARowCount - 1 do
    begin
      SID := PString(R.PME( 0, i))^;
      if SID = AProvSID then
        Result := i;
      WProvID := StrToInt( SID );
      SL.AddObject( K_CMGetProviderDetails( WProvID, '(#ProviderSurname#)' ), TObject(i) );
    end;
    // Sort Wrk List
    SL.CaseSensitive := FALSE;
    SL.Sort();
    for i := 0 to SL.Count - 1 do
    begin
      Ind := Integer(SL.Objects[i]);
      WProvID := StrToInt( PString(R.PME( 0, Ind))^ );
      SL[i] := K_CMGetProviderDetails( WProvID, K_CMENPTSAProviderDetails );
    end;
  end;
  Result := SL.IndexOfObject( TObject(Result) );
  AStrings.Assign( SL );
  SL.Free;
end; // function K_CMSAFillProvidersList

//************************************************ K_CMSASetLocationNameDlg ***
// Set CMS Standalone Location Name Dialog
//
//     Parameters
// ALocName - Locaton Name
// ACaption - form TitleBar Text
// Result - Returns FALSE if user do not click OK
//
function K_CMSASetLocationNameDlg( var ALocName : string;
                                   const ACaption : string; AReadOnly : Boolean = FALSE ) : Boolean;
var
  CurControl : TWinControl;
begin

    // Show Location Title Dialog
  N_CurMemIni.DeleteKey('N_Forms', 'N_EditParamsForm');
  with N_CreateEditParamsForm( 350 ) do
  begin // Set new Value to LocationsInfo and to DB
    OnCloseQueryProcOfObj := TK_CMSADialogsHandlers(nil).SADCheckLocationAttrs;
    Caption := ACaption;
    BorderIcons := [biSystemMenu];
    AddLEdit( '', 0,  ALocName );
//    ShowSelfModal();

    Position := poScreenCenter;
    ClientWidth  := ContrWidth + LeftMargin + RightMargin;
    ClientHeight := CurTop + 10;
    Constraints.MaxHeight := Height;
    Constraints.MinHeight := Height;
    Constraints.MinWidth := Width;
    CurControl := TWinControl(EPControls[0].CRContr);
    CurControl.Anchors := CurControl.Anchors + [akRight];
    TLabeledEdit(CurControl).OnKeyPress :=  TK_CMSADialogsHandlers(nil).SADKeyPress;
    TLabeledEdit(CurControl).Color := $00A2FFFF;
    TLabeledEdit(CurControl).Enabled := not AReadOnly;
    if not AReadOnly then
      ActiveControl := CurControl;
    ShowModal();

    Result := (ModalResult = mrOK) and not AReadOnly;
    if not Result then Exit;

    // Set new Value to LocationsInfo and to DB
    ALocName := TLabeledEdit(CurControl).Text;

  end; // with N_CreateEditParamsForm( 250 ) do
end; // end of K_CMSASetLocationNameDlg

//************************************************** K_CMGetStartContextDlg ***
// Get CMS Standalone mode start context
//
//     Parameters
// AGSCSet - get CMS Start Context Flags Set
// Result - Returns FALSE if some problems with context selection were detected
//
function K_CMGetStartContextDlg( AGSCSet : TK_CMSGetStartContextSet ) : Boolean;
var
  CurControl : TControl;
  SelProvInd, SelLocInd : Integer;
  WStr : string;
  CMSALocationDBData : TK_CMSALocationDBData;

label LocationNameLoop;
begin
//  Result := TRUE;
//  if not (K_CMEDAccess is TK_CMEDDBAccess) then Exit; // precaution
  Result := TRUE;
  N_Dump2Str( 'K_CMGetStartContextDlg start' );
  with K_CMEDAccess do
  begin
    EDASAInitDBInfo( Byte(AGSCSet) );

   ////////////////////
   // Select Location
   //
    if K_gscLocation in AGSCSet then
    begin
      SelLocInd  := 1;
      EDASAGetLocationsInfo( FALSE );
      with LocationsInfo.R do
      begin
        if (PString(PME(1, 1))^ = '') or
           (PString(PME(1, 1))^ = '[' + PString(PME(0, 1))^ + ']') then
        begin
        // Location is not Set
        // Show Location Title Dialog
          K_CMShowMessageDlg( K_CML1Form.LLLSADialogs1.Caption + ' ' + K_CML1Form.LLLPressOKToContinue.Caption,
//            'Please enter the name of your dental practice. Press OK to continue.',
                           mtWarning, [mbOK] );

          CMSALocationDBData.ALName := K_CML1Form.LLLSADialogs2.Caption; // 'My dental Practice';
          Result := K_CMSASetLocationNameDlg( CMSALocationDBData.ALName,
                                              K_CML1Form.LLLSADialogs3.Caption
//                                              'Dental Practice name'
                                             );
          if not Result then Exit;
          WStr := '-101';
          EDASASetOneLocationInfo( WStr, @CMSALocationDBData, FALSE );
        end; // if PString(PME(1, 1))^ = ''
      end; // with LocationsInfo.R do

      if (LocationsInfo.R.ARowCount > 2) then
      begin
        with N_CreateEditParamsForm( 250 ) do
        begin
          Caption := K_CML1Form.LLLSADialogs4.Caption;// 'Select the practice';
          AddFixComboBox( '', [],  -1 );
          CurControl := TControl(EPControls[0].CRContr);
          with TComboBox(CurControl), LocationsInfo do
          begin
            Color := $00A2FFFF;
            Style := csDropDownList;
            ItemIndex := K_CMSAFillLocationsList( Items, IntToStr(K_CMSAppStartContext.CMASLocID) );
            if ItemIndex = -1 then ItemIndex := 0;

            DropDownCount := Min( 20, R.ARowCount - 1 );
          end;
  //        ShowSelfModal();

          Position := poScreenCenter;
          Width  := ContrWidth + 2*LeftMargin + 8 + 120;
          ClientHeight := CurTop + 10;
          Constraints.MaxHeight := Height;
          Constraints.MinHeight := Height;
          Constraints.MinWidth := Width;
          CurControl := TControl(EPControls[0].CRContr);
          CurControl.Anchors := CurControl.Anchors + [akRight];
          OnActivate := TK_CMSADialogsHandlers(nil).SADLocAndProvFormActivate;
          ShowModal();

          Result := ModalResult = mrOK;
          if not Result then Exit;

          SelLocInd := TComboBox(EPControls[0].CRContr).ItemIndex + 1;
          N_Dump2Str( 'K_CMGetStartContextDlg SelLocInd=' + IntToStr(SelLocInd) );
        end; // N_CreateEditParamsForm( 250 )
      end; // if (LocationsInfo.R.ARowCount > 2) then
      K_CMSAppStartContext.CMASLocID := StrToIntDef( PString(LocationsInfo.R.PME( 0, SelLocInd ))^, 1 );
    end; // if K_gscLocation in AGSCSet then

   /////////////////////
   // Select Provider
   //
    if K_gscProvider in AGSCSet then
    begin
      SelProvInd := 1;
      EDASAGetProvidersInfo( FALSE );
      if (ProvidersInfo.R.ARowCount > 2) then
      begin
        with N_CreateEditParamsForm( 250 ) do
        begin
          Caption := K_CML1Form.LLLSADialogs5.Caption; //'Select the dentist';

          AddFixComboBox( '', [],  -1 );

          CurControl := TControl(EPControls[0].CRContr);
          with TComboBox(CurControl), ProvidersInfo do
          begin
            Color := $00A2FFFF;
            Style := csDropDownList;
            ItemIndex := K_CMSAFillProvidersList( Items, IntToStr(K_CMSAppStartContext.CMASProvID) );
            if ItemIndex = -1 then ItemIndex := 0;
            DropDownCount := Min( 20, R.ARowCount - 1 );
  {
            for i := 1 to R.ARowCount - 1 do
            begin
              WProvID := StrToInt( PString(R.PME( 0, 1))^ );
              Items.Add( K_CMGetProviderDetails( WProvID, K_CMENPTSAProviderDetails ) );
            end;

            ItemIndex := Max( 0, K_IndexOfStringInRArray( IntToStr(K_CMSAppStartContext.CMASProvID),
                                                  R.PME( 0, 1),
                                                  R.ArowCount - 1,
                                                  R.ElemSize * R.AColCount ) );
  }
          end;

  //        ShowSelfModal();
          Position := poScreenCenter;
          Width  := ContrWidth + 2*LeftMargin + 8 + 120;
          ClientHeight := CurTop + 10;
          Constraints.MaxHeight := Height;
          Constraints.MinHeight := Height;
          Constraints.MinWidth := Width;
          CurControl := TControl(EPControls[0].CRContr);
          CurControl.Anchors := CurControl.Anchors + [akRight];
          OnActivate := TK_CMSADialogsHandlers(nil).SADLocAndProvFormActivate;
          ShowModal();

          Result := ModalResult = mrOK;
          if not Result then Exit;

          with TComboBox(EPControls[0].CRContr) do
            SelProvInd := Integer(Items.Objects[ItemIndex]);
          N_Dump2Str( 'K_CMGetStartContextDlg SelProvInd=' + IntToStr(SelProvInd) );
        end; // with N_CreateEditParamsForm( 250 ) do
      end; // if (ProvidersInfo.R.ARowCount > 2) then
      K_CMSAppStartContext.CMASProvID:= StrToIntDef( PString(ProvidersInfo.R.PME( 0, SelProvInd ))^, 1 );
    end; // if K_gscLocation in AGSCSet then

   /////////////////////
   // Select Patient
   //
    if K_gscPatient in AGSCSet then
    begin
      WStr := IntToStr(K_CMSAppStartContext.CMASPatID);
//TestMemoryDestruction20180829();
//WStr := '-101';
      Result := K_CMSASelectPatientDlg( WStr, FALSE, TRUE );
      if not Result then Exit;
      K_CMSAppStartContext.CMASPatID := StrToIntDef( WStr, K_CMSAppStartContext.CMASPatID );
    end;
    if AGSCSet <> [] then
      with K_CMSAppStartContext do
        N_Dump2Str( format( 'K_CMGetStartContextDlg fin PatID=%d ProvID=%d LocID=%d',
                    [CMASPatID, CMASProvID, CMASLocID] ) );
  end; // with K_CMEDAccess do
end; // end of K_CMGetStartContextDlg

  // Init CLL Data
//***************************************************** K_CMSCLLContextInit ***
// Initialized CLL Context
//
procedure K_CMSCLLContextInit( );
begin
  K_CMSCLLAttrs.LocationAttrs.CLLLID := -1;
  K_CMSCLLAttrs.LocationAttrs.CLLLName := '';

  K_CMSCLLAttrs.ProviderAttrs.CLLUID := -1;
  K_CMSCLLAttrs.ProviderAttrs.CLLUTitle := '';
  K_CMSCLLAttrs.ProviderAttrs.CLLUSurname := '';
  K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname := '';
  K_CMSCLLAttrs.ProviderAttrs.CLLUAuthorities := 0;

  K_CMSCLLAttrs.PatientAttrs.CLLPID := -1;
  K_CMSCLLAttrs.PatientAttrs.CLLPCardNum := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPTitle := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPSurname := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPFirstname := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPAddr1 := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPAddr2 := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPPostCode := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPSuburb := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPPhone1 := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPPhone2 := '';
  K_CMSCLLAttrs.PatientAttrs.CLLPDOB := 0;
  K_CMSCLLAttrs.PatientAttrs.CLLPState := '';
//  K_CMSCLLAttrs.PatientAttrs.CMSPProvID := 1;

end; // procedure K_CMSCLLContextInit

//********************************************** K_CMSCLLContextFromIniFile ***
// Parse Patient Date of Birth from text
//
//     Parameters
// AStrDOB - Patient Date of Birth text
// Result - Returns Patient Date of Birth value converted to TDateTime
//
function K_CMSCLLDOBFromText( const AStrDOB : string ) : TDateTime;
begin
  Result := 0;
  if AStrDOB = '' then Exit;
  Result := StrToDateDef(AStrDOB, 0, N_WinFormatSettings );
  if Result > 0 then Exit;
  if Result = 0 then
    N_Dump1Str( 'Patient DOB Conv ERROR: DOB=' + AStrDOB + ', needed format=' + N_WinFormatSettings.ShortDateFormat )
  else
    N_Dump1Str( 'Patient DOB ERROR: DOB=' + AStrDOB );
end; // function K_CMSCLLDOBFromText

//********************************************** K_CMSCLLContextFromIniFile ***
// Parse CMS Command Line context from Ini-file
//
//     Parameters
// AFName - ini-file name
// Result - Returns resulting value: 0 - OK, 1 - file load error, 2 - file doesn't exist
//
function K_CMSCLLContextFromIniFile( const AFName :string; AInitContext : Boolean ) : Integer;
var
  MemIni : TMemIniFile;
begin

  Result := 2;
  if not FileExists( AFName ) then Exit;

  // Try to Load MemIni
  N_Dump2Str( 'CLL from Ini file: ' + AFName ); // Command Line Ini File
  Result := 1;
  try
    MemIni := nil;
    if not K_LoadMemIniFromFile( MemIni, AFName ) then
    begin
      FreeAndNil(MemIni);
      Exit;
    end;
  except
    FreeAndNil(MemIni);
    Exit;
  end;

  K_CMEDAccess.TmpStrings.Clear();
  MemIni.GetStrings( K_CMEDAccess.TmpStrings );
  N_Dump2Strings( K_CMEDAccess.TmpStrings, 5 ); // Command Line Ini File

  if AInitContext then K_CMSCLLContextInit();

  // Parse MemIni
  K_CMSCLLAttrs.PatientAttrs.CLLPID := MemIni.ReadInteger( 'Patient', 'ID', K_CMSCLLAttrs.PatientAttrs.CLLPID );
  K_CMSCLLAttrs.PatientAttrs.CLLPSurname := MemIni.ReadString( 'Patient', 'Name', '' );

  Result := 0;
  K_CMSCLLAttrs.PatientAttrs.CLLPCardNum := MemIni.ReadString( 'Patient', 'CardNum', '' );
  K_CMSCLLAttrs.PatientAttrs.CLLPTitle := MemIni.ReadString( 'Patient', 'Title', '' );
  K_CMSCLLAttrs.PatientAttrs.CLLPGender := K_CMGetPatientGenderTextByTitle( K_CMSCLLAttrs.PatientAttrs.CLLPTitle );
  K_CMSCLLAttrs.PatientAttrs.CLLPFirstname := MemIni.ReadString( 'Patient', 'FirstName', '' );
  K_CMSCLLAttrs.PatientAttrs.CLLPAddr1 := MemIni.ReadString( 'Patient', 'Address1', '' );
  K_CMSCLLAttrs.PatientAttrs.CLLPAddr2 := MemIni.ReadString( 'Patient', 'Address2', '' );
  K_CMSCLLAttrs.PatientAttrs.CLLPPostCode := MemIni.ReadString( 'Patient', 'ZipCode', '' );
  K_CMSCLLAttrs.PatientAttrs.CLLPSuburb := MemIni.ReadString( 'Patient', 'Town', '' );
  K_CMSCLLAttrs.PatientAttrs.CLLPPhone1 := MemIni.ReadString( 'Patient', 'Phone1', '' );
  K_CMSCLLAttrs.PatientAttrs.CLLPPhone2 := MemIni.ReadString( 'Patient', 'Phone2', '' );
  K_CMSCLLAttrs.PatientAttrs.CLLPDOB := K_CMSCLLDOBFromText( MemIni.ReadString( 'Patient', 'BirthDate', '' ) );
//  StrToDateDef( MemIni.ReadString( 'Patient', 'BirthDate', '' ), 0, N_WinFormatSettings );
  K_CMSCLLAttrs.PatientAttrs.CLLPState := MemIni.ReadString( 'Patient', 'State', '' );

  K_CMSCLLAttrs.ProviderAttrs.CLLUID := MemIni.ReadInteger( 'Dentist', 'ID', -1 );
  K_CMSCLLAttrs.ProviderAttrs.CLLUTitle := MemIni.ReadString( 'Dentist', 'Title', '' );
  K_CMSCLLAttrs.ProviderAttrs.CLLUSurname := MemIni.ReadString( 'Dentist', 'Name', '' );
  K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname := MemIni.ReadString( 'Dentist', 'FirstName', '' );

  K_CMSCLLAttrs.LocationAttrs.CLLLID := MemIni.ReadInteger( 'Practice', 'ID', -1 );
  K_CMSCLLAttrs.LocationAttrs.CLLLName := MemIni.ReadString( 'Practice', 'Name', '' );
  K_CMSCLLAttrs.CodePage := MemIni.ReadInteger( 'Common', 'CodePage', 0 ); // <CodePage>

  FreeAndNil(MemIni);

end; // function K_CMSCLLContextFromIniFile

//************************************************ K_CMSCLLContextToIniFile ***
// Save CMS Command Line context to Ini-file
//
//     Parameters
// AFName - ini-file name
// Result - Returns TRUE if ini file was successfully created
//
function K_CMSCLLContextToIniFile( AFName :string ) : Boolean;
var
  MemIni : TMemIniFile;
begin
  Result := FALSE;
  if K_CMSCLLAttrs.PatientAttrs.CLLPID = -1 then Exit;
  MemIni := TMemIniFile.Create( '' );

  MemIni.WriteInteger( 'Patient', 'ID', K_CMSCLLAttrs.PatientAttrs.CLLPID );
  if K_CMSCLLAttrs.PatientAttrs.CLLPCardNum <> '' then
    MemIni.WriteString( 'Patient', 'CardNum', K_CMSCLLAttrs.PatientAttrs.CLLPCardNum );
  if K_CMSCLLAttrs.PatientAttrs.CLLPTitle <> '' then
    MemIni.WriteString( 'Patient', 'Title', K_CMSCLLAttrs.PatientAttrs.CLLPTitle );
  if K_CMSCLLAttrs.PatientAttrs.CLLPSurname <> '' then
    MemIni.WriteString( 'Patient', 'Name', K_CMSCLLAttrs.PatientAttrs.CLLPSurname );
  if K_CMSCLLAttrs.PatientAttrs.CLLPFirstname <> '' then
    MemIni.WriteString( 'Patient', 'FirstName', K_CMSCLLAttrs.PatientAttrs.CLLPFirstname );
  if K_CMSCLLAttrs.PatientAttrs.CLLPAddr1 <> '' then
    MemIni.WriteString( 'Patient', 'Address1', K_CMSCLLAttrs.PatientAttrs.CLLPAddr1 );
  if K_CMSCLLAttrs.PatientAttrs.CLLPAddr2 <> '' then
    MemIni.WriteString( 'Patient', 'Address2', K_CMSCLLAttrs.PatientAttrs.CLLPAddr2 );
  if K_CMSCLLAttrs.PatientAttrs.CLLPPostCode <> '' then
    MemIni.WriteString( 'Patient', 'ZipCode', K_CMSCLLAttrs.PatientAttrs.CLLPPostCode );
  if K_CMSCLLAttrs.PatientAttrs.CLLPSuburb <> '' then
    MemIni.WriteString( 'Patient', 'Town', K_CMSCLLAttrs.PatientAttrs.CLLPSuburb );
  if K_CMSCLLAttrs.PatientAttrs.CLLPPhone1 <> '' then
    MemIni.WriteString( 'Patient', 'Phone1', K_CMSCLLAttrs.PatientAttrs.CLLPPhone1 );
  if K_CMSCLLAttrs.PatientAttrs.CLLPPhone2 <> '' then
    MemIni.WriteString( 'Patient', 'Phone2', K_CMSCLLAttrs.PatientAttrs.CLLPPhone2 );
  if K_CMSCLLAttrs.PatientAttrs.CLLPState <> '' then
    MemIni.WriteString( 'Patient', 'State', K_CMSCLLAttrs.PatientAttrs.CLLPState );
  if K_CMSCLLAttrs.PatientAttrs.CLLPDOB <> 0 then
    MemIni.WriteString( 'Patient', 'BirthDate', DateToStr(K_CMSCLLAttrs.PatientAttrs.CLLPDOB, N_WinFormatSettings )  );

  if K_CMSCLLAttrs.ProviderAttrs.CLLUID <> -1 then
  begin
    MemIni.WriteInteger( 'Dentist', 'ID', K_CMSCLLAttrs.ProviderAttrs.CLLUID );
    if K_CMSCLLAttrs.ProviderAttrs.CLLUTitle <> '' then
      MemIni.WriteString( 'Dentist', 'Title', K_CMSCLLAttrs.ProviderAttrs.CLLUTitle );
    if K_CMSCLLAttrs.ProviderAttrs.CLLUSurname <> '' then
      MemIni.WriteString( 'Dentist', 'Name', K_CMSCLLAttrs.ProviderAttrs.CLLUSurname );
    if K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname <> '' then
      MemIni.WriteString( 'Dentist', 'FirstName', K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname );
  end;

  if K_CMSCLLAttrs.LocationAttrs.CLLLID <> -1 then
  begin
    MemIni.WriteInteger( 'Practice', 'ID', K_CMSCLLAttrs.LocationAttrs.CLLLID );
    if K_CMSCLLAttrs.LocationAttrs.CLLLName <> '' then
      MemIni.WriteString( 'Practice', 'Name', K_CMSCLLAttrs.LocationAttrs.CLLLName );
  end;

  if K_CMSCLLAttrs.CodePage > 0  then
  begin
    MemIni.WriteInteger( 'Common', 'CodePage', K_CMSCLLAttrs.CodePage );
  end;

  K_CMEDAccess.TmpStrings.Clear();
  MemIni.GetStrings( K_CMEDAccess.TmpStrings );
  AFName := K_ExpandFileName(AFName);
  N_Dump1Str( 'CLL Info to >> ' + AFName );
  N_Dump1Strings( K_CMEDAccess.TmpStrings, 5 );
  try
    K_ForceFilePath( AFName );
    K_VFSaveStrings( K_CMEDAccess.TmpStrings, AFName, K_DFCreateEncrypted );
    Result := TRUE;
  except
  end;
  MemIni.Free;
end; // function K_CMSCLLContextToIniFile

//****************************************** K_CMSCLLContextFromCommandLine ***
// Parse CMS Command Line context
//
//     Parameters
// Result - Returns TRUE if Command Line is Valid
//
function K_CMSCLLContextFromCommandLine( ) : Boolean;
var
  ParCount, i, Ind, ParKeyVPos, ParKeyEPos  : Integer;
  FName : string;
  ParKey, ParKeyVal, ParValue :string;
  PrevVWParType : Integer;
  ParseUDFResult : Integer;

  procedure WrongIniFileMessage();
  begin
    K_CMShowMessageDlg( format( K_CML1Form.LLLLinks1.Caption + ' ' + K_CML1Form.LLLPressOkToClose.Caption,
//          'The file with link parameters "%s" is missing or corrupted. Press OK to close Media Suite',
                        [FName] ), mtWarning );
  end; // procedure WrongIniFileMessage

  function CheckPatientID() : Boolean;
  begin
    Result := K_CMSCLLAttrs.PatientAttrs.CLLPID <> -1;
    if Result then
    begin
      Include( K_CMEDAccess.UpdatePPLFlagsSet, K_uliPatients );
      K_CMSAppStartContext.CMASPatID := K_CMSCLLAttrs.PatientAttrs.CLLPID;
//    end
//    else
//    begin
//      K_CMShowMessageDlg( 'The patient ID is invalid. Click OK to close Media Suite SQL',
//                          mtWarning );
    end;
  end; // function CheckPatientID

  function CheckProviderID() : Boolean;
  begin
    Result := K_CMSCLLAttrs.ProviderAttrs.CLLUID <> -1;
    if Result then
    begin
      Include( K_CMEDAccess.UpdatePPLFlagsSet, K_uliProviders );
      K_CMSAppStartContext.CMASProvID := K_CMSCLLAttrs.ProviderAttrs.CLLUID;
    end
  end; // function CheckProviderID

  function CheckLocationID() : Boolean;
  begin
    Result := K_CMSCLLAttrs.LocationAttrs.CLLLID <> -1;
    if Result then
    begin
      Include( K_CMEDAccess.UpdatePPLFlagsSet, K_uliLocations );
      K_CMSAppStartContext.CMASLocID := K_CMSCLLAttrs.LocationAttrs.CLLLID;
    end
  end; // function CheckLocationID

  function TryToUseIniFile() : Boolean;
  var
    RCode : Integer;
  begin
    Result := FALSE;
    RCode := K_CMSCLLContextFromIniFile( FName, FALSE );
    if RCode > 0 then
    begin
      WrongIniFileMessage();
      Exit;
    end;

    if K_CMSCLLAttrs.PatientAttrs.CLLPSurname = '' then
    begin
      K_CMShowMessageDlg( K_CML1Form.LLLLinks2.Caption + ' ' + K_CML1Form.LLLPressOkToClose.Caption,
//                         'Patient Surname is missing in the file. Click OK to close Media Suite',
                           mtWarning );
      Exit;
    end;

    Result := TRUE;

    CheckProviderID();

    CheckLocationID();
  end; // function TryToUseIniFile
{
  function TryToUseIniFile() : Boolean;
  var
    MemIni : TMemIniFile;
  begin
    Result := FALSE;
    if not FileExists( FName ) then
    begin
      WrongIniFileMessage();
      Exit;
    end;

    // Try to Load MemIni
    try
      MemIni := nil;
      if not K_LoadMemIniFromFile( MemIni, FName ) then
      begin
        FreeAndNil(MemIni);
        WrongIniFileMessage();
        Exit;
      end;
    except
      FreeAndNil(MemIni);
      WrongIniFileMessage();
      Exit;
    end;

    MemIni.GetStrings( K_CMEDAccess.TmpStrings );
    N_Dump2Str( 'CMDL Ini file: ' + FName ); // Command Line Ini File
    N_Dump2Strings( K_CMEDAccess.TmpStrings, 5 ); // Command Line Ini File

    // Parse MemIni
    K_CMSCLLAttrs.PatientAttrs.CLLPID := MemIni.ReadInteger( 'Patient', 'ID', -1 );
    K_CMSCLLAttrs.PatientAttrs.CLLPSurname := MemIni.ReadString( 'Patient', 'Name', '' );
    if K_CMSCLLAttrs.PatientAttrs.CLLPSurname = '' then
    begin
      K_CMShowMessageDlg( 'Patient Surname is missing in the file. Click OK to close Media Suite SQL',
                           mtWarning );
      FreeAndNil(MemIni);
      Exit;
    end;
    Result := TRUE;
    K_CMSCLLAttrs.PatientAttrs.CLLPCardNum := MemIni.ReadString( 'Patient', 'CardNum', '' );
    K_CMSCLLAttrs.PatientAttrs.CLLPTitle := MemIni.ReadString( 'Patient', 'Title', '' );
    K_CMSCLLAttrs.PatientAttrs.CLLPFirstname := MemIni.ReadString( 'Patient', 'FirstName', '' );
    K_CMSCLLAttrs.PatientAttrs.CLLPAddr1 := MemIni.ReadString( 'Patient', 'Address1', '' );
    K_CMSCLLAttrs.PatientAttrs.CLLPAddr2 := MemIni.ReadString( 'Patient', 'Address2', '' );
    K_CMSCLLAttrs.PatientAttrs.CLLPPostCode := MemIni.ReadString( 'Patient', 'ZipCode', '' );
    K_CMSCLLAttrs.PatientAttrs.CLLPSuburb := MemIni.ReadString( 'Patient', 'Town', '' );
    K_CMSCLLAttrs.PatientAttrs.CLLPPhone1 := MemIni.ReadString( 'Patient', 'Phone1', '' );
    K_CMSCLLAttrs.PatientAttrs.CLLPPhone2 := MemIni.ReadString( 'Patient', 'Phone2', '' );
    K_CMSCLLAttrs.PatientAttrs.CLLPDOB := StrToDateDef(
                  MemIni.ReadString( 'Patient', 'BirthDate', '' ), 0, N_WinFormatSettings );
    K_CMSCLLAttrs.PatientAttrs.CLLPState := MemIni.ReadString( 'Patient', 'State', '' );

    K_CMSCLLAttrs.ProviderAttrs.CLLUID := MemIni.ReadInteger( 'Dentist', 'ID', -1 );
    CheckProviderID();
    K_CMSCLLAttrs.ProviderAttrs.CLLUTitle := MemIni.ReadString( 'Dentist', 'Title', '' );
    K_CMSCLLAttrs.ProviderAttrs.CLLUSurname := MemIni.ReadString( 'Dentist', 'Name', '' );
    K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname := MemIni.ReadString( 'Dentist', 'FirstName', '' );

    K_CMSCLLAttrs.LocationAttrs.CLLLID := MemIni.ReadInteger( 'Practice', 'ID', -1 );
    CheckLocationID();
    K_CMSCLLAttrs.LocationAttrs.CLLLName := MemIni.ReadString( 'Practice', 'Name', '' );
    K_CMSCLLAttrs.CodePage := MemIni.ReadInteger( 'Common', 'CodePage', 0 ); // <CodePage>


    FreeAndNil(MemIni);

  end;
}

  function CheckVWKey( const AKey :  string ) : Integer;
  begin
     Result := -1;
     if SameText( '-I', AKey ) then
       Result := 0
     else
     if SameText( '-N', AKey ) then
       Result := 1
     else
     if SameText( '-C', AKey ) then
       Result := 2;
  end; // function CheckVWKey

  function SetUDFormatValue() : Integer;
  begin
    Result := 0;
    if ParKeyVal = '<PatID>' then
    begin
      K_CMSCLLAttrs.PatientAttrs.CLLPID := StrToIntDef( ParValue, -1); // <PatID>
      if not CheckPatientID() then Result := 1;
    end
    else
    if ParKeyVal = '<PatSurname>' then
    begin
      K_CMSCLLAttrs.PatientAttrs.CLLPSurname := ParValue; // <PatSurname>
    end
    else
    if ParKeyVal = '<PatFirstName>' then
    begin
      K_CMSCLLAttrs.PatientAttrs.CLLPFirstname := ParValue; // <PatFirstName>
    end
    else
    if ParKeyVal = '<PatCard>' then
    begin
      K_CMSCLLAttrs.PatientAttrs.CLLPCardNum := ParValue; // <PatCard>
    end
    else
    if (ParKeyVal = '<PatientDOB>') or
       (ParKeyVal = '<PatDOB>') then
    begin
      K_CMSCLLAttrs.PatientAttrs.CLLPDOB := K_CMSCLLDOBFromText( ParValue ); // "<PatientDOB>"
//              StrToDateDef( ParValue, 0, N_WinFormatSettings ); // "<PatientDOB>"
    end
    else
    if ParKeyVal = '<ProvID>' then
    begin
      K_CMSCLLAttrs.ProviderAttrs.CLLUID := StrToIntDef( ParValue, -1); // <ProvID>
      CheckProviderID();
    end
    else
    if ParKeyVal = '<ProvSurname>' then
    begin
      K_CMSCLLAttrs.ProviderAttrs.CLLUSurname := ParValue; // <ProvSurname>
    end
    else
    if ParKeyVal = '<ProvFirstName>' then
    begin
      K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname := ParValue; // <ProvFirstName>
    end
    else
    if ParKeyVal = '<LocID>' then
    begin
      K_CMSCLLAttrs.LocationAttrs.CLLLID := StrToIntDef( ParValue, -1); // <ProvID>
      CheckLocationID();
    end
    else
    if ParKeyVal = '<LocName>' then
    begin
      K_CMSCLLAttrs.LocationAttrs.CLLLName := ParValue; // <ProvSurname>
    end
    else
    if ParKeyVal = '<CP>' then
    begin
      K_CMSCLLAttrs.CodePage := StrToIntDef( ParValue, 0); // <CodePage>
    end
    else
      Result := 2;
  end; // function SetUDFormatValue()

  function ParseUDFormat : Integer;
  begin
    Result := 0;
    ParKeyEPos := N_PosEx( '<', K_CMSLinkCommandLineUDFormat, ParKeyVPos, Length(K_CMSLinkCommandLineUDFormat) );
    if (ParKeyEPos = 0) or (ParKeyEPos - ParKeyVPos > 5)  then
      Result := 1
    else
    begin
    // Continue user defind format parsing
      ParKeyVPos := ParKeyEPos;
      ParKeyEPos := N_PosEx( '>', K_CMSLinkCommandLineUDFormat, ParKeyVPos + 1, Length(K_CMSLinkCommandLineUDFormat) );
      if ParKeyVPos = 0 then
        Result := 2
      else
      // Parse Command Line Key Value
        ParKeyVal := copy( K_CMSLinkCommandLineUDFormat, ParKeyVPos, ParKeyEPos - ParKeyVPos + 1 );
    end;
  end; // function ParseUDFormat

begin
  Result := FALSE;

  // Init CLL Data
  K_CMSCLLContextInit( );

  K_CMEDAccess.UpdatePPLFlagsSet := [];

  ParCount := K_CMDParams.Count;
  N_Dump1Str( format( 'CMDL F=%d Params >> %s', [Ord(K_CMSLinkCommandLineFormatMode), K_CMDParams.CommaText] ) ); // Application Command Line
  if ParCount = 0 then Exit;

  if K_CMSLinkCommandLineFormatMode = K_cmclfCL2000 then
  begin
  /////////////////////////////////
  // CL2000 Command Line Format
  //
    for i := 0 to ParCount - 1 do
    begin
      case i of
      0: begin
        K_CMSCLLAttrs.PatientAttrs.CLLPID := StrToIntDef( K_CMDParams[0], -1); // <PatID>
        Result := CheckPatientID();
        if not Result then break;
      end;
      1: K_CMSCLLAttrs.PatientAttrs.CLLPSurname    := K_CMDParams[1]; // "<PatSurname>"
      2: K_CMSCLLAttrs.PatientAttrs.CLLPFirstname  := K_CMDParams[2]; // "<PatFirstName>"
      3: K_CMSCLLAttrs.PatientAttrs.CLLPDOB        := K_CMSCLLDOBFromText( K_CMDParams[3] ); // "<PatientDOB>"
//      StrToDateDef( K_CMDParams[3], 0, N_WinFormatSettings ); // "<PatientDOB>"
      4: K_CMSCLLAttrs.PatientAttrs.CLLPCardNum    := K_CMDParams[4]; // "<PatCard>"
      5: begin
        K_CMSCLLAttrs.ProviderAttrs.CLLUID        := StrToIntDef( K_CMDParams[5], -1); // <ProvID>
        CheckProviderID();
      end;
      6: K_CMSCLLAttrs.ProviderAttrs.CLLUSurname   := K_CMDParams[6]; // "<ProvSurname>"
      7: K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname := K_CMDParams[7]; // "<ProvFirstName>"
      8: begin
        K_CMSCLLAttrs.LocationAttrs.CLLLID        := StrToIntDef( K_CMDParams[8], -1); // <LocID>
        CheckLocationID();
      end;
      9: K_CMSCLLAttrs.LocationAttrs.CLLLName      := K_CMDParams[9]; // "<LocName>"
     10: K_CMSCLLAttrs.CodePage                    := StrToIntDef( K_CMDParams[10], 0); // <CodePage>
      end;
    end;
  //
  // CL2000 Command Line Format
  /////////////////////////////////
  end
  else
  if K_CMSLinkCommandLineFormatMode = K_cmclfVW then
  begin
  /////////////////////////////////
  // VW Command Line Format
  //
    i := 0;
    while i <= ParCount - 2 do
    begin
      PrevVWParType := CheckVWKey( K_CMDParams[i] );
      case PrevVWParType of
        0 : begin
          K_CMSCLLAttrs.PatientAttrs.CLLPID := StrToIntDef( K_CMDParams[i+1], -1); // <PatID>
          Inc(i,2);
        end;
        1 : begin
          K_CMSCLLAttrs.PatientAttrs.CLLPSurname := K_CMDParams[i+1]; // "<PatSurname>"
          Inc( i );
          if (i <= ParCount - 2) and
             (CheckVWKey( K_CMDParams[i+1] ) < 0) then
          begin
            K_CMSCLLAttrs.PatientAttrs.CLLPFirstname := K_CMDParams[i+1]; // "<PatFirstName>"
            Inc(i);
          end;
          Inc(i);
        end;
        2 : begin
          K_CMSCLLAttrs.CodePage := StrToIntDef( K_CMDParams[i+1], 0); // <CodePage>
          Inc(i,2);
        end;
      else
        Inc(i);
      end;
    end;
    Result := CheckPatientID();
{
    for i := 0 to ParCount - 1 do
    begin
      case i of
      0: if not SameText( '-I', K_CMDParams[0] ) then
         begin
           K_CMShowMessageDlg( 'The patient ID is not specified. Click OK to close Media Suite SQL',
                          mtWarning );
           break;
         end;
      1: begin
        K_CMSCLLAttrs.PatientAttrs.CLLPID := StrToIntDef( K_CMDParams[1], -1); // <PatID>
        Result := CheckPatientID();
        if not Result then break;
      end;
      2: if not SameText( '-N', K_CMDParams[2] ) then Exit;
      3: K_CMSCLLAttrs.PatientAttrs.CLLPSurname    := K_CMDParams[3]; // "<PatSurname>"
      4: K_CMSCLLAttrs.PatientAttrs.CLLPFirstname  := K_CMDParams[4]; // "<PatFirstName>"
      5: if not SameText( '-C', K_CMDParams[5] ) then Exit;
      6: K_CMSCLLAttrs.CodePage := StrToIntDef( K_CMDParams[6], 0); // <CodePage>
      end;
    end;
}
  //
  // VW Command Line Format
  /////////////////////////////////
  end
  else
  if K_CMSLinkCommandLineFormatMode = K_cmclfIni then
  begin
  /////////////////////////////////
  // Ini Command Line Format
  //
    for i := 0 to ParCount - 1 do
    begin
      case i of
      0: begin
        K_CMSCLLAttrs.PatientAttrs.CLLPID := StrToIntDef( K_CMDParams[0], -1); // <PatID>
        Result := CheckPatientID();
        if not Result then break;
      end;
//      1: if not SameText( '-A:', K_CMDParams[1] ) then
//      begin
//        WrongIniFileMessage();
//        break;
//      end;
      1: begin
        FName := K_CMDParams[1];
        if not K_StrStartsWith( '-A:', FName ) then
        begin
          WrongIniFileMessage();
          break;
        end;
        if Length(FName) = 3 then Continue;
        FName := Copy( FName, 4, Length(FName) );
        if FName[1] = '"' then // FileName in Quotes
          FName := Copy( FName, 2, Length(FName) - 2 );
        Result := TryToUseIniFile();
        break;
      end;
      2: begin
        FName := K_ExpandFileName( K_CMDParams[2] );
        Result := TryToUseIniFile();
        break;
       end;
      end;
    end;
  //
  // Ini Command Line Format
  /////////////////////////////////
  end
  else
  if K_CMSLinkCommandLineFormatMode = K_cmclfUDVW then
  begin
  /////////////////////////////////
  // User Defined Command Line Format
  //
    if K_CMSLinkCommandLineUDFormat = '' then
    begin
      K_CMShowMessageDlg( K_CML1Form.LLLLinks3.Caption + ' ' + K_CML1Form.LLLPressOKToContinue.Caption,
//                          'User defined Command Line is not specified. Click OK to continue',
                               mtWarning );
      Exit;
    end;

    N_Dump1Str( 'CMDL UDFormat >> ' + K_CMSLinkCommandLineUDFormat ); // Command Line UD format
    if Pos( '"', K_CMSLinkCommandLineUDFormat ) > 0 then
    begin // key based User Defined Format
      ParCount := ParCount shr 1;
      for i := 0 to ParCount - 1 do
      begin
        Ind := i * 2;
        ParKey := K_CMDParams[Ind];
        if Ind + 1 >= K_CMDParams.Count then
        begin
          K_CMShowMessageDlg( format( K_CML1Form.LLLLinks4.Caption + ' ' + K_CML1Form.LLLPressOKToContinue.Caption,
  //          'Value for last command line key "%s" is absent. Click OK to continue',
                              [ParKey] ), mtWarning );
          break;
        end;

        ParKeyVPos := N_PosEx( '"' + ParKey + '"', K_CMSLinkCommandLineUDFormat, 1, Length(K_CMSLinkCommandLineUDFormat) );
        if ParKeyVPos = 0 then
          K_CMShowMessageDlg( format( K_CML1Form.LLLLinks5.Caption + ' ' + K_CML1Form.LLLPressOKToContinue.Caption,
  //           'Wrong command line key "%s" is found. Click OK to continue',
                              [ParKey] ), mtWarning )
        else
        begin
        // Start user defind format parsing
          ParKeyVPos := ParKeyVPos + Length(ParKey) + 2;
          ParseUDFResult := ParseUDFormat();
          if ParseUDFResult = 1 then
            K_CMShowMessageDlg( format( K_CML1Form.LLLLinks6.Caption + ' ' + K_CML1Form.LLLPressOKToContinue.Caption,
  //             'Wrong user defined command line format in position %d near key "%s" is found. Click OK to continue',
                                        [ParKeyVPos, ParKey] ), mtWarning )
          else
          if ParseUDFResult = 2 then
              K_CMShowMessageDlg( format( K_CML1Form.LLLLinks6.Caption + ' ' + K_CML1Form.LLLPressOKToContinue.Caption,
  //            'Wrong user defined command line format in position %d near key "%s" is found. Click OK to continue',
                                          [ParKeyVPos, ParKey] ), mtWarning )
          else
          begin
            ParValue := K_CMDParams[Ind + 1];
            N_Dump1Str( format( 'CMDL UDFormat >> parsed key "%s"="%s" value="%s"', [ParKey,ParKeyVal,ParValue] ) ); // Command Line UD format
            case SetUDFormatValue() of
//            0: Continue;
            1: Break;
            2: K_CMShowMessageDlg( format( K_CML1Form.LLLLinks7.Caption + ' ' + K_CML1Form.LLLPressOKToContinue.Caption,
  //                'Wrong user defind value "%s" for key "%s" is found. Click OK to continue',
                                          [ParKey, ParKeyVal] ),  mtWarning );
            end;
          end; // end of Parse Command Line Key Value
        end; // end of Start user defind format parsing
      end; // for i := 0 to ParCount - 1 do
    end
    else
    begin // position based User Defined Format
      ParKeyVPos := 1;
      for i := 0 to ParCount - 1 do
      begin
        ParKeyVPos := ParKeyEPos + 1;
        ParseUDFResult := ParseUDFormat();
        if ParseUDFResult = 1 then
          K_CMShowMessageDlg( format( 'Wrong user defined command line format in position %d is found. Click OK to continue',
                                      [ParKeyVPos] ), mtWarning )
        else
        if ParseUDFResult = 2 then
            K_CMShowMessageDlg( format('Wrong user defined command line format in position %d is found. Click OK to continue',
                                        [ParKeyVPos] ), mtWarning )
        else
        begin
          ParValue := K_CMDParams[i];
          N_Dump1Str( format( 'CMDL UDFormat >> parsed %s="%s"', [ParKeyVal,ParValue] ) ); // Command Line UD format
          case SetUDFormatValue() of
//          0: Continue;
          1: Break;
          2: K_CMShowMessageDlg( format( 'Wrong user defined key "%s" is found. Click OK to continue',
                                        [ParKeyVal] ),  mtWarning );
          end;
        end;
      end;
    end;
    Result := CheckPatientID();
  //
  // User Defined Command Line Format
  /////////////////////////////////
  end;

///////////////////////////////
// Check Results
  if K_CMSCLLAttrs.PatientAttrs.CLLPID <> -1 then Exit;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPCardNum) > 20 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPCardNum := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPCardNum, 1, 20 );
    N_Dump1Str( format( 'CMDL Patient CardNum cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPCardNum] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPTitle) > 20 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPTitle := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPTitle, 1, 20 );
    N_Dump1Str( format( 'CMDL Patient Title cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPTitle] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPSurname) > 40 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPSurname := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPSurname, 1, 40 );
    N_Dump1Str( format( 'CMDL Patient Surname cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPSurname] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPFirstname) > 40 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPFirstname := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPFirstname, 1, 40 );
    N_Dump1Str( format( 'CMDL Patient Firstname cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPFirstname] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPAddr1) > 100 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPAddr1 := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPAddr1, 1, 100 );
    N_Dump1Str( format( 'CMDL Patient Addr1 cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPAddr1] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPAddr2) > 100 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPAddr2 := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPAddr2, 1, 100 );
    N_Dump1Str( format( 'CMDL Patient Addr2 cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPAddr2] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPPostCode) > 10 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPPostCode := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPPostCode, 1, 10 );
    N_Dump1Str( format( 'CMDL Patient PostCode cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPPostCode] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPSuburb) > 100 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPSuburb := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPSuburb, 1, 100 );
    N_Dump1Str( format( 'CMDL Patient Suburb cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPSuburb] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPPhone1) > 40 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPPhone1 := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPPhone1, 1, 40 );
    N_Dump1Str( format( 'CMDL Patient Phone1 cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPPhone1] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPPhone2) > 40 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPPhone2 := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPPhone2, 1, 40 );
    N_Dump1Str( format( 'CMDL Patient Phone2 cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPPhone2] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPPhone2) > 40 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPPhone2 := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPPhone2, 1, 40 );
    N_Dump1Str( format( 'CMDL Patient Phone2 cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPPhone2] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPState) > 20 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPState := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPState, 1, 20 );
    N_Dump1Str( format( 'CMDL Patient State cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPState] ) );
  end;
  if Length(K_CMSCLLAttrs.PatientAttrs.CLLPGender) > 1 then
  begin
    K_CMSCLLAttrs.PatientAttrs.CLLPGender := Copy( K_CMSCLLAttrs.PatientAttrs.CLLPGender, 1, 1 );
    N_Dump1Str( format( 'CMDL Patient State cut to "%s"', [K_CMSCLLAttrs.PatientAttrs.CLLPGender] ) );
  end;

  if K_CMSCLLAttrs.ProviderAttrs.CLLUID <>  -1 then
  begin
    if Length(K_CMSCLLAttrs.ProviderAttrs.CLLUTitle) > 20 then
    begin
      K_CMSCLLAttrs.ProviderAttrs.CLLUTitle := Copy( K_CMSCLLAttrs.ProviderAttrs.CLLUTitle, 1, 20 );
      N_Dump1Str( format( 'CMDL Provider Title cut to "%s"', [K_CMSCLLAttrs.ProviderAttrs.CLLUTitle] ) );
    end;
    if Length(K_CMSCLLAttrs.ProviderAttrs.CLLUSurname) > 40 then
    begin
      K_CMSCLLAttrs.ProviderAttrs.CLLUSurname := Copy( K_CMSCLLAttrs.ProviderAttrs.CLLUSurname, 1, 40 );
      N_Dump1Str( format( 'CMDL Provider Surname cut to "%s"', [K_CMSCLLAttrs.ProviderAttrs.CLLUSurname] ) );
    end;
    if Length(K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname) > 40 then
    begin
      K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname := Copy( K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname, 1, 40 );
      N_Dump1Str( format( 'CMDL Provider Firstname cut to "%s"', [K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname] ) );
    end;
  end;

  if K_CMSCLLAttrs.LocationAttrs.CLLLID <> -1 then
  begin
    if Length(K_CMSCLLAttrs.LocationAttrs.CLLLName) > 40 then
    begin
      K_CMSCLLAttrs.LocationAttrs.CLLLName := Copy( K_CMSCLLAttrs.LocationAttrs.CLLLName, 1, 40 );
      N_Dump1Str( format( 'CMDL Location Name cut to "%s"', [K_CMSCLLAttrs.LocationAttrs.CLLLName] ) );
    end;
  end;

end; // function K_CMSCLLContextFromCommandLine

//*********************************************** K_CMSCLLContextFromEDAPPL ***
// Get CMS Command Line context
//
//     Parameters
// Result - Returns Patient/Provider/Location Start Context Flags Set
//
procedure K_CMSCLLContextFromEDAPPL( ALocID, AProvID, APatID : Integer );
var
  FieldInd, RowInd  : Integer;
  SID : string;

begin
  K_CMSCLLContextInit( );

  with K_CMEDAccess do
  begin
    if K_uliLocations in K_CMEDAccess.UpdatePPLFlagsSet then
    begin
      if ALocID > 0 then
      begin
      // Set Location CLL Update Info
        K_CMSCLLAttrs.LocationAttrs.CLLLID := ALocID;
        SID := IntToStr( K_CMSCLLAttrs.LocationAttrs.CLLLID );
        RowInd := EDAArchUDTabIndexOf( SID, LocationsInfo );
        if RowInd < 1 then
        begin
        // Info for given ID is absent
          Exclude( K_CMEDAccess.UpdatePPLFlagsSet, K_uliLocations );
          N_Dump1Str( format( '!!!K_CMSCLLContextFromEDAPPL >> Location ID=%s INFO is absent in D4W link data', [SID] ) );
        end   // if RowInd < 1 then
        else
        begin // if RowInd >= 1 then
          // Location Title
          FieldInd := EDAArchUDTabFieldIndex( 'LocationTitle', LocationsInfo, FALSE );
          if FieldInd < 0 then
           // LocationTitle is absent
            Exclude( K_CMEDAccess.UpdatePPLFlagsSet, K_uliLocations )
          else
            K_CMSCLLAttrs.LocationAttrs.CLLLName := PString(LocationsInfo.R.PME(FieldInd, RowInd))^;

          // Location CustRefN
          FieldInd := EDAArchUDTabFieldIndex( 'LocationRef#', LocationsInfo, FALSE );
          if FieldInd >= 0 then
            K_CMSCLLAttrs.LocationAttrs.CLLLCustRefN := PString(LocationsInfo.R.PME(FieldInd, RowInd))^;
//            K_CMSCLLAttrs.LocationAttrs.CLLLCustRefN := StrToIntDef( PString(LocationsInfo.R.PME(FieldInd, RowInd))^, 0 );
        end;  // if RowInd >= 1 then
      end // if ALocID > 0 then
      else
        Exclude( K_CMEDAccess.UpdatePPLFlagsSet, K_uliLocations )
    end; // if K_uliLocations in K_CMEDAccess.UpdatePPLFlagsSet then

    if K_uliProviders in K_CMEDAccess.UpdatePPLFlagsSet then
    begin
      if AProvID > 0 then
      begin
      // Set Provider CLL Update Info
        K_CMSCLLAttrs.ProviderAttrs.CLLUID := AProvID;
        SID := IntToStr( K_CMSCLLAttrs.ProviderAttrs.CLLUID );
        RowInd := EDAArchUDTabIndexOf( SID, ProvidersInfo );
        if RowInd < 1 then
        begin
        // Info for given ID is absent
          Exclude( K_CMEDAccess.UpdatePPLFlagsSet, K_uliProviders );
          N_Dump1Str( format( '!!!K_CMSCLLContextFromEDAPPL >> Provider ID=%s INFO is absent in D4W link data', [SID] ) );
        end  // if RowInd < 1 then
        else
          // Get Providers Info
          with ProvidersInfo.R do
          begin
            FieldInd := EDAArchUDTabFieldIndex( 'ProviderFirstName', ProvidersInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname := PString(PME(FieldInd, RowInd))^;

            FieldInd := EDAArchUDTabFieldIndex( 'ProviderSurname', ProvidersInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.ProviderAttrs.CLLUSurname := PString(PME(FieldInd, RowInd))^;

            FieldInd := EDAArchUDTabFieldIndex( 'ProviderTitle', ProvidersInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.ProviderAttrs.CLLUTitle := PString(PME(FieldInd, RowInd))^;

            FieldInd := EDAArchUDTabFieldIndex( 'ProviderFlags', ProvidersInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.ProviderAttrs.CLLUAuthorities := StrToIntDef( PString(PME(FieldInd, RowInd))^, 2047 );
          end; // with ProvidersInfo.R do
      end // if AProvID > 0 then
      else
        Exclude( K_CMEDAccess.UpdatePPLFlagsSet, K_uliProviders )
    end; // if K_uliProviders in K_CMEDAccess.UpdatePPLFlagsSet then

    if K_uliPatients in K_CMEDAccess.UpdatePPLFlagsSet then
    begin
    // Set Patient CLL Update Info
      if APatID > 0 then
      begin
        K_CMSCLLAttrs.PatientAttrs.CLLPID := APatID;
        SID := IntToStr( K_CMSCLLAttrs.PatientAttrs.CLLPID );
        RowInd := EDAArchUDTabIndexOf( SID, PatientsInfo );
        if RowInd < 1 then
        begin
        // Info for given ID is absent
          Exclude( K_CMEDAccess.UpdatePPLFlagsSet, K_uliPatients );
          N_Dump1Str( format( '!!!K_CMSCLLContextFromEDAPPL >> Patient ID=%s INFO is absent in D4W link data', [SID] ) );
        end  // if RowInd < 1 then
        else
          with PatientsInfo.R do
          begin
            FieldInd := EDAArchUDTabFieldIndex( 'PatientCardNumber', PatientsInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.PatientAttrs.CLLPCardNum := PString(PME(FieldInd, RowInd))^;

            FieldInd := EDAArchUDTabFieldIndex( 'PatientFirstName', PatientsInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.PatientAttrs.CLLPFirstname := PString(PME(FieldInd, RowInd))^;

            FieldInd := EDAArchUDTabFieldIndex( 'PatientSurname', PatientsInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.PatientAttrs.CLLPSurname := PString(PME(FieldInd, RowInd))^;

            FieldInd := EDAArchUDTabFieldIndex( 'PatientTitle', PatientsInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.PatientAttrs.CLLPTitle := PString(PME(FieldInd, RowInd))^;

            FieldInd := EDAArchUDTabFieldIndex( 'PatientDOB', PatientsInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.PatientAttrs.CLLPDOB := K_CMSCLLDOBFromText( PString(PME(FieldInd, RowInd))^ );
//              StrToDateDef( PString(PME(FieldInd, RowInd))^, 0, N_WinFormatSettings );

            FieldInd := EDAArchUDTabFieldIndex( 'PatientGender', PatientsInfo, FALSE );
            if FieldInd >= 0 then
              K_CMSCLLAttrs.PatientAttrs.CLLPGender := PString(PME(FieldInd, RowInd))^;
          end; // with PatientsInfo.R do
      end // if APatID > 0 then
      else
        Exclude( K_CMEDAccess.UpdatePPLFlagsSet, K_uliPatients )
    end; // if K_uliPatients in K_CMEDAccess.UpdatePPLFlagsSet then

  end;

end; // function K_CMSCLLContextFromEDAPPL

//***************************************** K_CMSCLLContextFromURLToIniFile ***
// Save launch context from URL to Ini-file
//
//     Parameters
// AFName - ini-file name
// Result - Returns TRUE if ini file was successfully created
//
function K_CMSCLLContextFromURLToIniFile( AFName :string ) : Boolean;
begin
  Result := FALSE;
  if K_CMSCLLAttrs.PatientAttrs.CLLPID = -1 then Exit;

  K_CMEDAccess.TmpStrings.Clear();

  K_CMEDAccess.TmpStrings.Add( '[Patient]' );
  K_CMEDAccess.TmpStrings.Add( 'ID=' + K_CMVUIURLList.Values['PatientID']);
  K_CMEDAccess.TmpStrings.Add( 'CardNum=' + K_CMVUIURLList.Values['PatientCardNum']);
// Gender is automatically detected by Title Mr - Male, Mrs - Female
  K_CMEDAccess.TmpStrings.Add( 'Title=' + K_CMVUIURLList.Values['PatientTitle']);
  K_CMEDAccess.TmpStrings.Add( 'Name=' + K_CMVUIURLList.Values['PatientSurName']);
  K_CMEDAccess.TmpStrings.Add( 'FirstName=' + K_CMVUIURLList.Values['PatientFirstName']);
  K_CMEDAccess.TmpStrings.Add( 'BirthDate=' + K_CMVUIURLList.Values['PatientDOB']);
  K_CMEDAccess.TmpStrings.Add( '' );
  K_CMEDAccess.TmpStrings.Add( '[Dentist]' );
  K_CMEDAccess.TmpStrings.Add( 'ID=' + K_CMVUIURLList.Values['DentistID']);
  K_CMEDAccess.TmpStrings.Add( 'Title=' + K_CMVUIURLList.Values['DentistTitle']);
  K_CMEDAccess.TmpStrings.Add( 'Name=' + K_CMVUIURLList.Values['DentistSurName']);
  K_CMEDAccess.TmpStrings.Add( 'FirstName=' + K_CMVUIURLList.Values['DentistFirstName']);
  K_CMEDAccess.TmpStrings.Add( '' );
  K_CMEDAccess.TmpStrings.Add( '[Practice]' );
  K_CMEDAccess.TmpStrings.Add( 'ID=' + K_CMVUIURLList.Values['PracticeID']);
  K_CMEDAccess.TmpStrings.Add( 'Name=' + K_CMVUIURLList.Values['PracticeName']);
{
  //   It is not needed now
  K_CMEDAccess.TmpStrings.Add( '' );
  K_CMEDAccess.TmpStrings.Add( '[Common]' );
  K_CMEDAccess.TmpStrings.Add( 'CodePage=' + IntToStr(K_CMSCLLAttrs.CodePage) );
}
  AFName := K_ExpandFileName(AFName);
  N_Dump1Str( 'URL Info to >> ' + AFName );
  N_Dump1Strings( K_CMEDAccess.TmpStrings, 5 );
  try
    K_ForceFilePath( AFName );
    K_VFSaveStrings( K_CMEDAccess.TmpStrings, AFName, K_DFCreateEncrypted );
    Result := TRUE;
  except
  end;
end; // function K_CMSCLLContextFromURLToIniFile

//************************************************** K_CMSCLLContextFromURL ***
// Save launch context from URL to CLL context
//
procedure K_CMSCLLContextFromURL( );
begin
  K_CMSCLLContextInit();
  K_CMSCLLAttrs.PatientAttrs.CLLPID := StrToIntDef( K_CMVUIURLList.Values['PatientID'],-1 );
  K_CMSCLLAttrs.PatientAttrs.CLLPCardNum := K_CMVUIURLList.Values['PatientCardNum'];
  K_CMSCLLAttrs.PatientAttrs.CLLPTitle := K_CMVUIURLList.Values['PatientTitle'];
  K_CMSCLLAttrs.PatientAttrs.CLLPGender := K_CMGetPatientGenderTextByTitle( K_CMSCLLAttrs.PatientAttrs.CLLPTitle );
  K_CMSCLLAttrs.PatientAttrs.CLLPSurname := K_CMVUIURLList.Values['PatientSurName'];
  K_CMSCLLAttrs.PatientAttrs.CLLPFirstname := K_CMVUIURLList.Values['PatientFirstName'];
  K_CMSCLLAttrs.PatientAttrs.CLLPDOB := K_CMSCLLDOBFromText( K_CMVUIURLList.Values['PatientDOB'] );

  K_CMSCLLAttrs.ProviderAttrs.CLLUID := StrToIntDef( K_CMVUIURLList.Values['DentistID'],-1 );
  K_CMSCLLAttrs.ProviderAttrs.CLLUTitle := K_CMVUIURLList.Values['DentistTitle'];
  K_CMSCLLAttrs.ProviderAttrs.CLLUSurname := K_CMVUIURLList.Values['DentistSurName'];
  K_CMSCLLAttrs.ProviderAttrs.CLLUFirstname := K_CMVUIURLList.Values['DentistFirstName'];

  K_CMSCLLAttrs.LocationAttrs.CLLLID := StrToIntDef( K_CMVUIURLList.Values['PracticeID'],-1 );
  K_CMSCLLAttrs.LocationAttrs.CLLLName := K_CMVUIURLList.Values['PracticeName'];
end; // procedure K_CMSCLLContextFromURL

{
//******************************************** K_CMUpdateEDAPPLByCLLContext ***
// Update CMS Patient|Provider|Location EDA Object Info by Command Line context
//
//     Parameters
// Result - Returns Patient/Provider/Location Start Context Flags Set
//
procedure K_CMUpdateEDAPPLByCLLContext( );
var
  i  : Integer;
  SID : string;
  FirstNameInd, SurnameInd, TitleInd, ProvFlagsInd, CardNumInd, DOBInd : Integer;

begin
  with K_CMEDAccess do
  begin
    if K_CMSCLLLocationAttrs.CLLLID <> -1 then
    begin
      with LocationsInfo.R do
      begin
        SID := IntToStr( K_CMSCLLLocationAttrs.CLLLID );
        if ALength() <= 1 then
//          EDASAGetLocationsInfo( FALSE );
        begin
          ASetLength( 2, 2 );
          PString(PME(0, 0))^ := 'LocationID';
          PString(PME(1, 0))^ := 'LocationTitle';
          TitleInd := 1;
        end
        else
          TitleInd := EDAArchUDTabFieldIndex( 'LocationTitle', LocationsInfo );

        i := EDAArchUDTabIndexOf( SID, LocationsInfo );
        if i = 0 then
        begin
          i := ARowCount;
          ASetLength( AColCount(), i + 1 );
          PString(PME(0, i))^ := SID;
        end;
        if K_CMSCLLLocationAttrs.CLLLName <> '' then
          PString(PME(TitleInd, i))^ := K_CMSCLLLocationAttrs.CLLLName;
      end;
    end;

    if K_CMSCLLProviderAttrs.CLLUID <> -1 then
    begin
      with ProvidersInfo.R do
      begin
//        if ALength() <= 1 then
//          EDASAGetProvidersInfo( FALSE );

        if ALength() <= 1 then
        begin
          ASetLength( 5, 2 );
          PString(PME(0, 0))^ := 'ProviderID';
          PString(PME(1, 0))^ := 'ProviderFirstName';
          PString(PME(2, 0))^ := 'ProviderSurname';
          PString(PME(3, 0))^ := 'ProviderTitle';
          PString(PME(4, 0))^ := 'ProviderFlags';
          FirstNameInd := 1;
          SurnameInd := 2;
          TitleInd := 3;
          ProvFlagsInd := 4;
        end
        else
        begin
          FirstNameInd := EDAArchUDTabFieldIndex( 'ProviderFirstName', ProvidersInfo );
          SurnameInd := EDAArchUDTabFieldIndex( 'ProviderSurname', ProvidersInfo );
          TitleInd := EDAArchUDTabFieldIndex( 'ProviderTitle', ProvidersInfo );
          ProvFlagsInd := EDAArchUDTabFieldIndex( 'ProviderFlags', ProvidersInfo );
        end;


        SID := IntToStr( K_CMSCLLProviderAttrs.CLLUID );
        i := EDAArchUDTabIndexOf( SID, ProvidersInfo );
        if i = 0 then
        begin
          i := ARowCount();
          ASetLength( AColCount(), i + 1 );
          PString(PME(0, i))^ := SID;
        end;
        if K_CMSCLLProviderAttrs.CLLUFirstname <> '' then
          PString(PME(FirstNameInd, i))^ := K_CMSCLLProviderAttrs.CLLUFirstname;
        if K_CMSCLLProviderAttrs.CLLUSurname <> '' then
          PString(PME(SurnameInd, i))^ := K_CMSCLLProviderAttrs.CLLUSurname;
        if K_CMSCLLProviderAttrs.CLLUTitle <> '' then
          PString(PME(TitleInd, i))^ := K_CMSCLLProviderAttrs.CLLUTitle;
        if PString(PME(ProvFlagsInd, i))^ = '' then
          PString(PME(ProvFlagsInd, i))^ := '2047';
      end;
    end;

    if K_CMSCLLPatientAttrs.CLLPID <> -1 then
    begin
      with PatientsInfo.R do
      begin
        if ALength() <= 1 then
//          EDASAGetPatientsInfo( FALSE );

        begin
          ASetLength( 7, 2 );
          PString(PME(0, 0))^ := 'PatientID';
          PString(PME(1, 0))^ := 'PatientCardNumber';
          PString(PME(2, 0))^ := 'PatientFirstName';
          PString(PME(3, 0))^ := 'PatientSurname';
          PString(PME(4, 0))^ := 'PatientTitle';
          PString(PME(5, 0))^ := 'PatientGender';
          PString(PME(6, 0))^ := 'PatientDOB';
          CardNumInd := 1;
          FirstNameInd := 2;
          SurnameInd := 3;
          TitleInd := 4;
          DOBInd := 6;
        end
        else
        begin
          CardNumInd := EDAArchUDTabFieldIndex( 'PatientCardNumber', PatientsInfo );
          FirstNameInd := EDAArchUDTabFieldIndex( 'PatientrFirstName', PatientsInfo );
          SurnameInd := EDAArchUDTabFieldIndex( 'PatientSurname', PatientsInfo );
          TitleInd := EDAArchUDTabFieldIndex( 'PatientTitle', PatientsInfo );
          DOBInd := EDAArchUDTabFieldIndex( 'PatientDOB', PatientsInfo );
        end;


        SID := IntToStr( K_CMSCLLPatientAttrs.CLLPID );
        i := EDAArchUDTabIndexOf( SID, PatientsInfo );
        if i = 0 then
        begin
          i := ARowCount;
          ASetLength( AColCount(), i + 1 );
          PString(PME(0, i))^ := SID;
        end;
        if K_CMSCLLPatientAttrs.CLLPCardNum <> '' then
          PString(PME(CardNumInd, i))^ := K_CMSCLLPatientAttrs.CLLPCardNum;
        if K_CMSCLLPatientAttrs.CLLPFirstname <> '' then
          PString(PME(FirstNameInd, i))^ := K_CMSCLLPatientAttrs.CLLPFirstname;
        if K_CMSCLLPatientAttrs.CLLPSurname <> '' then
          PString(PME(SurnameInd, i))^ := K_CMSCLLPatientAttrs.CLLPSurname;
        if K_CMSCLLPatientAttrs.CLLPTitle <> '' then
          PString(PME(TitleInd, i))^ := K_CMSCLLPatientAttrs.CLLPTitle;
        if K_CMSCLLPatientAttrs.CLLPDOB <> 0 then
          PString(PME(DOBInd, i))^ := K_DateTimeToStr( K_CMSCLLPatientAttrs.CLLPDOB, N_WinFormatSettings.ShortDateFormat );
      end;
    end;
  end;
end; // function K_CMUpdateEDAPPLByCLLContext
}
{ 14-07-2014 - moved to N_GRA3.N_CMDIBAdjustLight
//******************************************************* K_CMSE2VDIBAdjust ***
// Adjust E2V DIBObj
//
//     Parameters
// ADIBObj - given DIBObj to adjust (8 or 16 bit)
//
procedure K_CMSE2VDIBAdjust( var ADIBObj : TN_DIBObj );
var
  ILL, IUL, XLATLength : Integer;
  HistValues, XLAT : TN_IArray;
  WrkLLFactor, WrkULFactor : FLoat;
begin
  N_Dump2Str( 'K_CMSE2VDIBAdjust Start ' );

// Recalc WrkLLFactor and WrkLUFactor
  ADIBObj.CalcBrighHistNData( HistValues );
  N_HistFindLLUL2( HistValues, ILL, IUL );
  WrkLLFactor := ILL / High(HistValues) * 100;
  WrkULFactor := IUL / High(HistValues) * 100;
 
// Correct LL/LU to Initial Values if needed
  if (WrkLLFactor = 0) and (WrkULFactor = 100) then
    WrkULFactor := 0;

  XLATLength := 1 shl ADIBObj.DIBNumBits;
  SetLength( XLat, XLATLength );
  N_BCGImageXlatBuild( XLAT, XLATLength-1, 0, 0, -26.1, WrkLLFactor, WrkULFactor, FALSE );
  ADIBObj.CalcXLATDIB( ADIBObj, 0, @XLAT[0], 1, ADIBObj.DIBPixFmt, ADIBObj.DIBExPixFmt );

  N_Dump2Str( 'K_CMSE2VDIBAdjust Fin' );
end; // procedure K_CMSE2VDIBAdjust
}
var
 K_LSFApertureM1 : TK_LineSegmFunc;
 K_LSFApertureM2 : TK_LineSegmFunc;
 K_LSFApertureM3 : TK_LineSegmFunc;

//************************************ K_CMSelectFilterApertureByResolution ***
// Select Filter Aperture by given Slide resolution
//
//     Parameters
// ASlidePixpermm  - slide resolution in Pixel per mm
// AFType   - filter type (1..3) (Sharp/Smooth-Median-Despeckle)
// Result - Returns filter aperture
//
function K_CMSelectFilterApertureByResolution( ASlidePixpermm : float; AFType : Integer ) : Integer;
var
  CurLineSegmFunc : TK_LineSegmFunc;
begin
  Result := 3;
  CurLineSegmFunc := nil;
  case AFType of
  1: begin
    if ASlidePixpermm = Round(72 * 100 / 2.54) / 1000 then
    begin
      Result := 17;
      exit;
    end;
    if K_LSFApertureM1 = nil then
    begin
      K_LSFApertureM1 := TK_LineSegmFunc.Create([0, 3,  400, 5,  650, 6,  1300, 14,  3000, 25]);
    end;
    CurLineSegmFunc := K_LSFApertureM1;
  end;
  2: begin
    if K_LSFApertureM2 = nil then
    begin
      K_LSFApertureM2 := TK_LineSegmFunc.Create([0, 1,  500, 1,  650, 2,  1300, 3,  5000, 6]);
    end;
    CurLineSegmFunc := K_LSFApertureM2;
  end;
  3: begin
    if K_LSFApertureM3 = nil then
    begin
      K_LSFApertureM3 := TK_LineSegmFunc.Create([0, 1,  500, 1,  650, 2,  1300, 3,  5000, 6]);
    end;
    CurLineSegmFunc := K_LSFApertureM3;
  end;
  end;

  if CurLineSegmFunc = nil  then Exit;

  Result := Round(CurLineSegmFunc.Arg2Func( ASlidePixpermm  * 25.4 ));
  Result := 2 * Result + 1;
end; // function K_CMSelectFilterApertureByResolution


//***************************************** K_CMGetPatientGenderTextByTitle ***
// Get Gender name by Title
//
//     Parameters
// ATitle - patient title
// Result - Returns patient gender name 1-st letter or empty string
//          if gender is not defined by title
//
function K_CMGetPatientGenderTextByTitle( const ATitle : string ) : string;

begin
  Application.CreateForm(TK_FormCMSASetPatientData, K_FormCMSASetPatientData);
  K_SetFFCompCurLangTexts( K_FormCMSASetPatientData );
  Result := K_FormCMSASetPatientData.GetGenderTextByTitle( ATitle );
  K_FormCMSASetPatientData.Release();
  K_FormCMSASetPatientData := nil;
end; // function K_CMGetPatientGenderTextByTitle

//****************************************************** K_CMSetSlidesAttrs ***
// Get Current Slides List Last Items
//
//    Parameters
// ASlidesCount - number of Slides to get
// Result - Returns Slides Array
//
function K_CMGetCurSlidesListLastSlides( ASlidesCount : Integer) : TN_UDCMSArray;
var
  i, j : Integer;
begin
  SetLength( Result, ASlidesCount );
  j := High(Result);
  with K_CMEDAccess do
    for i := CurSlidesList.Count - 1 downto CurSlidesList.Count - ASlidesCount  do
    begin
      Result[j] := CurSlidesList[i];
      Dec(j);
    end;
end; // function K_CMGetCurSlidesListLastSlides

//************************************ K_CMBSlideCreateThumbnailDIBByAspect ***
// Create Slide Thumbnail DIB by Aspect
//
function K_CMBSlideCreateThumbnailDIBByAspect( AThumbAspect: Double ): TN_DIBObj;
var
  ThumbSize: TPoint;
begin
  ThumbSize := Point(K_CMSlideThumbSize, K_CMSlideThumbSize);
  ThumbSize := N_AdjustSizeByAspect(aamDecRect, ThumbSize, AThumbAspect);
  Result := TN_DIBObj.Create(ThumbSize.X, ThumbSize.Y, pf24bit);
end; // procedure K_CMBSlideCreateThumbnailDIBByAspect

//*************************************** K_CMBSlideCreateThumbnailDIBByDIB ***
// Create Slide Thumbnail DIB by DIB
//
function K_CMBSlideCreateThumbnailDIBByDIB( ADIBObj: TN_DIBObj ): TN_DIBObj;
var
  ThumbAspect: Double;
begin

  ThumbAspect := 1;
  if ADIBObj <> nil then
    with ADIBObj.DIBSize do
      ThumbAspect := Y / X;
  Result := K_CMBSlideCreateThumbnailDIBByAspect( ThumbAspect );
  if ADIBObj = nil then Exit;

  with ADIBObj do
  begin
    SetStretchBltMode( Result.DIBOCanv.HMDC, HALFTONE );
    N_StretchRect( Result.DIBOCanv.HMDC, Result.DIBRect, DIBOCanv.HMDC, DIBRect );
  end;
end; // procedure K_CMBSlideCreateThumbnailDIBByDIB

//************************************* K_CMBSlideCreateThumbnailDIBByDIBEx ***
// Get Image Thumbnail DIB by given internal enhanced DIB
//
//    Parameters
// ADIBObj    - source DIB
// Result     - Returns resulting thumbnail DIB
//
function K_CMBSlideCreateThumbnailDIBByDIBEx( ADIBObj : TN_DIBObj ) : TN_DIBObj;
var
  WDIBObj : TN_DIBObj;
  WDIBObj1 : TN_DIBObj;
  NumBits : Integer;
begin
  Result := nil;
  if ADIBObj = nil then Exit;
  N_Dump2Str( 'K_CMBSlideCreateThumbnailDIBByDIBEx >> Start' );
  WDIBObj := ADIBObj;
  if ADIBObj.DIBExPixFmt = epfGray16 then // conv to Gray8
  begin
    NumBits := ADIBObj.DIBNumBits;
    if ADIBObj.DIBNumBits > 8 then
      ADIBObj.DIBNumBits := 16;
    WDIBObj1 := nil;
    ADIBObj.CalcMaxContrastDIB( WDIBObj1 );
    ADIBObj.DIBNumBits := NumBits; // Restore ADIBObj fields

    WDIBObj := TN_DIBObj.Create( WDIBObj1, WDIBObj1.DIBRect, pfCustom, epfGray8 );
    WDIBObj1.Free;
  end
  else
  if ADIBObj.DIBExPixFmt = epfColor48 then // conv to Color24
    WDIBObj := TN_DIBObj.Create( ADIBObj, WDIBObj.DIBRect, pf24bit, epfBMP );

  Result := K_CMBSlideCreateThumbnailDIBByDIB( WDIBObj );
  if WDIBObj <> ADIBObj then WDIBObj.Free;
end; // function K_CMBSlideCreateThumbnailDIBByDIBEx

//*********************************** K_CMBSlideCreateThumbnailDIBByMapRoot ***
// Create Slide Thumbnail DIB by Slide Map Root
//
function K_CMBSlideCreateThumbnailDIBByMapRoot( AMapRoot: TN_UDCompBase ): TN_DIBObj;
var
  ThumbAspect: Double;
  TmpGCont: TN_GlobCont;
  ExpParams: TN_ExpParams;
begin
//  MapRoot := GetMapRoot();
  ThumbAspect := 1;
  if AMapRoot <> nil then
    with TN_UDCompVis(AMapRoot).PCCS.SRSize do
      ThumbAspect := Y / X;
  Result := K_CMBSlideCreateThumbnailDIBByAspect( ThumbAspect );
  if AMapRoot = nil then Exit;

  TmpGCont := TN_GlobCont.Create();

  ExpParams := N_DefExpParams;
  ExpParams.EPImageExpMode := iemJustDraw;
  ExpParams.EPExecFlags := ExpParams.EPExecFlags + [epefHALFTONE];

  with ExpParams.EPImageFPar do
  begin
    IFPPixFmt := pf24bit;
    IFPSizePix := Result.DIBSize;
    IFPSizemm := FPoint(25.4 * IFPSizePix.X / 72, 25.4 * IFPSizePix.Y / 72);
    // assume 72 DPI
  end; // with ExpParams.EPImageFPar do

  TmpGCont.ExecuteRootComp(AMapRoot, [], nil, nil, @ExpParams, K_CMSStudyThumbBGColor );
{
//////////////////////////////////////////////////
// Replace ExecuteRootComp For set current stretchBltMode for Thumbnail
  with TmpGCont do
  begin
    PrepForExport( MapRoot, @ExpParams );
    SetStretchBltMode( DstOCanv.HMDC,
                        K_CMStretchBltMode );
    ExecuteComp( MapRoot, [cifRootComp] );
    FinishExport();
  end;
//////////////////////////////////////////////////
}
//      SetStretchBltMode( TmpGCont.DstOCanv.HMDC, K_CMStretchBltMode );


  with TmpGCont do
  begin
    SetStretchBltMode( Result.DIBOCanv.HMDC, HALFTONE );
    N_StretchRect( Result.DIBOCanv.HMDC, Result.DIBRect, DstOCanv.HMDC,
      DstPixRect );
  end;

  TmpGCont.Free;
end; // procedure K_CMBSlideCreateThumbnailDIBByMapRoot

//*********************************** K_CMBStudyCreateThumbnailDIBByMapRoot ***
// Create Study Thumbnail DIB by Slide Map Root
//
function K_CMBStudyCreateThumbnailDIBByMapRoot( AMapRoot: TN_UDCompBase ): TN_DIBObj;
var
  PUP: TN_POneUserParam;
  PSkipMainImg: PByte;
  PSkipThumbImg: PByte;
begin

  PUP := N_GetUserParPtr(TN_UDCompBase(AMapRoot).R, 'SkipMainImage');
  PSkipMainImg :=  PByte(PUP.UPValue.P);

  PUP := N_GetUserParPtr(TN_UDCompBase(AMapRoot).R, 'SkipThumbImage');
  PSkipThumbImg :=  PByte(PUP.UPValue.P);

  // Rebuild ThumbNail
  PSkipMainImg^  := 1;
  PSkipThumbImg^ := 0;
  Result := K_CMBSlideCreateThumbnailDIBByMapRoot( AMapRoot );
  PSkipMainImg^  := 0;
  PSkipThumbImg^ := 1;

end; // function K_CMBStudyCreateThumbnailDIBByMapRoot


//****************************************** K_CMBSlideCreateThumbnailUDDIB ***
// Create Thumbnail TN_UDDIB, based upon given AThumbDIBObj
//
//     Parameters
// ADIBObj - given DIBObj
//
function K_CMBSlideCreateThumbnailUDDIB( ADIBObj: TN_DIBObj ): TN_UDDIB;
begin
  Result := nil;
  if ADIBObj = nil then
    Exit; // Thumbnail is not given

  Result := N_CreateUDDIB(N_CMDIBURect, [], '', 'Thumbnail');
  with Result.PCCS()^ do // set coords related fields needed for showing Thumb in Mounts Item
  begin
    SRSizeAspect  := -3; // means using self DIBObj Aspect
    SRSizeAspType := catGiven; // Aspect is given in SRSizeAspect field
    CurFreeFlags  := [cffFullAspSize]; // use CurFreeRect and preserve given Aspect
  end;

  with Result.PISP()^ do // Set Save Data Attributes
  begin
    CDIBFlagsN := [uddfnUseUDData,uddfnFreeUDData];
    CDIBDataFormat := uddfDIBSer2;
  end;

  Result.DIBObj := ADIBObj;
end; // function K_CMBSlideCreateThumbnailUDDIB

//*********************************************** K_CMSlideEEFNamePrepMacro ***
// Create Export/Email File MacroList by given Patient Attributes Macro List
//
//     Parameters
// ASrcPatMacroList - macro list with source patient attributes
// AResFileMacroList - resulting macrolist for future  file names generation
//
// AResFileMacroList on output will contain 'FileNum', 'ObjDTaken' and 'ObjChart'
// macro attribute on 0, 1, 2 positions
//
procedure K_CMSlideEEFNamePrepMacro( ASrcPatMacroList, AResFileMacroList : TStrings );
var
  SInd, RInd : Integer;
  SVal : string;

  procedure SetResVal( ARName, ARVal : string );
  begin
    ARVal := ARName + '=' + ARVal;
    RInd := AResFileMacroList.IndexOfName( ARName );
    if RInd < 0 then
      AResFileMacroList.Insert( 0, ARVal )
    else
      AResFileMacroList[RInd] := ARVal;
  end;

  procedure InsObjAttr( ARName : string );
  begin
    RInd := AResFileMacroList.IndexOfName( ARName );
    if RInd < 0 then
      AResFileMacroList.Insert(0, ARName + '=' );
  end;


begin
  if K_efnPatSurname in K_CMSlideEEFNameFlagsSet then
  begin
    SInd := ASrcPatMacroList.IndexOfName( 'PatientSurname' );
    if SInd < 0 then
      SVal := IntToStr(K_CMEDAccess.CurPatID)
    else
      SVal := ASrcPatMacroList.ValueFromIndex[SInd];

    SetResVal( 'PatSurname', SVal );
  end;

  // Patient First Name
  if K_efnPatFirstName in K_CMSlideEEFNameFlagsSet then
  begin
    SInd := ASrcPatMacroList.IndexOfName( 'PatientFirstName' );
    SVal := '';
    if SInd >= 0 then
      SVal := ' ' + ASrcPatMacroList.ValueFromIndex[SInd];

    SetResVal( 'PatFirstName', SVal )
  end;

  // Patient Title
  if K_efnPatTitle in K_CMSlideEEFNameFlagsSet then
  begin
    SInd := ASrcPatMacroList.IndexOfName( 'PatientTitle' );
    SVal := '';
    if SInd >= 0 then
      SVal := ', ' + ASrcPatMacroList.ValueFromIndex[SInd];

    SetResVal( 'PatTitle', SVal )
  end;

  // Patient Card Number
  if K_efnPatCardNum in K_CMSlideEEFNameFlagsSet then
  begin
    SInd := ASrcPatMacroList.IndexOfName( 'PatientCardNumber' );
    SVal := '';
    if SInd >= 0 then
      SVal := ' [' + ASrcPatMacroList.ValueFromIndex[SInd] + ']';

    SetResVal( 'PatCardNum', SVal )
  end;

  // Patient DOB
  if K_efnPatDOB in K_CMSlideEEFNameFlagsSet then
  begin
    SInd := ASrcPatMacroList.IndexOfName( 'PatientDOB' );
    SVal := '';
    if SInd >= 0 then
    begin
      SVal := ASrcPatMacroList.ValueFromIndex[SInd];
      if SVal <> '' then
        SVal := ' ' + K_CML1Form.LLLExpFileNameParts.Items[0] + ' ' + SVal;
//      SVal := ' DOB ' + ASrcPatMacroList.ValueFromIndex[SInd];
//      SVal := ' DOB:' + ASrcPatMacroList.ValueFromIndex[SInd];
    end;
    SetResVal( 'PatDOB', SVal )
  end;

  RInd := AResFileMacroList.IndexOfName( 'FileNum' );
  if RInd < 0 then
  begin
    AResFileMacroList.Insert(0, 'ObjChart=' );
    AResFileMacroList.Insert(0, 'ObjTTaken=' );
    AResFileMacroList.Insert(0, 'ObjDTaken=' );
    AResFileMacroList.Insert(0, 'FileNum=' );
  end;
end; // procedure K_CMSlideEEFNamePrepMacro

//*********************************************** K_CMSlideEEFNamePrepMacro ***
// Build Export/Email File Name by given Slide
//
//     Parameters
// AFileMacroList - macrolist for file names generation
// ASlide         - Slide
// AFNum          - FileNumber
// Result         - Returns File Name
//
function  K_CMSlideEEFNameBuild( AFileMacroList : TStrings; ASlide : TN_UDCMSlide; AFNum : Integer ) : string;
var
  SVal : string;
begin

  if K_efnObjID in K_CMSlideEEFNameFlagsSet then
    SVal := ASlide.ObjName
  else
    SVal := IntToStr(AFNum);
  AFileMacroList[0] := 'FileNum=' + SVal;

  with ASlide.P^ do
  begin
    if K_efnObjDTaken in K_CMSlideEEFNameFlagsSet then
      SVal := ' ' + K_CML1Form.LLLExpFileNameParts.Items[1] + ' ' + K_DateTimeToStr( CMSDTTaken, 'dd"-"mm"-"yyyy' )
//      SVal := ' Taken ' + K_DateTimeToStr( CMSDTTaken, 'dd"-"mm"-"yyyy' )
//      SVal := ' Taken:' + K_DateTimeToStr( CMSDTTaken, 'dd"/"mm"/"yyyy' )
    else
      SVal := '';
    AFileMacroList[1] := 'ObjDTaken=' + SVal;

    if K_efnObjTTaken in K_CMSlideEEFNameFlagsSet then
      SVal := ' ' + K_DateTimeToStr( CMSDTTaken, 'hh:nn:ss' )
    else
      SVal := '';
    AFileMacroList[2] := 'ObjTTaken=' + SVal;

    if K_efnObjChart in K_CMSlideEEFNameFlagsSet then
    begin
      SVal := K_CMSTeethChartStateToText(CMSTeethFlags);
      if SVal <> '' then
        SVal := ' ' + K_CML1Form.LLLExpFileNameParts.Items[2] + ' ' + SVal;
//        SVal := ' Chart ' + SVal;
//        SVal := ' Chart:' + SVal;
    end
    else
      SVal := '';
    AFileMacroList[3] := 'ObjChart=' + SVal;
  end;

  Result := K_StringMListReplace( K_CMSlideEEFNamePattern, AFileMacroList, K_ummRemoveMacro);

end; // function K_CMSlideEEFNameBuild

//*********************************************** K_CMStudyCreateFromSample ***
// Create new Study by Sample
//
//     Parameters
// AStudySample - Study Sample Object
// AStudyLabel  - Study Name
// AStudyColor  - Study Color
// Result - Returns New Study
//
function  K_CMStudyCreateFromSample( AStudySample : TN_UDBase; const AStudyLabel : string;
                                     AStudyColorInd : Integer ) : TN_UDCMStudy;
var
  UDSampleThumb : TN_UDBase;
begin
// Clear Study Thumbnail before Save Sample Tree to Memory
  UDSampleThumb := AStudySample.DirChild(K_CMSlideIndThumbnail);
  Inc( UDSampleThumb.RefCounter );
  AStudySample.PutDirChild( K_CMSlideIndThumbnail, nil ); // Clear Sample Thumbnail

  K_SaveTreeToMem( AStudySample, N_SerialBuf, false, [K_lsfJoinAllSLSR] );

// Restore Study Thumbnail After Save Sample Tree to Memory
  AStudySample.PutDirChild( K_CMSlideIndThumbnail, UDSampleThumb ); // Restore Sample Thumbnail
  Dec( UDSampleThumb.RefCounter );

  Result := TN_UDCMStudy(K_LoadTreeFromMem(N_SerialBuf, [K_lsfJoinAllSLSR]));

  K_CMSlideInitByCurContext(Result);
  Result.ObjName := 'Study';
  Result.ObjInfo := 'Created from ' + AStudySample.ObjAliase;
  Result.ObjAliase := '';

  with Result, P()^ do
  begin
    CMSDTTaken := CMSDTCreated; // Slide DateTime Created
    CMSPatId := K_CMEDAccess.CurPatID; // Current Patient ID
    CMSSourceDescr := AStudyLabel; // Source Descr - Study Name
    CMSMediaType   := AStudyColorInd; // Media Type - Study Color Index = 0 (for empty color)
  end;

  Result.CreateThumbnail(); // Create Study Thumbnail
  Result.CMSStudySampleID := StrToInt(AStudySample.ObjName);
  Result.PutDirChildSafe( K_CMStudyIndSrcSample, AStudySample ); // Reference to Source Sample

  Result.InitByMapRoot;

  K_CMEDAccess.EDAAddSlide(Result);
  K_CMEDAccess.EDAStudySavingStart();
  K_CMEDAccess.EDASaveSlidesArray( TN_PUDCMSlide(@Result), 1 );
  K_CMEDAccess.EDAStudySavingFinish();
end; // function  K_CMStudyCreateFromSample

//******************************************* K_CMStudyGetItemInvisibleRoot ***
// Get given Study Item Invisible Slides Root
//
//     Parameters
// AStudyItem - given Study Item
// Result - Returns Invisible Slides Root or nil
//
function K_CMStudyGetItemInvisibleRoot( AStudyItem : TN_UDBase ) : TN_UDBase;
begin
  with AStudyItem do
    Result := DirChild(DirHigh());
  if Result.ObjName <> 'Invisible' then
    Result := nil;
end; // K_CMStudyGetOneSlideByItem

//********************************************** K_CMStudyGetOneSlideByItem ***
// Get given Study Item mounted Slide
//
//     Parameters
// AStudyItem - given Study Item
// Result - Returns mounted Slide, or nil
//
function K_CMStudyGetOneSlideByItem( AStudyItem : TN_UDBase ) : TN_UDCMSlide;
var
  AItemThumb : TN_UDBase;
begin
//  AItemThumb := AStudyItem.DirChild(0).DirChild(0).DirChild(0); // Image Thumbnaile
  with AStudyItem do
    AItemThumb := DirChild(IndexOfChildObjName( 'ImagePanel' )).DirChild(0).DirChild(0); // Image Thumbnaile
  Result := nil;
  if (AItemThumb <> nil) and (AItemThumb.Owner is TN_UDCMSLide) then
    Result := TN_UDCMSlide(AItemThumb.Owner);
end; // K_CMStudyGetOneSlideByItem

//********************************************* K_CMStudyGetAllSlidesByItem ***
// Get given Study Item All mounted Slides
//
//     Parameters
// AStudyItem - given Study Item
// AMountedSlides - all resulting mounted slides
// AInd - AMountedSlides item index to fill
// Result - Returns linked invisible slides item root
//
function  K_CMStudyGetAllSlidesByItem( AStudyItem : TN_UDBase; var AMountedSlides : TN_UDCMSArray; var AInd : Integer ) : TN_UDBase;
var
  MSlidesNum, i, RLength : Integer;
  StudyCurSlide : TN_UDCMSlide;
  Capacity : Integer;
begin
  Result := nil;
//  AMountedSlides := nil;

  StudyCurSlide := K_CMStudyGetOneSlideByItem( AStudyItem );
  if StudyCurSlide = nil then Exit;

  MSlidesNum := 1;
  // get linked invisible slides item root
//  Result := AStudyItem.DirChild(K_CMStudyItemIndInvisRoot); // Other Linked Slides Root
  Result := K_CMStudyGetItemInvisibleRoot( AStudyItem );

  if Result <> nil then
    MSlidesNum := Result.DirLength() + 1;

  RLength := AInd + MSlidesNum;
  Capacity := Length(AMountedSlides);
  if AInd = 0 then
    SetLength(AMountedSlides, RLength)
  else
  if K_NewCapacity( RLength, Capacity ) then
    SetLength(AMountedSlides, Capacity);

  AMountedSlides[AInd] := StudyCurSlide;

  for i := 1 to MSlidesNum - 1 do
    AMountedSlides[i + AInd] := TN_UDCMSlide(Result.DirChild(i - 1).Owner);

  AInd := RLength;

end; // K_CMStudyGetAllSlidesByItem

//********************************************** K_CMStudyItemAddSlidesPrep ***
// Prepare Study Item for Slides adding
//
//     Parameters
// AStudyItem - given Study Item
// Result - Returns minimal Pos Code
//
function  K_CMStudyItemAddSlidesPrep( AStudyItem : TN_UDBase; out AUDRoot : TN_UDBase ) : Integer;
begin
//  AUDRoot := AStudyItem.DirChild(K_CMStudyItemIndInvisRoot);
  AUDRoot := K_CMStudyGetItemInvisibleRoot( AStudyItem );
  if AUDRoot = nil then // Create Invisible Slides Root
  begin
    AUDRoot := AStudyItem.AddOneChild( TN_UDBase.Create );
    AUDRoot.ObjName := 'Invisible';
  end;
  Result := DateTimeToFileDate( Now() );
end; // K_CMStudyItemAddSlidesPrep

//************************************************* K_CMStudyGetStudyByItem ***
// Get given Study Item Study object
//
//     Parameters
// AStudyItem - given Study Item
// Result - Returns mounted Slide, or nil
//
function K_CMStudyGetStudyByItem( AStudyItem : TN_UDBase ) : TN_UDCMStudy;
begin
  Result := nil;
  if AStudyItem = nil then Exit;
  Result := TN_UDCMStudy(AStudyItem.Owner.Owner);
end; // K_CMStudyGetStudyByItem

//***************************************************** K_CMStudyItemFRFags ***
// Get given Study Item FlipRotate Flags
//
//     Parameters
// AStudyItem - given Study Item
// Result - Returns Item FlipRotate Flags
//
function K_CMStudyItemFRFags( AStudyItem : TN_UDBAse ) : Integer;
var
  PUP: TN_POneUserParam;
begin
  // Define Item FlipRotate Flags
  Result := 0;
  if AStudyItem = nil then Exit; // precaution
  PUP := N_GetUserParPtr(TN_UDCompBase(AStudyItem).R, 'FlipRotateFlags');
  if PUP <> nil then
    Result := PByte(PUP.UPValue.P)^;
end; // function K_CMStudyItemFRFags

//************************************************** K_CMStudyItemTeethFags ***
// Get given Study Item Teeth Flags
//
//     Parameters
// AStudyItem - given Study Item
// Result - Returns Item Teeth Flags
//
function K_CMStudyItemTeethFags( AStudyItem : TN_UDBAse ) : Int64;
var
  PUP: TN_POneUserParam;
begin
  // Define Item FlipRotate Flags
  Result := 0;
  if AStudyItem = nil then Exit; // precaution
  PUP := N_GetUserParPtr(TN_UDCompBase(AStudyItem).R, 'TeethFlags');
  if PUP <> nil then
    Result := PInt64(PUP.UPValue.P)^;
end; // function K_CMStudyItemTeethFags

//********************************************** K_CMStudyGetRemountContext ***
// Get remount given Slide to given Study Item Context
//
//     Parameters
// ARSlide - Slide to remount
// ARItem  - Study Item to remount
// APRContext - pointer to Remount Context structure
// Result - Returns Remount Update Flags
//
function K_CMStudyGetRemountContext( ARSlide : TN_UDCMSlide; ARItem: TN_UDBase;
                                     APRContext : TK_PCMStudyRemountOneSlideContext ) : TK_CMStudyRemountUpdateFlags;
begin
  FillChar( APRContext^, SizeOf(TK_CMStudyRemountOneSlideContext), 0 );
  Result := [];
  with APRContext^ do
  begin
  // Fill Item Current State Info
    CMRItem := ARItem;
    CMRItemStudy := TN_UDCMStudy(ARItem.Owner.Owner);
    CMRItemSlide := K_CMStudyGetOneSlideByItem( ARItem );

    if CMRItemSlide = ARSlide then Exit;

    Include( Result, K_srufRedrawItemStudy );
    Include( Result, K_srufRebuildVisSlides );

    CMRItemFRFlags := K_CMStudyItemFRFags( CMRItem );
    CMRItemTeethFlags := K_CMStudyItemTeethFags( CMRItem );

  // Fill Slide Current State Info
    CMRSlide := ARSlide;
    CMRSlideItem := ARSlide.DirChild( K_CMSlideIndStudyItem );
    if CMRSlideItem <> nil then
    begin
      CMRSlideStudy := TN_UDCMStudy(CMRSlideItem.Owner.Owner);
      if CMRItemStudy <> CMRSlideStudy then
        Include( Result, K_srufRedrawSlideStudy );
      CMRSlideItemFRFlags := K_CMStudyItemFRFags( CMRSlideItem );
      CMRSlideItemTeethFlags := K_CMStudyItemTeethFags( CMRSlideItem );
    end;
  end;

end; // end of K_CMStudyGetRemountContext

//*************************************************** K_CMRefreshOpenedView ***
// Refresh opened Slides and Studies View
//
//     Parameters
// AClearViewFlagsOnly - if TRUE then no Refresh will be done
// Result - Returns number of Refreshed Opened Objects
//
//
function K_CMRefreshOpenedView( AClearViewFlagsOnly : Boolean = FALSE ) : Integer;
var
  i : Integer;
  Slide : TN_UDCMSlide;
  Study : TN_UDCMStudy;
begin
  Result := 0;
  N_Dump2Str( 'DB >> RefreshOpenedView start' );
  if K_CMEDAccess.CurSlidesList.Count = 0 then Exit;
  ///////////////////////////////////////////
  // Mark opened Objects needed view refresh
  //
  for i := 0 to K_CMEDAccess.CurSlidesList.Count - 1 do
  begin
    Slide :=  TN_UDCMSlide(K_CMEDAccess.CurSlidesList[i]);
    if not Slide.CMSViewUpdateFlag then Continue;
    Slide.CMSViewUpdateFlag := FALSE; // Clear Update Flag
    if AClearViewFlagsOnly then Continue;
    // Check Self
    if TN_UDCMBSlide(Slide) is TN_UDCMStudy then
    begin
      if Slide.CMSViewRefreshFlag or (Slide.CMSRFrame = nil) then Continue; //
      Slide.CMSViewRefreshFlag := TRUE; // Set Update Flag
    end
    else
    begin
      if not Slide.CMSViewRefreshFlag and (Slide.CMSRFrame <> nil) then
        Slide.CMSViewRefreshFlag := TRUE; // Set Update Flag
      Study := Slide.GetStudy();
      if (Study = nil)           or // Slide is not mounted
         (Study.CMSRFrame = nil) or // Study is not opened
         (Study.Marker <> 0) then   // Study is already added
        Continue;
      Study.CMSViewRefreshFlag := TRUE; // Set Update Flag
    end;
  end; // for i := 0 to K_CMEDAccess.CurSlidesList.Count - 1 do

  ///////////////////////////////////////////
  // Refresh Opened Objects View
  //
  for i := 0 to K_CMEDAccess.CurSlidesList.Count - 1 do
  begin
    Slide :=  TN_UDCMSlide(K_CMEDAccess.CurSlidesList[i]);
    if not Slide.CMSViewRefreshFlag then Continue;
    Slide.CMSViewRefreshFlag := FALSE;
    if AClearViewFlagsOnly then Continue;
    Inc(Result);
    with N_CM_MainForm.CMMFFindEdFrame(Slide), Slide, P^ do
    begin
      if (CMSlideEdState <> K_edsSkipOpen) and
         not (cmsfCloseOpened in CMSRFlags) then
      begin
      // Opened Object view should be updated
        N_Dump2Str( 'DB >> Refresh Update Opened ID=' + Slide.ObjName );
        if TN_UDCMBSlide(Slide) is TN_UDCMStudy then
        begin // Redraw Opened Study Veiw
          FrameRightCaption.Caption := Slide.P.CMSSourceDescr;
          RFrame.RedrawAllAndShow();
        end
        else
        begin
        // Rebuild Opened Slide Context
          InitSlideView();
          EdVObjSelected := nil;
        end;
      end // End of opened Object view update
      else
      begin
      // Opened Object should be closed
        N_Dump2Str( 'DB >> Refresh  Close Opened ID=' + Slide.ObjName );
        EdFreeObjects();
      end;
      Exclude( CMSRFlags, cmsfCloseOpened);
    end; // with N_CM_MainForm.CMMFFindEdFrame(Slide), Slide, P^ do
  end; // for i := 0 to K_CMEDAccess.CurSlidesList.Count - 1 do

  N_Dump2Str( 'DB >> RefreshOpenedView fin' );
end; // procedure K_CMRefreshOpenedView

//*********************************************** K_CMSAddStudySlidesToList ***
// Add Study Slide to Objects Array
//
//     Parameters
// AUDCMSArray  - source studies and unlinked slides
// Result - Returns array with added studies slides
//
function K_CMSAddStudyCurSlidesToArray( AUDCMSArray : TN_UDCMSArray ) : TN_UDCMSArray;
var
  i, Ind, Capacity : Integer;
begin
  Capacity := Length(AUDCMSArray);
  SetLength( Result, Capacity );
  Ind := 0;
  for i := 0 to High(AUDCMSArray) do
  begin
    if K_NewCapacity( Ind + 1,  Capacity ) then
      SetLength( Result, Capacity );
    Result[Ind] := AUDCMSArray[i];
    Inc(Ind);
    if TN_UDCMBSlide(AUDCMSArray[i]) is TN_UDCMSlide then Continue;
    Ind := TN_UDCMStudy(AUDCMSArray[i]).GetCurSlidesToArray( Result, Ind );
  end;
  SetLength( Result, Ind );
end; // function K_CMSAddStudyCurSlidesToArray

//***************************************************** K_CMEDAInitDFPLExec ***
// Init DFPL execute context
//
procedure K_CMEDAInitDFPLExec;
begin
  /////////////////////////////////////////////////////////
  // Text Fragms with DFPL scripts for contexts processing
  //
  if K_CMEDADFPLExec = nil then
  begin
    K_CMEDADFPLExec := TK_DFPLScriptExec.Create; // DFPL Script Processor for contexts processing
    K_CMEDADFPLExec.DstIniFile.Free;
    K_CMEDAMemTextFragms := TN_MemTextFragms.CreateFromVFile( N_MemIniToString('CMS_Main', 'SaveDFPLLib', '') );
    K_CMEDADFPLExec.CallMemTextFragms := K_CMEDAMemTextFragms.MTFragmsList;
    K_CMEDADFPLMacroList := TStringList.Create;
    K_CMEDADFPLExec.DFPLSetMacroList( K_CMEDADFPLMacroList, FALSE );
  end;
end; // end of K_CMEDAInitDFPLExec

//***************************************** K_CMEDAHideLoginPasswordForDump ***
// Hide Login/Password in Strings for Dump
//
//     Parameters
// AStrings     - Strings to hide login/password
// AEncodeLogin - If TRUE hide login and password else only password
//
procedure K_CMEDAHideLoginPasswordForDump( AStrings : TStrings;
                                           AEncodeLogin : Boolean = FALSE );
var
  Ind : Integer;
  PSW : string;
  PSW1 : array [1..100] of AnsiChar;

  procedure PutEncodedString();
  var
    i, n : Integer;
  begin
    // Hide real passowrd Value
    AStrings[Ind] := AStrings.Names[Ind] + '=******';

    // Prepare encoded PSW
    n := Length(PSW);
    Move( N_StringToAnsi( PSW )[1], PSW1[1], n );
    for i := n downto 1 do
    begin
      PSW1[2*i] := AnsiChar(Byte(PSW1[i]) + 1);
      // Random char from '0'$30 to '}'$7D
      PSW1[2*i - 1] := AnsiChar($30 + Round(Random($7D - $30)));
    end; // for i := n downto 1 do
    PSW1[2*n + 1] := #0; // Put terminating Zero

    // Put 'CRC=...' line with encoded Password after '...assword=******' Line
    Inc(Ind);
    PSW := 'CRC=' + N_AnsiToString( AnsiString(@PSW1[1]) );
    if Ind < AStrings.Count then
      AStrings.Insert( Ind, PSW )
    else
      AStrings.Add( PSW );
  end; // PutEncodedString();

begin
  //Check Login
  if AEncodeLogin then
  begin
    Ind := K_SearchInStrings( AStrings, 'ogin=', 0, 0, FALSE, FALSE, TRUE );
    if Ind >= 0 then
    begin // Hide login value
      PSW := AStrings.ValueFromIndex[Ind];
      if PSW <> '' then
      begin // login is not empty
        PutEncodedString();
      end; // if PSW <> '' then
    end;
  end; // if AEncodeLogin then

  // Check Password
  Ind := K_SearchInStrings( AStrings, 'assword=', 0, 0, FALSE, FALSE, TRUE );
  if Ind >= 0 then
  begin // Hide password value
    PSW := AStrings.ValueFromIndex[Ind];
    if PSW <> '' then
    begin // Password is not empty
      PutEncodedString();
    end; // if PSW <> '' then
  end;
end; // procedure K_CMEDAHideLoginPasswordForDump

//*********************************************** K_CMEDAExtIniFileToMemIni ***
// Add content from given Ini-file to current MemIni
//
//     Parameters
// AIniFName    - ini file name
// AIniDFPLName - copy DFPL script name
// Result - Returns TRUE if content is copied
//
// If AIniDFPLName = '' then AIniFName file name is used as DFPL script name
//
function K_CMEDAExtIniFileToMemIni( AIniFName : string;
                                    const AIniDFPLName : string = '' ): Boolean;
var
  UseDFPLScript : Boolean;
  ScriptName : string;
begin
  Result := FALSE;
  if (AIniFName <> '') and (AIniFName[Length(AIniFName)] = '*') then // Skip Spec Flag '*'
    AIniFName[Length(AIniFName)] := #0;

  AIniFName := K_ExpandFileName( PChar(AIniFName) );
//  if not FileExists(AIniFName) then
  if not K_VFileExists(AIniFName) then
  begin
    N_Dump2Str('Ini File ' + AIniFName + ' not found');
    Exit;
  end;
//  K_CMEDAMemIniFile.Rename(AIniFName, TRUE);
  if not K_LoadMemIniFromFile( K_CMEDAMemIniFile, AIniFName ) then
  begin
    N_Dump1Str('Ini File ' + AIniFName + ' load error');
    Exit;
  end;

  Result := TRUE;
  K_CMEDAMemIniStrings.Clear;
  K_CMEDAMemIniFile.GetStrings( K_CMEDAMemIniStrings );
  N_Dump2Str(#13#10 + '*** Source Ini ' + AIniFName);
  K_CMEDAHideLoginPasswordForDump(K_CMEDAMemIniStrings);
  N_Dump2Strings( K_CMEDAMemIniStrings, 5);
  N_Dump2Str('*** end of source ' + AIniFName + #13#10);
  K_CMEDADFPLExec.DstIniFile := N_CurMemIni;
  K_CMEDADFPLExec.SrcIniFile := K_CMEDAMemIniFile;

  UseDFPLScript := FALSE;
  if AIniDFPLName <> '' then
  begin
    ScriptName := AIniDFPLName + '|Load';
    UseDFPLScript := K_CMEDADFPLExec.DFPLExecTFSection( ScriptName );
  end;

  if not UseDFPLScript then
  begin
    ScriptName := ExtractFileName(AIniFName) + '|Load';
    UseDFPLScript := K_CMEDADFPLExec.DFPLExecTFSection( ScriptName );
  end;

  if not UseDFPLScript then
    K_AddMemIni( K_CMEDAMemIniFile, N_CurMemIni )
  else
  begin
    N_Dump2Str( #13#10 + '*** DFPL Script to add >> ' + ScriptName );
    N_Dump2Strings(K_CMEDADFPLExec.LastCommandsStrings, 5);
    N_Dump2Str( '*** end of DFPL Script' + #13#10 );
  end;

end; // end of K_CMEDAExtIniFileToMemIni

//*********************************************** K_CMEDAMemIniToExtIniFile ***
// Add content to given Ini-file from Current MemIni
//
//     Parameters
// AIniFName - external Ini-file Name
// AIniDFPLName - name of DFPL script to copy data
// Result - Returns TRUE if content is copied
//
// If AIniDFPLName = '' then AIniFName file name is used as DFPL script name
//
function K_CMEDAMemIniToExtIniFile( AIniFName: string; const
                                    AIniDFPLName : string = ''): Boolean;
var
  UseDFPLScript : Boolean;
  ScriptName : string;
  CreateIniFileFlag : Boolean;
begin
  Result := FALSE;
  CreateIniFileFlag := (AIniFName <> '') and (AIniFName[Length(AIniFName)] = '*');
  if CreateIniFileFlag then // Skip Spec Flag '*'
    AIniFName[Length(AIniFName)] := #0;

  AIniFName := K_ExpandFileName( PChar(AIniFName) );
  if not K_VFileExists(AIniFName) then
  begin
    if not CreateIniFileFlag then
    begin
      N_Dump2Str( 'Ini File ' + AIniFName + ' not found' );
      Exit;
    end;
  end
  else
  // K_IniFileCreateParams are set in K_LoadMemIniFromFile()
    K_LoadMemIniFromFile( K_CMEDAMemIniFile, AIniFName );

  K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
  K_CMEDADFPLExec.DstIniFile := K_CMEDAMemIniFile;

  UseDFPLScript := FALSE;
  if AIniDFPLName <> '' then
  begin
    ScriptName := AIniDFPLName + '|Save';
    UseDFPLScript := K_CMEDADFPLExec.DFPLExecTFSection( ScriptName );
    if not UseDFPLScript then
      N_Dump2Str( format( '!!>> K_CMEDAMemIniToExtIniFile >> Script "%s" is absent', [ScriptName]) );
  end;

  if not UseDFPLScript then
  begin
    ScriptName := ExtractFileName(AIniFName) + '|Save';
    UseDFPLScript := K_CMEDADFPLExec.DFPLExecTFSection( ScriptName );
    if not UseDFPLScript then
      N_Dump2Str( format( '!!>> K_CMEDAMemIniToExtIniFile >> Script "%s" is absent', [ScriptName]) );
  end;

  if not UseDFPLScript then Exit;

  N_Dump2Str( format( 'Add Ini Info to "%s" using "%s"', [AIniFName, ScriptName] ) );
  N_Dump2Str(#13#10 + '*** Save Info to ' + AIniFName);
  K_CMEDAMemIniStrings.Clear;
  K_CMEDAMemIniFile.GetStrings(K_CMEDAMemIniStrings);

  K_VFSaveStrings( K_CMEDAMemIniStrings, AIniFName, K_IniFileCreateParams );
//  K_SaveMemIniToFile( K_CMEDAMemIniFile );
//  K_CMEDAMemIniFile.UpdateFile();
  K_CMEDAHideLoginPasswordForDump(K_CMEDAMemIniStrings);
  N_Dump2Strings( K_CMEDAMemIniStrings, 5);
  N_Dump2Str('*** end of ' + AIniFName + #13#10);

  Result := TRUE;
end; // end of K_CMEDAMemIniToExtIniFile

//********************************************** K_CMEDAExtIniFilesToMemIni ***
// Add content of Ini-files to Current MemIni
//
//     Parameters
// ASaveDefaults - save current MemIni default values flag
// Result - Returns number of Ini files processed successfully
//
// List of Ini-files is get from [CMSIniFiles] section of Current MemIni
//
function K_CMEDAExtIniFilesToMemIni( ASaveDefaults : Boolean = FALSE ): Integer;
var
  i: Integer;
  WIniFiles: TStringList;
  IniFName: string;
  IniDFPLName: string;

begin
  /////////////////////////////////////////////////////////
  // Initialized Text Fragms with DFPL scripts for contexts processing
  //
  K_CMEDAInitDFPLExec();
  WIniFiles := TStringList.Create;
  N_CurMemIni.ReadSectionValues('CMSIniFiles', WIniFiles);
  Result := 0;
// Save MemIni Default Fields to Default
//  if (WIniFiles.Count > 0) then
  if (WIniFiles.Count > 0) and ASaveDefaults then
  begin
    K_CMEDADFPLExec.SrcIniFile := N_CurMemIni;
    K_CMEDADFPLExec.DstIniFile := K_CMEDADefaultMemIni;
    if not K_CMEDADFPLExec.DFPLExecTFSection( 'SaveDefaults' ) then
      N_Dump2Str( '!!>> K_CMEDAExtIniFilesToMemIni >> Script "SaveDefaults" is absent' );
  end;

  N_Dump2Str(#13#10'****** CMSIniFiles DUMP');
  K_IniFileCreateParams := K_DFCreatePlain;
  for i := 0 to WIniFiles.Count - 1 do
  begin
    N_Dump2Str(#13#10 + WIniFiles[i]);
    IniDFPLName := WIniFiles.Names[i];
    if K_StrStartsWith( '//', IniDFPLName ) then Continue;
    IniFName := WIniFiles.ValueFromIndex[i];
    if (IniFName = '') or
       not K_CMEDAExtIniFileToMemIni( IniFName, IniDFPLName ) then
      Continue;
    N_Dump2Str(#13#10);
    Inc(Result);
  end;
  WIniFiles.Free;
end; // end of K_CMEDAExtIniFilesToMemIni

//********************************************** K_CMEDAMemIniToExtIniFiles ***
// Save content from Current MemIni to Ini-files
//
//     Parameters
// Result - Returns number of Ini files processed successfully
//
// List of Ini-files is get from [CMSIniFiles] section of Current MemIni
//
function K_CMEDAMemIniToExtIniFiles(): Integer;
var
  i: Integer;
  WIniFiles: TStringList;
  IniFName: string;
  IniDFPLName: string;
begin
  WIniFiles := TStringList.Create;
  N_CurMemIni.ReadSectionValues('CMSIniFiles', WIniFiles);
  Result := 0;
  for i := 0 to WIniFiles.Count - 1 do
  begin
    IniDFPLName := WIniFiles.Names[i];
    if K_StrStartsWith( '//', IniDFPLName ) then Continue;
    IniFName := WIniFiles.ValueFromIndex[i];
    if (IniFName <> '') and
       K_CMEDAMemIniToExtIniFile( IniFName, IniDFPLName ) then
      Inc(Result);
  end;
  WIniFiles.Free;
end; // end of K_CMEDAMemIniToExtIniFiles

//************************************************ K_CMSRebuildCommonRImage ***
// Rebuild Common Raster Image Object by current context
//
function K_CMSRebuildCommonRImage() : Boolean;
Type TRasterImageClass = class of TK_RasterImage;
var
  NewClass : TRasterImageClass;
  NewRI : TK_RasterImage;
  WStr : string;
begin
  Result := TRUE;
  NewClass := TK_RIGDIP;   // GDI+
  if K_CMSRImageType = 1 then
    NewClass := TN_RIImLib // ImLib
  else
  if K_CMSRImageType = 2 then
    NewClass := TK_URI;   // TK_CMRI
  if K_RIObj.ClassType <> NewClass then
  begin
    NewRI := NewClass.Create();
    if NewRI.RIObjectReady() then
    begin
      WStr := format( 'RebuildCommonRImage %s >> %s OK',
                  [K_RIObj.ClassName,	NewRI.ClassName] );
      K_RIObj.Free;
      K_RIObj := NewRI;
    end
    else
    begin
      Result := FALSE;
      WStr := format( 'RebuildCommonRImage %s >> %s fails', [K_RIObj.ClassName,	NewRI.ClassName] );
      NewRI.Free;
      K_CMSRImageType := 0;
      if NewClass = TK_RIGDIP then
        K_CMSRImageType := K_CMSRImageNotGDIType;
    end;
  end
  else
    WStr := format( 'RebuildCommonRImage %s stay', [K_RIObj.ClassName] );

  N_Dump1Str( WStr + ' 16bitMode=' + N_B2S( not K_CMSSkip16bitMode ) );
end; // end of K_CMSRebuildCommonRImage

//*************************************************** K_CMSCheckMemForSlide ***
// Check Memory state for Slide open or creation
//
//     Parameters
// AUDSlide   - opening Slide for memory check
// ABufCount  - number of buffers to check
// ADIBCount  - number of DIBs to check
// APixWidth  - creating Slide width
// APixHeight - creating Slide height
//
function K_CMSCheckMemForSlide( AUDSlide : TN_UDCMSlide; ABufCount : Integer = 0;
                                ADIBCount : Integer = 0; APixWidth  : Integer = 0;
                                APixHeight : Integer = 0 ) : Boolean;
var
  i, BytesCount : Integer;
  MEMs : array of THandle;
  DIBMEMs : array of THandle;
  FPixBytes : Integer;
//  DIBs : TN_DIBObjArray;
//  PixFmt: TPixelFormat;
//  ExPixFmt: TN_ExPixFmt;
  CurImgExists : Boolean;
  MapImgExists : Boolean;

begin
{
  Result := ((K_CMImgMaxMemSize = 0) or (K_CMImgMaxMemSize > K_CMImgCurMemSize));
  if not Result then Exit; // not enough memory

  Result := ((K_CMImgCheckMemFragmSize = 0) or (K_CMImgCheckMemFragmSize > K_CMImgCurMemSize));
  if Result then Exit; // additional memory check is not needed;
}

  MEMs := nil;
  DIBMEMs := nil;
  if ABufCount < 0 then ABufCount := 0;
  if ADIBCount < 0 then ADIBCount := 0;

  if AUDSlide <> nil then
  begin
  // Check By Slide - should be used before Slide should be opened or some pixels convertion
  // operation should be done
    Result := TRUE;

    SetLength( MEMs, ABufCount );

    with AUDSlide.P()^.CMSDB do
    begin
      APixWidth := PixWidth;
      APixHeight := PixHeight;
      FPixBytes := (PixBits + 7) shr 3;
//      PixFmt := pf24bit;
//      ExPixFmt := epfBMP;
//      case FPixBytes of
//      1 : begin PixFmt := pfCustom; ExPixFmt := epfGray8; end;
//      2 : begin PixFmt := pfCustom; ExPixFmt := epfGray16; end;
//      end;
    end;

    // DIBs 1 for CurImage, 1 for MapImage and 1 additional DIB for CurImage loading by RIObj
//    SetLength( DIBs, ADIBCount + 3 );
    SetLength( DIBMEMs, ADIBCount + 3 );

    // Check Memory for Current Image
    CurImgExists := AUDSlide.GetCurrentImage( TRUE, TRUE ) <> nil;
    MapImgExists := AUDSlide.GetMapImage( TRUE ) <> nil;

    if not CurImgExists then
    begin
      if K_RIObj is TK_RIGDIP then
      begin // TK_RIGDIP
        if (ADIBCount = 0) and
           MapImgExists then
          Inc( ADIBCount ); // additional DIB for CurImage loading by RIObj is needed
      end
      else
      begin // TK_RIImLib
        if (ABufCount = 0) and
           MapImgExists then // additional Buffer for loading by RIObj is needed
        begin
          ABufCount := 1;
          SetLength( MEMs, 1 );
        end
      end;

      // Check space for Current Image DIB
      BytesCount := (((APixWidth * FPixBytes + 3) shr 2) shl 2) // DIB Lines should be DWord aligned
                    * APixHeight;
      DIBMEMs[0] := Windows.GlobalAlloc( GMEM_MOVEABLE, BytesCount );
      if DIBMEMs[0] = 0 then
      begin
        N_Dump2Str( format( '!!!CheckMemForSlide CurImage Size=%d fails', [BytesCount] ) );
        Result := FALSE;
      end;
      AUDSlide.CMSSkipMemFree4CurImage := Result;

{
      DIBs[0] := TN_DIBObj.Create();
      try
        DIBs[0].PrepEmptyDIBObj( APixWidth, APixHeight, PixFmt, -1, ExPixFmt );
      except
        Result := FALSE;
      end;
}
    end; // if AUDSlide.GetCurrentImage( TRUE, TRUE ) = nil

    // Check Memory for Map Image
    if Result and not MapImgExists then
    begin
      BytesCount := (((APixWidth * 3 + 3) shr 2) shl 2) // DIB Lines should be DWord aligned
                    * APixHeight;
      // Check space for Map Image DIB
      DIBMEMs[1] := Windows.GlobalAlloc( GMEM_MOVEABLE, BytesCount );
      if DIBMEMs[1] = 0 then
      begin
        N_Dump2Str( format( '!!!CheckMemForSlide MapImage Size=%d fails', [BytesCount] ) );
        Result := FALSE;
      end;
{

      DIBs[1] := TN_DIBObj.Create();
      try
        DIBs[1].PrepEmptyDIBObj( APixWidth, APixHeight, pf24bit );
      except
        Result := FALSE;
      end;
}
      AUDSlide.CMSSkipMemFree4MapImage := Result;
    end; // if Result and (AUDSlide.GetMapImage( TRUE ) = nil) then

    // Check Memory for future DIB operations with slide
    if Result then
    begin
      BytesCount := (((APixWidth * 4 + 3) shr 2) shl 2) // DIB Lines should be DWord aligned
                    * APixHeight;
      for i := 2 to 1 + ADIBCount do
      begin
        DIBMEMs[i] := Windows.GlobalAlloc( GMEM_MOVEABLE, BytesCount );
        if DIBMEMs[i] <> 0 then Continue;
        N_Dump2Str( format( '!!!CheckMemForSlide for future %d Size=%d fails',
                    [i, BytesCount] ) );
        Result := FALSE;
        break;
      end;
    end;
{
    try
      for i := 2 to 1 + ADIBCount do
      begin
        DIBs[i] := TN_DIBObj.Create();
        DIBs[i].PrepEmptyDIBObj( APixWidth, APixHeight, pf32bit );
      end;
    except
      Result := FALSE;
    end;
}
    // Check Memory buffers for future operations with slide
    if Result then
    begin
      BytesCount := (((APixWidth * FPixBytes + 3) shr 2) shl 2) // DIB Lines should be DWord aligned
                    * APixHeight;

      if (BytesCount > Length(K_CMSUNDOBuffer)) and
         (ABufCount = 0) then
      begin // Additional Buffer for UNDO realloc check
        K_CMSUNDOBuffer := nil; // Free K_CMSUNDOBuffer before memory Test
        SetLength( MEMs, 1 );
        MEMs[0] := Windows.GlobalAlloc( GMEM_MOVEABLE, BytesCount );
        if MEMs[0] = 0 then
        begin
          N_Dump2Str( format( '!!!CheckMemForSlide for UNDO buf Size=%d fails',
                              [BytesCount] ) );
          Result := FALSE;
        end;
      end   // Additional Buffer for UNDO realloc check
      else
      begin // Check Additional Buffers
        BytesCount := (((APixWidth * 4 + 3) shr 2) shl 2) // DIB Lines should be DWord aligned
                      * APixHeight;
        for i := 0 to High(MEMs) do
        begin
          MEMs[i] := Windows.GlobalAlloc( GMEM_MOVEABLE, BytesCount );
          if MEMs[i] <> 0 then Continue;
          N_Dump2Str( format( '!!!CheckMemForSlide for 1 add bufs %d Size=%d fails',
                    [i, BytesCount] ) );
          Result := FALSE;
          Break;
        end;
      end;
    end;
    if not Result then
    begin
      AUDSlide.CMSSkipMemFree4CurImage := FALSE;
      AUDSlide.CMSSkipMemFree4MapImage := FALSE;
    end;
  end // end of Check By Slide
  else
  begin
  // Check By Width/Height - should be used before creation new slide from imported DIB

    BytesCount := (((APixWidth*4+3) shr 2) shl 2) // DIB Lines should be DWord aligned
                  * APixHeight;
    if BytesCount = 0 then  BytesCount :=  K_CMImgMaxPixelsSize * 3;

    SetLength( MEMs, ABufCount + ADIBCount );

    // Check Memory DIBs and buffers for future operations with slide
    Result := TRUE;
    for i := 0 to ABufCount - 1 do
    begin
      MEMs[i] := Windows.GlobalAlloc( GMEM_MOVEABLE, BytesCount );
      if MEMs[i] <> 0 then Continue;
      N_Dump2Str( format( '!!!CheckMemForSlide for 2 add bufs %d Size=%d fails',
                [i, BytesCount] ) );
      Result := FALSE;
      Break;
    end;
{
    // Check Memory for future DIB operations with slide
    SetLength( DIBs, ADIBCount );
    if Result then
    try
      for i := 2 to High(DIBs) do
      begin
        DIBs[i] := TN_DIBObj.Create();
        DIBs[i].PrepEmptyDIBObj( APixWidth, APixHeight, pf32bit );
      end;
    except
      Result := FALSE;
    end;
}
  end; // end of Check By Width/Height

  // Free Buffers
  for i := High(MEMs) downto 0 do
    if MEMs[i] <> 0 then Windows.GlobalFree( MEMs[i] );
  MEMs := nil;
  for i := High(DIBMEMs) downto 0 do
    if DIBMEMs[i] <> 0 then Windows.GlobalFree( DIBMEMs[i] );
  DIBMEMs := nil;
{
  // Free DIBs
  for i := High(DIBs) downto 0 do
    DIBs[i].Free();
  DIBs := nil
}
end; // end of K_CMSCheckMemForSlide

//*************************************************** K_CMSCheckMemForSlide ***
// Check Memory state for Slide open or creation
//
//     Parameters
// AUDSlide   - opening Slide for memory check
// ABufCount  - number of buffers to check
// ADIBCount  - number of DIBs to check
// APixWidth  - creating Slide width
// APixHeight - creating Slide height
//
function K_CMSCheckMemForSlide1( AUDSlide : TN_UDCMSlide; ABufCount : Integer = 0;
                                ADIBCount : Integer = 0; APixWidth  : Integer = 0;
                                APixHeight : Integer = 0 ) : Boolean;
begin
{ !!! previous version
  if not ASkipMemFree then
    K_CMSCheckMemConstraints( AUDSlide ); // Free Memory before Slide action MemCheck

  Result := K_CMSCheckMemForSlide( AUDSlide, ABufCount, ADIBCount,
                                  APixWidth, APixHeight );
  if Result then Exit;

  K_CMSCheckMemConstraints( AUDSlide, TRUE ); // Free All Memory before next Slide action MemCheck

  Result := K_CMSCheckMemForSlide( AUDSlide, ABufCount, ADIBCount,
                                   APixWidth, APixHeight );
}
  Result := K_CMSCheckMemForSlide( AUDSlide, ABufCount, ADIBCount,
                                  APixWidth, APixHeight );
  if Result then Exit;

  N_Dump2Str( format( 'CheckMemForSlide bufs=%d dibs=%d w=%d h=%d',
                        [ABufCount, ADIBCount, APixWidth, APixHeight] ) );
  K_CMSCheckMemConstraints( AUDSlide ); // Free Memory after Slide action MemCheck

  Result := K_CMSCheckMemForSlide( AUDSlide, ABufCount, ADIBCount,
                                  APixWidth, APixHeight );
  if Result then Exit;

  N_Dump2Str( 'CheckMemForSlide free all' );
  K_CMSCheckMemConstraints( AUDSlide, TRUE ); // Free All Memory before next Slide action MemCheck

  Result := K_CMSCheckMemForSlide( AUDSlide, ABufCount, ADIBCount,
                                   APixWidth, APixHeight );
end; // end of K_CMSCheckMemForSlide1

//************************************************ K_CMSCheckMemForSlideDlg ***
// Check Memory state for change Slide pixels operation
//
//     Parameters
// AUDSlide  - opening Slide for memory check
// AWarning  - warning text if out of memory
// ABufCount - number of additional buffers to check
// ADIBCount - number of additional DIBs to check
//
function K_CMSCheckMemForSlideDlg( AUDSlide : TN_UDCMSlide; AWarning : string;
                                   ABufCount : Integer = 0; ADIBCount : Integer = 0 ) : Boolean;
begin
  Result := K_CMSCheckMemForSlide1( AUDSlide, ABufCount, ADIBCount );
  if Result then Exit;
  K_CMOutOfMemoryFlag := TRUE;
  K_CMShowSoftMessageDlg( AWarning, mtWarning, 10 );
end; // function K_CMSCheckMemForSlideDlg

//*************************************************** K_CMSCheckMemFreeDump ***
// Check Memory state for change Slide pixels operation
//
procedure K_CMSCheckMemFreeDump();
var
  MaxFree : Integer;
begin
  MaxFree := K_FreeSpaceSearchMax( 2000000000, K_FreeSpaceMemCheck );
  N_Dump1Str( format( 'MemFreeSpace >> Maximal Alloc Space %d', [MaxFree] ) );
//  MaxFree := K_FreeSpaceSearchMax( 2000000000, K_FreeSpaceBufCheck );
//  N_Dump2Str( format( 'MemFreeSpace >> Maximal Buf Free Space %d', [MaxFree] ) );
//  MaxFree := K_FreeSpaceSearchMax( 2000000000, N_CheckDIBFreeSpace );
//  N_Dump2Str( format( 'MemFreeSpace >> Maximal DIB Free Space %d', [MaxFree] ) );
end; // procedure K_CMSCheckMemFreeDump

//***************************************************** K_CMSearchSlideByID ***
// Resample given Slides if needed
//
//     Parameters
// APSlide - pointer to start element in Slides array to resample
// ASlidesCount - number of Slides in Slides array
// AShowInfoProc - show resample info
// APOutOfMemCount - pointer to
// Result - Returns number of Resampled Slides
//
function K_CMSResampleSlides( APSlide: TN_PUDCMSlide; ASlidesCount: Integer;
                              AShowInfoProc : TK_NotifyStr1Proc = nil ): Integer;
var
  i: Integer;
  RSize : TPoint;
  UDDIB : TN_UDDIB;
  WDIBObj : TN_DIBObj;
  DIBPixArea : Integer;
  PData : Pointer;
  DSize : Integer;
  FilePath : string;
  SSysInfo : string;
  MapRoot : TN_UDCompVis;
  ProcessResult : Integer;
  SaveDBErrFlag : Boolean;
  ResampledSlides : TN_UDCMSArray;
  SQLStr : string;

label ContLoop;

  ////////////////////////////////////////////////////////// Resample8BitDIBObj
  //
  function Resample8BitDIBObj( var ADIBObj : TN_DIBObj ) : TN_DIBObj;
  var
    NeededSize : TPoint;
    ConvertToGreyFlag : Boolean;
  begin
    Result := nil;
    NeededSize := K_RIObj.RIGetDIBMaxSize( ADIBObj.DIBSize );

    // Reduce ADIBObj Size to NeededSize by drawing (by N_StretchRect)

    WDIBObj := TN_DIBObj.Create();
    try
      WDIBObj.PrepEmptyDIBObj( NeededSize.X, NeededSize.Y, pf24bit );
    except
      WDIBObj.Free;
      Exit;
    end; // except

    N_StretchRect( WDIBObj.DIBOCanv.HMDC, WDIBObj.DIBRect, ADIBObj.DIBOCanv.HMDC, ADIBObj.DIBRect );

    Result := WDIBObj;
    ConvertToGreyFlag := ADIBObj.DIBExPixFmt = epfGray8;
    if ConvertToGreyFlag then
    begin
      WDIBObj := TN_DIBObj.Create();
      try
        WDIBObj.PrepEmptyDIBObj( NeededSize.X, NeededSize.Y, pf24bit );
      except
        FreeAndNil( Result );
        WDIBObj.Free;
        Exit;
      end; // except
      Result.CalcGrayDIB( WDIBObj );
      FreeAndNil( Result );
      Result := WDIBObj;
    end;

    FreeAndNil( ADIBObj );
  end; // function Resample8BitDIBObj

  ///////////////////////////////////////////////////////////// SaveUDDIBToFile
  //
  function SaveUDDIBToFile( AFName : string; AImageType : string ) : Boolean;
  var
    ChildInd : Integer;
  begin
    with UDDIB, PISP()^ do
    begin
      CDIBFlagsN := [uddfnUseUDData,uddfnFreeUDData];
      CDIBDataFormat  := uddfJPEG; // UDData field Format while saving (not used while loading!)
      CDIBJPEGQuality := 100; // JPEG Quality (Compression level) from 1 to 100
      UDData := nil;
    end;

    if K_CMEDAccess is TK_CMEDDBAccess then
    begin
    // Rewrite File in Ext DB Mode
      K_CMGetUDDIBSData( UDDIB, PData, DSize );
      Result := K_edOK = K_CMEDAccess.EDASlideDataToFile( PData, DSize, AFName );
    end
    else
    begin
    // Rewrite File in Local DB Mode
      if AImageType = 'Original' then
      begin
        K_CMEDAccess.EDASaveSlideSrcImage();
        ChildInd := K_CMSlideIndSrcImg;
      end
      else
      begin
        K_CMEDAccess.EDASaveSlideCurImage();
        ChildInd := K_CMSlideIndCurImg;
      end;
      Result := K_edOK = K_CMEDAccess.EDASlideDIBToFile( APSlide.DirChild(ChildInd), TRUE );
    end;

    if not Result then Exit;
    N_Dump1Str( 'SlideResample >> file is rewrited' );
  end; // function SaveUDDIBToFile

  //////////////////////////////////////////////////////////////// ProcessUDDIB
  //
  //  Resul: 0 - Resampled DIB was successfully saved to file
  //         1 - DIB is already resampled
  //         2 - Resampled DIB saving error
  //         3 - New UDDIB saving format: LoadDIBObj problems
  //         4 - Old UDDIB saving format: out of memory while loading to memory
  //
  function ProcessUDDIB( AImageType : string; AFName : string; APFSize : PInteger ) : Integer;
  label SaveToFile;
  begin
    Result := 10;                                         // '%s is resampling ...'
    if Assigned( AShowInfoProc ) then AShowInfoProc( format(K_CML1Form.LLLResampleLarge0.Caption, [ExtractFileName(AFName)] ) );
    if UDDIB <> nil then
    begin
      Result := 1;
      if UDDIB.DIBObj <> nil then
      begin
      // check old version format
        if DIBPixArea = UDDIB.DIBObj.DIBSize.X * UDDIB.DIBObj.DIBSize.Y then
        begin
        // Resample DIB and save new UDDIB to file
          N_Dump1Str( 'SlideResample >> ' + AImageType + ' old image 8Bit DIBObj' );
          WDIBObj := Resample8BitDIBObj( UDDIB.DIBObj );
          if WDIBObj <> nil then
          begin
            UDDIB.DIBObj := WDIBObj;
SaveToFile:
            if SaveUDDIBToFile( AFName, AImageType ) then
            begin
              APFSize^ := DSize;  // Store Slide Original Image Size
              Result := 0;
            end
            else
            begin
              N_Dump1Str( 'SlideResample >> ' + AImageType + ' image SlideDataToFile Error' );
              Result := 2;
            end;
          end
          else
          begin
            Result := 4;
            Inc(K_CMSResampleOutOfMemCount);
            N_Dump1Str( 'SlideResample >> ' + AImageType + ' image Out Of Memory' );
          end;
        end
        else
          N_Dump1Str( 'SlideResample >> ' + AImageType + ' image is resampled' );
      end // if UDDIB.DIBObj <> nil then
      else
      begin // if UDDIB.DIBObj = nil then
        N_Dump1Str( 'SlideResample >> ' + AImageType + ' new DIBObj' );
        try
          UDDIB.LoadDIBObj;
        except
          on E: Exception do
          begin
            Result := 3;
            if Pos( 'memory', E.Message ) > 0 then
              Inc(K_CMSResampleOutOfMemCount);
            N_Dump1Str( 'SlideResample >> ' + AImageType + ' image Load Error >> ' + E.Message );
          end;
        end;
        if UDDIB.DIBObj <> nil then
        begin
          if DIBPixArea = K_RIObj.RILastImageSize.X * K_RIObj.RILastImageSize.Y then
            goto SaveToFile
          else
            N_Dump1Str( 'SlideResample >> ' + AImageType + ' image is resampled' );
        end;
      end
    end
    else
      N_Dump1Str( 'SlideResample >> ' + AImageType + ' image is absent' );
  end; // function ProcessUDDIB

begin

  Result := 0;

  K_RIObj.RIMaxPixelsCount := K_CMImgMaxPixelsSize;
  SetLength( ResampledSlides, ASlidesCount );
  for i := 0 to ASlidesCount - 1 do
  begin
  ////////////////////////////////
    if TN_UDCMBSlide(APSlide^) is TN_UDCMStudy then goto ContLoop;

    with APSlide^, P^  do
    begin
      if cmsfIsMediaObj in CMSDB.SFlags then goto ContLoop;

      if GetCurrentImage( TRUE, TRUE ) <> nil then goto ContLoop;

    // Image is not loaded - check the size

      RSize := K_RIObj.RIGetDIBMaxSize( Point( CMSDB.PixWidth, CMSDB.PixHeight ) );
      if RSize.X < CMSDB.PixWidth then
      begin // Resample is needed
        // DUMP Start Resample
        N_Dump1Str( 'SlideResample >> start ID=' + ObjName );
        DIBPixArea := CMSDB.PixWidth * CMSDB.PixHeight;
        FilePath := '';
        if K_CMEDAccess is TK_CMEDDBAccess then
          FilePath := TK_CMEDDBAccess(K_CMEDAccess).EDAGetSlideImgPath( APSlide^ );

      /////////////////////////////
      //  Resample Original Image
      //
        if cmsfHasSrcImg in CMSDB.SFlags then
        begin // Try to resample Origial image
          UDDIB := GetSourceImage( FALSE, TRUE );
          ProcessResult := ProcessUDDIB( 'Original',
                        GetSrcImgFileName(FilePath),
                        @CMSSrcImgFSize );
          if ProcessResult >= 2 then goto ContLoop;
        end; // if cmsfHasSrcImg in CMSDB.SFlags then
      //
      //  Resample Original Image
      /////////////////////////////

      /////////////////////////////
      //  Resample Current Image
      //
        UDDIB := GetCurrentImage( FALSE, TRUE );
        ProcessResult := ProcessUDDIB( 'Current',
                         GetCurImgFileName(FilePath),
                         @CMSCurImgFSize );
        if ProcessResult >= 2 then goto ContLoop;
      //
      //  Resample Current Image
      /////////////////////////////

      /////////////////////////////
      // Rebuild Slide Attrs by DIB
        CMSDB.PixWidth := RSize.X;
        CMSDB.PixHeight:= RSize.Y;
        CMSDB.PixBits := UDDIB.DIBObj.DIBNumBits;
        if UDDIB.DIBObj.DIBPixFmt = pf24bit then // Color24
          CMSDB.PixBits := 24;
        CMSDB.BytesSize:= ((CMSDB.PixBits + 7) shr 3) * RSize.X * RSize.Y;

        if K_CMEDAccess is TK_CMEDDBAccess then
        begin
          with TK_CMEDDBAccess(K_CMEDAccess) do
          begin
          // Try To Change MapRoot and Slide

            with CurSlidesDSet do
            begin
              SQL.Text := 'select ' +
              K_CMENDBSTFSlideID      + ',' +
              K_CMENDBSTFSlideSysInfo + ',' +
              K_CMENDBSTFSlideMapRoot + ',' +
              K_CMENDBSTFSlideCurFSize+ ',' +
              K_CMENDBSTFSlideSrcFSize+
              ' from ' + K_CMENDBSlidesTable +
              ' where ' + K_CMENDBSTFSlideID + ' = ' + ObjName;

              Filtered := false;
              Open;
              SaveDBErrFlag := K_edOK <> EDAGetSlideMapRoot0( APSlide^ );
              if not SaveDBErrFlag then
              begin
                MapRoot := TN_UDCompVis(DirChild(K_CMSlideIndMapRoot));
                with MapRoot.PCCS()^ do
                  SRSize := FPoint( RSize );

              // Save Fields
                if K_CMEDDBSysInfoSPLDTC.DTCode = 0 then
                  K_CMEDDBSysInfoSPLDTC := K_GetExecTypeCodeSafe('TN_CMSlideSDBF');

                Edit;

                SSysInfo := K_SaveSPLDataToText( CMSDB, K_CMEDDBSysInfoSPLDTC.All );
                EDAPutStringFieldValue( Fields[1], SSysInfo );

                K_SaveTreeToText(MapRoot, K_SerialTextBuf);
                DSize := EDAStringsToAnsiText(K_SerialTextBuf.TextStrings, PData);
                EDAPutBlobFieldValue( CurSlidesDSet, Fields[2], PData, DSize );

                if (CMSCurImgFSize <> 0) and (Fields[3].AsInteger <> CMSCurImgFSize) then
                  Fields[3].AsInteger := CMSCurImgFSize;
                if (CMSSrcImgFSize <> 0) and (Fields[4].AsInteger <> CMSSrcImgFSize) then
                  Fields[4].AsInteger := CMSSrcImgFSize;

                UpdateBatch;
              end // if not SaveDBErrFlag then
              else
                N_Dump1Str( 'SlideResample >> MapRoot Load Erro' );

              Close;
              PutDirChild( K_CMSlideIndMapRoot, nil ); // Clear Map Root
              if not SaveDBErrFlag then
              begin
                ResampledSlides[Result] := APSlide^;
                Inc( Result );
              end;
            end; // with CurSlidesDSet do
          end; // with TK_CMEDDBAccess(K_CMEDAccess) do
        end // if K_CMEDAccess is TK_CMEDDBAccess then
        else
        begin // Local DB Mode
          MapRoot := TN_UDCompVis(DirChild(K_CMSlideIndMapRoot));
          with MapRoot.PCCS()^ do
            SRSize := FPoint( RSize );

          K_SetChangeSubTreeFlags(APSlide^);
          Inc( Result );
        end;

      end; // if RSize.X < CMSDB.PixWidth then - start Resample
    end; // with APSlide.P^ do
ContLoop:
    Inc(APSlide);
  end; // for i := 0 to ASlidesCount - 1 do

  if Result > 0 then
  begin
    if K_CMEDAccess is TK_CMEDDBAccess then
      with TK_CMEDDBAccess(K_CMEDAccess) do
      begin // Save History event
        EDABuildSelectSQLBySlidesList( @ResampledSlides[0], Result, @SQLStr, nil );
        EDASaveSlidesHistory( SQLStr, EDABuildHistActionCode(K_shATChange,
                                   Ord(K_shCAImage), Ord(K_shImgActResample)) );
      end
    else
      K_SetArchiveChangeFlag();
  end;

  K_RIObj.RIMaxPixelsCount := 0;

end; // end of K_CMSResampleSlides

//************************************************* K_CMEDAGetDBStringValue ***
// Get DB Field string value
//
//     Parameters
// AField - TField object
// Result - Returns Field String Value
//
function  K_CMEDAGetDBStringValue( AField : TField ) : string;
begin
{$IF SizeOf(Char) = 2} // Wide Chars (>= Delphi 2010) Types and constants
  Result := N_AnsiToString( AField.AsAnsiString )
{$ELSE} //*************** Ansi Chars (Delphi 7) Types and constants
  Result := AField.AsString;
{$IFEND}
//  if K_CMEDAMSSQL and (AField is TMemoField) and (Length(Result) > 0)then
//    AField.GetData( @Result[1] );
//    if AField is TStringField then
//    Result := N_AnsiToString( TMemoField(AField).Value );
end; // K_CMEDAGetDBStringValue

//******************************************* K_CMEDAGetSlideSelectWhereStr ***
// Get Slide WHERE clause string for select statement
//
//     Parameters
// ACtrlFlags - flags to control WHERE clause
// AFieldPref - field name prefix
// Result - Returns string with WHERE clause string for select statement
//
function K_CMEDAGetSlideSelectWhereStr( ACtrlFlags : TK_CMEDASelectWhereFlags;
                                        AFieldPref : string = '' ) : string;
begin
  Result := '';
  if K_CMEDDBVersion < 10 then Exit;
  if ACtrlFlags  = K_swfSkipFlagsCond then Exit;
  if ACtrlFlags = K_swfSkipAllDel then
    Result := ' and (' + AFieldPref + K_CMENDBSTFSlideFlags + '=0' + ' or ' + AFieldPref + K_CMENDBSTFSlideFlags + ' IS NULL)'
  else if ACtrlFlags = K_swfOnlyMarkedAsDel then
    Result := ' and ' + AFieldPref + K_CMENDBSTFSlideFlags + '= 1'
  else if ACtrlFlags = K_swfSkipDBDeleting then
    Result := ' and (' + AFieldPref + K_CMENDBSTFSlideFlags + '<> 2' + ' or ' + AFieldPref + K_CMENDBSTFSlideFlags + ' IS NULL)'
  else if ACtrlFlags = K_swfOnlyDBDeleting then
    Result := ' and ' + AFieldPref + K_CMENDBSTFSlideFlags + '= 2'

//  if K_CMEnterpriseModeFlag then
//    Result := ' and ' + K_CMENDBLFILocID + '=' + IntToStr(CurLocID) +
//              ' and ' + K_CMENDBLFILocSlideID + '=' + K_CMENDBSTFSlideID;
end; // end of K_CMEDAGetSlideSelectWhereStr

//******************************************** K_CMEDAGetSlideSysFieldsData ***
// Get Slide Sys Fields Data
//
//     Parameters
// ASysInfo - SysInfo string Data
// APCMSlideSDBF - pointer to Slide Sys Fields Data
//
procedure K_CMEDAGetSlideSysFieldsData( const ASysInfo: string; APCMSlideSDBF: TN_PCMSlideSDBF);
var
  ErrorString : string;
begin
  if ASysInfo <> '' then
  begin
{DEB CODE
N_s := ASysInfo;
with  K_GetFormTextEdit( nil ) do
  EditText( N_s, 'SysInfo', TRUE, TRUE );
{}
    if K_CMEDDBSysInfoSPLDTC.DTCode = 0 then
      K_CMEDDBSysInfoSPLDTC := K_GetExecTypeCodeSafe('TN_CMSlideSDBF');
    if ASysInfo[1] = '<' then
      // new format
      K_LoadSPLDataFromText(APCMSlideSDBF^, K_CMEDDBSysInfoSPLDTC.All, ASysInfo)
    else
    begin
      // old format
      ErrorString := K_SPLValueFromString( APCMSlideSDBF^,
                                           K_CMEDDBSysInfoSPLDTC.All, ASysInfo );
      if ErrorString <> '' then
        raise Exception.Create(ErrorString);
    end;
  end
  else
  with APCMSlideSDBF^ do
  begin
    SFlags := [];
    BytesSize := 0;
  end;

end; // end of K_CMEDAGetSlideSysFieldsData

//*************************************************** K_CMPrepSlideDCMAttrs ***
// Prepare Slide DICOM Attributes from Dialog DICOM Attributes
//
//    Parameters
// APSrcDCMAttrs - pointer to Dialog DICOM Attributes record
// AResDCMAttrs  - resulting Slide DICOM Attributes record
//
procedure K_CMPrepSlideDCMAttrs( APSrcDCMAttrs : TK_PCMDCMAttrs; var AResDCMAttrs : TK_CMDCMAttrs );
var
  EmptyAttrs : Boolean;
begin
  // Prepare DICOM Attrs
  AResDCMAttrs := APSrcDCMAttrs^;
  with AResDCMAttrs do
  begin
    EmptyAttrs := (CMDCMModality = '') or
                  (CMDCMModality = K_CMSlideDefDCMModColorXC) or
                  (CMDCMModality = K_CMSlideDefDCMModColorES) or
                  (CMDCMModality = K_CMSlideDefDCMModColorGM);
    if EmptyAttrs then
    begin
      CMDCMKVP := 0;
      CMDCMTubeCur := 0;
      CMDCMExpTime := 0;
    end;
{
    if EmptyAttrs or (CMDCMKVP = K_CMSlideDefDCMKVP) then
      CMDCMKVP := 0;
    if EmptyAttrs or (CMDCMTubeCur = K_CMSlideDefDCMTubeCur) then
      CMDCMTubeCur := 0;
    if EmptyAttrs or (CMDCMExpTime = K_CMSlideDefDCMExpTime) then
      CMDCMExpTime := 0;
}
  end;

end; // end of K_CMPrepSlideDCMAttrs

//************************************************** K_CMPrepDialogDCMAttrs ***
// Prepare Dialog DICOM Attributes from Slide DICOM Attributes
//
//    Parameters
// APSrcDCMAttrs - pointer to Dialog DICOM Attributes record
// AResDCMAttrs  - resulting DICOM Attributes record for saving to Slide
// APSrcDCMAttrs - pointer to Slide DICOM Attributes record
// AResDCMAttrs  - resulting Dialog DICOM Attributes record
//
procedure K_CMPrepDialogDCMAttrs( APSrcDCMAttrs : TK_PCMDCMAttrs; var AResDCMAttrs : TK_CMDCMAttrs );
begin
  // Prepare DICOM Attrs
  if APSrcDCMAttrs <> nil then
    AResDCMAttrs := APSrcDCMAttrs^;
{
  with AResDCMAttrs do
  begin
    if CMDCMKVP = 0 then
      CMDCMKVP := K_CMSlideDefDCMKVP;
    if CMDCMTubeCur = 0 then
      CMDCMTubeCur := K_CMSlideDefDCMTubeCur;
    if CMDCMExpTime = 0 then
      CMDCMExpTime := K_CMSlideDefDCMExpTime;
  end;
}
end; // end of K_CMPrepDialogDCMAttrs

//******************************************************* K_CMPrepHPContext ***
// Prepare High Resolution Show Context by D4W (COM-client) info
//
//    Parameters
// AMediaSlide - Slide Object if Slide with ID=K_CMD4WHPViewSlideID is Video, nil else
// Result - Returns Current Show Index
//
function K_CMPrepHPContext( out AMediaSlide : TN_UDCMSlide ) : Integer;
var
  NewSlidesCount, DelSlidesCount, UpdateSlidesCount : Integer;
  SL : TStringList;
  RebuildVisSlides : Boolean;
  i, j, Ind : Integer;
  UDSlide, SelUDSlide : TN_UDCMSlide;
  StudiesCount : Integer;
  SelSID : string;
  CurSkipArchivedFlag : Boolean;
  WCurVisSlidesArray  : TN_UDCMSArray;

label IncludeAllPatSlides;

  function PrepSlideView () : Boolean;
  begin
    with UDSlide.P()^.CMSDB  do
    begin
      Result := not (cmsfIsMediaObj in SFlags) and
                not (cmsfIsImg3DObj in SFlags);
      if not Result then Exit;
      if (SFlags * [cmsfShowColorize, cmsfShowIsodensity, cmsfShowEmboss]) <> [] then
      begin
        K_CMEDAccess.EDAInitSlideViewAttrs(UDSlide);
        UDSlide.ClearMapImage();
      end;
    end;
  end;

begin
// Prepare Cur Slides Set
  K_CMSAppStartContext.CMASPatID := K_CMD4WHPNewPatientID;
  K_CMSAppStartContext.CMASProvID:= K_CMD4WHPNewProviderID;
  K_CMSAppStartContext.CMASLocID := K_CMD4WHPNewLocationID;
  K_CMSAppStartContext.CMASPSlideFilterAttrs := nil;
  K_CMD4WCNewPatientID := -1; // Clear VEUI Relaunch Context


  K_CMMarkAsDelShowFlag := FALSE;
  RebuildVisSlides := K_CMEDAccess.CurSlidesSelectAttrs.SSPatID <> K_CMSAppStartContext.CMASPatID;
  if RebuildVisSlides then
  begin // Switch to another patient
    N_Dump1Str( format( 'K_CMPrepHPContext >> Switch Patient %d -> %d',
           [K_CMEDAccess.CurSlidesSelectAttrs.SSPatID, K_CMSAppStartContext.CMASPatID] ) );
    K_CMEDAccess.CurSlidesSelectAttrs.SSPatID := K_CMSAppStartContext.CMASPatID;
    K_CMEDAccess.EDAGetCurSlidesSet();
  end
  else
  begin // Refresh current patient
    RebuildVisSlides := K_CMD4WHPFilmStripPrevIDs <> K_CMD4WHPFilmStripIDs;
    if RebuildVisSlides then
      K_CMEDAccess.EDARefreshCurSlidesSet( NewSlidesCount, DelSlidesCount, UpdateSlidesCount );
  end;

//////////////////////////////
// Select all visible Slides
//
  K_CMCurVisSlidesArray := nil;
  CurSkipArchivedFlag := K_CMShowArchivedSlidesFlag;
  K_CMShowArchivedSlidesFlag := FALSE;
  with K_CMEDAccess.CurSlidesList do
    K_CMRebuildSlidesArrayByFilter( TN_PUDCMSlide(@(List[0])), Count,
                                  K_CMCurVisSlidesArray, StudiesCount,
                                  nil );
  K_CMShowArchivedSlidesFlag := CurSkipArchivedFlag;
  AMediaSlide := nil;
  Result := -1;
  if Length(K_CMCurVisSlidesArray) = 0 then Exit;

//////////////////////////////
// Search Preview Slide
//
  with K_CMEDAccess do
  begin
    SelUDSlide := nil;
    for i := 0 to CurSlidesList.Count -1 do
    begin
      UDSlide := TN_UDCMSlide(CurSlidesList[i]);
      if UDSlide.ObjName <> K_CMD4WHPViewSlideID then Continue;
      SelUDSlide := UDSlide;
      Break;
    end;
  end;

{
  if Length(K_CMCurVisSlidesArray) > 0 then
  i := K_IndexOfIntegerInRArray(Integer(ASlide),
      PInteger(@K_CMCurVisSlidesArray[0]), Length(K_CMCurVisSlidesArray) );
}
//////////////////////////////
// Check if Selected is Video or 3D
//

  with SelUDSlide.P()^ do
    if (SelUDSlide <> nil) and
       ( (cmsfIsMediaObj in CMSDB.SFlags) or
         (cmsfIsImg3DObj in CMSDB.SFlags) ) then
    begin
      if 0 <= K_IndexOfIntegerInRArray(Integer(SelUDSlide),
        PInteger(@K_CMCurVisSlidesArray[0]), Length(K_CMCurVisSlidesArray) ) then
      begin
        AMediaSlide := SelUDSlide;
        Exit;
      end; // if selected slide is visible  
    end;

  K_CMD4WHPFilmStripPrevIDs := K_CMD4WHPFilmStripIDs;

  if RebuildVisSlides then
  begin
//////////////////////////////////////////////////
// Prepare new FilmStrip Contents and View Slide
//
    N_Dump1Str( 'K_CMPrepHPContext >> New FilmStrip src IDs >> ' + K_CMD4WHPFilmStripIDs );
    SL := TStringList.Create;
    if K_CMDesignModeFlag then
      SL.Delimiter := ';' // for testing by Proj_CMSAComClient
    else
      SL.Delimiter := #9;

    if K_CMD4WHPFilmStripIDs = '' then
    begin
IncludeAllPatSlides:
      with K_CMEDAccess do
      begin
{ // Visible Slides Array is already build
        // Prepare Visible Slides Array by CMS rules
        K_CMFilterAttrsClear(@K_CMCurSlideFilterAttrs);
        K_CMCurVisSlidesArray := nil;
        with CurSlidesList do
          K_CMRebuildSlidesArrayByFilter( TN_PUDCMSlide(@(List[0])), Count,
                                        K_CMCurVisSlidesArray, StudiesCount,
                                        @K_CMCurSlideFilterAttrs );
}
        // Remove Video or 3D Slides
        j := 0;
        for i := 0 to High(K_CMCurVisSlidesArray) do
        begin
          UDSlide := K_CMCurVisSlidesArray[i];
          if not PrepSlideView() then Continue;
          K_CMCurVisSlidesArray[j] := UDSlide;
          Inc(j);
        end;
        SetLength( K_CMCurVisSlidesArray, j );
      end;
    end   // if K_CMD4WHPFilmStripIDs = '' then
    else
    begin // if K_CMD4WHPFilmStripIDs <> '' then
//      if Pos( #9, K_CMD4WHPFilmStripIDs ) < 1 then
//        SL.Delimiter := #9
//      else
//        SL.Delimiter := ';';
      SL.DelimitedText := K_CMD4WHPFilmStripIDs;

      // Prepare Visible Slides Array from existing Slides in given List (skip video)
{ // Old code without archived control
      SetLength( K_CMCurVisSlidesArray, SL.Count );
      ZeroMemory( @K_CMCurVisSlidesArray[0], SL.Count * SizeOf(TN_UDCMSlide) );
      j := 0;
      for i := 0 to K_CMEDAccess.CurSlidesList.Count - 1 do
      begin
        UDSlide := TN_UDCMSlide(K_CMEDAccess.CurSlidesList[i]);
        Ind := SL.IndexOf( UDSlide.ObjName );
        if (Ind < 0) or not PrepSlideView() then Continue;
        K_CMCurVisSlidesArray[Ind] := UDSlide;
        Inc(j);
      end;
}
      SetLength( WCurVisSlidesArray, SL.Count );
      ZeroMemory( @WCurVisSlidesArray[0], SL.Count * SizeOf(TN_UDCMSlide) );
      j := 0;
      for i := 0 to High(K_CMCurVisSlidesArray) do
      begin
        UDSlide := K_CMCurVisSlidesArray[i];
        Ind := SL.IndexOf( UDSlide.ObjName );
        if (Ind < 0) or not PrepSlideView() then Continue;
        WCurVisSlidesArray[Ind] := UDSlide;
        Inc(j);
      end;
      K_CMCurVisSlidesArray := WCurVisSlidesArray;
      SL.Clear;

    end; // if K_CMD4WHPFilmStripIDs <> '' then

    // Remove nils from Visible Slides Array, prepare dump and define View Slide Index
    Ind := 0;
    SL.Capacity := j;
    Result := 0;
    for i := 0 to High(K_CMCurVisSlidesArray) do
    begin
      UDSlide := K_CMCurVisSlidesArray[i];
      if UDSlide = nil then Continue;
      K_CMCurVisSlidesArray[Ind] := UDSlide;
      if SelUDSlide = UDSlide then Result := Ind;
      SL.Add( UDSlide.ObjName );
      Inc(Ind);
    end;
    SetLength( K_CMCurVisSlidesArray, Ind );

{
    if (Ind = 0) and (K_CMD4WHPFilmStripIDs <> '') then
    begin // Emty Resulting Film Strip - Use All Patient Slides
      K_CMD4WHPFilmStripIDs := '';
      goto IncludeAllPatSlides;
    end;
}
    N_Dump1Str( 'K_CMPrepHPContext >> New FilmStrip res IDs >> ' + SL.DelimitedText );
    SL.Free();
//
// end of Prepare new FilmStrip Contents and View Slide Index
//////////////////////////////////////////////////////////////
  end // if RebuildVisSlides then
  else
  begin
////////////////////////////////////
// Search for View Slide Index only
//
    Result := 0;
    for i := 0 to High(K_CMCurVisSlidesArray) do
    begin
      if (SelUDSlide <> K_CMCurVisSlidesArray[i]) then Continue;
      Result := i;
      Break;
    end;
//
// end of Search for View Slide Index only
////////////////////////////////////
  end;


  SelSID := '';
  if Result >= Length(K_CMCurVisSlidesArray) then
    Result := -1
  else
    SelSID := K_CMCurVisSlidesArray[Result].ObjName;

  N_Dump1Str( format( 'K_CMPrepHPContext >> New HR ID %s > %s',
                      [K_CMD4WHPViewSlideID,SelSID] ) );

end; // end of K_CMPrepHPContext

//********************************************************* K_CMSwithToHPUI ***
// Swith to High Resolution Preview User Interface
//
procedure K_CMSwithToHPUI();
//var
//  DlgType : TMsgDlgType;
//  DlgCapt : string;

begin
  N_Dump1Str( 'K_CMSwithToHPUI start' );

  if N_CM_MainForm.CMMCurFMainForm <> nil then
  begin
  // Close CMS VE UI
    K_CMCloseOnCurUICloseFlag := FALSE;
    N_CM_MainForm.CMMCurFMainForm.Close();
  end
  else
  if (N_CM_MainForm.CMMCurFHPMainForm = nil) and
     (K_CMEDAccess is TK_CMEDDBAccess) then
  // Initialize Application
    if not K_CMReopenDBConnection() then Exit;
{
    with TK_CMEDDBAccess(K_CMEDAccess) do
    begin
      if K_edOK <> EDACheckDBConnection( LANDBConnection ) then
      begin
        N_Dump1Str('DB>> K_CMSwithToHPUI >> EDACheckDBConnection fails');
        K_CMUICheckInitResult();
        Exit;
      end;
    end;
}
 // Open CMS HP UI
  N_CM_MainForm.CMMLaunchHPUI();
end; // procedure K_CMSwithToHPUI()

//********************************************** K_CMCheckAutoUpgradeLaunch ***
// Check Auto Upgrade Launch
//
procedure K_CMCheckAutoUpgradeLaunch();
var
  AUCLine : string;
  AParams : string;
  ErrStr : string;
begin
  if (K_CMSLiRegState = K_lrsUnregCMSBuild) and (K_CMAUType = '1') then
  begin
{ !!! 2015-10-22 Replace Code
    AUCLine := format( '%s -hp <%u> -cd <%s>', [K_CMAUBridge, GetCurrentProcessId(), Application.ExeName] );
    N_Dump1Str( 'DB >> Auto Upgrade Command >> ' + AUCLine );
    if not K_RunExeByCmdl( AUCLine ) then
    begin
      N_Dump1Str( 'DB >> Auto Upgrade Error >> ' + SysErrorMessage( GetLastError() ) );
      K_CMShowMessageDlg( 'Error running client''s auto upgrading'#13#10 + AUCLine, mtError );
    end;
}
    AParams := format( '-hp <%u> -cd <%s>', [GetCurrentProcessId(), Application.ExeName] );
    AUCLine := K_CMAUBridge + ' ' + AParams;
    N_Dump1Str( 'DB >> Auto Upgrade Command >> ' + AUCLine );

    ErrStr := K_RunExe( K_CMAUBridge, AParams );
    if ErrStr <> '' then
    begin
      N_Dump1Str( 'DB >> Auto Upgrade Error >> ' + ErrStr );
      K_CMShowMessageDlg( 'Error running client''s auto upgrading'#13#10 + AUCLine, mtError );
    end;
  end;
end; // procedure K_CMCheckAutoUpgradeLaunch

//*************************************************** K_CMUICheckInitResult ***
// Check Connection Initialization Result
//
function K_CMUICheckInitResult() : Boolean;
var
  DlgType : TMsgDlgType;
  DlgCapt : string;
begin
  Result := FALSE;
  if K_CMSAppStartContext.CMASMode <= K_cmamCOMVEUI then
  begin
  // Not HR Preview or WEB
    if (K_CMSLiRegState < K_lrsOK) then
      Include( N_CM_MainForm.CMMUICurStateFlags, uicsAllActsDisabled)
    else
      Exclude( N_CM_MainForm.CMMUICurStateFlags, uicsAllActsDisabled);

    if uicsAllActsDisabled in N_CM_MainForm.CMMUICurStateFlags then
    begin
      DlgCapt := N_MemIniToString( 'RegionTexts', 'CMSuiteProductName', 'MediaSuite' );
      if K_CMSAppStartContext.CMASState = K_cmasStop then
      begin
        DlgType := mtError;
        DlgCapt := DlgCapt + ' error';
      end
      else
      begin
        DlgType := mtWarning;
        DlgCapt := DlgCapt + ' warning';
      end;
      K_CMShowMessageDlg1(K_CMSLiRegWarning, DlgType, [], DlgCapt );
      if K_CMSAppStartContext.CMASState = K_cmasStop then
      begin    // Close Application
        K_CMCheckAutoUpgradeLaunch();
        N_CM_MainForm.Close();
      end else // Show Registartion Dialog
      begin
        N_CM_MainForm.CMMCallActionByTimer(N_CMResForm.aHelpRegistration, FALSE);
        K_CMSAppStartContext.CMASState := K_cmasSkipStartContext;
      end;
      Exit;
    end
    else if K_CMSAppStartContext.CMASState = K_cmasStop then
    begin // Some DB Errors
      if K_CMSLiRegWarning <> '' then
        K_CMShowMessageDlg1( K_CMSLiRegWarning, mtError );
      K_CMCheckAutoUpgradeLaunch();
      N_CM_MainForm.Close();
      Exit;
    end;
  end
  else
  begin
  // HR Preview or WEB
    if (K_CMSLiRegState < K_lrsOK) then
    begin
      if (K_CMSLiRegWarning <> '') then
      begin
        if K_CMSAppStartContext.CMASMode < K_cmamCOMWEB then
          K_CMShowMessageDlg1( K_CMSLiRegWarning, mtError )
        else
          N_Dump1Str(K_CMSLiRegWarning);
      end;
      K_CMSAppStartContext.CMASState := K_cmasStop;
      N_CM_MainForm.Close();
      Exit;
    end; // if (K_CMSLiRegState < K_lrsOK) then
  end;
  Result := TRUE;
end; // function K_CMUICheckInitResult

//************************************************** K_CMReopenDBConnection ***
// Reopen DB connection
//
function K_CMReopenDBConnection() : Boolean;
begin
  N_Dump1Str( 'D4W >> ReopenConnection' );
  Result := FALSE;
  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    if K_edOK <> EDACheckDBConnection( LANDBConnection ) then
    begin
      N_Dump1Str( 'D4W >> ReopenConnection fails' );
      K_CMUICheckInitResult();
      if K_CMSAppStartContext.CMASState = K_cmasStop then
      begin
        N_Dump1Str( 'D4W >> ReopenConnection stop' );
        Exit;
      end;
    end;
    if LANDBConnection.Connected and
       (K_CMAddDBConnection <> nil) then
    begin
      FreeAndNil(K_CMAddADOQuery);
      FreeAndNil(K_CMAddADOCommand);
      FreeAndNil(K_CMAddDBConnection);
    end;
    Result := LANDBConnection.Connected;
  end; // with TK_CMEDDBAccess(K_CMEDAccess) do
end; // procedure K_CMReopenDBConnection

//****************************************************** K_CMPrepLaunchVEUI ***
// Prepare ViewEdit interface lanching
//
procedure K_CMPrepLaunchVEUI();
begin
  N_Dump2Str( 'K_CMPrepLaunchVEUI start' );
  if N_CM_MainForm.CMMCurFHPMainForm <> nil then
  begin
  // Close CMS HP UI
    N_Dump1Str( 'D4W >> Switch HP to VE UI' );
    K_CMCloseOnCurUICloseFlag := FALSE;
    K_CMCloseCurUIFlag := TRUE;
    N_CM_MainForm.CMMCurFHPMainForm.Close();
  end // if N_CM_MainForm.CMMCurFHPMainForm <> nil then
  else
  begin // if_MainForm.CMMCurFHPMainForm = nil
  // Open VE UI case - Reopen Connection
    if K_CMEDAccess is TK_CMEDDBAccess then
    begin
//      K_CMReopenDBConnection();
//      if K_CMSAppStartContext.CMASState = K_cmasStop then Exit;
      if not K_CMReopenDBConnection() then Exit;
    end;
  end; // if N_CM_MainForm.CMMCurFHPMainForm = nil
  K_CMSAppStartContext.CMASState := K_cmasSkipStartContext;
  N_CM_MainForm.CMMLaunchVEUI();

end; // K_CMPrepLaunchVEUI

//******************************************* K_CMCheckDentalUnitActionExec ***
// Check Dental Unit Event and Execute Capture Action if needed
//
//    Parameters
// Result - Returns TRUE if capture action activate
//
function K_CMCheckDentalUnitActionExec() : Boolean;
var
  ProfileName : string;
  i : Integer;
  PCMVideoProfile : TK_PCMVideoProfile;
begin
  Result := FALSE;
  if not N_CMResForm.aCaptByDentalUnit.Enabled then Exit;

  ProfileName := ''; // to avoid warning
  with N_FPCBObj do
    if FPCBIfDUCameraTaken() then ProfileName := FPCBDUProfName
                             else Exit;

  // Check if Dental Unit Action is already waiting for exectuion
  if (N_CM_MainForm.CMMServActions <> nil) and
     (0 <= N_CM_MainForm.CMMServActions.IndexOf(N_CMResForm.aCaptByDentalUnit)) then
  begin
    N_Dump2Str( 'DB >> Dental Unit Action is already waiting' );
    Exit; // Action is already wait for execution
  end;

  // Search Video Profile
  for i := 0 to K_CMEDAccess.VideoProfiles.AHigh do
  begin
    PCMVideoProfile := K_CMEDAccess.VideoProfiles.PDE( i );
    if PCMVideoProfile^.CMDPCaption <> ProfileName then Continue;
    // Execute action
    N_Dump1Str( format( 'DB >> Capture by Dental Unit Profile "%s"',
                        [ProfileName] ) );
    N_CMResForm.aCaptByDentalUnit.Tag := i;
    N_CM_MainForm.CMMCallActionByTimer( N_CMResForm.aCaptByDentalUnit, K_CMD4WWaitApplyDataCount = 0 );
    Result := TRUE;
    Exit;
  end;
  N_Dump1Str( format( 'DB >> Dental Unit Profile "%s" is absent', [ProfileName] ) );
end; // function K_CMCheckDentalUnitActionExec

//******************************************************* K_CMSWrkFilesInit ***
// Initialized CMSWrkFiles Folder for not RDP mode
//
// Collect Separated Device Calibrate Folders from WrkFiles\%UserName%\ folders
// to WrkFiles\!DevicesInfo\
//
procedure K_CMSWrkFilesInit();
const
  CaptDevInfoFolderName = '!CaptDevInfo';
var
  CurCMSWrkFiles, WrkFiles, DPath, SPath : string;
  F: TSearchRec;
begin
  N_Dump2Str( 'K_CMSWrkFilesInit >> check 0' );
  if K_CMSServerClientInfo.CMSSessionInfo.WTSClientProtocolType <> WTS_PROTOCOL_TYPE_CONSOLE then Exit;
  N_Dump2Str( 'K_CMSWrkFilesInit >> check 1' );

  //Check if CMSWrkFiles = old (#WrkFiles#)%USERNAME%\
  CurCMSWrkFiles := N_MemIniToString( K_FileGPathsIniSection, 'CMSWrkFiles', '' );
//  if Pos( '%USERNAME%', CurCMSWrkFiles ) = 0 then Exit; // Old
  // %USERNAME% is used in CMSWrkFiles - Replace CMSWrkFiles by (#WrkFiles#)+!CaptDevInfo\
  if SameText( '(#WrkFiles#)%USERNAME%\', CurCMSWrkFiles ) then
  begin // Try to Copy to !CaptDevInfo all device info from (#WrkFiles#)%USERNAME%
  // is actual for old CMSuite versions
    N_Dump2Str( 'K_CMSWrkFilesInit >> check 2' );
    WrkFiles := K_ExpandFileName( '(#WrkFiles#)' );
    DPath := IncludeTrailingPathDelimiter( WrkFiles + CaptDevInfoFolderName );
    if not DirectoryExists(DPath) then
    begin // Move Files from %UserName% folders to common (#WrkFiles#)!CaptDevInfo\
      N_Dump2Str( 'K_CMSWrkFilesInit >> Move Files start' );
      if FindFirst( WrkFiles + '*.*', faDirectory, F ) = 0 then
        repeat
          if (F.Name[1] = '.') or
             (F.Name = CaptDevInfoFolderName) or
             ((F.Attr and faDirectory) = 0) then Continue;
          SPath := IncludeTrailingPathDelimiter( WrkFiles + F.Name );
          N_Dump1Str( format( 'K_CMSWrkFilesInit >> Move from "%s" to "%s"',
                              [SPath, DPath] ) );
          K_CopyFolderFiles( SPath, DPath );
          K_DeleteFolderFiles( SPath, '*.*', [K_dffRemoveReadOnly] );
          RemoveDir(SPath);
        until FindNext( F ) <> 0;
      FindClose( F );
    end; // if not DirectoryExists(DPath) then
  end; // if SameText( '(#WrkFiles#)%USERNAME%', CurCMSWrkFiles ) then

  // Set New Value (#WrkFiles#)!CaptDevInfo\ to CMSWrkFiles
  N_StringToMemIni( K_FileGPathsIniSection, 'CMSWrkFiles',
         IncludeTrailingPathDelimiter( '(#WrkFiles#)' + CaptDevInfoFolderName ) );

  K_InitAppDirsList(); // Rebuild Dirs List

end; // procedure K_CMSWrkFilesInit

//******************************************* K_CMCheckNewVersionProcessing ***
// Check if CMS new version processing is needed
//
//    Parameters
// Result - Returns TRUE if new version processing is needed
//
function K_CMCheckNewVersionProcessing() : Boolean;
var
  FileVersion : string;
begin
//K_CMSLastVersion := '04.009.00'; // debug - Study Templates Init
  Result := K_CMSLastVersion <> N_CMSVersion;
//Result := TRUE; // debug
  if not Result then Exit;
  FileVersion := '';
  if K_CMSLastVersion = '' then
  begin
// try to get Last Version from file
    if FileExists( K_ExpandFileName( '(##Exe#)PrevBuild03.059.00.dat' ) ) then
    begin
      K_CMSLastVersion := '03.059.00';
      FileVersion := K_CMSLastVersion;
    end;
  end;
  N_Dump1Str( format( '!!!New Version %s after %s (%s)', [N_CMSVersion, K_CMSLastVersion, FileVersion] ) );
end; // function K_CMCheckNewVersionProcessing

//************************************************ K_CMDBGetOneProviderInfo ***
// Get givev Provider Info and Lock in Stand alone mode
//
//     Parameters
// Resulting Error
// ADataSet - Data Set to access to Provider Data
// ASQLIDFName - Provider ID SQL field name
// AppRTID - application Runtime ID
// APatSID - Patient ID string
// APCMSAPatientDBData - pointer to Patient Data
// ALockOnly - Lock Only Flag
// Result - Returns operation resulting code
//
function K_CMDBGetOneProviderInfo( ADataSet : TADOQuery;
                       const ASQLIDFName : string; AppRTID : Integer;
                       const AProvSID : string;
                       APCMSAProviderDBData : TK_PCMSAProviderDBData;
                       ALockFlags : TK_CMSAGetInfoFlags ) : TK_CMEDResult;
var
  SQLText : string;
begin
  N_Dump2Str('DB>> K_CMDBGetOneProviderInfo ID=' + AProvSID );

  Result := K_edOK;

  with ADataSet do
  begin
    SQLText := 'select ' +
      K_CMENDAUActRTID  + ',' + K_CMENDAUFlags + ',' + K_CMENDAUBridgeID;
      //   0                           1                      2
    if not (K_cmsagiLockOnly in ALockFlags) then
    begin
      SQLText := SQLText + ',' +
        K_CMENDAUTitle + ',' +                                 // 3
        K_CMENDAUSurname  + ',' + K_CMENDAUFirstname + ',' +   // 4, 5
        K_CMENDAUMiddle  + ',' + K_CMENDAUAuthorities ;        // 6, 7
      if K_CMEDDBVersion >= 31 then
        SQLText := SQLText + ',' +K_CMENDAUEncLP;              // 8
    end;
//           + ',' +      K_CMENDAUID;


    SQL.Text := SQLText +
      ' from ' + K_CMENDBAllProvidersTable +
      ' where ' + ASQLIDFName + ' = ' + AProvSID;

    Filtered := false;
    Open;
    if RecordCount > 0 then
    begin
      First;
      with APCMSAProviderDBData^, FieldList do
      begin
        AUIsLocked   := Fields[0].AsInteger = AppRTID;
        AUDBFlags    := Fields[1].AsInteger and 1;
        AUIsPMSSync  := Fields[2].AsInteger > 0;

        if not (K_cmsagiLockOnly in ALockFlags) then
        begin
          AUTitle       := Fields[3].AsString;
          AUSurname     := Fields[4].AsString;
          AUFirstname   := Fields[5].AsString;
          AUMiddle      := Fields[6].AsString;
          AUAuthorities := Fields[7].AsString;
          if K_CMEDDBVersion >= 31 then
            AUEncodeLP    := Fields[8].AsString
          else
            AUEncodeLP    := '';
//            SRProvID      := Fields[8].AsString;
        end;
      end;
    end
    else
      Result := K_edFails;

    Close;
    if Result = K_edFails then
      N_Dump2Str('DB>> K_CMDBGetOneProviderInfo fails')
    else
    begin
      SQL.Text := 'select count(*)' +
        ' from ' + K_CMENDBAllPatientsTable +
        ' where ' + K_CMENDAPProvID + ' = ' + AProvSID;

      Filtered := false;
      Open;
      APCMSAProviderDBData.AUPatCount := FieldList.Fields[0].AsInteger;
      Close;
      N_Dump2Str('DB>> K_CMDBGetOneProviderInfo fin');
    end;
  end; // with ADataSet do

end; // end of K_CMDBGetOneProviderInfo

//**************************************** K_CMDBCheckAppInstanceLostRecord ***
// Check if CMS Instance record is lost
//
//     Parameters
// AAppInstDataSet - data set with CMS Instance Table select
// ATimestampFI - data set field index with CMS Instance timestamp
// AFlagsFI - data set field index  with CMS Instance state flags
// ACurTS - Current Time to check
// Result - Returns TRUE if CMS Instance record is lost (is not activate too long)
//
function K_CMDBCheckAppInstanceLostRecord( AAppInstDataSet : TDataSet; ATimestampFI, AFlagsFI: Integer;
                                                        ACurTS: TDateTime ) : Boolean;
var
  ActiveAppTSDelta : TDateTime;
begin
  ActiveAppTSDelta := ACurTS - TDateTimeField(AAppInstDataSet.FieldList.Fields[ATimestampFI]).Value;

  Result := (K_CMEDDBVersion >= 15) and (AFlagsFI >= 0) and
      ((AAppInstDataSet.FieldList.Fields[AFlagsFI].AsInteger and K_CMEDAInstanceNActiveStateFlag) <> 0);

  Result := (not Result and (K_CMEDAActiveTimeOut < ActiveAppTSDelta)) or
            (Result and (K_CMEDANotActiveTimeOut < ActiveAppTSDelta));

end; // K_CMDBCheckAppInstanceLostRecord

//****************************************************** K_CMShowEnterprise ***
// Check if Enterpise Mode should be shown in CMS Use Interface
//
//     Parameters
// Result - Returns TRUE if Enterpise Mode should be shown in CMS User Interface
//
function K_CMShowEnterprise( ) : Boolean;
begin
  Result := (K_CMSVIPCTitle <> '') or
            K_CMEnterpriseModeFlag or
            (K_CMSLiRegStatus = K_lrtEnterprise) or
            ((K_CMSLiRegStatus = K_lrtComplex) and not (limdDICOM in K_CMSLiRegModDisable));
end; // K_CMShowEnterprise

//************************************************** K_CMGetCustomRefNumber ***
// Get Custom Reference Number
//
//     Parameters
// Result - Returns Custom Reference Number string or empty string if not defind
//
function K_CMGetCustomRefNumber( ) : string;
var
  FInd, Ind : Integer;
  SLID : string;
begin
  Result := '';
  if (K_CMEDAccess is TK_CMEDDBAccess) and
     (K_CMEDDBVersion >= 33) and
     (K_CMEDAccess.LocationsInfo <> nil) then
  begin
    FInd := K_CMEDAccess.EDAArchUDTabFieldIndex( 'LocationRef#', K_CMEDAccess.LocationsInfo );
    if FInd < 0 then Exit; // CustRef# field is absent

    SLID := IntToStr( K_CMEDAccess.CurLocID );
    Ind := K_CMEDAccess.EDAArchUDTabIndexOf( SLID, K_CMEDAccess.LocationsInfo );
    if Ind <= 0 then Exit; // Current Location Data is absent

    Result := PString(K_CMEDAccess.LocationsInfo.R.PME(FInd, Ind))^;
  end;
end; // K_CMGetCustomRefNumber


//************************************************** K_CMGetECacheFilesPath ***
// Get EmCache files path in terminal session and in CONSOL mode
//
//     Parameters
// Result - Returns EmCache files path
//
function  K_CMGetECacheFilesPath( ) : string;
begin
  Result := K_ExpandFileName('(#CMECacheFiles#)');
//  if K_CMSServerClientInfo.CMSSessionInfo.WTSClientProtocolType <> WTS_PROTOCOL_TYPE_CONSOLE then
//    Result := Result + K_CMSServerClientInfo.CMSSessionInfo.WTSClientName + '\';
// K_CMScanClientName value is already set using DesignModeFlag
//  if K_CMDesignModeFlag and (K_CMScanClientName <> '') then
  if K_CMDesignModeFlag then // for debug
    Result := Result + K_CMScanClientName + '\';
//  Result := Result + K_CMSServerClientInfo.CMSSessionInfo.WTSUserName + '\';
end; // function  K_CMGetECacheFilesPath

//***************************************************** K_CMClearActCaption ***
// Remove '&' from given caption
//
//     Parameters
// ActCapt - action caption to clear
// Result - Returns clear caption
//
function K_CMClearActCaption( const ActCapt : string ) : string;
var
 i, j : Integer;
begin
  // Skip '&' from caption
  j := 1;
  SetLength( Result, Length(ActCapt) );
  for i := 1 to Length(ActCapt) do
    if ActCapt[i] <> '&' then
    begin
      Result[j] := ActCapt[i];
      Inc(j);
    end;
  if j <= Length(ActCapt) then
    SetLength(Result, j - 1);
end; // function K_CMClearActCaption

//*********************************************** K_CMGetDICOMAppEntityName ***
// DICOM Application Entity Name
//
//     Parameters
// Result - Returns DICOM Application Entity Name
//
function K_CMGetDICOMAppEntityName() : string;
begin
  if not K_CMDICOMNewFlag then
    Result := format( '%s_%d',[K_CMSServerClientInfo.CMSClientVirtualName,
                 TK_CMEDDBAccess(K_CMEDAccess).ClientAppGlobID] )
  else
    Result := format( '%s_%d',[K_CMSServerClientInfo.CMSSessionInfo.WTSServerCompName,
                 TK_CMEDDBAccess(K_CMEDAccess).CurServID] )
end; // function K_CMGetDICOMAppEntityName

{// 2020-12-12 save in Global Context
//***************************************** K_CMDICOMSettingsStoreModeApply ***
// DICOM Settings store mode apply
//
//
procedure K_CMDICOMSettingsStoreModeApply();
var
  WStr : string;
  WInt : Integer;
begin
//  WStr := N_MemIniToString( 'CMS_Main', 'DCMQRSetStoreMode', '' );
  if K_CMEDADFPLMacroList = nil then Exit;
  WInt := K_CMEDADFPLMacroList.IndexOfName( 'DCMQRSetStoreMode' );
  if K_CMDCMSettingsStoreMode <> 1 then
  begin
    WStr := 'DCMQRSetStoreMode=' + IntToStr(K_CMDCMSettingsStoreMode);
    if WInt >= 0 then
      K_CMEDADFPLMacroList[Wint] := WStr
    else
      K_CMEDADFPLMacroList.Add( WStr );
  end
  else
  if WInt >= 0 then
    K_CMEDADFPLMacroList.Delete(Wint);


end; // procedure K_CMDICOMSettingsStoreModeApply
}

//****************************************** K_CMToothNumSchemeListRebuild ***
// Rebuild K_CMToothNumSchemeList if needed
//
//
procedure K_CMToothNumSchemeListRebuild();
var
  CPStr: PString;
  i: Integer;
begin
  if K_CMToothNumSchemeList = nil then
    K_CMToothNumSchemeList := TStringList.Create
  else
  if K_CMToothNumSchemeFlag = K_CMToothNumSchemeListFlag then Exit
  else
    K_CMToothNumSchemeList.Clear;

  CPStr := @K_CMTNumUSANames[0];
  if K_CMToothNumSchemeFlag = K_CMTNumFDIScheme then
    CPStr := @K_CMTNumFDINames[0];


  K_CMToothNumSchemeListFlag := K_CMToothNumSchemeFlag;
  K_CMToothNumSchemeList.Sorted := FALSE;
  for i := 0 to High(K_CMTNumUSANames) do
  begin
    if CPStr^ <> '' then
      K_CMToothNumSchemeList.AddObject( CPStr^, TObject(i) );
    Inc(CPStr);
  end;

  K_CMToothNumSchemeList.Sort();

end; // procedure K_CMToothNumSchemeListRebuild

//*************************************************** K_CMStudyCaptAddSlide ***
// Add Slide to Study in case direct capture
//
//     Parameters
// ASlide - added ASlide
//
procedure K_CMStudyCaptAddSlide( ASlide : TN_UDCMSlide );
var
  SelectNewItemResCode : Integer;
begin
  with K_FormCMStudyCapt, CMStudyFrame, TN_UDCMStudy(EdSlide) do
  begin
    if ReplaceLastSlideMode then
    begin  // Replace Last Slide
      if PrevStudyDelSlide = nil then
      begin // Replace only if last slide was not rejected
        N_Dump2Str( format( 'Replace in item %s prev added by Slide=%s(%p)',
                             [StudyPrevAddItem.ObjName, ASlide.ObjName, Pointer(ASlide)] ) );
        K_CMEDAccess.EDAStudyReplaceSlideInItem( StudyPrevAddItem, ASlide, TN_UDCMStudy(EdSlide) );
        CaptStudyPreviewSlide( ASlide );
        CaptStudyAddSlideDataSavingPrep( ASlide );
        RFrame.RedrawAllAndShow();
      end
      else
      begin
        // Prepare Slide Deletion
        N_Dump2Str( format( 'Prep deletion of Slide=%s(%p)', [ASlide.ObjName, Pointer(ASlide)] ) );
        K_CMEDAccess.EDAClearSlideECache( ASlide );
        K_CMEDAccess.CurSlidesList.Remove( ASlide );
        PrevStudyDelSlide := ASlide;
        ReplaceLastSlideMode := FALSE;
        RFrame.RedrawAllAndShow(); // Because of Correct Items Search
      end;
      if CaptureToLastPosition then
        LaunchTimer.Enabled := TRUE;
    end
    else
    begin // Add New Slide
      // Save Last Added Slide Data to DB
      if CaptureToLastPosition then
      begin
//        K_CMShowMessageDlgByTimer( ' The image is mounted on the last study position. Please select the next position if you want to continue.',
//                                    mtInformation, TRUE, [], FALSE, '', 7 );
        CaptureToLastPositionShowWarning := TRUE;
        Dec(CurStudyItemIndex);
        SelectItemByIndex( CurStudyItemIndex );
      end;

      CaptStudyPrevAddDataSave();

      // Mount New Slide To Study position
      K_CMEDAccess.EDAStudyMountAddSlideToItem( CMSSelectedItems[0], Pointer(ASlide), TN_UDCMStudy(EdSlide), FALSE );

      CaptStudyPreviewSlide( ASlide );

      CaptStudyAddSlideDataSavingPrep( ASlide );

      // Select New Study Item Index
      UnSelectItem( CMSSelectedItems[0] );
      Inc(CurStudyItemIndex);
      CMSStudyCaptStartPos := CurStudyItemIndex;
      SelectNewItemResCode := SelectItemByIndex( CurStudyItemIndex );

      if SelectNewItemResCode < 0 then
      begin
        if ChBAutoTake.Visible then
        begin
          AutoTakeIfContinueCapt := ChBAutoTake.Checked;
          ChBAutoTake.Checked := FALSE;
        end
        else if Assigned(K_CMStudyCaptAttrs.CMSDCDAutoTakeStateGetFunc) then
          AutoTakeIfContinueCapt := K_CMStudyCaptAttrs.CMSDCDAutoTakeStateGetFunc();

        CaptureToLastPosition := TRUE;
        CMSStudyCaptStartPos := 0;
        LaunchTimer.Enabled := TRUE;
      end; // if SelectNewItemResCode < 0 then

      // Redraw Study State
      RFrame.RedrawAllAndShow();

    end; // Add New Slide
  end; // with K_FormCMStudyCapt, CMStudyFrame, TN_UDCMStudy(EdSlide) do

end; // procedure K_CMStudyCaptAddSlide

//********************************************* K_CMStudyCaptFinishByDevice ***
// Study direct capture finish by device
//
procedure K_CMStudyCaptFinishByDevice();
begin
// Close Capture by device
//  if K_CMStudyCaptModeState = 0 then
  if K_CMStudyCaptState >= K_cmscOK then
  begin // Capture to Study Close by Device
    N_Dump1Str( 'Capture to Study finish by device' );
    if K_CMStudyCaptAttrs.CMSDCDDlg <> nil then
    begin
      N_Dump1Str( K_CMStudyCaptAttrs.CMSDCDDlg.Name + ' SelfClose' );
      if K_CMStudyCaptAttrs.CMSDCDDlgCPanel <> nil then
      begin
        K_CMStudyCaptAttrs.CMSDCDDlgCPanel.Parent := K_CMStudyCaptDevDlgCPanelParent;
        K_CMStudyCaptAttrs.CMSDCDDlgCPanel := nil;
      end;
      K_CMStudyCaptAttrs.CMSDCDDlg := nil;
    end;
  end
  else
    N_Dump1Str( 'Capture to Study is closed by K_FormCMStudyCapt' );

//  K_CMStudyCaptModeState := -1; // Clear Capture to Study mode
  K_CMStudyCaptState := K_cmscNon; // Clear Capture to Study mode
  if K_FormCMStudyCapt <> nil then
  begin
    K_FormCMStudyCapt.UnConditionalClose := TRUE;
    K_FormCMStudyCapt.Close(); // If Capture to Study Dlg is opened - close it
  end;

end; // procedure K_CMStudyCaptFinishByDevice

//*************************************************** K_CMDBFilePathPrepStr ***
// Prepare Path string for saving in DB
//
function K_CMDBFilePathPrepStr( const ASrcPath : string ) : string;
var
  i, Ind : Integer;
begin
{
  Result := ASrcPath;
  if (Result[1] = '\') and
     (Result[2] = '\') and
     (Result[3] <> '\') then
    Result := '\' + Result;
}
  Result := '';
  if ASrcPath = '' then Exit;

  // Result start length
  Ind := Length(ASrcPath);
  Ind := Ind + Round(Ind / 2);
  SetLength( Result, Ind );

  // Build Resulting string
  Ind := 1;
  for i := 1 to Length(ASrcPath) do
  begin
    if ASrcPath[i] = '\' then
    begin
      Result[Ind] := '\';
      Inc(Ind);
    end;
    Result[Ind] := ASrcPath[i];
    Inc(Ind);
  end; // for i := 1 to Length(ASrcPath) do
  SetLength( Result, Ind - 1 );

end; // function K_CMDBFilePathPrepStr

//******************************************************** K_CMDICOMVisible ***
// Get DICOM visibility
//
function K_CMDICOMVisible() : Boolean;
begin
  Result := ( (K_CMSLiRegStatus <> K_lrtComplex) and
                   K_CMGUIDICOMMenuVisFlag )
                                  or
                ( (K_CMSLiRegStatus = K_lrtComplex) and
                  not (limdDICOM in K_CMSLiRegModDisable) )
                                  or
                           K_CMDesignModeFlag;
end; // function K_CMDICOMVisible


//***************************************** K_CMPrepIniFileCustToolbarNames ***
// Prepare Cust Toolbar context Ini-files names
//
procedure K_CMPrepIniFileCustToolbarNames( out ActListsIni,ASmallButtonsIni : string );
begin
  // Provider|Instance specific
  ActListsIni := 'CMCustToolbar';
  ASmallButtonsIni := 'CustToolbarSmallButtons';
//  if K_CMUseCustToolbarGlobal then
  if K_CMUseCustToolbarInd = 1 then
  begin // Location specific
    ActListsIni := 'G' + ActListsIni;
    ASmallButtonsIni := 'G' + ASmallButtonsIni;
  end
  else
  if K_CMUseCustToolbarInd = 2 then
  begin // Global specific
    ActListsIni := 'GG' + ActListsIni;
    ASmallButtonsIni := 'GG' + ASmallButtonsIni;
  end
  else
  if K_CMUseCustToolbarInd = 3 then
  begin // Provider specific
    ActListsIni := 'P' + ActListsIni;
    ASmallButtonsIni := 'P' + ASmallButtonsIni;
  end;
end; // procedure K_CMPrepIniFileCustToolbarNames

//****************************************** K_CMInitIniFileCustToolbarCont ***
// Prepare Cust Toolbar init context
//
procedure K_CMInitIniFileCustToolbarCont( );
var
  ActListsIni, SmallButtonsIni : string;
begin
  K_CMPrepIniFileCustToolbarNames( ActListsIni, SmallButtonsIni );

  if (N_MemIniToString( 'CMS_Main', SmallButtonsIni, '' ) <> '') then Exit;

  // Init ToolBar Settings - empty Cust Toolbar Context
  N_BoolToMemIni( 'CMS_Main', SmallButtonsIni,  FALSE );

  if N_MemIniToString( 'CMCustToolbar', '0', '' ) = '' then
  begin // Init Init Cust Toolbar Context
    N_StringToMemIni( 'CMCustToolbar', '0', 'aEditUndoLast' );
    N_StringToMemIni( 'CMCustToolbar', '1', 'aEditUndoRedo' );
    N_StringToMemIni( 'CMCustToolbar', '2', 'aToolsBriCoGam' );
    N_StringToMemIni( 'CMCustToolbar', '3', 'aToolsNegate11' );
    N_StringToMemIni( 'CMCustToolbar', '4', 'aToolsEmboss' );
    N_StringToMemIni( 'CMCustToolbar', '5', 'aToolsColorize' );
    N_StringToMemIni( 'CMCustToolbar', '6', 'aToolsIsodens' );
    N_StringToMemIni( 'CMCustToolbar', '7', 'aToolsRotateLeft' );
    N_StringToMemIni( 'CMCustToolbar', '8', 'aToolsRotateRight' );
    N_StringToMemIni( 'CMCustToolbar', '9', 'aToolsRotate180' );
    N_StringToMemIni( 'CMCustToolbar', '10', 'aToolsFlipHorizontally' );
    N_StringToMemIni( 'CMCustToolbar', '11', 'aToolsFlipVertically' );
    N_Dump1Str( 'Init CMCustToolbar Context' );
  end; // Init Cust Toolbar Context
end; // procedure K_CMInitIniFileCustToolbarCont

//********************************************* K_FillDICOMModalitiesUIList ***
// Fill DICOM Modalities UI List
//
//     Parameters
// ASL - Strings to fill
//
procedure K_FillDICOMModalitiesList( ASL : TStrings );

begin
  ASL.Clear;
  ASL.Add('');
  ASL.Add(K_CMSlideDefDCMModColorXC);
  ASL.Add(K_CMSlideDefDCMModColorES);
  ASL.Add(K_CMSlideDefDCMModColorGM);
  ASL.Add(K_CMSlideDefDCMModXRayIO);
  ASL.Add(K_CMSlideDefDCMModXRayCR);
  ASL.Add(K_CMSlideDefDCMModXRayCT);
  ASL.Add(K_CMSlideDefDCMModXRayDX);
  ASL.Add(K_CMSlideDefDCMModXRayPan);
  ASL.Add(K_CMSlideDefDCMModXRayOT);
end; // procedure K_FillDICOMModalitiesUIList

//****************************************** K_GetDICOMUIDComponentFromGUID ***
// Create DICOM UID component from GUID not more then 31 chars length
//
//     Parameters
// ASGUID - source GUID string
// Result - Returns resulting DICOM UID component string not more then 31 chars length
//
function K_GetDICOMUIDComponentFromGUID31( const ASGUID : string ) : string;
var
  WStr : string;
  W641 : Int64;
  W642 : Int64;
  W643 : Int64;
  W644 : Int64;
  W645 : Int64;
  CFlag : Boolean;

begin
// Parse GUID
  Result := '';
  SetLength( WStr, 17 );
  WStr[1] := '$';
  Move( ASGUID[2], WStr[2], 8 * SizeOf(Char) );
  Move( ASGUID[11], WStr[10], 4 * SizeOf(Char) );
  Move( ASGUID[16], WStr[14], 4 * SizeOf(Char) );
  W641 := StrToInt64(WStr);
  Move( ASGUID[21], WStr[2], 4 * SizeOf(Char) );
  Move( ASGUID[26], WStr[6], 12 * SizeOf(Char) );
  W642 := StrToInt64(WStr);

// Add 13.14.153 bytes to 13

// Add 13(5) byte to 0-3 bytes
  W643 := 0;
  Move( (TN_BytesPtr(@W642) + 5)^, W643, 1 );
  W644 := 0;
  Move( W641, W644, 4 );
  W645 := W643 + W644;
  CFlag := W645 > $00000000FFFFFFFF;
  Move( W645, W641, 4 );

// Add 14(6) byte to 4-7 bytes
  Move( (TN_BytesPtr(@W642) + 6)^, W643, 1 );
  W644 := 0;
  Move( (TN_BytesPtr(@W641) + 4)^, W644, 4 );
  W645 := W643 + W644;
  if CFlag then
    W645 := W645 + 1;
  CFlag := W645 > $00000000FFFFFFFF;
  Move( W645, (TN_BytesPtr(@W641) + 4)^, 4 );
  W641 := W641 and $7FFFFFFFFFFFFFFF;

// Add 15(7) byte to 8-12(0-5) bytes
  Move( (TN_BytesPtr(@W642) + 7)^, W643, 1 );
  Move( W642, W644, 5 );
  W645 := W643 + W644;
  if CFlag then
    W645 := W645 + 1;
  W645 := W645 and $7FFFFFFFFF;
  Result := format( '%u%u', [W641,W645] );
end; // function K_GetDICOMUIDComponentFromGUID31

//*********************************************************** K_CMGetDBAPSW ***
// Get DBAPSW by secadm
//
procedure K_CMGetDBAPSW();
var
  WStr : string;
  PSW : String;
begin
  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    // save old 'ExtProperties' - part of connection string
    WStr := N_MemIniToString( 'CMSDB', 'ExtProperties', '' );
    // set new 'ExtProperties' - part of connection string
    N_StringToMemIni( 'CMSDB', 'ExtProperties', 'UID=secretcode;PWD=c9:@:Bw[6n:5s;DSN=CMSImg' );
    LANDBConnection.ConnectionString := K_CMDBGetConnectionString();
    try
      LANDBConnection.Open();
      with CurDSet1 do
      begin
        Connection := LANDBConnection;
        ExtDataErrorCode := K_eeDBSelect;

        SQL.Text := 'select "secretcode"."sec_get_retcode"(''dba'');';
        Filtered := false;
        Open;
        PSW := FieldList.Fields[0].AsString;
        if PSW = '' then
          K_CMDBAPSW := 'sql'
        else
          K_CMDBAPSW := N_AnsiToString(N_Decript1(N_StringToAnsi(PSW)));
        Close();
      end;
    except
      K_CMDBAPSW := '';
    end;

    // return saveed 'ExtProperties' - part of connection string
    N_StringToMemIni('CMSDB', 'ExtProperties', WStr);

    LANDBConnection.Close();
  end;  // with TK_CMEDDBAccess(K_CMEDAccess) do
{
  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    // save old 'ExtProperties' - part of connection string
    WStr := N_MemIniToString( 'CMSDB', 'ExtProperties', '' );
    // set new 'ExtProperties' - part of connection string
    N_StringToMemIni( 'CMSDB', 'ExtProperties', 'UID=secadm;PWD=version6:password;DSN=CMSImg' );

    LANDBConnection.ConnectionString := K_CMDBGetConnectionString();
    N_Dump1Str( 'K_CMGetDBAPSW before connect to DB as secadm' );
    LANDBConnection.Open();
    N_Dump2Str( 'K_CMGetDBAPSW after connect to DB as secadm' );
    try
      with CurDSet1 do
      begin
        Connection := LANDBConnection;
        ExtDataErrorCode := K_eeDBSelect;

        // *** Synchronize Self Time with System Time
        SQL.Text := 'SELECT ' + K_CMENDBGTFDBAPSW + ' from dba.' + K_CMENDBGlobAttrsTable;
        Filtered := false;
        Open;
        K_CMDBAPSW := FieldList.Fields[0].AsString;
        Close();
      end;
    except
      K_CMDBAPSW := '';
    end;

    // return saveed 'ExtProperties' - part of connection string
    N_StringToMemIni('CMSDB', 'ExtProperties', WStr);

    N_Dump2Str( 'K_CMGetDBAPSW before secadm connection close' );
    LANDBConnection.Close();
    N_Dump1Str( 'K_CMGetDBAPSW after secadm connection close' );
  end;
}
end; // procedure K_CMGetDBAPSW

//*********************************************************** K_CMSetDBAPSW ***
// Set DBAPSW by secadm
//
procedure K_CMSetDBAPSW();
//var
//  WStr : string;
begin
{
  with TK_CMEDDBAccess(K_CMEDAccess) do
  begin
    if LANDBConnection.Connected then
      LANDBConnection.Close;

    N_StringToMemIni( 'CMSDB', 'ExtProperties', 'UID=secadm;PWD=version6:password;DSN=CMSImg' );
    LANDBConnection.ConnectionString := K_CMDBGetConnectionString();
    N_Dump1Str( 'K_CMSetDBAPSW before connect to DB as secadm' );
    LANDBConnection.Open();
    N_Dump2Str( 'K_CMSetDBAPSW after connect to DB as secadm' );

    WStr := K_CMDBAPSW;
    if WStr = '' then WStr := 'sql';

    try
      with CurSQLCommand1 do
      begin
        Connection := LANDBConnection;
        CommandText := 'GRANT CONNECT TO "dba" IDENTIFIED BY ''' + WStr + ''';' + #10 +
        'update "dba"."' + K_CMENDBGlobAttrsTable + '" set ' + K_CMENDBGTFDBAPSW + '=''' + K_CMDBAPSW + ''';';
        Execute;
      end;
    except
      K_CMDBAPSW := '';
    end;


    N_Dump2Str( 'K_CMGetDBAPSW before secadm connection close' );
    LANDBConnection.Close();
    N_Dump1Str( 'K_CMGetDBAPSW after secadm connection close' );


    N_StringToMemIni( 'CMSDB', 'ExtProperties', 'UID=dba;PWD='+ WStr +';DSN=CMSImg' );
    LANDBConnection.ConnectionString := K_CMDBGetConnectionString();
    N_Dump1Str( 'K_CMSetDBAPSW defore connect to DB as DBA' );
    LANDBConnection.Open();
    N_Dump1Str( 'K_CMSetDBAPSW after connect to DB as DBA' );
 end;
}
end; // procedure K_CMSetDBAPSW


{*** TK_CFPFilePathCheckThread ***}

//*************************************** TK_CFPFilePathCheckThread.Execute ***
// Check File Path Thread Execute
//
procedure TK_CFPFilePathCheckThread.Execute;
var
  CheckRes : Boolean;
  NewCheckState   : TK_CFPState;
begin
  CFPUT := TN_CPUTimer1.Create;
  CFPCheckLoopDelay := 1000;

  while TRUE do
  begin
    try
      if Terminated then Break; // check Terminated at Loop start
      // Get New Current Context

      if CFPCheckStopFlag then Suspended := TRUE;

      if Terminated then Break; // check Terminated after Resume

      Synchronize( CFPSyncGetCheckContext );

      if CFPCurFilePath = '' then // precaution
      begin
        Suspended := TRUE;
        Continue;
      end; // if CFPCurFilePath = '' then

      CFPUT.Start;
//if CFPCurResult.CFPCheckNum mod 100 < 10 then
//sleep( 11000 );
      if CFPCurForcePathFlag then
        CheckRes := K_ForceDirPath( CFPCurFilePath )
      else
        CheckRes := DirectoryExists( CFPCurFilePath );
      CFPUT.Stop;

      if CheckRes then
        NewCheckState := cfpsOpOK
      else
        NewCheckState := cfpsOpFails;

      Inc( CFPCurResult.CFPCheckNum );
      CFPDumpStr := '';
      if (CFPCurResult.CFPState <> NewCheckState) or
         ((CFPCurResult.CFPTime >= K_CMScanNetworkMaxDelay * N_CPUFrequency) and
          (CFPUT.DeltaCounter   <  K_CMScanNetworkMidDelay * N_CPUFrequency)) or
         ((CFPCurResult.CFPTime <  K_CMScanNetworkMidDelay * N_CPUFrequency) and
          (CFPUT.DeltaCounter   >= K_CMScanNetworkMaxDelay * N_CPUFrequency)) then
        CFPDumpStr := format( 'CFP> FilePathCheckThread CN=%d ST=%d>%d DET=%s',
                          [CFPCurResult.CFPCheckNum, Ord(CFPCurResult.CFPState),
                           Ord(NewCheckState), CFPUT.ToStr()] );

      CFPCurResult.CFPState := NewCheckState;
      CFPCurResult.CFPTime  := CFPUT.DeltaCounter;

      Synchronize( CFPSyncReturnCheckResult );

      if CFPCurSingleCheckFlag or CFPCurForcePathFlag then
      begin
        Suspended := TRUE;
        Continue;
      end; // if CFPCurSingleCheckFlag or CFPCurForcePathFlag then

    except
      on E: Exception do
      begin
        CFPDumpStr := 'CFP> FilePathCheckThread exception >> ' + E.Message;
        Synchronize( CFPSyncDump );
      end;
    end; // try

    if Terminated then Break; // check Terminated before Sleep
    sleep( CFPCheckLoopDelay );

  end; // while TRUE do

  CFPUT.Free;
  
end; // TK_CFPFilePathCheckThread.Execute

//**************************** TK_CFPFilePathCheckThread.CFPSetNewCheckPath ***
// Set new File Path to check
//
//     Parameters
// APath  - new File Path to check
// Result - Returns new File Path CRC
//
function TK_CFPFilePathCheckThread.CFPSetNewCheckPath( const APath : string ) : Integer;
begin
  Result := 0;
  if APath = '' then
    CFPStop()
  else
  begin
    CFPNewPathCode := CFPCurResult.CFPPathCode;
    if CFPCurFilePath <> APath then
    begin
      CFPNewFilePath := APath;
      CFPNewPathCode := N_AdlerChecksum( @CFPNewFilePath[1], Length(CFPNewFilePath) * SizeOf(Char) );
    end;
    Result := CFPNewPathCode;
    // Skip Thread Activate if Same Path and SingleCheck Mode
    if not CFPSingleCheckFlag or (CFPNewPathCode <> CFPCurResult.CFPPathCode) then
      CFPContinue();
  end;
end; // TK_CFPFilePathCheckThread.CFPSetNewCheckPath

//*********************************** TK_CFPFilePathCheckThread.CFPContinue ***
// Continue Check File Path Thread
//
procedure TK_CFPFilePathCheckThread.CFPContinue();
begin
  CFPCheckStopFlag := FALSE;
  if Suspended then Suspended := FALSE;
end; // TK_CFPFilePathCheckThread.CFPContinue

//*************************************** TK_CFPFilePathCheckThread.CFPStop ***
// Stop Check File Path Thread
//
procedure TK_CFPFilePathCheckThread.CFPStop;
begin
  if Suspended then Exit;
  CFPCurCheckStopFlag := TRUE;
end; // TK_CFPFilePathCheckThread.CFPStop

//*********************************** TK_CFPFilePathCheckThread.CFPSyncDump ***
// Write single string to main Dump1
//
// For call by Thread Synchronize method
//
procedure TK_CFPFilePathCheckThread.CFPSyncDump(  );
begin
  N_Dump1Str( CFPDumpStr );
end; // TK_CFPFilePathCheckThread.CFPSyncDump

//********************** TK_CFPFilePathCheckThread.CFPSyncReturnCheckResult ***
// Return last check results
//
// For call by Thread Synchronize method
//
procedure TK_CFPFilePathCheckThread.CFPSyncReturnCheckResult();
begin
  if CFPDumpStr <> '' then
  begin
    if CFPDump2CheckResultFlag then
      N_Dump2Str( CFPDumpStr )
    else
      N_Dump1Str( CFPDumpStr );
  end;
  if CFPPResult = nil then Exit;
  CFPPResult^ := CFPCurResult;
end; // TK_CFPFilePathCheckThread.CFPSyncReturnCheckResult

//************************ TK_CFPFilePathCheckThread.CFPSyncGetCheckContext ***
// Get next check context
//
// For call by Thread Synchronize method
//
procedure TK_CFPFilePathCheckThread.CFPSyncGetCheckContext();
begin

  CFPCurSingleCheckFlag := CFPSingleCheckFlag; // Single Check File Path flag
  CFPCurForcePathFlag   := CFPForcePathFlag;   // Force File Path flag

  if CFPNewPathCode <> CFPCurResult.CFPPathCode then
  begin
    CFPCurFilePath := CFPNewFilePath;           // New File Path
    CFPCurResult.CFPPathCode := CFPNewPathCode; // New File Path Code
    CFPCurResult.CFPState := cfpsNotDef;        // Cur Result State
  end;

end; // TK_CFPFilePathCheckThread.CFPSyncGetCheckContext

{*** end of TK_CFPFilePathCheckThread ***}



///////////////////////////////////////////////////////////////////////////////

//************************************************ K_UDACMStudyCreateSample ***
// Create new CMSStudy Sample by given Action
//
// CAUDBase1  - Source Study Sample with one Child - Mounts Item Root
// CAUDBase2  - Root for Resulting Study Sample
// CAUDBase3  - Stub Images Root
// CAParStr1  - NX NY (Number of Mounts Items along X Y)
// CAParStr2  - ItemName
// CAIRect    - dxOut(Left) dyOut(Top) dxIn(Right) dyIn(Bottom) - Gaps between Mounts Items
//              ( OuterGapsWidth, OuterGapsHeight, InnerGapsWidth, InnerGapsHeight )
//
// (for using in TN_UDAction under Action Name CreateStudySample )
//
procedure K_UDACMStudyCreateSample( APParams: TN_PCAction; AP1, AP2: Pointer );
var
  Ind, ir, RFSepInd, FlipRotateFlags, i, IAng  : integer;
  ItemName, ItemImageName, SFlipRotate, STeethFlags : string;
  MainParent, NMPR, SMPIR, NMPIR, Thumbnail, WrkUDBase, UDDIB: TN_UDBase;
  UDParaBox : TN_UDParaBox;
  ItemsRects: TN_SIRSArray;
  PUP: TN_POneUserParam;
  TeethFlags  : Int64;
  SL : TStringList;
//SampleUDMapRoot : TN_UDBase;
//StubImgUDFolder : TN_UDBase;

begin
  with APParams^ do
  begin
    if PString(CAStrArray.P(0))^[1] = '<' then
    begin
    // Load XML version
      MainParent := CAUDBase2; // Source and New Mounts Pattern Roots Parent
      MainParent.ClearChilds();

      SL := TStringList.Create;
      Ind := CAStrArray.AHigh;
      for ir := 0 to Ind do
        SL.Add( PString(CAStrArray.P(ir))^ );

      N_T1.Start();
{
      if not K_CMStudyTemplatePrepSampleMapRoot( SampleUDMapRoot ) or
        not K_CMStudyTemplatePrepStubImgUDFolder( StubImgUDFolder ) then
      begin
        N_Dump1Str( '!!! Errors prepare SampleUDMapRoot and StubImgUDFolder' );
        Exit;
      end;
}
      if not K_CMStudyTemplateLoadDescr( MainParent, SL, TRUE{ nil, nil, SampleUDMapRoot, StubImgUDFolder}) then
        N_Dump1Str( '!!! Error loading '  + MainParent.ObjAliase + #13#10 + SL.Text );
      N_T1.SS( 'K_CMStudyTemplateLoadDescr ' + MainParent.ObjAliase, N_s );

      SL.Free();
      Exit;
    end;

    N_LayoutIRects1( CAStrArray, ItemsRects );

    //***** CAUDBase1 - Source Study Sample Root
//    NMPR  := CAUDBase1.Clone( True ); // New Study Sample Root

    NMPR := N_CreateSubTreeClone( CAUDBase1 );
    SMPIR := NMPR.DirChild( 0 ); // Source Study Item Sample Root

    with TN_UDCompVis(NMPR).PCCS()^ do // Set New Mounts Pattern Root Size in Pixels
      SRSize := FPoint( ItemsRects[0].IRS.Size );

    Ind := 0;
    ItemName := CAParStr2;
    if ItemName = '' then
      ItemName := SMPIR.ObjName;
    K_UDCursorGet('@Tmp:').SetRoot( NMPR ); // Needed to Correct References from Item to MapRoot

    for ir := 1 to High(ItemsRects) do // along all Items Rects
    begin
      NMPR.RefPath := '@Tmp:';
      NMPIR := N_CreateSubTreeClone( SMPIR ); // New Mounts Pattern Item Root
      NMPIR.ObjALiase := ItemName + IntToStr( ind );
      NMPIR.ObjName := IntToStr( ind );

      // Set Item Index text
      UDParaBox := TN_UDParaBox( NMPIR.DirChild(0).DirChild(2) );
      with UDParaBox.PISP()^ do
        TN_POneTextBlock(CPBTextBlocks.P).OTBMText := IntToStr( ind + 1 );

      NMPR.AddOneChildV( NMPIR );

      with TN_UDCompVis(NMPIR).PCCS()^ do // Set New Item TopLeft in Pixels
      begin
        BPCoords := FPoint( ItemsRects[ir].IRS.TopLeft );
        SRSize   := FPoint( ItemsRects[ir].IRS.Size );
      end; // with TN_UDCompVis(NMPIR).PCCS()^ do // Set New Item TopLeft in Pixels

      // Set Item Image, Item FlipRotate, Item TeethFlags
      if ItemsRects[ir].Str <> '' then
      begin
        // Str part format is <ImageName>[|<FlipRotateInfo>[|<TeethFlags>]]
        // exampl1 NR|R1H|25    - ImageName=NR| Rotate+90, FlipHor | RightFlags = 25
        // exampl2 NC|R2H|25,35 - ImageName=NC| Rotate180, FlipHor | RightFlags = 25 LeftFlags = 35
        // exampl3 XR|R3V|,35   - ImageName=XR| Rotate-90, FlipVer | RightFlags = 0 LeftFlags = 35
        // exampl4 XC||,35      - ImageName=XC|   no Flip Rotate   | RightFlags = 0 LeftFlags = 35
        WrkUDBase := NMPIR.DirChild(0).DirChild(0);
        ItemImageName := ItemsRects[ir].Str;
        RFSepInd := Pos( '|', ItemsRects[ir].Str );
        if RFSepInd > 1 then
        begin // ',' should be not in the 1-st position
        // Extract Stub Image Name
          ItemImageName := Copy( ItemsRects[ir].Str, 1, RFSepInd - 1 );
        // Set Item Rotate Flags
        // SFlipRotate should be a set of 'R1'(90), 'R2'(180), 'R3'(270), 'V', 'H'
          SFlipRotate := Copy( ItemsRects[ir].Str, RFSepInd + 1,  Length(ItemsRects[ir].Str) );

          RFSepInd := Pos( '|', SFlipRotate );
          if RFSepInd > 0 then
          begin
            STeethFlags := Copy( SFlipRotate, RFSepInd + 1,  Length(SFlipRotate) );
            SFlipRotate := Copy( SFlipRotate, 1, RFSepInd - 1 );

            // Parse TeethFlags Info
            TeethFlags  := K_CMSTeethChartTextToState( STeethFlags, ';' );
            if TeethFlags <> 0 then
            begin
              PUP := N_GetUserParPtr( TN_UDCompBase(NMPIR).R, 'TeethFlags' );
              PInt64(PUP.UPValue.P)^ := TeethFlags;
            end;

          end; // if RFSepInd > 1 then

          // Parse FlipRotate Info
          if SFlipRotate <> '' then
          begin

            FlipRotateFlags := 0;
            i := 1;
            while i <= Length(SFlipRotate) do
            begin
              case SFlipRotate[i] of
                'R':
                begin
                  if i < Length(SFlipRotate) then // Precaution
                  begin
                    Inc(i);
                    IAng := Ord(SFlipRotate[i]) - Ord('0');
                    FlipRotateFlags := N_RotateFRFlags ( FlipRotateFlags, IAng * 90 );
                  end;
                end;
                'H': FlipRotateFlags := FlipRotateFlags xor N_FlipHorBit;
                'V': FlipRotateFlags := FlipRotateFlags xor N_FlipVertBit;
              end;
              Inc(i);
            end; // while i <= Length(SFlipRotate) do

            PUP := N_GetUserParPtr( TN_UDCompBase(NMPIR).R, 'FlipRotateFlags' );
            PByte(PUP.UPValue.P)^ := FlipRotateFlags;
          end; // if SFlipRotate <> '' then
        end; // if RFSepInd > 1 then

        UDDIB := N_GetUObjByPath( CAUDBase3, ItemImageName );
        WrkUDBase.PutDirChildSafe( 0, UDDIB );
      end; // if ItemsRects[ir].Str <> '' then // Set Item Image

      Inc( Ind );
    end; // for ir := 1 to High(ItemsRects) do // along all Items Rects

    MainParent := CAUDBase2; // Source and New Mounts Pattern Roots Parent
    MainParent.ClearChilds();
   // Add New Sample MapRoot
//    NMPR.ObjName := N_CreateUniqueUObjName( MainParent, CAUDBase1.ObjName );
    MainParent.AddOneChildV( NMPR ); // NPR

    // Remove Source Study Item Sample Root
    NMPR.RemoveDirEntry(0);
   // Add New Sample Thumbnail
//    Thumbnail := K_CMBSlideCreateThumbnailUDDIB( K_CMBStudyCreateThumbnailDIBByMapRoot( TN_UDCompVis(NMPR) ) );
    Ind := K_CMSlideThumbSize;
    K_CMSlideThumbSize := K_CMSlideThumbSize * 2;
    Thumbnail := K_CMBSlideCreateThumbnailUDDIB(
      K_CMBSlideCreateThumbnailDIBByMapRoot( TN_UDCompVis(NMPR) ) );
    K_CMSlideThumbSize := Ind;

    MainParent.InsOneChild( 0, Thumbnail);
    MainParent.AddChildVNodes( 0 );

    K_SetChangeSubTreeFlags( MainParent );

  end; // with APParams^ do

{////////////////// my peviouse version
var
  ix, iy, ind: integer;
  NX, NY: integer;
  ITemWidth, ItemHeight: Float;
  Str1, ItemName: String;
  MainParent, NMPR, SMPIR, NMPIR, Thumbnail: TN_UDBase;
  UDParaBox : TN_UDParaBox;
begin
  with APParams^ do
  begin
    Str1 := CAParStr1;
    NX   := N_ScanInteger( Str1 ); // Number of Sample Items along X
    NY   := N_ScanInteger( Str1 ); // Number of Sample Items along Y

    //***** CAUDBase1 - Source Study Sample Root
//    NMPR  := CAUDBase1.Clone( True ); // New Study Sample Root

    NMPR := N_CreateSubTreeClone( CAUDBase1 );
    SMPIR := NMPR.DirChild( 0 ); // Source Study Item Sample Root


    with TN_UDCompVis(SMPIR).PCCS()^ do // Get Mounts Pattern Items Size in Pixels
    begin
      ITemWidth  := SRSize.X;
      ITemHeight := SRSize.Y;
    end; // with TN_UDCompVis(NPR).PCCS()^ do // Set New Pattern Root Size in Pixels

    with TN_UDCompVis(NMPR).PCCS()^ do // Set New Mounts Pattern Root Size in Pixels
    begin
      SRSize.X := NX*ITemWidth  + (NX-1)*CAIRect.Right  + 2*CAIRect.Left;
      SRSize.Y := NY*ItemHeight + (NY-1)*CAIRect.Bottom + 2*CAIRect.Top;
    end; // with TN_UDCompVis(NMPR).PCCS()^ do // Set New Mounts Pattern Root Size in Pixels

    ind := 0;
    ItemName := CAParStr2;
    if ItemName = '' then
      ItemName := SMPIR.ObjName;
    K_UDCursorGet('@Tmp:').SetRoot( NMPR ); // Needed to Correct References from Item to MapRoot
    for iy := 0 to NY-1 do // along all Slides Rows
    for ix := 0 to NX-1 do // along all Slides in Row
    begin
      NMPR.RefPath := '@Tmp:';
      NMPIR := N_CreateSubTreeClone( SMPIR ); // New Mounts Pattern Item Root
      NMPIR.ObjALiase := ItemName + IntToStr( ind );
      NMPIR.ObjName := IntToStr( ind );

      // Set Item Index text
      UDParaBox := TN_UDParaBox( NMPIR.DirChild(0).DirChild(2) );
      with UDParaBox.PISP()^ do
        TN_POneTextBlock(CPBTextBlocks.P).OTBMText := IntToStr( ind + 1 );

      NMPR.AddOneChildV( NMPIR );

      with TN_UDCompVis(NMPIR).PCCS()^ do // Set New Item TopLeft in Pixels
      begin
        BPCoords.X := CAIRect.Left + ix*( ITemWidth  + CAIRect.Right  );
        BPCoords.Y := CAIRect.Top  + iy*( ItemHeight + CAIRect.Bottom );
      end; // with TN_UDCompVis(NMPIR).PCCS()^ do // Set New Item TopLeft in Pixels
      Inc( ind );

    end; // for ix ... ; for iy ...

    MainParent := CAUDBase2; // Source and New Mounts Pattern Roots Parent
    MainParent.ClearChilds(); // Source and New Mounts Pattern Roots Parent
   // Add New Sample MapRoot
//    NMPR.ObjName := N_CreateUniqueUObjName( MainParent, CAUDBase1.ObjName );
    MainParent.AddOneChildV( NMPR ); // NPR

    // Remove Source Study Item Sample Root
    NMPR.RemoveDirEntry(0);
   // Add New Sample Thumbnail
    Thumbnail := K_CMBSlideCreateThumbnailUDDIB( K_CMBStudyCreateThumbnailDIBByMapRoot( TN_UDCompVis(NMPR) ) );
    MainParent.InsOneChild( 0, Thumbnail);
    MainParent.AddChildVNodes( 0 );

    K_SetChangeSubTreeFlags( MainParent );

  end; // with APParams^ do
}
end; // procedure K_UDACMStudyCreateSample

//***************************************************** K_CMSDebAction1Proc ***
// Debug Action 1 - used in TN_CMResForm.aDebAction1Execute
//
procedure K_CMSDebAction1Proc();
// Debug Action 1
var
  F1, F2 : TN_BaseForm;
  VFThumbPar: TN_VFThumbParams;
  ThumbDIB: TN_DIBObj;
  NamesList: TStringList;
  BArray: TN_BArray;
  VV : string;
  i : Integer;
//  Slide : TN_UDCMSlide;
  DIB1, DIB2: TN_DIBObj;
  DT : TDateTime;
  EdFrame : TN_CMREdit3Frame;
  PRevParent : TWinControl;
  Form: TForm;
  ARLData : TN_MemTextFragms;
  ASLData : TN_MemTextFragms;
  AULData : TN_MemTextFragms;
  WPos, SPos, FPos, SLeng, PatCount : Integer;
  RIImLib : TN_RIImLib;
  DIBObj : TN_DIBObj;
  Stream : TFileStream;
  FileEncInfo : TK_RIFileEncInfo;
  UDTemplate : TN_UDBase;
  DevProfile : TK_CMOtherProfile;

{
function WinVistaSelectFolder: String;
var
  FolderDialog : IFileDialog;
  hr: HRESULT;
  IResult: IShellItem;
  FileName: PChar;
  Settings: DWORD;
begin
  hr := CoCreateInstance (CLSID_FileOpenDialog,nil,CLSCTX_INPROC_SERVER,IFileDialog, FileDialog);
  if hr = S_OK then
  begin
    FileDialog.GetOptions(Settings);
    Settings := Settings or FOS_PICKFOLDERS or FOS_FORCEFILESYSTEM;
    FileDialog.SetOptions(Settings);
    FileDialog.SetOkButtonLabel('Select');
     Title := 'Select a directory';
    FileDialog.SetTitle(PWideChar(Title));
    hr := FileDialog.Show(0);
    if hr = S_OK then
    begin
      hr := FileDialog.GetResult(IResult);
      if hr = S_OK then
      begin
        IResult.GetDisplayName(SIGDN_FILESYSPATH, FileName);
        Result := FileName;
      end;
    end;
  end;
end;
}

Slide3D : TN_UDCMSlide;
UD1, UD2 : TN_UDBase;
UDl1, UDL2 : TN_UDPolyline;
FP1, FP2, S1, S2   : TFPoint;
//UD3 : TN_UDBase;
//UDL3 : TN_UDPolyline;
Mode : integer;
DumpObj : TK_DumpObj;
DI : TK_HDCMINST;
WS : WideString;

//*************************************************** K_PMTRebuildLineAnnot ***
// Add new or rebuild existing Eeyes Line
//
//     Parameters
// AP1 - Line 1-st point
// AP2 - Line 2-d point
// AColor  - Line color (is used for added Line, not used if existing is rebuild)
// ALWidth - Line width (0.1 to 12) in points (is used for added Line, not used if existing is rebuild)
// Result - Returns TRUE if new Line was added
//
function K_PMTRebuildLineAnnot( AP1, AP2 : TDPoint; AColor : Integer; ALWidth : float ) : Boolean;
var
  UD3 : TN_UDBase;
  UDL3 : TN_UDPolyline;
  FActType : Byte;
  FActCapt : string;
  PUPColor: TN_POneUserParam;
  PUPLineWidth: TN_POneUserParam;
begin
  with N_CM_MainForm, CMMFEdFrames[0], EdSlide, GetMeasureRoot() do
  begin
    UD3 := DirChild(0);
    if UD3.ObjName[1] <> 'L' then
    begin
    // Add New Object
      UD3 := AddNewMeasurement('Line');
      MoveEntries( 0, DirHigh() );

      FActType := Ord(K_shVOActAdd);
      FActCapt := 'Add Eyes Line';
      Result := TRUE;

      PUPColor := K_CMGetVObjPAttr( UD3, 'MainColor' );
      if PUPColor <> nil then
        PInteger(PUPColor.UPValue.P)^ := AColor;

      PUPLineWidth := K_CMGetVObjPAttr( UD3, 'LineWidth' );
      if PUPLineWidth <> nil then
        PFloat(PUPLineWidth.UPValue.P)^ := ALWidth;
      RebuildVObjsSearchList();
    end
    else
    begin
      FActType := Ord(K_shVOActMoveVertex);
      FActCapt := 'Rebuild Eyes Line';
      Result := FALSE;
    end;

    TN_UDCompVis(UD3).PSP.CCoords.BPCoords := FPoint( -100,-100 );
    UDL3 := TN_UDPolyline(UD3.DirChild(1));

    with UDl3.PSP.CPolyline.CPCoords do
    begin
      PFPoint(P(0))^ := N_Add2P( FPoint( AP1 ), FPoint( 100,100 ) );
      PFPoint(P(1))^ := N_Add2P( FPoint( AP2 ), FPoint( 100,100 ) );
    end;
    CMMFFinishVObjEditing( FActCapt,
        K_CMEDAccess.EDABuildHistActionCode(K_shATChange,
          Ord(K_shCAVOObject), FActType, Ord(K_shVOTypePolyLine)));

  end; // with N_CM_MainForm, CMMFEdFrames[0], EdSlide, GetMeasureRoot() do
end; // function K_PMTRebuildLineAnnot

//**************************************************** K_PMTRemoveLineAnnot ***
// Remove Eyes Line
//
//     Parameters
// Result - Returns TRUE if Line was removed
//
function K_PMTRemoveLineAnnot( ) : Boolean;
var
  UD3 : TN_UDBase;
begin
  with N_CM_MainForm, CMMFEdFrames[0], EdSlide, GetMeasureRoot() do
  begin
    UD3 := DirChild(0);
    Result := UD3.ObjName[1] = 'L';
    if not Result then Exit;
    RemoveDirEntry( 0 );
    CMMFFinishVObjEditing( 'Remove Eyes Line',
        K_CMEDAccess.EDABuildHistActionCode(K_shATChange,
          Ord(K_shCAVOObject), Ord(K_shVOActDel), Ord(K_shVOTypePolyLine)));
  end; // with N_CM_MainForm, CMMFEdFrames[0], EdSlide, GetMeasureRoot() do
end; // function K_PMTRemoveLineAnnot

function K_PMTSetLineAttrs( AColor : Integer; ALWidth : float ) : Boolean;
var
  UD3 : TN_UDBase;
  PUPColor: TN_POneUserParam;
  PUPLineWidth: TN_POneUserParam;
begin
  with N_CM_MainForm, CMMFEdFrames[0], EdSlide, GetMeasureRoot() do
  begin
    UD3 := DirChild(0);
    Result := UD3.ObjName[1] = 'L';
    if not Result then Exit;

    PUPColor := K_CMGetVObjPAttr( UD3, 'MainColor' );
    if PUPColor <> nil then
      PInteger(PUPColor.UPValue.P)^ := AColor;

    PUPLineWidth := K_CMGetVObjPAttr( UD3, 'LineWidth' );
    if PUPLineWidth <> nil then
      PFloat(PUPLineWidth.UPValue.P)^ := ALWidth;

    if (PUPColor = nil) and (PUPLineWidth = nil) then Exit;

    CMMFFinishVObjEditing( 'Change draw attributes',
        K_CMEDAccess.EDABuildHistActionCode(K_shATChange,
          Ord(K_shCAVOObject), Ord(K_shVOActEdAttrs), Ord(K_shVOTypePolyLine)));
  end; // with N_CM_MainForm, CMMFEdFrames[0], EdSlide, GetMeasureRoot() do
end; // function K_PMTSetLineAttrs

begin
WS := 'D:\Delphi_prj_new\DTmp\CMS Test Data\MEDICALDicomDataSetsWG04\compsamples_refanddir\IMAGES\REF\CT2_UNC';
DI := K_DCMGLibW.DLCreateInstanceFromFile( @WS[1], 255 );
Slide3D := K_DCMCreateSlideFromInstanceHandle( DI, -101, N_WideToString(WS) );
K_CMDCMStoreAutoSkipFlag := TRUE;
K_CMEDAccess.EDASaveSlidesArray( @Slide3D, 1 );
K_CMDCMStoreAutoSkipFlag := FALSE;

Exit;

DumpObj := TK_DumpObj.Create( K_ExpandFileName('(#WrkFiles#)') + '1txt.txt' );

DumpObj.DumpStr0( 'Text1' );
DumpObj.DumpStr0( 'Text2' );
DumpObj.DumpStr0( 'Text3' );


N_SL.Clear;
N_SL.LoadFromFile( DumpObj.DLogFname );

DumpObj.Destroy();
Exit;

//K_PMTRemoveLineAnnot();
//Exit;
with N_CM_MainForm, CMMFActiveEdFrame, EdSlide do
begin
  with GetMeasureRoot() do
  begin
    for i := 0 to DirHigh() - 1 do
    begin
      UD1 := DirChild(i);
      if (UD1.ObjName[1] <> 'D') then
        Continue; // Not Measure Line
      UD2 := DirChild(i + 1);
      if (UD2.ObjName[1] <> 'D') then
        Continue; // Not Measure Line
      N_Dump2Str( UD1.ObjName + ' ' + UD2.ObjName );
      UDl1 := TN_UDPolyline(UD1.DirChild(1));
      UDl2 := TN_UDPolyline(UD2.DirChild(1));
//      N_Dump2Str( UDL1.ObjName + ' ' + UDL2.ObjName );
      with TN_UDCompVis(UD1) do
      begin
        with PSP.CCoords.BPCoords do
        begin
          FP1 := PSP.CCoords.BPCoords;
        end;
      end;
  N_Dump2Str( format( '%s=%f %f', [UD1.ObjName, FP1.X, FP1.Y] ) );

      with TN_UDCompVis(UD2) do
      begin
        with PSP.CCoords.BPCoords do
        begin
          FP2 := PSP.CCoords.BPCoords;
        end;
      end;
  N_Dump2Str( format( '%s=%f %f', [UD2.ObjName, FP2.X, FP2.Y] ) );
{
      S1 := N_Add2P( FP1, FPoint( 100,100 ) );
      S2 := N_Add2P( FP2, FPoint( 100,100 ) );
      S1.X := FP1.X + 100;
      S1.Y := FP1.Y + 100;
      S2.X := FP2.X + 100;
      S2.Y := FP2.Y + 100;
}
      with UDl1.PSP.CPolyline.CPCoords do
      begin
        FP1 := N_Add2P( PFPoint(P(0))^, FP1 );
//        FP1 := PFPoint(P(0))^;
//        FP1.X := FP1.X + S1.X;
//        FP1.Y := FP1.Y + S1.Y;
      end;

      with UDl2.PSP.CPolyline.CPCoords do
      begin
        FP2 := N_Add2P( PFPoint(P(0))^, FP2 );
//        FP2 := PFPoint(P(0))^;
//        FP2.X := FP2.X + S2.X;
//        FP2.Y := FP2.Y + S2.Y;
      end;
      K_PMTRebuildLineAnnot( DPoint(FP1), DPoint(FP2), 255*256, 6 );
      Exit;
{
      UD3 := DirChild(0);
      if UD3.ObjName[1] <> 'L' then
      begin
      // Add New Object
        UD3 := AddNewMeasurement('Line');
        MoveEntries( 0, DirHigh() );
      end;

      if UD3.ObjName[1] <> 'L' then Exit; // precaution
      UDL3 := TN_UDPolyline(UD3.DirChild(1));

      with TN_UDCompVis(UD3) do
      begin
        with PSP.CCoords.BPCoords do
        begin
          X := -100;
          Y := -100;
        end;
      end;

      with UDl3.PSP.CPolyline.CPCoords do
      begin
        PFPoint(P(0))^ := FP1;
        PFPoint(P(1))^ := FP1;
      end;
 }
    end;
  end;
  RFrame.RedrawAllAndShow();
end;
exit;

with K_CMEDAccess do
Slide3D := TN_UDCMSlide( CurSlidesList[CurSlidesList.Count - 1] );
N_s:=TK_CMEDDBAccess(K_CMEDAccess).EDAGetSlideImg3DPath( Slide3D )+
K_CMSlideGetImg3DFolderName(Slide3D.ObjName);
exit;

with TOpenDialog.Create(nil) do
begin
  if Execute then
  begin
    N_s := FileName;
//    K_CMDCMImportOneSlideTest( N_s );
  end
end;
exit;
{
if Win32MajorVersion >= 6 then
  with TFileOpenDialog.Create(nil) do
    try
      Title := 'Select Directory';
      Options := [fdoPickFolders, fdoPathMustExist, fdoForceFileSystem]; // YMMV
      OkButtonLabel := 'Select';
      DefaultFolder := FDir;
      FileName := FDir;
      if Execute then
        ShowMessage(FileName);
    finally
      Free;
    end;
Exit;
}
//N_s := WinVistaSelectFolder();
//Exit;
  K_CMEDAccess.TmpStrings.Text :=
  #13#10'[DevicePlatesClient]'#13#10 +
  '44=2|20190918120000'#13#10 +
  '33=2|20190901120000'#13#10 +
  '33=2|20190918120000';
  K_GetDevicePlatesClientInfoFromTaskToDB( K_CMEDAccess.TmpStrings );
exit;

  K_CMEDAccess.TmpStrings.Clear;
  K_AddDevicePlatesTotalInfoToTask( K_CMEDAccess.TmpStrings );
  K_AddDevicePlatesClientInfoToTask( K_CMEDAccess.TmpStrings );
exit;

if K_CMSlidesCopyMoveArchivedCheck(1) then
  K_CMSlidesCopyMoveLaunchByPat(1, 2, 1)
else
  K_CMSlidesCopyMoveByPat( 1, 2, 1, FALSE );
{
if K_CMSlidesCopyMoveArchivedCheck(-103) then
  K_CMSlidesCopyMoveLaunchByPat(-103, 2, 1)
else
  K_CMSlidesCopyMoveByPat( -103, 2, 1, FALSE );

if K_CMSlidesCopyMoveArchivedCheck(-103) then
  K_CMSlidesCopyMoveLaunchByPat(-103, 2, 0)
else
  K_CMSlidesCopyMoveByPat( -103, 2, 0, FALSE );
}
{
if K_CMSlidesCopyMoveArchivedCheck(-105) then
  K_CMSlidesCopyMoveLaunchByPat(-105, 2, 0)
else
  K_CMSlidesCopyMoveByPat( -105, 2, 0, FALSE );
}
exit;

with N_CMResForm do
  aServArchSaveExecute( aServArchSave );
//  aServArchRestoreExecute( aServArchSave );
exit;

K_CMEDAccess.TmpStrings.Clear;
N_SL.Clear;
K_CMFSBuildNeededFLists( K_CMEDAccess.TmpStrings, K_CMEDAccess.TmpStrings,K_CMEDAccess.TmpStrings,
                         N_SL, N_SL, N_SL, [],
                         TK_CMEDDBAccess(K_CMEDAccess).CurDSet1, nil );
K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1TestNeededFiles.txt' ) );
N_SL.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1TestArchivedFiles.txt' ) );
exit;

DevProfile.CMDPCaption := 'Captured from ' + N_CMECD_Slida_Name;
DevProfile.CMDPGroupName := N_CMECD_Slida_Name;

K_CMDev3DCreateSlide( @DevProfile, '111', nil,
                                100, 200, 300, 8 );
exit;

K_CMLoadUserStrings();
N_i := StrToIntDef( K_CMGetUserString( 'Name' ), 0 ) + 1;
K_CMSetUserString('Name', IntToStr(N_i) );
K_CMSaveUserStrings();
exit;

  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(0), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  //N_b := K_CheckTextPattern( 'pat_2017-10-17.xml', '*.xml' );
  //N_b := K_CheckTextPattern( 'pat_2017-10-17.xml', 'pat_2017-10-17.xml' );
  N_b := K_CheckTextPattern( 'pat_2017-10-17.xml', '*_??????????.xml' );

  N_b := K_CheckTextPattern( ExtractFileName('a\pat_2017-10-17.xml'), '*_????-??-??.xml' );
  exit;

//  UDTemplate := K_CreateUDByRTypeName('TN_CMSlide', 1, N_UDCMStudyCI);
//  K_CMStudyTemplateLoadDescr( UDTemplate, K_CMEDAccess.TmpStrings );
//  UDTemplate.UDDelete();

  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(0), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1FMX21.xml' ) );


  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(1), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1FMX18.xml' ) );

  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(2), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1FMX18C.xml' ) );

  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(3), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1Checkup7.xml' ) );

  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(4), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1Checkup6.xml' ) );

  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(5), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1BW4.xml' ) );

  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(6), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1OPG2.xml' ) );

  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(7), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1Video13.xml' ) );

  K_CMStudyTemplateUnloadDescr( K_CMEDAccess.ArchStudySamplesLibRoot.DirChild(8), K_CMEDAccess.TmpStrings, [K_sttUnloadPosAttrDetails] );
  K_CMEDAccess.TmpStrings.SaveToFile( K_ExpandFileName('(##Exe#)..\DTmp\1Square24.xml' ) );
  exit;

  K_CMRemoveOldDump2ExceptFiles( );
  K_CMRemoveOldDump2HaltFiles( );
  exit;
//  N_i1 := 0;
//  N_i := Round(35 / N_i1);

  with N_CM_MainForm, CMMFActiveEdFrame do
  begin
    if not CMMFCheckBSlideExisting() then
    begin
      N_Dump2Str( 'Nothing to do ');
      Exit;
    end;

    K_CMImg3DViewAnnotsContPrep( );
    K_CMImg3DViewAnnotsImport( EdSlide, 'C:\Delphi_prj_new\DTmp\3DAnnots21.txt', EdSlide.P.CMSDB.PixPermm );
    K_CMImg3DViewAnnotsContFree( );
  end; // with N_CM_MainForm do

  exit;

  N_BaseFormStayOnTop := 2;
  N_Dump2Str( 'Before DebForm1 create'  );
  F1 := TN_BaseForm.Create(Application);
  N_Dump2Str( 'Before DebForm1 init'  );
  F1.BaseFormInit( nil, 'DebForm1' );
  N_Dump2Str( 'Before DebForm1 show'  );
  F1.Show();
  N_Dump2Str( 'Before DebForm2 create'  );
  F2 := TN_BaseForm.Create(Application);
  N_Dump2Str( 'Before DebForm2 init'  );
  F2.BaseFormInit( nil, 'DebForm2' );
  N_Dump2Str( 'Before DebForm2 show'  );
  F2.Show();
  N_Dump2Str( 'After DebForm2 show'  );
  Exit;
//  K_CMSlidesCopyMoveByPat( 14, -101, 0 );
//  K_CMSlidesCopyMoveByPat( 11, -101, 1 );
//  K_CMSlidesCopyMoveByPat( -101, 11, 0 );
//  K_CMSlidesCopyMoveByPat( -101, -102, 1 );
//  K_CMSlidesCopyMoveByPat( -101, -103, 0 );
//  K_CMSlidesCopyMoveByPat( -103, -101, 0 );
//  K_CMSlidesCopyMoveByPat( -103, -102, 0 );
//  K_CMSlidesCopyMoveByPat( -102, -103, 0 );
  K_CMSlidesCopyMoveByPat( -102, -103, 1, FALSE );
  Exit;


  RIImLib := TN_RIImLib.Create;
  RIImLib.RIOpenFile( 'C:\Delphi_prj_new\DTMP\CMS Test Data\Test.png' );
  DIBObj := nil;
  RIImLib.RIGetDIB( 0, DIBObj );
  RIImLib.RIClose;

  Stream := TFileStream.Create( 'C:\Delphi_prj_new\DTMP\CMS Test Data\Test1.png', fmCreate );
  RIImLib.RIClearFileEncInfo( @FileEncInfo );
  FileEncInfo.RIFileEncType := rietPNG;
  RIImLib.RISaveDIBToStream( DIBObj, Stream, @FileEncInfo );
  Stream.Free;

  RIImLib.RIClearFileEncInfo( @FileEncInfo );
  RIImLib.RISaveDIBToFile( DIBObj, 'C:\Delphi_prj_new\DTMP\CMS Test Data\Test2.bmp', @FileEncInfo );
  RIImLib.Free;
  DIBObj.Free;
  exit;

  ARLData := TN_MemTextFragms.Create;
  NamesList :=  TStringList.Create;

  K_PrepAllUITextFragms( ARLData );
  K_PrepLangTexts( ARLData );
  ARLData.SelfAddToStrings( NamesList );
  NamesList.SaveToFile('C:\Delphi_prj_new\N_Tree\Proj_CMS.LLL.New1.txt');

  NamesList.Free;
  ARLData.Free;
  Exit;

  ARLData := TN_MemTextFragms.Create;

  Form := CreateMessageDialog('', mtWarning, [mbOk, mbCancel, mbAbort, mbRetry, mbIgnore,mbAll, mbNoToAll, mbYesToAll,mbYes, mbNo]);
  K_GetFFCompTexts( ARLData, Form );
  Form.Free;

//  K_GetFFCompTexts( ARLData, N_CMResForm );
  TComponent(Form) := TN_CMResForm.Create( nil );
  K_GetFFCompTexts( ARLData, Form );
  Form.Free;

//  K_GetFFCompTexts( ARLData, K_CML1Form );
  TComponent(Form) := TK_CML1Form.Create( nil );
  K_GetFFCompTexts( ARLData, Form );
  Form.Free;
{
  TComponent(Form) := TK_FormCMImportPPL.Create( nil );
  K_GetFFCompTexts( ARLData, Form );
  Form.Free;

  Form := TK_FormCMExportPPL.Create( nil );
  K_GetFFCompTexts( ARLData, Form );
  Form.Free;
}
  NamesList :=  TStringList.Create;
  K_PrepLangTexts( ARLData );
  ARLData.SelfAddToStrings( NamesList );
  NamesList.SaveToFile('C:\Delphi_prj_new\N_Tree\Proj_CMS.LLL.New.txt');

  with  K_GetFormTextEdit( nil ) do
    EditStrings( NamesList, 'All Form Texts',
                                    TRUE, TRUE );

  ASLData := TN_MemTextFragms.CreateFromVFile( 'C:\Delphi_prj_new\N_Tree\Proj_CMS.LLL.txt' );
  AULData := TN_MemTextFragms.Create;

  K_GetLangTextsCompareStrings( ASLData, ARLData, AULData, FALSE );
  NamesList.Clear;
  AULData.SelfAddToStrings( NamesList );
  with  K_GetFormTextEdit( nil ) do
    EditStrings( NamesList, 'All New and Updated',
                                    TRUE, TRUE );

  AULData.Clear;
  K_GetLangTextsCompareStrings( ARLData, ASLData, AULData, TRUE );
  NamesList.Clear;
  AULData.SelfAddToStrings( NamesList );
  with  K_GetFormTextEdit( nil ) do
    EditStrings( NamesList, 'All Removed',
                                    TRUE, TRUE );

  NamesList.Free;
  ARLData.Free;
  ASLData.Free;
  AULData.Free;

  Exit;

  NamesList :=  TStringList.Create;
//  K_GetFFCompTextsToStrings( NamesList, N_CMResForm );

//  K_GetFFCompTextsToStrings( NamesList, K_CML1Form );
{
  TMsgDlgType = (mtWarning, mtError, mtInformation, mtConfirmation, mtCustom);
  TMsgDlgBtn = (mbYes, mbNo, mbOK, mbCancel, mbAbort, mbRetry, mbIgnore,
    mbAll, mbNoToAll, mbYesToAll, mbHelp);
}
//  Form := CreateMessageDialog('Test', mtConfirmation, [mbYes, mbNo]);
//  K_GetFFCompTextsToStrings( NamesList, Form );
//  Form.Free;
  Form := CreateMessageDialog('Test', mtWarning, [mbOk, mbCancel, mbAbort, mbRetry, mbIgnore,mbAll, mbNoToAll, mbYesToAll,mbYes, mbNo]);
  K_GetFFCompTextsToStrings( NamesList, Form );
  Form.Free;
{
  Form := TK_FormCMExportPPL.Create( nil );
  K_GetFFCompTextsToStrings( NamesList, Form );
  Form.Free;

  Form := TK_FormCMImportPPL.Create( nil );
  K_GetFFCompTextsToStrings( NamesList, Form );
  Form.Free;
}
  with  K_GetFormTextEdit( nil ) do
    EditStrings( NamesList, 'Form Texts',
                                    TRUE, TRUE );
  NamesList.Free;
  Exit;

  K_VFLoadText( VV, 'C:\Delphi_prj_new\DTmp\ErrLogs\2012-06-21_ImportFileFromD4W\patients_2012-06-21.xml' );
  SLeng := Length(VV);
  SPos := 1;
  SPos := N_PosEx( '>', VV, SPos, SLeng );
  SPos := N_PosEx( '<', VV, SPos, SLeng );
  WPos := 0;

  //////////////////////
  // All Patients Loop
  //
  N_i := 0;
  FPos := SPos;
  while TRUE do
  begin
    PatCount := 0;
    while PatCount < 10 do
    begin // Next 100 patients loop
      WPos := N_PosEx( '/>', VV, FPos, SLeng );
      if WPos > 0 then
      begin
        FPos := WPos + 2;
        Inc(PatCount);
      end
      else
        break;
    end; // Next 100 patients loop

    N_i := N_i + PatCount;

    if PatCount = 0 then
      break; // Empty Patients Portion
    // Exec Procedure

    N_S := Copy( VV, SPos, FPos - SPos );

    SPos := FPos;
    if WPos = 0 then
      break; // Last Patients Portion
  end;
  //
  // All Patients Loop
  //////////////////////
  exit;


{ // check ODBC DSN in Windows Registry
  with TRegistry.Create do
  begin
    if OpenKey('Software',False) then
    begin
      if OpenKey('ODBC',False) then
      begin
        if OpenKey('ODBC.INI',False) then
        begin
          if OpenKey('CMSImg',False) then
          begin
            N_S := ReadString('PWD');
          end;
        end;
      end;
    end;

    Free();
  end;
}

  with TK_CMEDDBAccess(K_CMEDAccess), CurDSet1 do
  begin
    Connection := LANDBConnection;
    SQL.Text := 'select ' +
      K_CMENDAPID + ' as PatID,' +
      K_CMENDAPSurname + ' as PatSurname,' +
      K_CMENDAPFirstname  + ' as PatFirstName' +
      ' from ' + K_CMENDBAllPatientsTable + ' as Patient' +
      ' where ' + K_CMENDAPFlags + '=0' +
      ' FOR XML AUTO';
    Filtered := false;
    Open;
    N_s := FieldList.Fields[0].AsString;
    N_s := AnsiReplaceStr( N_s, '/><', '/>'#13#10 + '<' );

    Close();
  end;
  Exit;

  NamesList := TStringList.Create;
  K_CMAddDeviceProfilesList(NamesList);
  with  K_GetFormTextEdit( nil ) do begin
    EditStrings( NamesList, 'Profiles list',
                                    TRUE, TRUE );
  end;
  NamesList.Free;
  Exit;

//  N_TstShowShapeInfo();
//  N_TstWinGDI_1();
  Exit;

  with N_CM_MainForm, CMMFActiveEdFrame do
  begin
    K_CMFlipRotateSlideImage( EdSlide, 90, 0 );
    RFrame.RFrChangeRootComp( EdSlide.GetMapRoot ); // SetNew Root Comp
    RFrame.RedrawAllAndShow(); // needed for VObjects Search
    // ShowWholeImage();
    CMMCurFThumbsRFrame.RedrawAllAndShow();
    CMMCurFThumbsDGrid.DGInitRFrame();
  end;
  Exit;

  N_i1 := N_GetFNamesFromClipboard( N_SL );
  Exit;

  N_i1 := WM_KEYDOWN;
  N_i2 := VK_LBUTTON;

  NamesList := TStringList.Create;
  K_GetWinEnvironmentStrings( NamesList );
  NamesList.Free;
  Exit;


  Form := TN_BaseForm.Create( Application);
  Form.Width := 400;
  Form.Height := 400;
  EdFrame := N_CM_MainForm.CMMFEdFrames[0];
  EdFrame.Visible := FALSE;
//  EdFrame.Align := alNone;
  EdFrame.Left   := 0;
  EdFrame.Top    := 0;
//  EdFrame.Align  := alClient;
  PRevParent := EdFrame.Parent;
  EdFrame.Parent := Form;
  EdFrame.Visible := TRUE;
  TN_BaseForm(Form).BaseFormInit(nil);
  Form.ShowModal;

  EdFrame.Visible := FALSE;
  EdFrame.Parent := PRevParent;
  EdFrame.Visible := TRUE;

  Exit;


  K_CMSlidesCopyMoveByPat( 33, 233, 0, FALSE );
  K_CMSlidesCopyMoveByPat( 233, 33, 0, FALSE );
  Exit;

//  N_CreateCMTestForm( nil ).ShowModal();
//  K_CMTRebuildAndRedrawSlideAnnots( 100 );
  Exit;

  for i := 0 to 100 do begin
  K_CMSlidesCopyMoveByPat( 33, 233, 0, FALSE );
  K_CMSlidesCopyMoveByPat( 233, 33, 0, FALSE );
  end;
  Exit;

  K_CMChangeCaptButDelay();
  Exit;

  NamesList := TStringList.Create;
  K_GetSysFontFaceNamesList(NamesList);
  with  K_GetFormTextEdit( nil ) do begin
    EditStrings( NamesList, 'Fonts list',
                                    TRUE, TRUE );
  end;

  NamesList.Free;
  Exit;

  DT := K_StrToDateTime( '2009-12-01' );
  VV := K_DateTimeToStr( DT );

  NamesList := TStringList.Create;
  K_GetWinEnvironmentStrings( NamesList );

  NamesList.SaveToFile('C:\Delphi_prj_new\DTmp\Environment.txt');
  VV := GetEnvironmentVariable( 'HOMEPATH' );
  VV := GetEnvironmentVariable( 'homedrive' );
  VV := GetEnvironmentVariable( 'HOMEDRIVE' );
  VV := GetEnvironmentVariable( 'user documents' );
  VV := GetEnvironmentVariable( 'mydocuments' );
  VV := GetEnvironmentVariable( 'my documents' );
  VV := GetEnvironmentVariable( 'UserDocuments' );
  VV := GetEnvironmentVariable( '%System Root%' );
  VV := GetEnvironmentVariable( 'windir' );
  NamesList.Free;
//  DIB1 := nil;
  exit;
  DIB1 := N_CreateDIBFromCMSI( 'C:\1.cmsi' );
  if DIB1.DIBExPixFmt = epfGray16 then
  begin
    DIB2 := TN_DIBObj.Create( DIB1 , DIB1.DIBRect, pfCustom, epfGray8 );
//    DIB2 := N_CreateGray8DIBFromGray16( DIB1 );
    DIB2.SaveToBMPFormat( 'C:\aa.bmp' );
  end;
//  DIB2 := TN_DIBObj.Create( DIB1.DIBSize.X, DIB1.DIBSize.Y, pf24bit );
  Exit;

{
  with TK_FormCMSLM.Create(Application) do begin
    BaseFormInit(nil);
    ShowModal();
    //    Exit;
  end;

  with TK_FormCMRegister.Create(Application) do begin
    BaseFormInit(nil);
    ShowModal();
    Exit;
  end;
}
//  N_CMLoadExtDLL1();

//  N_AddDirToPATHVar( 'C:\Delphi_Prj\DTmp\!CMS_DLLs' );
//  N_CMLoadExtDLL1();
  Exit;

  N_AddDirToPATHVar( 'C:\Delphi_Prj\DTmp' );
  N_AddDirToPATHVar( 'C:\Delphi_Prj\DTmp' );
  N_AddDirToPATHVar( 'C:\Delphi_Prj' );
  N_AddDirToPATHVar( 'C:\Delphi_Prj\' );
  Exit;

//  N_TestWinTransform1();
//  N_TstMemAlloc1();

  with N_CM_MainForm, CMMFActiveEdFrame do
  begin

    with EdSlide, P()^, GetCurrentImage do
    begin
{
   // Paste Image conversion to Gray
        DIBObj - ýòîò òîò DIB êîòîðûé íàäî ìåíÿòü èëè îñâîáîäèòü è ïðèñâîèòü íîâûé

   // end of Image conversion to Gray
}

      ClearMapImage();
      Include( CMSDB.SFlags, cmsfGreyScale );
      CMSRFlags := CMSRFlags + [cmsfAttribsChanged,cmsfCurImgChanged];
    end;
    CMMFFinishImageEditing( 'Set Grey', [],
             K_CMEDAccess.EDABuildHistActionCode( K_shATChange, Ord(K_shCAImage),
                                              Ord(K_shImgActConvToGrey) ) );
  end; // with N_CM_MainForm do
  Exit;


//  N_TstSplitIntegerValue();
  Exit;

//  AppBarData: TAppBarData;
//  N_i := SHAppBarMessage( ABM_GETSTATE, nil ); // @AppBarData

  N_i1 := 99;
  N_i2 := 99;
  if N_KeyIsDown( VK_SHIFT ) then N_i1 := 100;
  if N_KeyIsDown( VK_CONTROL ) then N_i2 := 101;
  if N_KeyIsDown( VK_SHIFT ) and N_KeyIsDown( VK_CONTROL ) then N_i2 := 102;
  N_i2 := N_i;

  Exit;

  ThumbDIB := TN_DIBObj.Create;
  ThumbDIB.LoadFromClipborad();
  ThumbDIB.SaveToBMPFormat( 'C:\\zz1.bmp' );
  ThumbDIB.Free;
  Exit;

//                 0 1   2 3    4  5    6  7    8  9
  N_IA := N_CrIA( [2,5,  7,8,  10,10,  11,11,  12,14] );

  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 0 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 2 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 3 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 4 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 5 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 6 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 7 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 8 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 9 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 10 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 11 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 12 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 13 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 14 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 15 );
  N_i1 := N_BinSearch2( TN_BytesPtr(@N_IA[0]), Length(N_IA), SizeOf(N_IA[0]), 16 );



  FillChar( VFThumbPar, SizeOf(VFThumbPar), 0 );
  VFThumbPar.VFTPThumbSize := 100;
  VFThumbPar.VFTPMainBordWidth := 12;
  VFThumbPar.VFTPBlackBordWidth := 2;
  VFThumbPar.VFTPWhiteWholesWidth := 8;

  ThumbDIB := N_GetVideoFileThumb( '(#OutFiles#)ResVideo_000.avi', @VFThumbPar );
  ThumbDIB.SaveToBMPFormat( 'C:\\ztmp2.bmp' ); // debug
  ThumbDIB.Free;

{
  with N_CreateTestForm() do
  begin
    Left := 20;
    Top := 100;
    Width := 800;
    Height := 600;
//    DoubleBuffered := True;
//    Panel1.DoubleBuffered := True;
//    Panel2.DoubleBuffered := True;
    Panel3.DoubleBuffered := True;
//    Panel4.DoubleBuffered := True;
    Show();
  end; // with N_CreateTestForm() do
}
end; // procedure K_CMSDebAction1Proc();

{ TN_UDCMSArrayHelper }

procedure TN_UDCMSArrayHelper.Delete(const AIndex: integer);
var
  ALength: Cardinal;
  i: Cardinal;
begin
  ALength := Length(Self);
  Assert(ALength > 0);
  Assert(AIndex < ALength);
  for i := AIndex + 1 to ALength - 1 do
    Self[i - 1] := Self[i];
  SetLength(Self, ALength - 1);
end;

Initialization
{
uses Variants;
var
qqq:variant;

SetLength(N_ia, 10);
N_ia[0]:=1;N_ia[9]:=9;
DynArrayToVariant(qqq, N_ia, TypeInfo( TN_IArray ));
DynArrayFromVariant(Pointer(N_ia1), qqq, TypeInfo( TN_IArray ));

var
qqq:variant;
sss:TN_SArray;
ssn:TN_SArray;

SetLength(sss, 10);
sss[0]:='1';sss[9]:='999';
DynArrayToVariant(qqq, sss, TypeInfo( TN_SArray ));
DynArrayFromVariant(Pointer(ssn), qqq, TypeInfo( TN_SArray ));
}

// CMS Init

N_ClassRefArray[N_UDCMSlideCI] := TN_UDCMSlide;
N_ClassTagArray[N_UDCMSlideCI] := 'CMSSlide';

N_ClassRefArray[N_UDCMStudyCI] := TN_UDCMStudy;
N_ClassTagArray[N_UDCMStudyCI] := 'CMSStudy';

// Add MemIni Contexts
K_CMEDADefaultMemIni := TMemIniFile.Create(''); // MemIni Object for saving Some Default IniFile Fields for futute restore
K_CMEDAMemIniFile    := TMemIniFile.Create('');

K_CMEDAMemIniStrings := TStringList.Create;

K_CMSLiRegMacroInfo := TStringList.Create;

// Register
N_RegActionProc( 'CreateStudySample', K_UDACMStudyCreateSample ); // Create Study Sample


Finalization

K_CMSLiRegMacroInfo.Free;
K_CMEDAMemIniStrings.Free;
K_CMEDAMemTextFragms.Free;
K_CMCaptDevCaptsOrderedList.Free;
K_CMCaptDevCaptsOrdered3DList.Free;
K_CMToothNumSchemeList.Free;


if K_CMEDADFPLExec <> nil then
begin
  K_CMEDADFPLExec.DstIniFile := nil;
  K_CMEDADFPLExec.SrcIniFile := nil;
  K_CMEDADFPLExec.Free;
  K_CMEDADFPLMacroList.Free;
end;

K_CMEDAMemIniFile.Free;
K_CMEDADefaultMemIni.Free;
K_CMD4WUICommandsList.Free;
K_LSFApertureM1.Free;
K_LSFApertureM2.Free;
K_LSFApertureM3.Free;

K_CMSLiRegValidDevTypesList.Free;

end.
